; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35216.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?g_Templates@@3PAVCFactoryTemplate@@A		; g_Templates
PUBLIC	?g_NumOfTemplates@@3HA				; g_NumOfTemplates
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_09FBNMMHMJ@Exception@			; `string'
PUBLIC	??_C@_08PHCNGLJD@ReturnNt@			; `string'
PUBLIC	??_C@_08KFPKLAKH@ReturnHr@			; `string'
PUBLIC	??_C@_05LKGDKHFF@LogNt@				; `string'
PUBLIC	??_C@_05OILEHMGB@LogHr@				; `string'
PUBLIC	??_C@_08IAOKKAJK@FailFast@			; `string'
PUBLIC	??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@ ; `string'
PUBLIC	??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@ ; `string'
PUBLIC	??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@ ; `string'
PUBLIC	??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@ ; `string'
PUBLIC	??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@	; `string'
PUBLIC	??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@ ; `string'
PUBLIC	??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@ ; `string'
PUBLIC	??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@ ; `string'
PUBLIC	??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@ ; `string'
PUBLIC	??_C@_13LBAGMAIH@?$AA?6@			; `string'
PUBLIC	??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@ ; `string'
PUBLIC	??_C@_0BH@EEDPADAA@RaiseFailFastException@	; `string'
PUBLIC	??_C@_0O@KIMGFJMA@WIL?5Exception@		; `string'
PUBLIC	??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@ ; `string'
PUBLIC	??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@ ; `string'
PUBLIC	??_C@_0BC@CNPFEPCO@FixedSamplingRate@		; `string'
PUBLIC	??_C@_0N@FDBGAPPM@PeriodFrames@			; `string'
PUBLIC	??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@		; `string'
PUBLIC	??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@	; `string'
PUBLIC	??_C@_0N@BNFIBEN@MaxIrpNumber@			; `string'
PUBLIC	??_C@_0BD@JPDMMNEG@FirstPacketLatency@		; `string'
PUBLIC	??_C@_0O@DDKFKBEA@PreSendFrames@		; `string'
PUBLIC	??_C@_0BB@PIAJBBGI@OutputFrameDelay@		; `string'
PUBLIC	??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@	; `string'
PUBLIC	??_C@_0L@ONBBLLLB@AsioDevice@			; `string'
PUBLIC	??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@	; `string'
PUBLIC	??_C@_0N@DLKKJNAP@OutHubOffset@			; `string'
PUBLIC	??_C@_0BI@IIKKMOIC@InBufferOperationOffset@	; `string'
PUBLIC	??_C@_0M@IIIMLOLG@InHubOffset@			; `string'
PUBLIC	??_C@_0BF@BAAHAIB@BufferThreadPriority@		; `string'
PUBLIC	??_C@_0BB@GLAIOBJJ@DropoutDetection@		; `string'
PUBLIC	??_C@_0BH@ECDADGG@OutBulkOperationOffset@	; `string'
PUBLIC	??_C@_0O@CHCBIFB@USBAudio2?9ACX@		; `string'
PUBLIC	??_C@_0O@LGMBKNOO@RenderDevice0@		; `string'
PUBLIC	??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@ ; `string'
PUBLIC	??_C@_09OOLPICH@Apartment@			; `string'
PUBLIC	??_C@_08JKCDEOBL@USB?5ASIO@			; `string'
PUBLIC	??_C@_0M@BFGLKKGE@USBAsio?4dll@			; `string'
PUBLIC	??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_08KPIIIDA@CUSBAsio@			; `string'
PUBLIC	??_C@_02KPKOKMHB@?$CFS@				; `string'
PUBLIC	??_C@_0L@CIJEIFL@channel?5?$CFu@		; `string'
PUBLIC	??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@	; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs@		; `string'
PUBLIC	??_C@_09FJFDCAPM@Pro?5Audio@			; `string'
PUBLIC	_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196
PUBLIC	??_R4IASIO@@6B@					; IASIO::`RTTI Complete Object Locator'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3IASIO@@8					; IASIO::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3CUSBAsio@@8				; CUSBAsio::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	g_pfnResultLoggingCallback
PUBLIC	?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA	; wil::g_pfnResultFromCaughtException
PUBLIC	?g_resultMessageCallbackSet@details@wil@@3_NA	; wil::details::g_resultMessageCallbackSet
PUBLIC	?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA ; wil::details::g_pfnFormatNtStatusMsg
PUBLIC	g_pfnResultFromCaughtException_CppWinRt
PUBLIC	g_pfnResultFromCaughtException_WinRt
PUBLIC	??_R17?0A@EA@INonDelegatingUnknown@@8		; INonDelegatingUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R3ResultException@wil@@8			; wil::ResultException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@IASIO@@8				; IASIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2CUSBAsio@@8				; CUSBAsio::`RTTI Base Class Array'
PUBLIC	??_7CUSBAsio@@6BCUnknown@@@			; CUSBAsio::`vftable'
PUBLIC	_Avx2WmemEnabledWeakValue
PUBLIC	?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid
PUBLIC	?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC ; `wil::details::RecordFailFast'::`2'::s_hrErrorLast
PUBLIC	??_7IASIO@@6B@					; IASIO::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CUSBAsio@@6BIASIO@@@			; CUSBAsio::`vftable'
PUBLIC	??_R1BA@?0A@EA@CBaseObject@@8			; CBaseObject::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ResultException@wil@@8		; wil::ResultException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVResultException@wil@@@8			; wil::ResultException `RTTI Type Descriptor'
PUBLIC	??_R2IASIO@@8					; IASIO::`RTTI Base Class Array'
PUBLIC	??_R2ResultException@wil@@8			; wil::ResultException::`RTTI Base Class Array'
PUBLIC	?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA ; `wil::details::GetCurrentModuleName'::`2'::s_szModule
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4CUSBAsio@@6BCUnknown@@@			; CUSBAsio::`RTTI Complete Object Locator'
PUBLIC	KSPROPSETID_LowLatencyAudio
PUBLIC	_CTA2?AVResultException@wil@@
PUBLIC	??_R17?0A@EA@CUnknown@@8			; CUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCUSBAsio@@@8				; CUSBAsio `RTTI Type Descriptor'
PUBLIC	?IID_ASIO_DRIVER@@3U_GUID@@A			; IID_ASIO_DRIVER
PUBLIC	??_R4ResultException@wil@@6B@			; wil::ResultException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIASIO@@@8				; IASIO `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CUSBAsio@@8			; CUSBAsio::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CUSBAsio@@6BIASIO@@@			; CUSBAsio::`RTTI Complete Object Locator'
PUBLIC	??_7ResultException@wil@@6B@			; wil::ResultException::`vftable'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_TI2?AVResultException@wil@@
EXTRN	_splitpath_s:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_DebugBreak:PROC
EXTRN	__imp_CreateProcessA:PROC
EXTRN	__imp_LoadStringA:PROC
EXTRN	__imp_GetModuleHandleW:PROC
EXTRN	__imp_GetProcessHeap:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_AvSetMmThreadCharacteristicsA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_AvSetMmThreadPriority:PROC
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	__imp_HeapAlloc:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	_errno:PROC
EXTRN	__stdio_common_vswprintf:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_K32GetModuleFileNameExA:PROC
EXTRN	__imp_FormatMessageW:PROC
EXTRN	_purecall:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	_invalid_parameter_noinfo:PROC
EXTRN	__imp_MessageBoxA:PROC
EXTRN	__std_exception_copy:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_InitializeCriticalSectionEx:PROC
EXTRN	_beginthreadex:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_SetThreadPriority:PROC
EXTRN	__imp_WaitForMultipleObjects:PROC
EXTRN	__imp_GetModuleHandleExW:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_timeGetTime:PROC
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__std_exception_destroy:PROC
;	COMDAT g_pfnResultLoggingCallback
_BSS	SEGMENT
g_pfnResultLoggingCallback DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA
_BSS	SEGMENT
?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA DQ 01H DUP (?) ; wil::g_pfnResultFromCaughtException
_BSS	ENDS
;	COMDAT ?g_resultMessageCallbackSet@details@wil@@3_NA
_BSS	SEGMENT
?g_resultMessageCallbackSet@details@wil@@3_NA DB 01H DUP (?) ; wil::details::g_resultMessageCallbackSet
_BSS	ENDS
;	COMDAT ?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA
_BSS	SEGMENT
?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA DQ 01H DUP (?) ; wil::details::g_pfnFormatNtStatusMsg
_BSS	ENDS
;	COMDAT g_pfnResultFromCaughtException_CppWinRt
_BSS	SEGMENT
g_pfnResultFromCaughtException_CppWinRt DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT g_pfnResultFromCaughtException_WinRt
_BSS	SEGMENT
g_pfnResultFromCaughtException_WinRt DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT _Avx2WmemEnabledWeakValue
_BSS	SEGMENT
_Avx2WmemEnabledWeakValue DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC
_BSS	SEGMENT
?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC DB 01H DUP (?) ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid
_BSS	ENDS
;	COMDAT ?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC
_BSS	SEGMENT
?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC DD 01H DUP (?) ; `wil::details::RecordFailFast'::`2'::s_hrErrorLast
_BSS	ENDS
;	COMDAT ?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA
_BSS	SEGMENT
?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA DB 040H DUP (?) ; `wil::details::GetCurrentModuleName'::`2'::s_szModule
_BSS	ENDS
;	COMDAT _TI2?AVResultException@wil@@
xdata$x	SEGMENT
_TI2?AVResultException@wil@@ DD 00H
	DD	imagerel ??1ResultException@wil@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVResultException@wil@@
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208
xdata$x	SEGMENT
_CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208 DD 00H
	DD	imagerel ??_R0?AVResultException@wil@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0d0H
	DD	imagerel ??0ResultException@wil@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_7ResultException@wil@@6B@
CONST	SEGMENT
??_7ResultException@wil@@6B@ DQ FLAT:??_R4ResultException@wil@@6B@ ; wil::ResultException::`vftable'
	DQ	FLAT:??_EResultException@wil@@UEAAPEAXI@Z
	DQ	FLAT:?what@ResultException@wil@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R4CUSBAsio@@6BIASIO@@@
rdata$r	SEGMENT
??_R4CUSBAsio@@6BIASIO@@@ DD 01H			; CUSBAsio::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCUSBAsio@@@8
	DD	imagerel ??_R3CUSBAsio@@8
	DD	imagerel ??_R4CUSBAsio@@6BIASIO@@@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CUSBAsio@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CUSBAsio@@8 DD imagerel ??_R0?AVCUSBAsio@@@8 ; CUSBAsio::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CUSBAsio@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIASIO@@@8
data$rs	SEGMENT
??_R0?AUIASIO@@@8 DQ FLAT:??_7type_info@@6B@		; IASIO `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUIASIO@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ResultException@wil@@6B@
rdata$r	SEGMENT
??_R4ResultException@wil@@6B@ DD 01H			; wil::ResultException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVResultException@wil@@@8
	DD	imagerel ??_R3ResultException@wil@@8
	DD	imagerel ??_R4ResultException@wil@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVCUSBAsio@@@8
data$rs	SEGMENT
??_R0?AVCUSBAsio@@@8 DQ FLAT:??_7type_info@@6B@		; CUSBAsio `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCUSBAsio@@', 00H
data$rs	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R17?0A@EA@CUnknown@@8
rdata$r	SEGMENT
??_R17?0A@EA@CUnknown@@8 DD imagerel ??_R0?AVCUnknown@@@8 ; CUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	02H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CUnknown@@8
rdata$r	ENDS
;	COMDAT _CTA2?AVResultException@wil@@
xdata$x	SEGMENT
_CTA2?AVResultException@wil@@ DD 02H
	DD	imagerel _CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT KSPROPSETID_LowLatencyAudio
CONST	SEGMENT
KSPROPSETID_LowLatencyAudio DD 016af08fH
	DW	0f499H
	DW	04637H
	DB	0b7H
	DB	0a5H
	DB	0afH
	DB	0c0H
	DB	01cH
	DB	086H
	DB	027H
	DB	06fH
CONST	ENDS
;	COMDAT ??_R4CUSBAsio@@6BCUnknown@@@
rdata$r	SEGMENT
??_R4CUSBAsio@@6BCUnknown@@@ DD 01H			; CUSBAsio::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	imagerel ??_R0?AVCUSBAsio@@@8
	DD	imagerel ??_R3CUSBAsio@@8
	DD	imagerel ??_R4CUSBAsio@@6BCUnknown@@@
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2ResultException@wil@@8
rdata$r	SEGMENT
??_R2ResultException@wil@@8 DD imagerel ??_R1A@?0A@EA@ResultException@wil@@8 ; wil::ResultException::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2IASIO@@8
rdata$r	SEGMENT
??_R2IASIO@@8 DD imagerel ??_R1A@?0A@EA@IASIO@@8	; IASIO::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IUnknown@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVResultException@wil@@@8
data$r	SEGMENT
??_R0?AVResultException@wil@@@8 DQ FLAT:??_7type_info@@6B@ ; wil::ResultException `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVResultException@wil@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ResultException@wil@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ResultException@wil@@8 DD imagerel ??_R0?AVResultException@wil@@@8 ; wil::ResultException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ResultException@wil@@8
rdata$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@CBaseObject@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@CBaseObject@@8 DD imagerel ??_R0?AVCBaseObject@@@8 ; CBaseObject::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	00H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CBaseObject@@8
rdata$r	ENDS
;	COMDAT ??_7CUSBAsio@@6BIASIO@@@
CONST	SEGMENT
??_7CUSBAsio@@6BIASIO@@@ DQ FLAT:??_R4CUSBAsio@@6BIASIO@@@ ; CUSBAsio::`vftable'
	DQ	FLAT:?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z
	DQ	FLAT:?AddRef@CUSBAsio@@UEAAKXZ
	DQ	FLAT:?Release@CUSBAsio@@UEAAKXZ
	DQ	FLAT:?init@CUSBAsio@@UEAAJPEAX@Z
	DQ	FLAT:?getDriverName@CUSBAsio@@UEAAXPEAD@Z
	DQ	FLAT:?getDriverVersion@CUSBAsio@@UEAAJXZ
	DQ	FLAT:?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z
	DQ	FLAT:?start@CUSBAsio@@UEAAJXZ
	DQ	FLAT:?stop@CUSBAsio@@UEAAJXZ
	DQ	FLAT:?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
	DQ	FLAT:?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z
	DQ	FLAT:?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z
	DQ	FLAT:?canSampleRate@CUSBAsio@@UEAAJN@Z
	DQ	FLAT:?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
	DQ	FLAT:?setSampleRate@CUSBAsio@@UEAAJN@Z
	DQ	FLAT:?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
	DQ	FLAT:?setClockSource@CUSBAsio@@UEAAJJ@Z
	DQ	FLAT:?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z
	DQ	FLAT:?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z
	DQ	FLAT:?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
	DQ	FLAT:?disposeBuffers@CUSBAsio@@UEAAJXZ
	DQ	FLAT:?controlPanel@CUSBAsio@@UEAAJXZ
	DQ	FLAT:?future@CUSBAsio@@UEAAJJPEAX@Z
	DQ	FLAT:?outputReady@CUSBAsio@@UEAAJXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7IASIO@@6B@
CONST	SEGMENT
??_7IASIO@@6B@ DQ FLAT:??_R4IASIO@@6B@			; IASIO::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT ??_7CUSBAsio@@6BCUnknown@@@
CONST	SEGMENT
??_7CUSBAsio@@6BCUnknown@@@ DQ FLAT:??_R4CUSBAsio@@6BCUnknown@@@ ; CUSBAsio::`vftable'
	DQ	FLAT:?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z
	DQ	FLAT:?NonDelegatingAddRef@CUnknown@@UEAAKXZ
	DQ	FLAT:?NonDelegatingRelease@CUnknown@@UEAAKXZ
	DQ	FLAT:??_ECUSBAsio@@W7EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R2CUSBAsio@@8
rdata$r	SEGMENT
??_R2CUSBAsio@@8 DD imagerel ??_R1A@?0A@EA@CUSBAsio@@8	; CUSBAsio::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IASIO@@8
	DD	imagerel ??_R1A@?0A@EA@IUnknown@@8
	DD	imagerel ??_R17?0A@EA@CUnknown@@8
	DD	imagerel ??_R17?0A@EA@INonDelegatingUnknown@@8
	DD	imagerel ??_R1BA@?0A@EA@CBaseObject@@8
	ORG $+3
rdata$r	ENDS
interprocess	SEGMENT
?g_WorkerThread@@3JA DD 00H				; g_WorkerThread
?g_AsioResetThread@@3JA DD 00H				; g_AsioResetThread
?g_Instance@@3JA DD 00H					; g_Instance
interprocess	ENDS
;	COMDAT ??_R1A@?0A@EA@IASIO@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IASIO@@8 DD imagerel ??_R0?AUIASIO@@@8	; IASIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3IASIO@@8
rdata$r	ENDS
;	COMDAT ??_R3ResultException@wil@@8
rdata$r	SEGMENT
??_R3ResultException@wil@@8 DD 00H			; wil::ResultException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ResultException@wil@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@INonDelegatingUnknown@@8
rdata$r	SEGMENT
??_R17?0A@EA@INonDelegatingUnknown@@8 DD imagerel ??_R0?AUINonDelegatingUnknown@@@8 ; INonDelegatingUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3INonDelegatingUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3CUSBAsio@@8
rdata$r	SEGMENT
??_R3CUSBAsio@@8 DD 00H					; CUSBAsio::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	imagerel ??_R2CUSBAsio@@8
rdata$r	ENDS
;	COMDAT ??_R3IASIO@@8
rdata$r	SEGMENT
??_R3IASIO@@8 DD 00H					; IASIO::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2IASIO@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4IASIO@@6B@
rdata$r	SEGMENT
??_R4IASIO@@6B@ DD 01H					; IASIO::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUIASIO@@@8
	DD	imagerel ??_R3IASIO@@8
	DD	imagerel ??_R4IASIO@@6B@
rdata$r	ENDS
;	COMDAT _GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196
CONST	SEGMENT
_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196 DD 06994ad04H
	DW	093efH
	DW	011d0H
	DB	0a3H
	DB	0ccH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	022H
	DB	031H
	DB	096H
CONST	ENDS
;	COMDAT ??_C@_09FJFDCAPM@Pro?5Audio@
CONST	SEGMENT
??_C@_09FJFDCAPM@Pro?5Audio@ DB 'Pro Audio', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@
CONST	SEGMENT
??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@ DB 'USBAsioControlPanel.exe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIJEIFL@channel?5?$CFu@
CONST	SEGMENT
??_C@_0L@CIJEIFL@channel?5?$CFu@ DB 'channel %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPKOKMHB@?$CFS@
CONST	SEGMENT
??_C@_02KPKOKMHB@?$CFS@ DB '%S', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPIIIDA@CUSBAsio@
CONST	SEGMENT
??_C@_08KPIIIDA@CUSBAsio@ DB 'CUSBAsio', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@ DB 'U'
	DB	'nregister Server failed ! (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@ DB 'Reg'
	DB	'ister Server failed ! (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFGLKKGE@USBAsio?4dll@
CONST	SEGMENT
??_C@_0M@BFGLKKGE@USBAsio?4dll@ DB 'USBAsio.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKCDEOBL@USB?5ASIO@
CONST	SEGMENT
??_C@_08JKCDEOBL@USB?5ASIO@ DB 'USB ASIO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOLPICH@Apartment@
CONST	SEGMENT
??_C@_09OOLPICH@Apartment@ DB 'Apartment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@
CONST	SEGMENT
??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@ DB 'Y'
	DB	00H, 'S', 00H, 'U', 00H, 'S', 00H, 'B', 00H, '_', 00H, 'A', 00H
	DB	'S', 00H, 'I', 00H, 'O', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGMBKNOO@RenderDevice0@
CONST	SEGMENT
??_C@_0O@LGMBKNOO@RenderDevice0@ DB 'RenderDevice0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CHCBIFB@USBAudio2?9ACX@
CONST	SEGMENT
??_C@_0O@CHCBIFB@USBAudio2?9ACX@ DB 'USBAudio2-ACX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ECDADGG@OutBulkOperationOffset@
CONST	SEGMENT
??_C@_0BH@ECDADGG@OutBulkOperationOffset@ DB 'OutBulkOperationOffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GLAIOBJJ@DropoutDetection@
CONST	SEGMENT
??_C@_0BB@GLAIOBJJ@DropoutDetection@ DB 'DropoutDetection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BAAHAIB@BufferThreadPriority@
CONST	SEGMENT
??_C@_0BF@BAAHAIB@BufferThreadPriority@ DB 'BufferThreadPriority', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIIMLOLG@InHubOffset@
CONST	SEGMENT
??_C@_0M@IIIMLOLG@InHubOffset@ DB 'InHubOffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IIKKMOIC@InBufferOperationOffset@
CONST	SEGMENT
??_C@_0BI@IIKKMOIC@InBufferOperationOffset@ DB 'InBufferOperationOffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLKKJNAP@OutHubOffset@
CONST	SEGMENT
??_C@_0N@DLKKJNAP@OutHubOffset@ DB 'OutHubOffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@
CONST	SEGMENT
??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@ DB 'OutBufferOperationOffset'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ONBBLLLB@AsioDevice@
CONST	SEGMENT
??_C@_0L@ONBBLLLB@AsioDevice@ DB 'AsioDevice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@
CONST	SEGMENT
??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@ DB 'DelayedOutputBufferSwit'
	DB	'ch', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PIAJBBGI@OutputFrameDelay@
CONST	SEGMENT
??_C@_0BB@PIAJBBGI@OutputFrameDelay@ DB 'OutputFrameDelay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DDKFKBEA@PreSendFrames@
CONST	SEGMENT
??_C@_0O@DDKFKBEA@PreSendFrames@ DB 'PreSendFrames', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JPDMMNEG@FirstPacketLatency@
CONST	SEGMENT
??_C@_0BD@JPDMMNEG@FirstPacketLatency@ DB 'FirstPacketLatency', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNFIBEN@MaxIrpNumber@
CONST	SEGMENT
??_C@_0N@BNFIBEN@MaxIrpNumber@ DB 'MaxIrpNumber', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@
CONST	SEGMENT
??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@ DB 'ClassicFramesPerIrp2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@
CONST	SEGMENT
??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@ DB 'ClassicFramesPerIrp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDBGAPPM@PeriodFrames@
CONST	SEGMENT
??_C@_0N@FDBGAPPM@PeriodFrames@ DB 'PeriodFrames', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNPFEPCO@FixedSamplingRate@
CONST	SEGMENT
??_C@_0BC@CNPFEPCO@FixedSamplingRate@ DB 'FixedSamplingRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@
CONST	SEGMENT
??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@ DB 'Software\Micr'
	DB	'osoft\Windows USB ASIO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
CONST	SEGMENT
??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'e', 00H, 'x', 00H
	DB	'c', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KIMGFJMA@WIL?5Exception@
CONST	SEGMENT
??_C@_0O@KIMGFJMA@WIL?5Exception@ DB 'WIL Exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EEDPADAA@RaiseFailFastException@
CONST	SEGMENT
??_C@_0BH@EEDPADAA@RaiseFailFastException@ DB 'RaiseFailFastException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@ DB 'k'
	DB	00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 'b', 00H
	DB	'a', 00H, 's', 00H, 'e', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13LBAGMAIH@?$AA?6@
CONST	SEGMENT
??_C@_13LBAGMAIH@?$AA?6@ DB 0aH, 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@
CONST	SEGMENT
??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@ DB '[', 00H, '%'
	DB	00H, 'h', 00H, 's', 00H, ']', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@
CONST	SEGMENT
??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@ DB '['
	DB	00H, '%', 00H, 'h', 00H, 's', 00H, '(', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ')', 00H, ']', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@
CONST	SEGMENT
??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@ DB 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'C', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'e', 00H, 'x', 00H, 't', 00H, ':', 00H, '[', 00H, '%'
	DB	00H, 'h', 00H, 's', 00H, ']', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@
CONST	SEGMENT
??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@ DB 'M'
	DB	00H, 's', 00H, 'g', 00H, ':', 00H, '[', 00H, '%', 00H, 'w', 00H
	DB	's', 00H, ']', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@
CONST	SEGMENT
??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@ DB ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@
CONST	SEGMENT
??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, '(', 00H, '%', 00H, 'd', 00H, ')', 00H
	DB	' ', 00H, 't', 00H, 'i', 00H, 'd', 00H, '(', 00H, '%', 00H, 'x'
	DB	00H, ')', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'X', 00H
	DB	' ', 00H, '%', 00H, 'w', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@
CONST	SEGMENT
??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@ DB '('
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'r', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 'p', 00H, ')', 00H, ' ', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@
CONST	SEGMENT
??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, '!', 00H, '%', 00H, 'p', 00H, ':', 00H
	DB	' ', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@
CONST	SEGMENT
??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@ DB '%'
	DB	00H, 'h', 00H, 's', 00H, '(', 00H, '%', 00H, 'u', 00H, ')', 00H
	DB	'\', 00H, '%', 00H, 'h', 00H, 's', 00H, '!', 00H, '%', 00H, 'p'
	DB	00H, ':', 00H, ' ', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAOKKAJK@FailFast@
CONST	SEGMENT
??_C@_08IAOKKAJK@FailFast@ DB 'FailFast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OILEHMGB@LogHr@
CONST	SEGMENT
??_C@_05OILEHMGB@LogHr@ DB 'LogHr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKGDKHFF@LogNt@
CONST	SEGMENT
??_C@_05LKGDKHFF@LogNt@ DB 'LogNt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KFPKLAKH@ReturnHr@
CONST	SEGMENT
??_C@_08KFPKLAKH@ReturnHr@ DB 'ReturnHr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PHCNGLJD@ReturnNt@
CONST	SEGMENT
??_C@_08PHCNGLJD@ReturnNt@ DB 'ReturnNt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBNMMHMJ@Exception@
CONST	SEGMENT
??_C@_09FBNMMHMJ@Exception@ DB 'Exception', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
?g_NumOfTemplates@@3HA DD 01H				; g_NumOfTemplates
	ORG $+4
?c_PeriodFramesValueName@@3PEBDEB DQ FLAT:??_C@_0N@FDBGAPPM@PeriodFrames@ ; c_PeriodFramesValueName
?c_RegistryKeyName@@3PEBDEB DQ FLAT:??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@ ; c_RegistryKeyName
?c_DropoutDetectionName@@3PEBDEB DQ FLAT:??_C@_0BB@GLAIOBJJ@DropoutDetection@ ; c_DropoutDetectionName
?c_FirstPacketLatencyValueName@@3PEBDEB DQ FLAT:??_C@_0BD@JPDMMNEG@FirstPacketLatency@ ; c_FirstPacketLatencyValueName
?c_OutputHubOffsetName@@3PEBDEB DQ FLAT:??_C@_0N@DLKKJNAP@OutHubOffset@ ; c_OutputHubOffsetName
?c_FrameRateList@@3QBKB DD 02b11H			; c_FrameRateList
	DD	05622H
	DD	07d00H
	DD	0ac44H
	DD	0bb80H
	DD	015888H
	DD	017700H
	DD	02b110H
	DD	02ee00H
	DD	056220H
	DD	05dc00H
	DD	0ac440H
	DD	0bb800H
	ORG $+4
?c_BufferThreadPriorityName@@3PEBDEB DQ FLAT:??_C@_0BF@BAAHAIB@BufferThreadPriority@ ; c_BufferThreadPriorityName
?c_OutputFrameDelayValueName@@3PEBDEB DQ FLAT:??_C@_0BB@PIAJBBGI@OutputFrameDelay@ ; c_OutputFrameDelayValueName
?c_ClassicFramesPerIrp2ValueName@@3PEBDEB DQ FLAT:??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@ ; c_ClassicFramesPerIrp2ValueName
?c_ReferenceName@@3PEBDEB DQ FLAT:??_C@_0O@LGMBKNOO@RenderDevice0@ ; c_ReferenceName
?c_DelayedOutputBufferSwitchName@@3PEBDEB DQ FLAT:??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@ ; c_DelayedOutputBufferSwitchName
?c_AsioDeviceValueName@@3PEBDEB DQ FLAT:??_C@_0L@ONBBLLLB@AsioDevice@ ; c_AsioDeviceValueName
?c_ClassicFramesPerIrpValueName@@3PEBDEB DQ FLAT:??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@ ; c_ClassicFramesPerIrpValueName
?c_ServiceName@@3PEBDEB DQ FLAT:??_C@_0O@CHCBIFB@USBAudio2?9ACX@ ; c_ServiceName
?c_PreSendFramesValueName@@3PEBDEB DQ FLAT:??_C@_0O@DDKFKBEA@PreSendFrames@ ; c_PreSendFramesValueName
?c_MaxIrpNumberValueName@@3PEBDEB DQ FLAT:??_C@_0N@BNFIBEN@MaxIrpNumber@ ; c_MaxIrpNumberValueName
?c_FixedSamplingRateValueName@@3PEBDEB DQ FLAT:??_C@_0BC@CNPFEPCO@FixedSamplingRate@ ; c_FixedSamplingRateValueName
?c_InputBufferOperationOffsetName@@3PEBDEB DQ FLAT:??_C@_0BI@IIKKMOIC@InBufferOperationOffset@ ; c_InputBufferOperationOffsetName
?c_OutputBufferOperationOffsetName@@3PEBDEB DQ FLAT:??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@ ; c_OutputBufferOperationOffsetName
?c_InputHubOffsetName@@3PEBDEB DQ FLAT:??_C@_0M@IIIMLOLG@InHubOffset@ ; c_InputHubOffsetName
?g_Templates@@3PAVCFactoryTemplate@@A DQ FLAT:??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@ ; g_Templates
	DQ	FLAT:?IID_ASIO_DRIVER@@3U_GUID@@A
	DQ	FLAT:?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
	ORG $+8
?IID_ASIO_DRIVER@@3U_GUID@@A DD 0327468a4H		; IID_ASIO_DRIVER
	DW	01351H
	DW	04930H
	DB	0bbH
	DB	06bH
	DB	0fH
	DB	0ebH
	DB	069H
	DB	0bfH
	DB	05dH
	DB	070H
PUBLIC	??_ECUSBAsio@@W7EAAPEAXI@Z			; [thunk]:CUSBAsio::`vector deleting destructor'
PUBLIC	?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z ; wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid
PUBLIC	??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
PUBLIC	?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z ; wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close
PUBLIC	??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z ; wistd::forward<_RTL_CRITICAL_SECTION * &>
PUBLIC	??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z ; wil::assign_to_opt_param<char const *>
PUBLIC	??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z ; wil::assign_null_to_opt_param<char const *>
PUBLIC	??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z ; wil::assign_to_opt_param<wchar_t const *>
PUBLIC	??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z ; wil::assign_null_to_opt_param<wchar_t const *>
PUBLIC	??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
PUBLIC	??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>
PUBLIC	??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z ; wil::details::WriteResultString<char const *>
PUBLIC	??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z ; wil::details::WriteResultString<wchar_t const *>
PUBLIC	??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z ; wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>
PUBLIC	??$assign_to_opt_param@I@wil@@YAXPEAII@Z	; wil::assign_to_opt_param<unsigned int>
PUBLIC	?WorkerThread@CUSBAsio@@CAIPEAX@Z		; CUSBAsio::WorkerThread
PUBLIC	?ThreadStop@CUSBAsio@@AEAAXXZ			; CUSBAsio::ThreadStop
PUBLIC	?ThreadStart@CUSBAsio@@AEAAXXZ			; CUSBAsio::ThreadStart
PUBLIC	?AsioResetThread@CUSBAsio@@CAIPEAX@Z		; CUSBAsio::AsioResetThread
PUBLIC	?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ	; CUSBAsio::RequestClockInfoChange
PUBLIC	?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ	; CUSBAsio::ObtainDeviceParameter
PUBLIC	?GetDesiredPath@CUSBAsio@@AEAA_NXZ		; CUSBAsio::GetDesiredPath
PUBLIC	?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ		; CUSBAsio::ExecuteControlPanel
PUBLIC	?ApplySettings@CUSBAsio@@AEAA_NXZ		; CUSBAsio::ApplySettings
PUBLIC	?MeasureLatency@CUSBAsio@@AEAA_NXZ		; CUSBAsio::MeasureLatency
PUBLIC	?outputReady@CUSBAsio@@UEAAJXZ			; CUSBAsio::outputReady
PUBLIC	?GetSupportedSampleFormats@CUSBAsio@@CAKXZ	; CUSBAsio::GetSupportedSampleFormats
PUBLIC	?BufferSwitchX@CUSBAsio@@AEAAXXZ		; CUSBAsio::BufferSwitchX
PUBLIC	?BufferSwitch@CUSBAsio@@QEAAXXZ			; CUSBAsio::BufferSwitch
PUBLIC	?future@CUSBAsio@@UEAAJJPEAX@Z			; CUSBAsio::future
PUBLIC	?controlPanel@CUSBAsio@@UEAAJXZ			; CUSBAsio::controlPanel
PUBLIC	?disposeBuffers@CUSBAsio@@UEAAJXZ		; CUSBAsio::disposeBuffers
PUBLIC	?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z ; CUSBAsio::createBuffers
PUBLIC	?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z ; CUSBAsio::getChannelInfo
PUBLIC	?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z ; CUSBAsio::getSamplePosition
PUBLIC	?setClockSource@CUSBAsio@@UEAAJJ@Z		; CUSBAsio::setClockSource
PUBLIC	?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z ; CUSBAsio::getClockSources
PUBLIC	?setSampleRate@CUSBAsio@@UEAAJN@Z		; CUSBAsio::setSampleRate
PUBLIC	?getSampleRate@CUSBAsio@@UEAAJPEAN@Z		; CUSBAsio::getSampleRate
PUBLIC	?canSampleRate@CUSBAsio@@UEAAJN@Z		; CUSBAsio::canSampleRate
PUBLIC	?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z		; CUSBAsio::getBufferSize
PUBLIC	?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z		; CUSBAsio::getLatencies
PUBLIC	?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2
PUBLIC	?getChannels@CUSBAsio@@UEAAJPEAJ0@Z		; CUSBAsio::getChannels
PUBLIC	?stop@CUSBAsio@@UEAAJXZ				; CUSBAsio::stop
PUBLIC	?start@CUSBAsio@@UEAAJXZ			; CUSBAsio::start
PUBLIC	?init@CUSBAsio@@UEAAJPEAX@Z			; CUSBAsio::init
PUBLIC	?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z		; CUSBAsio::getErrorMessage
PUBLIC	?getDriverVersion@CUSBAsio@@UEAAJXZ		; CUSBAsio::getDriverVersion
PUBLIC	?getDriverName@CUSBAsio@@UEAAXPEAD@Z		; CUSBAsio::getDriverName
PUBLIC	??1CUSBAsio@@UEAA@XZ				; CUSBAsio::~CUSBAsio
PUBLIC	??0IASIO@@QEAA@XZ				; IASIO::IASIO
PUBLIC	??_GCUSBAsio@@UEAAPEAXI@Z			; CUSBAsio::`scalar deleting destructor'
PUBLIC	??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z		; CUSBAsio::CUSBAsio
PUBLIC	?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z ; CUSBAsio::NonDelegatingQueryInterface
PUBLIC	?__autoclassinit2@CUSBAsio@@QEAAX_K@Z		; CUSBAsio::__autoclassinit2
PUBLIC	?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z ; CUSBAsio::CreateInstance
PUBLIC	?Release@CUSBAsio@@UEAAKXZ			; CUSBAsio::Release
PUBLIC	?AddRef@CUSBAsio@@UEAAKXZ			; CUSBAsio::AddRef
PUBLIC	?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z ; CUSBAsio::QueryInterface
PUBLIC	?toInt@@YAHW4UACSampleType@@@Z			; toInt
PUBLIC	?toInt@@YAHW4UserThreadStatuses@@@Z		; toInt
PUBLIC	?toInt@@YAHW4DeviceStatuses@@@Z			; toInt
PUBLIC	?toULong@@YAKW4UACSampleFormat@@@Z		; toULong
PUBLIC	?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ	; CUnknown::GetOwner
PUBLIC	?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ ; wil::critical_section::lock
PUBLIC	??1critical_section@wil@@QEAA@XZ		; wil::critical_section::~critical_section
PUBLIC	??0critical_section@wil@@QEAA@K@Z		; wil::critical_section::critical_section
PUBLIC	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >
PUBLIC	?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z ; wil::EnterCriticalSection
PUBLIC	?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z ; wil::details::RunFunctorWithExceptionFilter
PUBLIC	?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z ; wil::details::ResultFromCaughtExceptionInternal
PUBLIC	??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z	; wil::StoredFailureInfo::StoredFailureInfo
PUBLIC	??0ResultException@wil@@QEAA@AEBV01@@Z		; wil::ResultException::ResultException
PUBLIC	?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z ; wil::details::ThrowResultExceptionInternal
PUBLIC	?Rethrow@details@wil@@YAXXZ			; wil::details::Rethrow
PUBLIC	?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z ; wil::details::RecognizeCaughtExceptionFromCallback
PUBLIC	?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z ; wil::details::MaybeGetExceptionString
PUBLIC	?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z ; wil::details::MaybeGetExceptionString
PUBLIC	??1StoredFailureInfo@wil@@QEAA@XZ		; wil::StoredFailureInfo::~StoredFailureInfo
PUBLIC	??1ResultException@wil@@UEAA@XZ			; wil::ResultException::~ResultException
PUBLIC	??_GResultException@wil@@UEAAPEAXI@Z		; wil::ResultException::`scalar deleting destructor'
PUBLIC	?what@ResultException@wil@@UEBAPEBDXZ		; wil::ResultException::what
PUBLIC	?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ ; wil::ResultException::GetFailureInfo
PUBLIC	??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z ; wil::ResultException::ResultException
PUBLIC	?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z ; wil::StoredFailureInfo::SetFailureInfo
PUBLIC	?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ ; wil::StoredFailureInfo::GetFailureInfo
PUBLIC	??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z ; wil::StoredFailureInfo::StoredFailureInfo
PUBLIC	?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ ; wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse
PUBLIC	?ResultStringSize@details@wil@@YA_KPEB_W@Z	; wil::details::ResultStringSize
PUBLIC	?ResultStringSize@details@wil@@YA_KPEBD@Z	; wil::details::ResultStringSize
PUBLIC	?HrToNtStatus@details@wil@@YAJJ@Z		; wil::details::HrToNtStatus
PUBLIC	?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z ; wil::details::WilDynamicLoadRaiseFailFastException
PUBLIC	?DebugBreak@details@wil@@YAXXZ			; wil::details::DebugBreak
PUBLIC	?GetCurrentModuleName@details@wil@@YAPEBDXZ	; wil::details::GetCurrentModuleName
PUBLIC	?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z ; wil::details::K32GetModuleInformation
PUBLIC	?RecordFailFast@details@wil@@YAHJ@Z		; wil::details::RecordFailFast
PUBLIC	?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z ; wil::details::shared_buffer::assign
PUBLIC	?unique@shared_buffer@details@wil@@QEBA_NXZ	; wil::details::shared_buffer::unique
PUBLIC	??Bshared_buffer@details@wil@@QEBA_NXZ		; wil::details::shared_buffer::operator bool
PUBLIC	?size@shared_buffer@details@wil@@QEBA_KXZ	; wil::details::shared_buffer::size
PUBLIC	?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z	; wil::details::shared_buffer::get
PUBLIC	?create@shared_buffer@details@wil@@QEAA_N_K@Z	; wil::details::shared_buffer::create
PUBLIC	?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z ; wil::details::shared_buffer::create
PUBLIC	?reset@shared_buffer@details@wil@@QEAAXXZ	; wil::details::shared_buffer::reset
PUBLIC	??1shared_buffer@details@wil@@QEAA@XZ		; wil::details::shared_buffer::~shared_buffer
PUBLIC	??0shared_buffer@details@wil@@QEAA@AEBV012@@Z	; wil::details::shared_buffer::shared_buffer
PUBLIC	??0shared_buffer@details@wil@@QEAA@XZ		; wil::details::shared_buffer::shared_buffer
PUBLIC	?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z ; wil::details::ResultStatus::FromFailureInfo
PUBLIC	?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z ; wil::details::ResultStatus::FromResult
PUBLIC	?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ; wil::GetFailureLogString
PUBLIC	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@XZ			; std::exception::exception
PUBLIC	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ		; StringCchPrintfW
PUBLIC	?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z	; StringCchVPrintfW
PUBLIC	?StringCchCopyA@@YAJPEAD_KPEBD@Z		; StringCchCopyA
PUBLIC	_vsnwprintf
PUBLIC	_vsnwprintf_l
PUBLIC	?RegisterAsioDriver@@YAJXZ			; RegisterAsioDriver
PUBLIC	?UnregisterAsioDriver@@YAJXZ			; UnregisterAsioDriver
PUBLIC	g_header_init_WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse
PUBLIC	g_header_init_InitializeResultExceptions
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_ECUSBAsio@@UEAAPEAXI@Z:PROC			; CUSBAsio::`vector deleting destructor'
EXTRN	??_EResultException@wil@@UEAAPEAXI@Z:PROC	; wil::ResultException::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ DD imagerel ?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ
	DD	imagerel ?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ+50
	DD	imagerel $unwind$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ DD imagerel ??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
	DD	imagerel ??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ+50
	DD	imagerel $unwind$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z DD imagerel $LN40
	DD	imagerel $LN40+170
	DD	imagerel $unwind$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z DD imagerel $LN40
	DD	imagerel $LN40+175
	DD	imagerel $unwind$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WorkerThread@CUSBAsio@@CAIPEAX@Z DD imagerel $LN229
	DD	imagerel $LN229+335
	DD	imagerel $unwind$?WorkerThread@CUSBAsio@@CAIPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?WorkerThread@CUSBAsio@@CAIPEAX@Z DD imagerel $LN229+335
	DD	imagerel $LN229+1390
	DD	imagerel $chain$5$?WorkerThread@CUSBAsio@@CAIPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ThreadStop@CUSBAsio@@AEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+123
	DD	imagerel $unwind$?ThreadStop@CUSBAsio@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ThreadStart@CUSBAsio@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+99
	DD	imagerel $unwind$?ThreadStart@CUSBAsio@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z DD imagerel $LN107
	DD	imagerel $LN107+470
	DD	imagerel $unwind$?AsioResetThread@CUSBAsio@@CAIPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ DD imagerel $LN105
	DD	imagerel $LN105+254
	DD	imagerel $unwind$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ DD imagerel $LN174
	DD	imagerel $LN174+1308
	DD	imagerel $unwind$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetDesiredPath@CUSBAsio@@AEAA_NXZ DD imagerel $LN15
	DD	imagerel $LN15+310
	DD	imagerel $unwind$?GetDesiredPath@CUSBAsio@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ DD imagerel $LN4
	DD	imagerel $LN4+405
	DD	imagerel $unwind$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ApplySettings@CUSBAsio@@AEAA_NXZ DD imagerel $LN39
	DD	imagerel $LN39+1341
	DD	imagerel $unwind$?ApplySettings@CUSBAsio@@AEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?outputReady@CUSBAsio@@UEAAJXZ DD imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$?outputReady@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?outputReady@CUSBAsio@@UEAAJXZ DD imagerel $LN50+18
	DD	imagerel $LN50+128
	DD	imagerel $chain$0$?outputReady@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?outputReady@CUSBAsio@@UEAAJXZ DD imagerel $LN50+128
	DD	imagerel $LN50+136
	DD	imagerel $chain$1$?outputReady@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BufferSwitchX@CUSBAsio@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$?BufferSwitchX@CUSBAsio@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?BufferSwitch@CUSBAsio@@QEAAXXZ DD imagerel $LN14
	DD	imagerel $LN14+154
	DD	imagerel $unwind$?BufferSwitch@CUSBAsio@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?BufferSwitch@CUSBAsio@@QEAAXXZ DD imagerel $LN14+154
	DD	imagerel $LN14+206
	DD	imagerel $chain$0$?BufferSwitch@CUSBAsio@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?BufferSwitch@CUSBAsio@@QEAAXXZ DD imagerel $LN14+206
	DD	imagerel $LN14+250
	DD	imagerel $chain$1$?BufferSwitch@CUSBAsio@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?future@CUSBAsio@@UEAAJJPEAX@Z DD imagerel $LN131
	DD	imagerel $LN131+80
	DD	imagerel $unwind$?future@CUSBAsio@@UEAAJJPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?future@CUSBAsio@@UEAAJJPEAX@Z DD imagerel $LN131+80
	DD	imagerel $LN131+169
	DD	imagerel $chain$0$?future@CUSBAsio@@UEAAJJPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?future@CUSBAsio@@UEAAJJPEAX@Z DD imagerel $LN131+169
	DD	imagerel $LN131+417
	DD	imagerel $chain$1$?future@CUSBAsio@@UEAAJJPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?controlPanel@CUSBAsio@@UEAAJXZ DD imagerel $LN7
	DD	imagerel $LN7+405
	DD	imagerel $unwind$?controlPanel@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?disposeBuffers@CUSBAsio@@UEAAJXZ DD imagerel $LN139
	DD	imagerel $LN139+395
	DD	imagerel $unwind$?disposeBuffers@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z DD imagerel $LN801
	DD	imagerel $LN801+1852
	DD	imagerel $unwind$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z DD imagerel $LN123
	DD	imagerel $LN123+448
	DD	imagerel $unwind$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setClockSource@CUSBAsio@@UEAAJJ@Z DD imagerel $LN148
	DD	imagerel $LN148+412
	DD	imagerel $unwind$?setClockSource@CUSBAsio@@UEAAJJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84
	DD	imagerel $LN84+97
	DD	imagerel $unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+97
	DD	imagerel $LN84+173
	DD	imagerel $chain$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+173
	DD	imagerel $LN84+176
	DD	imagerel $chain$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+176
	DD	imagerel $LN84+202
	DD	imagerel $chain$5$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+202
	DD	imagerel $LN84+315
	DD	imagerel $chain$6$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+315
	DD	imagerel $LN84+336
	DD	imagerel $chain$7$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+336
	DD	imagerel $LN84+352
	DD	imagerel $chain$8$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD imagerel $LN84+352
	DD	imagerel $LN84+380
	DD	imagerel $chain$9$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setSampleRate@CUSBAsio@@UEAAJN@Z DD imagerel $LN231
	DD	imagerel $LN231+618
	DD	imagerel $unwind$?setSampleRate@CUSBAsio@@UEAAJN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD imagerel $LN49
	DD	imagerel $LN49+72
	DD	imagerel $unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD imagerel $LN49+72
	DD	imagerel $LN49+132
	DD	imagerel $chain$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD imagerel $LN49+132
	DD	imagerel $LN49+148
	DD	imagerel $chain$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?canSampleRate@CUSBAsio@@UEAAJN@Z DD imagerel $LN86
	DD	imagerel $LN86+55
	DD	imagerel $unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?canSampleRate@CUSBAsio@@UEAAJN@Z DD imagerel $LN86+55
	DD	imagerel $LN86+99
	DD	imagerel $chain$1$?canSampleRate@CUSBAsio@@UEAAJN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?canSampleRate@CUSBAsio@@UEAAJN@Z DD imagerel $LN86+99
	DD	imagerel $LN86+215
	DD	imagerel $chain$3$?canSampleRate@CUSBAsio@@UEAAJN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?canSampleRate@CUSBAsio@@UEAAJN@Z DD imagerel $LN86+215
	DD	imagerel $LN86+226
	DD	imagerel $chain$4$?canSampleRate@CUSBAsio@@UEAAJN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z DD imagerel $LN14
	DD	imagerel $LN14+215
	DD	imagerel $unwind$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD imagerel $LN51
	DD	imagerel $LN51+55
	DD	imagerel $unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD imagerel $LN51+55
	DD	imagerel $LN51+121
	DD	imagerel $chain$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD imagerel $LN51+121
	DD	imagerel $LN51+154
	DD	imagerel $chain$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?stop@CUSBAsio@@UEAAJXZ DD imagerel $LN22
	DD	imagerel $LN22+189
	DD	imagerel $unwind$?stop@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?start@CUSBAsio@@UEAAJXZ DD imagerel $LN19
	DD	imagerel $LN19+80
	DD	imagerel $unwind$?start@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?start@CUSBAsio@@UEAAJXZ DD imagerel $LN19+80
	DD	imagerel $LN19+176
	DD	imagerel $chain$0$?start@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?start@CUSBAsio@@UEAAJXZ DD imagerel $LN19+176
	DD	imagerel $LN19+218
	DD	imagerel $chain$1$?start@CUSBAsio@@UEAAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CUSBAsio@@UEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+328
	DD	imagerel $unwind$??1CUSBAsio@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCUSBAsio@@UEAAPEAXI@Z DD imagerel $LN40
	DD	imagerel $LN40+361
	DD	imagerel $unwind$??_GCUSBAsio@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z DD imagerel $LN209
	DD	imagerel $LN209+3393
	DD	imagerel $unwind$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z DD imagerel $LN25
	DD	imagerel $LN25+119
	DD	imagerel $unwind$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z DD imagerel $LN13
	DD	imagerel $LN13+85
	DD	imagerel $unwind$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA DD imagerel ?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA
	DD	imagerel ?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z DD imagerel ?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z
	DD	imagerel ?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z+87
	DD	imagerel $unwind$?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ DD imagerel $LN19
	DD	imagerel $LN19+39
	DD	imagerel $unwind$?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0critical_section@wil@@QEAA@K@Z DD imagerel $LN6
	DD	imagerel $LN6+29
	DD	imagerel $unwind$??0critical_section@wil@@QEAA@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z DD imagerel $LN14
	DD	imagerel $LN14+42
	DD	imagerel $unwind$?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+40
	DD	imagerel $unwind$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA DD imagerel ?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA
	DD	imagerel ?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA+47
	DD	imagerel $unwind$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DD imagerel $LN85
	DD	imagerel $LN85+250
	DD	imagerel $unwind$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+98
	DD	imagerel $unwind$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+106
	DD	imagerel $unwind$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+85
	DD	imagerel $unwind$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+98
	DD	imagerel $unwind$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+106
	DD	imagerel $unwind$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+106
	DD	imagerel $unwind$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD imagerel ?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel ?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA+30
	DD	imagerel $unwind$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ResultException@wil@@QEAA@AEBV01@@Z DD imagerel $LN41
	DD	imagerel $LN41+271
	DD	imagerel $unwind$??0ResultException@wil@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rethrow@details@wil@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?Rethrow@details@wil@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DD imagerel $LN21
	DD	imagerel $LN21+60
	DD	imagerel $unwind$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA DD imagerel ?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
	DD	imagerel ?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA+89
	DD	imagerel $unwind$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA DD imagerel ?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
	DD	imagerel ?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA+30
	DD	imagerel $unwind$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1StoredFailureInfo@wil@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+35
	DD	imagerel $unwind$??1StoredFailureInfo@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1StoredFailureInfo@wil@@QEAA@XZ DD imagerel $LN16+35
	DD	imagerel $LN16+72
	DD	imagerel $chain$0$??1StoredFailureInfo@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1StoredFailureInfo@wil@@QEAA@XZ DD imagerel $LN16+72
	DD	imagerel $LN16+94
	DD	imagerel $chain$1$??1StoredFailureInfo@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ResultException@wil@@UEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+195
	DD	imagerel $unwind$??1ResultException@wil@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GResultException@wil@@UEAAPEAXI@Z DD imagerel $LN42
	DD	imagerel $LN42+6
	DD	imagerel $unwind$??_GResultException@wil@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??_GResultException@wil@@UEAAPEAXI@Z DD imagerel $LN42+6
	DD	imagerel $LN42+210
	DD	imagerel $chain$3$??_GResultException@wil@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??_GResultException@wil@@UEAAPEAXI@Z DD imagerel $LN42+210
	DD	imagerel $LN42+232
	DD	imagerel $chain$4$??_GResultException@wil@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@ResultException@wil@@UEBAPEBDXZ DD imagerel $LN25
	DD	imagerel $LN25+257
	DD	imagerel $unwind$?what@ResultException@wil@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z DD imagerel $LN20
	DD	imagerel $LN20+83
	DD	imagerel $unwind$??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z DD imagerel $LN480
	DD	imagerel $LN480+2008
	DD	imagerel $unwind$?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+39
	DD	imagerel $unwind$??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z DD imagerel $LN10
	DD	imagerel $LN10+85
	DD	imagerel $unwind$?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentModuleName@details@wil@@YAPEBDXZ DD imagerel $LN58
	DD	imagerel $LN58+281
	DD	imagerel $unwind$?GetCurrentModuleName@details@wil@@YAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z DD imagerel $LN61
	DD	imagerel $LN61+315
	DD	imagerel $unwind$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD imagerel $LN16
	DD	imagerel $LN16+46
	DD	imagerel $unwind$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD imagerel $LN16+46
	DD	imagerel $LN16+79
	DD	imagerel $chain$0$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD imagerel $LN16+79
	DD	imagerel $LN16+119
	DD	imagerel $chain$1$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?create@shared_buffer@details@wil@@QEAA_N_K@Z DD imagerel $LN42
	DD	imagerel $LN42+231
	DD	imagerel $unwind$?create@shared_buffer@details@wil@@QEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z DD imagerel $LN39
	DD	imagerel $LN39+231
	DD	imagerel $unwind$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reset@shared_buffer@details@wil@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+31
	DD	imagerel $unwind$?reset@shared_buffer@details@wil@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reset@shared_buffer@details@wil@@QEAAXXZ DD imagerel $LN10+31
	DD	imagerel $LN10+64
	DD	imagerel $chain$0$?reset@shared_buffer@details@wil@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reset@shared_buffer@details@wil@@QEAAXXZ DD imagerel $LN10+64
	DD	imagerel $LN10+79
	DD	imagerel $chain$1$?reset@shared_buffer@details@wil@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1shared_buffer@details@wil@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+31
	DD	imagerel $unwind$??1shared_buffer@details@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1shared_buffer@details@wil@@QEAA@XZ DD imagerel $LN13+31
	DD	imagerel $LN13+64
	DD	imagerel $chain$0$??1shared_buffer@details@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1shared_buffer@details@wil@@QEAA@XZ DD imagerel $LN13+64
	DD	imagerel $LN13+79
	DD	imagerel $chain$1$??1shared_buffer@details@wil@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z DD imagerel $LN40
	DD	imagerel $LN40+691
	DD	imagerel $unwind$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ DD imagerel $LN38
	DD	imagerel $LN38+189
	DD	imagerel $unwind$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z DD imagerel ?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z
	DD	imagerel ?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z+131
	DD	imagerel $unwind$?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30
	DD	imagerel $LN30+62
	DD	imagerel $unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30+62
	DD	imagerel $LN30+69
	DD	imagerel $chain$0$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30+69
	DD	imagerel $LN30+138
	DD	imagerel $chain$1$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30+138
	DD	imagerel $LN30+166
	DD	imagerel $chain$2$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30+166
	DD	imagerel $LN30+182
	DD	imagerel $chain$4$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD imagerel $LN30+182
	DD	imagerel $LN30+190
	DD	imagerel $chain$5$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD imagerel $LN30
	DD	imagerel $LN30+59
	DD	imagerel $unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD imagerel $LN30+59
	DD	imagerel $LN30+151
	DD	imagerel $chain$0$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD imagerel $LN30+151
	DD	imagerel $LN30+173
	DD	imagerel $chain$1$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnwprintf DD imagerel $LN6
	DD	imagerel $LN6+103
	DD	imagerel $unwind$_vsnwprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnwprintf_l DD imagerel $LN4
	DD	imagerel $LN4+95
	DD	imagerel $unwind$_vsnwprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpy_s DD imagerel memcpy_s
	DD	imagerel memcpy_s+167
	DD	imagerel $unwind$memcpy_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RegisterAsioDriver@@YAJXZ DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$?RegisterAsioDriver@@YAJXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UnregisterAsioDriver@@YAJXZ DD imagerel $LN7
	DD	imagerel $LN7+182
	DD	imagerel $unwind$?UnregisterAsioDriver@@YAJXZ
;	COMDAT g_header_init_InitializeResultExceptions
_DATA	SEGMENT
g_header_init_InitializeResultExceptions DB 01H
_DATA	ENDS
;	COMDAT g_header_init_WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse
_DATA	SEGMENT
g_header_init_WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse DB 01H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UnregisterAsioDriver@@YAJXZ DD 031b19H
	DD	0180109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RegisterAsioDriver@@YAJXZ DD 031b19H
	DD	01a0109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpy_s DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnwprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnwprintf DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+59
	DD	imagerel $unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD 020521H
	DD	087405H
	DD	imagerel $LN30
	DD	imagerel $LN30+59
	DD	imagerel $unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z DD 081501H
	DD	0b6415H
	DD	0a5415H
	DD	093415H
	DD	0e0115215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+62
	DD	imagerel $unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 020021H
	DD	077400H
	DD	imagerel $LN30
	DD	imagerel $LN30+62
	DD	imagerel $unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 021H
	DD	imagerel $LN30+62
	DD	imagerel $LN30+69
	DD	imagerel $chain$0$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 020521H
	DD	06e405H
	DD	imagerel $LN30+62
	DD	imagerel $LN30+69
	DD	imagerel $chain$0$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 020521H
	DD	077405H
	DD	imagerel $LN30
	DD	imagerel $LN30+62
	DD	imagerel $unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ DD 041101H
	DD	0600d7211H
	DD	0300b500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ DD 071601H
	DD	0f0126216H
	DD	0700ee010H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z DB 02H
	DB	0caH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z DB 060H
	DD	imagerel $ip2state$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z DD 092519H
	DD	0533413H
	DD	04a0113H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z
	DD	0243H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1shared_buffer@details@wil@@QEAA@XZ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+31
	DD	imagerel $unwind$??1shared_buffer@details@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1shared_buffer@details@wil@@QEAA@XZ DD 020521H
	DD	063405H
	DD	imagerel $LN13
	DD	imagerel $LN13+31
	DD	imagerel $unwind$??1shared_buffer@details@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1shared_buffer@details@wil@@QEAA@XZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reset@shared_buffer@details@wil@@QEAAXXZ DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+31
	DD	imagerel $unwind$?reset@shared_buffer@details@wil@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reset@shared_buffer@details@wil@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+31
	DD	imagerel $unwind$?reset@shared_buffer@details@wil@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@shared_buffer@details@wil@@QEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z DD 086d01H
	DD	06e46dH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?create@shared_buffer@details@wil@@QEAA_N_K@Z DD 086d01H
	DD	06e46dH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+46
	DD	imagerel $unwind$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN16
	DD	imagerel $LN16+46
	DD	imagerel $unwind$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z DD 072019H
	DD	02a010eH
	DD	07005e007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentModuleName@details@wil@@YAPEBDXZ DD 031b19H
	DD	02a0109H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@ResultException@wil@@UEBAPEBDXZ DD 072a19H
	DD	020e6418H
	DD	020d3418H
	DD	020a0118H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	01040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??_GResultException@wil@@UEAAPEAXI@Z DD 021H
	DD	imagerel $LN42
	DD	imagerel $LN42+6
	DD	imagerel $unwind$??_GResultException@wil@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??_GResultException@wil@@UEAAPEAXI@Z DD 082521H
	DD	09e425H
	DD	08641bH
	DD	075414H
	DD	063405H
	DD	imagerel $LN42
	DD	imagerel $LN42+6
	DD	imagerel $unwind$??_GResultException@wil@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GResultException@wil@@UEAAPEAXI@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ResultException@wil@@UEAA@XZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1StoredFailureInfo@wil@@QEAA@XZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+35
	DD	imagerel $unwind$??1StoredFailureInfo@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1StoredFailureInfo@wil@@QEAA@XZ DD 020521H
	DD	063405H
	DD	imagerel $LN16
	DD	imagerel $LN16+35
	DD	imagerel $unwind$??1StoredFailureInfo@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1StoredFailureInfo@wil@@QEAA@XZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA DD 030b01H
	DD	05007420bH
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DB 04H
	DB	'$'
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DB 04H
	DB	017H
	DB	010H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	'@'
	DD	imagerel ?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
	DB	'N'
	DB	011H
	DB	080H
	DD	imagerel ?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA
	DB	'N'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DB 038H
	DD	imagerel $stateUnwindMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
	DD	imagerel $tryMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
	DD	imagerel $ip2state$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z DD 020f19H
	DD	0300b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rethrow@details@wil@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z DD 020701H
	DD	01f0107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ResultException@wil@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'p'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	'6'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'p'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	'B'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 02H
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DB 069H
	DD	imagerel $stateUnwindMap$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DD	imagerel $ip2state$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 08H
	DB	09cH
	DB	00H
	DB	08aH
	DB	02H
	DB	0acH
	DB	06H
	DB	014H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 08H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVResultException@wil@@@8
	DB	'P'
	DD	imagerel ?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DB	'p'
	DD	imagerel ?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	017H
	DB	010H
	DD	imagerel ??_R0?AVexception@std@@@8
	DB	080H
	DD	imagerel ?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	0e9H, 02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 06H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVResultException@wil@@@8
	DB	'@'
	DD	imagerel ?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	017H
	DB	012H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DB	'`'
	DD	imagerel ?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	021H
	DB	080H
	DD	imagerel ?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA
	DB	'U', 02H
	DB	0e9H, 02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 04H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$0$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 08H
	DB	08H
	DB	010H
	DB	018H
	DB	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DB 078H
	DD	imagerel $stateUnwindMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
	DD	imagerel $tryMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
	DD	imagerel $ip2state$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z DD 061f19H
	DD	0f01bb21fH
	DD	07017e019H
	DD	030156016H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DB 02H
	DB	'4'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA
	DB	'<'
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DB 038H
	DD	imagerel $stateUnwindMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
	DD	imagerel $tryMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
	DD	imagerel $ip2state$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0critical_section@wil@@QEAA@K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z DB 04H
	DB	'$'
	DB	00H
	DB	'F'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z DB 028H
	DD	imagerel $stateUnwindMap$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
	DD	imagerel $ip2state$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z DD 040a11H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z DB 04H
	DB	'u', 0fH
	DB	08H
	DB	0d5H, '$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z DB 028H
	DD	imagerel $stateUnwindMap$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z
	DD	imagerel $ip2state$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z DD 0b3419H
	DD	05b7423H
	DD	05a6423H
	DD	0593423H
	DD	0540123H
	DD	0e012f014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z
	DD	0292H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GCUSBAsio@@UEAAPEAXI@Z DB 02H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GCUSBAsio@@UEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_GCUSBAsio@@UEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_GCUSBAsio@@UEAAPEAXI@Z
	DD	imagerel $ip2state$??_GCUSBAsio@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCUSBAsio@@UEAAPEAXI@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_GCUSBAsio@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1CUSBAsio@@UEAA@XZ DB 02H
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1CUSBAsio@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1CUSBAsio@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CUSBAsio@@UEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1CUSBAsio@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?start@CUSBAsio@@UEAAJXZ DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+80
	DD	imagerel $unwind$?start@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?start@CUSBAsio@@UEAAJXZ DD 020521H
	DD	087405H
	DD	imagerel $LN19
	DD	imagerel $LN19+80
	DD	imagerel $unwind$?start@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?start@CUSBAsio@@UEAAJXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?stop@CUSBAsio@@UEAAJXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+55
	DD	imagerel $unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD 020521H
	DD	0b5405H
	DD	imagerel $LN51
	DD	imagerel $LN51+55
	DD	imagerel $unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z DD 041719H
	DD	07004d208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?canSampleRate@CUSBAsio@@UEAAJN@Z DD 021H
	DD	imagerel $LN86
	DD	imagerel $LN86+55
	DD	imagerel $unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?canSampleRate@CUSBAsio@@UEAAJN@Z DD 040021H
	DD	086400H
	DD	073400H
	DD	imagerel $LN86
	DD	imagerel $LN86+55
	DD	imagerel $unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?canSampleRate@CUSBAsio@@UEAAJN@Z DD 040a21H
	DD	07340aH
	DD	086405H
	DD	imagerel $LN86
	DD	imagerel $LN86+55
	DD	imagerel $unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+72
	DD	imagerel $unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD 020521H
	DD	087405H
	DD	imagerel $LN49
	DD	imagerel $LN49+72
	DD	imagerel $unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setSampleRate@CUSBAsio@@UEAAJN@Z DB 06H
	DB	0aeH
	DB	00H
	DB	'=', 06H
	DB	04H
	DB	0c8H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setSampleRate@CUSBAsio@@UEAAJN@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setSampleRate@CUSBAsio@@UEAAJN@Z DB 028H
	DD	imagerel $stateUnwindMap$?setSampleRate@CUSBAsio@@UEAAJN@Z
	DD	imagerel $ip2state$?setSampleRate@CUSBAsio@@UEAAJN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setSampleRate@CUSBAsio@@UEAAJN@Z DD 092619H
	DD	086817H
	DD	018340fH
	DD	012010fH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?setSampleRate@CUSBAsio@@UEAAJN@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 021H
	DD	imagerel $LN84
	DD	imagerel $LN84+97
	DD	imagerel $unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 021H
	DD	imagerel $LN84+173
	DD	imagerel $LN84+176
	DD	imagerel $chain$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 021H
	DD	imagerel $LN84+176
	DD	imagerel $LN84+202
	DD	imagerel $chain$5$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 020521H
	DD	06c405H
	DD	imagerel $LN84+176
	DD	imagerel $LN84+202
	DD	imagerel $chain$5$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 040f21H
	DD	05d40fH
	DD	075405H
	DD	imagerel $LN84+173
	DD	imagerel $LN84+176
	DD	imagerel $chain$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 040021H
	DD	04e400H
	DD	0f3400H
	DD	imagerel $LN84
	DD	imagerel $LN84+97
	DD	imagerel $unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 041421H
	DD	04e414H
	DD	0f3405H
	DD	imagerel $LN84
	DD	imagerel $LN84+97
	DD	imagerel $unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z DD 040901H
	DD	0f0057209H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setClockSource@CUSBAsio@@UEAAJJ@Z DB 06H
	DB	'U', 04H
	DB	04H
	DB	01cH
	DB	02H
	DB	0baH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setClockSource@CUSBAsio@@UEAAJJ@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?setClockSource@CUSBAsio@@UEAAJJ@Z DB 028H
	DD	imagerel $stateUnwindMap$?setClockSource@CUSBAsio@@UEAAJJ@Z
	DD	imagerel $ip2state$?setClockSource@CUSBAsio@@UEAAJJ@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setClockSource@CUSBAsio@@UEAAJJ@Z DD 082219H
	DD	0183413H
	DD	0f00cf213H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?setClockSource@CUSBAsio@@UEAAJJ@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z DB 0aH
	DB	'M', 0aH
	DB	08H
	DB	'f'
	DB	016H
	DB	0dH, 0cH
	DB	08H
	DB	011H, 04H
	DB	'"'
	DB	'<'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z DB 022H
	DB	0aH
	DD	imagerel ??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	0f0H
	DB	068H
	DB	03aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	01H
	DB	02H
	DB	0a8H
	DB	0b0H
	DB	0b8H
	DB	0c0H
	DB	0c8H
	DB	0d0H
	DB	06aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	021H
	DB	02H
	DB	021H
	DB	02H
	DB	041H
	DB	02H
	DB	061H
	DB	02H
	DB	081H
	DB	02H
	DB	0a1H
	DB	02H
	DB	0cdH
	DB	02H
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
	DD	imagerel $ip2state$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z DD 0b2a19H
	DD	030341cH
	DD	026011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
	DD	0122H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?disposeBuffers@CUSBAsio@@UEAAJXZ DB 02H
	DB	'q', 02H
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?disposeBuffers@CUSBAsio@@UEAAJXZ DB 04H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	050H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?disposeBuffers@CUSBAsio@@UEAAJXZ DB 028H
	DD	imagerel $stateUnwindMap$?disposeBuffers@CUSBAsio@@UEAAJXZ
	DD	imagerel $ip2state$?disposeBuffers@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?disposeBuffers@CUSBAsio@@UEAAJXZ DD 081211H
	DD	0c5412H
	DD	0b3412H
	DD	0e00e5212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?disposeBuffers@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?controlPanel@CUSBAsio@@UEAAJXZ DD 052619H
	DD	0623415H
	DD	0600115H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	02f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?future@CUSBAsio@@UEAAJJPEAX@Z DD 021H
	DD	imagerel $LN131
	DD	imagerel $LN131+80
	DD	imagerel $unwind$?future@CUSBAsio@@UEAAJJPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?future@CUSBAsio@@UEAAJJPEAX@Z DD 020521H
	DD	076405H
	DD	imagerel $LN131
	DD	imagerel $LN131+80
	DD	imagerel $unwind$?future@CUSBAsio@@UEAAJJPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?future@CUSBAsio@@UEAAJJPEAX@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?BufferSwitch@CUSBAsio@@QEAAXXZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+154
	DD	imagerel $unwind$?BufferSwitch@CUSBAsio@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?BufferSwitch@CUSBAsio@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN14
	DD	imagerel $LN14+154
	DD	imagerel $unwind$?BufferSwitch@CUSBAsio@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BufferSwitch@CUSBAsio@@QEAAXXZ DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?BufferSwitchX@CUSBAsio@@AEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?outputReady@CUSBAsio@@UEAAJXZ DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$?outputReady@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?outputReady@CUSBAsio@@UEAAJXZ DD 020521H
	DD	077405H
	DD	imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$?outputReady@CUSBAsio@@UEAAJXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?outputReady@CUSBAsio@@UEAAJXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ApplySettings@CUSBAsio@@AEAA_NXZ DD 072519H
	DD	01c7417H
	DD	01b3417H
	DD	0180117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ DD 052619H
	DD	0623415H
	DD	0600115H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	02f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetDesiredPath@CUSBAsio@@AEAA_NXZ DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ DB 04H
	DB	'u', 07H
	DB	02H
	DB	0d1H, 0bH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ DB 028H
	DD	imagerel $stateUnwindMap$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ
	DD	imagerel $ip2state$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ DD 0d3219H
	DD	0297424H
	DD	0286424H
	DD	0273424H
	DD	0200124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ
	DD	0f2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ DB 02H
	DB	0c1H, 03H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ DB 02H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ DB 028H
	DD	imagerel $stateUnwindMap$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ
	DD	imagerel $ip2state$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ DD 081411H
	DD	0b6414H
	DD	0a5414H
	DD	093414H
	DD	070105214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?AsioResetThread@CUSBAsio@@CAIPEAX@Z DB 08H
	DB	'!', 02H
	DB	02H
	DB	09aH
	DB	00H
	DB	0c2H
	DB	02H
	DB	0a0H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?AsioResetThread@CUSBAsio@@CAIPEAX@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?AsioResetThread@CUSBAsio@@CAIPEAX@Z
	DD	imagerel $ip2state$?AsioResetThread@CUSBAsio@@CAIPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AsioResetThread@CUSBAsio@@CAIPEAX@Z DD 082319H
	DD	046814H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ThreadStart@CUSBAsio@@AEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ThreadStop@CUSBAsio@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?WorkerThread@CUSBAsio@@CAIPEAX@Z DD 0c3c21H
	DD	010b83cH
	DD	011a830H
	DD	0129827H
	DD	013881eH
	DD	0147815H
	DD	0156808H
	DD	imagerel $LN229
	DD	imagerel $LN229+335
	DD	imagerel $unwind$?WorkerThread@CUSBAsio@@CAIPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WorkerThread@CUSBAsio@@CAIPEAX@Z DD 0d3219H
	DD	0357424H
	DD	0346424H
	DD	0333424H
	DD	02c0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ DB 02H
	DB	'L'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
	DD	imagerel $ip2state$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ DB 02H
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?UnregisterAsioDriver@@YAJXZ
_TEXT	SEGMENT
$T1 = 32
message$2 = 48
__$ArrayPad$ = 176
?UnregisterAsioDriver@@YAJXZ PROC			; UnregisterAsioDriver, COMDAT

; 140  : {

$LN7:
	push	rbx
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 141  :     HRESULT result = UnregisterAsioDriver(IID_ASIO_DRIVER, ASIODRV_NAME, DRIVER_NAME);

	movups	xmm0, XMMWORD PTR ?IID_ASIO_DRIVER@@3U_GUID@@A
	lea	rcx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	?UnregisterAsioDriver@@YAJU_GUID@@PEBD1@Z ; UnregisterAsioDriver
	mov	ebx, eax

; 142  : 
; 143  :     if (!SUCCEEDED(result))

	test	eax, eax
	jns	SHORT $LN2@Unregister

; 144  :     {
; 145  :         TCHAR message[ERROR_MESSAGE_LENGTH] = {0};
; 146  :         _stprintf_s(message, ERROR_MESSAGE_LENGTH, TEXT("Unregister Server failed ! (%d)"), result);

	xorps	xmm0, xmm0
	lea	r8, OFFSET FLAT:??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@
	mov	r9d, eax
	lea	rcx, QWORD PTR message$2[rsp]
	mov	edx, 128				; 00000080H
	movups	XMMWORD PTR message$2[rsp], xmm0
	movups	XMMWORD PTR message$2[rsp+16], xmm0
	movups	XMMWORD PTR message$2[rsp+32], xmm0
	movups	XMMWORD PTR message$2[rsp+48], xmm0
	movups	XMMWORD PTR message$2[rsp+64], xmm0
	movups	XMMWORD PTR message$2[rsp+80], xmm0
	movups	XMMWORD PTR message$2[rsp+96], xmm0
	movups	XMMWORD PTR message$2[rsp+112], xmm0
	call	sprintf_s

; 147  :         MessageBox(nullptr, message, DRIVER_NAME, MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_08JKCDEOBL@USB?5ASIO@
	lea	rdx, QWORD PTR message$2[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA

; 148  :     }
; 149  : 
; 150  :     return result;

	mov	eax, ebx
$LN2@Unregister:

; 151  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
?UnregisterAsioDriver@@YAJXZ ENDP			; UnregisterAsioDriver
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?RegisterAsioDriver@@YAJXZ
_TEXT	SEGMENT
$T1 = 48
message$2 = 64
__$ArrayPad$ = 192
?RegisterAsioDriver@@YAJXZ PROC				; RegisterAsioDriver, COMDAT

; 126  : {

$LN7:
	push	rbx
	sub	rsp, 208				; 000000d0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 127  :     HRESULT result = RegisterAsioDriver(IID_ASIO_DRIVER, ASIODRV_NAME, DRIVER_NAME, DRIVER_NAME, TEXT("Apartment"));

	movups	xmm0, XMMWORD PTR ?IID_ASIO_DRIVER@@3U_GUID@@A
	lea	rcx, QWORD PTR $T1[rsp]
	movaps	XMMWORD PTR $T1[rsp], xmm0
	call	?RegisterAsioDriver@@YAJU_GUID@@PEBD111@Z ; RegisterAsioDriver
	mov	ebx, eax

; 128  : 
; 129  :     if (!SUCCEEDED(result))

	test	eax, eax
	jns	SHORT $LN2@RegisterAs

; 130  :     {
; 131  :         TCHAR message[ERROR_MESSAGE_LENGTH] = {0};
; 132  :         _stprintf_s(message, ERROR_MESSAGE_LENGTH, TEXT("Register Server failed ! (%d)"), result);

	xorps	xmm0, xmm0
	lea	r8, OFFSET FLAT:??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@
	mov	r9d, eax
	lea	rcx, QWORD PTR message$2[rsp]
	mov	edx, 128				; 00000080H
	movups	XMMWORD PTR message$2[rsp], xmm0
	movups	XMMWORD PTR message$2[rsp+16], xmm0
	movups	XMMWORD PTR message$2[rsp+32], xmm0
	movups	XMMWORD PTR message$2[rsp+48], xmm0
	movups	XMMWORD PTR message$2[rsp+64], xmm0
	movups	XMMWORD PTR message$2[rsp+80], xmm0
	movups	XMMWORD PTR message$2[rsp+96], xmm0
	movups	XMMWORD PTR message$2[rsp+112], xmm0
	call	sprintf_s

; 133  :         MessageBox(nullptr, message, DRIVER_NAME, MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_08JKCDEOBL@USB?5ASIO@
	lea	rdx, QWORD PTR message$2[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA

; 134  :     }
; 135  : 
; 136  :     return result;

	mov	eax, ebx
$LN2@RegisterAs:

; 137  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 208				; 000000d0H
	pop	rbx
	ret	0
?RegisterAsioDriver@@YAJXZ ENDP				; RegisterAsioDriver
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
;	COMDAT memcpy_s
_TEXT	SEGMENT
_Destination$ = 48
_DestinationSize$ = 56
_Source$ = 64
_SourceSize$ = 72
memcpy_s PROC						; COMDAT

; 45   :     {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	rsi, r8
	mov	rdi, rdx

; 46   :         if (_SourceSize == 0)

	test	r9, r9
	je	SHORT $LN16@memcpy_s

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rcx, rcx
	jne	SHORT $LN3@memcpy_s
$LN15@memcpy_s:

; 63   :         return 0;
; 64   :     }

	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
$LN7@memcpy_s:
	mov	eax, 22
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@memcpy_s:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	test	rsi, rsi
	je	SHORT $LN5@memcpy_s
	cmp	rdi, rbx
	jb	SHORT $LN5@memcpy_s

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, rbx
	mov	rdx, rsi
	call	memcpy
$LN16@memcpy_s:

; 63   :         return 0;
; 64   :     }

	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@memcpy_s:

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

	mov	r8, rdi
	xor	edx, edx
	call	memset

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	test	rsi, rsi
	je	SHORT $LN15@memcpy_s

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	cmp	rdi, rbx
	jae	SHORT $LN7@memcpy_s
	call	_errno
	mov	DWORD PTR [rax], 34			; 00000022H
	call	_invalid_parameter_noinfo

; 63   :         return 0;
; 64   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 34					; 00000022H
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
;	COMDAT _vsnwprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_Locale$dead$ = 88
_ArgList$ = 96
_vsnwprintf_l PROC					; COMDAT

; 1061 :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR _ArgList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], 0
	call	__stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;
; 1067 :     }

	mov	rbx, QWORD PTR [rsp+64]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+72]
	mov	ecx, -1
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnwprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
;	COMDAT _vsnwprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnwprintf PROC					; COMDAT

; 1129 :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rdi
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vswprintf

; 1130 :         return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1131 :     }

	mov	rbx, QWORD PTR [rsp+64]

; 1066 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax

; 1130 :         return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1131 :     }

	mov	rbp, QWORD PTR [rsp+72]

; 1066 :         return _Result < 0 ? -1 : _Result;

	mov	ecx, -1

; 1130 :         return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1131 :     }

	mov	rsi, QWORD PTR [rsp+80]

; 1066 :         return _Result < 0 ? -1 : _Result;

	cmovs	eax, ecx

; 1130 :         return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1131 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vsnwprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringCchCopyA@@YAJPEAD_KPEBD@Z
_TEXT	SEGMENT
pszDest$ = 8
cchDest$ = 16
pszSrc$ = 24
?StringCchCopyA@@YAJPEAD_KPEBD@Z PROC			; StringCchCopyA, COMDAT

; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	lea	rax, QWORD PTR [rdx-1]
	mov	r9d, 2147483646				; 7ffffffeH
	cmp	rax, r9
	ja	SHORT $LN8@StringCchC

; 543  :     HRESULT hr;
; 544  : 
; 545  :     hr = StringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 546  : 
; 547  :     if (SUCCEEDED(hr))
; 548  :     {
; 549  :         hr = StringCopyWorkerA(pszDest,

	sub	r9, rdx
	sub	r8, rcx
$LL11@StringCchC:

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	lea	rax, QWORD PTR [r9+rdx]
	test	rax, rax
	je	SHORT $LN12@StringCchC
	movzx	eax, BYTE PTR [r8+rcx]
	test	al, al
	je	SHORT $LN12@StringCchC

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	mov	BYTE PTR [rcx], al
	inc	rcx

; 9919 :         cchDest--;

	sub	rdx, 1
	jne	SHORT $LL11@StringCchC
$LN12@StringCchC:

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	test	rdx, rdx
	lea	rax, QWORD PTR [rcx-1]
	cmovne	rax, rcx
	xor	ecx, ecx
	test	rdx, rdx
	mov	BYTE PTR [rax], 0
	mov	eax, -2147024774			; ffffffff8007007aH
	cmovne	eax, ecx

; 558  :     }
; 559  : 
; 560  :     return hr;
; 561  : }

	ret	0
$LN8@StringCchC:

; 550  :                 cchDest,
; 551  :                 NULL,
; 552  :                 pszSrc,
; 553  :                 STRSAFE_MAX_LENGTH);
; 554  :     }
; 555  :     else if (cchDest > 0)

	mov	eax, -2147024809			; ffffffff80070057H
	test	rdx, rdx
	je	SHORT $LN4@StringCchC

; 556  :     {
; 557  :         *pszDest = '\0';

	mov	BYTE PTR [rcx], 0
$LN4@StringCchC:

; 558  :     }
; 559  : 
; 560  :     return hr;
; 561  : }

	ret	0
?StringCchCopyA@@YAJPEAD_KPEBD@Z ENDP			; StringCchCopyA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z
_TEXT	SEGMENT
pszDest$ = 64
cchDest$ = 72
pszFormat$ = 80
argList$ = 88
?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z PROC		; StringCchVPrintfW, COMDAT

; 4559 : {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	lea	rax, QWORD PTR [rdx-1]

; 4559 : {

	mov	rbp, r9
	mov	r14, r8
	mov	rsi, rcx

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	rax, 2147483646				; 7ffffffeH
	jbe	SHORT $LN7@StringCchV

; 4560 :     HRESULT hr;
; 4561 : 
; 4562 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);
; 4563 : 
; 4564 :     if (SUCCEEDED(hr))
; 4565 :     {
; 4566 :         hr = StringVPrintfWorkerW(pszDest,
; 4567 :                 cchDest,
; 4568 :                 NULL,
; 4569 :                 pszFormat,
; 4570 :                 argList);
; 4571 :     }
; 4572 :     else if (cchDest > 0)

	mov	eax, -2147024809			; ffffffff80070057H
	test	rdx, rdx
	je	SHORT $LN4@StringCchV

; 4573 :     {
; 4574 :         *pszDest = L'\0';

	xor	ebx, ebx
	mov	WORD PTR [rcx], bx
	jmp	SHORT $LN4@StringCchV
$LN7@StringCchV:
	mov	QWORD PTR [rsp+64], rdi

; 10129:     HRESULT hr = S_OK;

	xor	ebx, ebx

; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	lea	rdi, QWORD PTR [rdx-1]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbp
	mov	r9, r14
	mov	r8, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	test	eax, eax
	js	SHORT $LN13@StringCchV
	cdqe
	cmp	rax, rdi
	ja	SHORT $LN13@StringCchV

; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	jne	SHORT $LN15@StringCchV

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';

	mov	WORD PTR [rsi+rdi*2], bx

; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }

	jmp	SHORT $LN15@StringCchV
$LN13@StringCchV:

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';

	mov	WORD PTR [rsi+rdi*2], bx

; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	ebx, -2147024774			; ffffffff8007007aH
$LN15@StringCchV:

; 4575 :     }
; 4576 : 
; 4577 :     return hr;

	mov	rdi, QWORD PTR [rsp+64]
	mov	eax, ebx
$LN4@StringCchV:

; 4578 : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z ENDP		; StringCchVPrintfW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ
_TEXT	SEGMENT
pszDest$ = 96
cchDest$ = 104
pszFormat$ = 112
?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ PROC		; StringCchPrintfW, COMDAT

; 5050 : {

$LN30:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 64					; 00000040H

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	lea	rax, QWORD PTR [rdx-1]

; 5050 : {

	mov	rbp, r8
	mov	rsi, rcx

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	rax, 2147483646				; 7ffffffeH
	jbe	SHORT $LN7@StringCchP

; 5060 : 
; 5061 :         hr = StringVPrintfWorkerW(pszDest,
; 5062 :                 cchDest,
; 5063 :                 NULL,
; 5064 :                 pszFormat,
; 5065 :                 argList);
; 5066 : 
; 5067 :         va_end(argList);
; 5068 :     }
; 5069 :     else if (cchDest > 0)

	mov	eax, -2147024809			; ffffffff80070057H
	test	rdx, rdx
	je	$LN4@StringCchP

; 5070 :     {
; 5071 :         *pszDest = '\0';

	xor	ebx, ebx
	mov	WORD PTR [rcx], bx

; 5075 : }

	add	rsp, 64					; 00000040H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN7@StringCchP:
	mov	QWORD PTR [rsp+56], rdi

; 10129:     HRESULT hr = S_OK;

	xor	ebx, ebx
	mov	QWORD PTR [rsp+48], r14

; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	lea	rdi, QWORD PTR [rdx-1]

; 5051 :     HRESULT hr;
; 5052 : 
; 5053 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);
; 5054 : 
; 5055 :     if (SUCCEEDED(hr))
; 5056 :     {
; 5057 :         va_list argList;
; 5058 : 
; 5059 :         va_start(argList, pszFormat);

	lea	r14, QWORD PTR pszFormat$[rsp+8]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], r14
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+32], rbx
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	mov	r14, QWORD PTR [rsp+48]
	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	test	eax, eax
	js	SHORT $LN13@StringCchP
	cdqe
	cmp	rax, rdi
	ja	SHORT $LN13@StringCchP

; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	jne	SHORT $LN15@StringCchP

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';

	mov	WORD PTR [rsi+rdi*2], bx

; 5072 :     }
; 5073 : 
; 5074 :     return hr;

	mov	eax, ebx
	mov	rdi, QWORD PTR [rsp+56]

; 5075 : }

	add	rsp, 64					; 00000040H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN13@StringCchP:

; 10151:         *pszDest = L'\0';

	mov	WORD PTR [rsi+rdi*2], bx

; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	ebx, -2147024774			; ffffffff8007007aH
$LN15@StringCchP:

; 5072 :     }
; 5073 : 
; 5074 :     return hr;

	mov	rdi, QWORD PTR [rsp+56]
	mov	eax, ebx
$LN4@StringCchP:

; 5075 : }

	add	rsp, 64					; 00000040H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ ENDP		; StringCchPrintfW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringValidateDestA@@YAJPEBD_K_K@Z
_TEXT	SEGMENT
pszDest$dead$ = 8
cchDest$ = 16
cchMax$dead$ = 24
?StringValidateDestA@@YAJPEBD_K_K@Z PROC		; StringValidateDestA, COMDAT

; 9667 :     HRESULT hr = S_OK;

	xor	eax, eax

; 9668 : 
; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	lea	rcx, QWORD PTR [rdx-1]
	cmp	rcx, 2147483646				; 7ffffffeH
	mov	edx, -2147024809			; ffffffff80070057H
	cmova	eax, edx

; 9670 :     {
; 9671 :         hr = STRSAFE_E_INVALID_PARAMETER;
; 9672 :     }
; 9673 : 
; 9674 :     return hr;
; 9675 : }

	ret	0
?StringValidateDestA@@YAJPEBD_K_K@Z ENDP		; StringValidateDestA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringValidateDestW@@YAJPEB_W_K_K@Z
_TEXT	SEGMENT
pszDest$dead$ = 8
cchDest$ = 16
cchMax$dead$ = 24
?StringValidateDestW@@YAJPEB_W_K_K@Z PROC		; StringValidateDestW, COMDAT

; 9721 :     HRESULT hr = S_OK;

	xor	eax, eax

; 9722 : 
; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	lea	rcx, QWORD PTR [rdx-1]
	cmp	rcx, 2147483646				; 7ffffffeH
	mov	edx, -2147024809			; ffffffff80070057H
	cmova	eax, edx

; 9724 :     {
; 9725 :         hr = STRSAFE_E_INVALID_PARAMETER;
; 9726 :     }
; 9727 : 
; 9728 :     return hr;
; 9729 : }

	ret	0
?StringValidateDestW@@YAJPEB_W_K_K@Z ENDP		; StringValidateDestW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringCopyWorkerA@@YAJPEAD_KPEA_KPEBD1@Z
_TEXT	SEGMENT
pszDest$ = 8
cchDest$ = 16
pcchNewDestLength$dead$ = 24
pszSrc$ = 32
cchToCopy$dead$ = 40
?StringCopyWorkerA@@YAJPEAD_KPEA_KPEBD1@Z PROC		; StringCopyWorkerA, COMDAT

; 9910 : {

	mov	r8, rdx

; 9913 : 
; 9914 :     // ASSERT(cchDest != 0);
; 9915 : 
; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	test	rdx, rdx
	je	SHORT $LN3@StringCopy

; 9911 :     HRESULT hr = S_OK;
; 9912 :     size_t cchNewDestLength = 0;

	mov	eax, 2147483646				; 7ffffffeH
	sub	r9, rcx
$LL2@StringCopy:

; 9913 : 
; 9914 :     // ASSERT(cchDest != 0);
; 9915 : 
; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	test	rax, rax
	je	SHORT $LN3@StringCopy
	movzx	edx, BYTE PTR [r9+rcx]
	test	dl, dl
	je	SHORT $LN3@StringCopy

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	mov	BYTE PTR [rcx], dl

; 9919 :         cchDest--;

	dec	rax
	inc	rcx
	sub	r8, 1
	jne	SHORT $LL2@StringCopy
$LN3@StringCopy:

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	xor	edx, edx
	mov	eax, -2147024774			; ffffffff8007007aH
	test	r8, r8
	cmovne	eax, edx
	lea	rdx, QWORD PTR [rcx-1]
	cmovne	rdx, rcx
	mov	BYTE PTR [rdx], 0

; 9935 : 
; 9936 :     if (pcchNewDestLength)
; 9937 :     {
; 9938 :         *pcchNewDestLength = cchNewDestLength;
; 9939 :     }
; 9940 : 
; 9941 :     return hr;
; 9942 : }

	ret	0
?StringCopyWorkerA@@YAJPEAD_KPEA_KPEBD1@Z ENDP		; StringCopyWorkerA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
;	COMDAT ?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z
_TEXT	SEGMENT
pszDest$ = 64
cchDest$ = 72
pcchNewDestLength$dead$ = 80
pszFormat$ = 88
argList$ = 96
?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z PROC	; StringVPrintfWorkerW, COMDAT

; 10128: {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9

; 10129:     HRESULT hr = S_OK;
; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	lea	rdi, QWORD PTR [rdx-1]
	mov	rsi, rcx
	xor	ebp, ebp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR argList$[rsp]
	or	rcx, 1
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rbp
	call	__stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	test	eax, eax
	js	SHORT $LN4@StringVPri
	movsxd	rcx, eax
	cmp	rcx, rdi
	ja	SHORT $LN4@StringVPri

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';
; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	mov	eax, ebp
	je	SHORT $LN17@StringVPri
	jmp	SHORT $LN6@StringVPri
$LN4@StringVPri:

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';
; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }
; 10166:     else
; 10167:     {
; 10168:         cchNewDestLength = (size_t)iRet;
; 10169:     }
; 10170: 
; 10171:     if (pcchNewDestLength)
; 10172:     {
; 10173:         *pcchNewDestLength = cchNewDestLength;
; 10174:     }
; 10175: 
; 10176:     return hr;

	mov	eax, -2147024774			; ffffffff8007007aH
$LN17@StringVPri:

; 10177: }

	mov	WORD PTR [rsi+rdi*2], bp
$LN6@StringVPri:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z ENDP	; StringVPrintfWorkerW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0exception@std@@QEAA@XZ PROC				; std::exception::exception, COMDAT

; 55   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	mov	QWORD PTR [rcx], rax

; 56   :     }

	mov	rax, rcx
	movups	XMMWORD PTR [rcx+8], xmm0
	ret	0
??0exception@std@@QEAA@XZ ENDP				; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rcx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	__std_exception_copy

; 75   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	jmp	__std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 97   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 91   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	__std_exception_destroy
	test	bl, 1
	je	SHORT $LN8@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ
_TEXT	SEGMENT
dest$ = 112
destEnd$ = 120
format$ = 128
?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ PROC	; wil::details::LogStringPrintf, COMDAT

; 1760 :     {

$LN38:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 1761 :         va_list argList;
; 1762 :         va_start(argList, format);
; 1763 :         StringCchVPrintfW(dest, (destEnd - dest), format, argList);

	mov	rbp, rdx
	lea	rsi, QWORD PTR format$[rsp+8]
	sub	rbp, rcx
	mov	r15, r8
	sar	rbp, 1
	mov	r14, rdx
	mov	rdi, rcx
	mov	rbx, -1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	je	SHORT $LN8@LogStringP
	cmp	rbp, 2147483647				; 7fffffffH
	ja	SHORT $LN27@LogStringP

; 10135:     cchMax = cchDest - 1;

	dec	rbp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rsi
	mov	r9, r15
	xor	esi, esi
	mov	r8, rbp
	mov	rdx, rdi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 1
	call	__stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	cmovs	eax, ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	test	eax, eax
	js	SHORT $LN17@LogStringP
	cdqe
	cmp	rax, rbp
	ja	SHORT $LN17@LogStringP

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';
; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	jne	SHORT $LN8@LogStringP
$LN17@LogStringP:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 1764 :         return (destEnd == dest) ? dest : (dest + wcslen(dest));

	mov	WORD PTR [rdi+rbp*2], si
	jmp	SHORT $LN8@LogStringP
$LN27@LogStringP:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 4574 :         *pszDest = L'\0';

	xor	esi, esi
	mov	WORD PTR [rcx], si
$LN8@LogStringP:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 1764 :         return (destEnd == dest) ? dest : (dest + wcslen(dest));

	cmp	r14, rdi
	jne	SHORT $LL3@LogStringP
	mov	rax, rdi

; 1765 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
	npad	3
$LL3@LogStringP:

; 1764 :         return (destEnd == dest) ? dest : (dest + wcslen(dest));

	cmp	WORD PTR [rdi+rbx*2+2], 0
	lea	rbx, QWORD PTR [rbx+1]
	jne	SHORT $LL3@LogStringP
	lea	rax, QWORD PTR [rdi+rbx*2]

; 1765 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ENDP	; wil::details::LogStringPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z
_TEXT	SEGMENT
szErrorText$1 = 64
__$ArrayPad$ = 576
pszDest$ = 640
cchDest$ = 648
failure$ = 656
?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z PROC ; wil::GetFailureLogString, COMDAT

; 1776 : {

$LN40:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 592				; 00000250H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	r14, rcx

; 1777 :     // This function was lenient to empty strings at one point and some callers became dependent on this behavior
; 1778 :     if ((cchDest == 0) || (pszDest == nullptr))

	test	rdx, rdx
	je	$LN33@GetFailure
	test	rcx, rcx
	je	$LN33@GetFailure

; 1779 :     {
; 1780 :         return S_OK;
; 1781 :     }
; 1782 : 
; 1783 :     pszDest[0] = L'\0';

	xor	r15d, r15d
	mov	WORD PTR [rcx], r15w

; 1784 : 
; 1785 :     // Call the logging callback (if present) to allow them to generate the debug string that will be pushed to the console
; 1786 :     // or the platform exception object if the caller desires it.
; 1787 :     if ((g_pfnResultLoggingCallback != nullptr) && details::g_resultMessageCallbackSet)

	mov	rax, QWORD PTR g_pfnResultLoggingCallback
	test	rax, rax
	je	SHORT $LN32@GetFailure
	cmp	BYTE PTR ?g_resultMessageCallbackSet@details@wil@@3_NA, r15b ; wil::details::g_resultMessageCallbackSet
	je	SHORT $LN32@GetFailure

; 1788 :     {
; 1789 :         // older-form callback was a non-const FailureInfo*; conceptually this is const as callers should not be modifying
; 1790 :         g_pfnResultLoggingCallback(const_cast<FailureInfo*>(&failure), pszDest, cchDest);

	mov	r8, rdx
	mov	rdx, rcx
	mov	rcx, rbx
	call	rax

; 1791 :     }
; 1792 : 
; 1793 :     // The callback only optionally needs to supply the debug string -- if the callback didn't populate it, yet we still want
; 1794 :     // it for OutputDebugString or exception message, then generate the default string.
; 1795 :     if (pszDest[0] == L'\0')

	cmp	WORD PTR [r14], r15w
	jne	$LN33@GetFailure
$LN32@GetFailure:

; 1796 :     {
; 1797 :         PCSTR pszType = "";

	lea	rdi, OFFSET FLAT:??_C@_00CNPNBAHC@@

; 1798 :         switch (failure.type)

	mov	ecx, DWORD PTR [rbx]
	test	ecx, ecx
	je	SHORT $LN8@GetFailure
	sub	ecx, 1
	je	SHORT $LN9@GetFailure
	sub	ecx, 1
	je	SHORT $LN12@GetFailure
	cmp	ecx, 1
	jne	SHORT $LN2@GetFailure

; 1823 :         case FailureType::FailFast:
; 1824 :             pszType = "FailFast";

	lea	rdi, OFFSET FLAT:??_C@_08IAOKKAJK@FailFast@
	jmp	SHORT $LN2@GetFailure
$LN12@GetFailure:

; 1813 :         case FailureType::Log:
; 1814 :             if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	test	BYTE PTR [rbx+4], 8

; 1815 :             {
; 1816 :                 pszType = "LogNt";
; 1817 :             }
; 1818 :             else
; 1819 :             {
; 1820 :                 pszType = "LogHr";
; 1821 :             }
; 1822 :             break;

	lea	rax, OFFSET FLAT:??_C@_05OILEHMGB@LogHr@
	lea	rdi, OFFSET FLAT:??_C@_05LKGDKHFF@LogNt@
	cmove	rdi, rax
	jmp	SHORT $LN2@GetFailure
$LN9@GetFailure:

; 1802 :             break;
; 1803 :         case FailureType::Return:
; 1804 :             if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	test	BYTE PTR [rbx+4], 8

; 1805 :             {
; 1806 :                 pszType = "ReturnNt";
; 1807 :             }
; 1808 :             else
; 1809 :             {
; 1810 :                 pszType = "ReturnHr";
; 1811 :             }
; 1812 :             break;

	lea	rax, OFFSET FLAT:??_C@_08KFPKLAKH@ReturnHr@
	lea	rdi, OFFSET FLAT:??_C@_08PHCNGLJD@ReturnNt@
	cmove	rdi, rax
	jmp	SHORT $LN2@GetFailure
$LN8@GetFailure:

; 1799 :         {
; 1800 :         case FailureType::Exception:
; 1801 :             pszType = "Exception";

	lea	rdi, OFFSET FLAT:??_C@_09FBNMMHMJ@Exception@
$LN2@GetFailure:

; 1825 :             break;
; 1826 :         }
; 1827 : 
; 1828 :         wchar_t szErrorText[256]{};

	xor	edx, edx
	mov	r8d, 512				; 00000200H
	lea	rcx, QWORD PTR szErrorText$1[rsp]
	call	memset

; 1829 :         LONG errorCode = 0;
; 1830 : 
; 1831 :         if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	test	BYTE PTR [rbx+4], 8
	je	SHORT $LN16@GetFailure

; 1832 :         {
; 1833 :             errorCode = failure.status;

	mov	ebp, DWORD PTR [rbx+12]

; 1834 :             if (wil::details::g_pfnFormatNtStatusMsg)

	mov	rax, QWORD PTR ?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA ; wil::details::g_pfnFormatNtStatusMsg
	test	rax, rax
	je	SHORT $LN17@GetFailure

; 1835 :             {
; 1836 :                 wil::details::g_pfnFormatNtStatusMsg(failure.status, szErrorText, ARRAYSIZE(szErrorText));

	mov	r8d, 256				; 00000100H
	lea	rdx, QWORD PTR szErrorText$1[rsp]
	mov	ecx, ebp
	call	rax

; 1837 :             }
; 1838 :         }

	jmp	SHORT $LN17@GetFailure
$LN16@GetFailure:

; 1839 :         else
; 1840 :         {
; 1841 :             errorCode = failure.hr;

	mov	ebp, DWORD PTR [rbx+8]

; 1842 :             FormatMessageW(

	mov	QWORD PTR [rsp+48], r15
	mov	DWORD PTR [rsp+40], 256			; 00000100H
	lea	rax, QWORD PTR szErrorText$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 1024				; 00000400H
	mov	r8d, ebp
	xor	edx, edx
	mov	ecx, 4608				; 00001200H
	call	QWORD PTR __imp_FormatMessageW
$LN17@GetFailure:

; 1843 :                 FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
; 1844 :                 nullptr,
; 1845 :                 failure.hr,
; 1846 :                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 1847 :                 szErrorText,
; 1848 :                 ARRAYSIZE(szErrorText),
; 1849 :                 nullptr);
; 1850 :         }
; 1851 : 
; 1852 :         // %FILENAME(%LINE): %TYPE(%count) tid(%threadid) %HRESULT %SystemMessage
; 1853 :         //     %Caller_MSG [%CODE(%FUNCTION)]
; 1854 : 
; 1855 :         PWSTR dest = pszDest;
; 1856 :         PCWSTR destEnd = (pszDest + cchDest);

	lea	rsi, QWORD PTR [r14+rsi*2]

; 1857 : 
; 1858 :         if (failure.pszFile != nullptr)

	mov	r9, QWORD PTR [rbx+56]
	mov	rax, QWORD PTR [rbx+136]
	mov	rcx, QWORD PTR [rbx+128]
	mov	rdx, rsi
	test	r9, r9
	je	SHORT $LN19@GetFailure

; 1859 :         {
; 1860 :             dest = details::LogStringPrintf(

	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+40], rcx
	mov	eax, DWORD PTR [rbx+64]
	mov	DWORD PTR [rsp+32], eax
	lea	r8, OFFSET FLAT:??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@
	mov	rcx, r14
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf

; 1861 :                 dest, destEnd, L"%hs(%u)\\%hs!%p: ", failure.pszFile, failure.uLineNumber, failure.pszModule, failure.returnAddress);
; 1862 :         }

	jmp	SHORT $LN37@GetFailure
$LN19@GetFailure:

; 1863 :         else
; 1864 :         {
; 1865 :             dest = details::LogStringPrintf(dest, destEnd, L"%hs!%p: ", failure.pszModule, failure.returnAddress);

	mov	QWORD PTR [rsp+32], rax
	mov	r9, rcx
	lea	r8, OFFSET FLAT:??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@
	mov	rcx, r14
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
$LN37@GetFailure:

; 1866 :         }
; 1867 : 
; 1868 :         if (failure.callerReturnAddress != nullptr)

	mov	r14, rax
	mov	r9, QWORD PTR [rbx+144]
	test	r9, r9
	je	SHORT $LN21@GetFailure

; 1869 :         {
; 1870 :             dest = details::LogStringPrintf(dest, destEnd, L"(caller: %p) ", failure.callerReturnAddress);

	lea	r8, OFFSET FLAT:??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@
	mov	rdx, rsi
	mov	rcx, rax
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
	mov	r14, rax
$LN21@GetFailure:

; 1871 :         }
; 1872 : 
; 1873 :         dest = details::LogStringPrintf(

	call	QWORD PTR __imp_GetCurrentThreadId
	lea	rcx, QWORD PTR szErrorText$1[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], ebp
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rbx+68]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, rdi
	lea	r8, OFFSET FLAT:??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@
	mov	rdx, rsi
	mov	rcx, r14
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf

; 1874 :             dest, destEnd, L"%hs(%d) tid(%x) %08X %ws", pszType, failure.cFailureCount, ::GetCurrentThreadId(), errorCode, szErrorText);
; 1875 : 
; 1876 :         if ((failure.pszMessage != nullptr) || (failure.pszCallContext != nullptr) || (failure.pszFunction != nullptr))

	cmp	QWORD PTR [rbx+24], r15
	jne	SHORT $LN23@GetFailure
	cmp	QWORD PTR [rbx+72], r15
	jne	SHORT $LN23@GetFailure
	cmp	QWORD PTR [rbx+48], r15
	je	$LN33@GetFailure
$LN23@GetFailure:

; 1877 :         {
; 1878 :             dest = details::LogStringPrintf(dest, destEnd, L"    ");

	lea	r8, OFFSET FLAT:??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@
	mov	rdx, rsi
	mov	rcx, rax
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf

; 1879 :             if (failure.pszMessage != nullptr)

	mov	r9, QWORD PTR [rbx+24]
	test	r9, r9
	je	SHORT $LN24@GetFailure

; 1880 :             {
; 1881 :                 dest = details::LogStringPrintf(dest, destEnd, L"Msg:[%ws] ", failure.pszMessage);

	lea	r8, OFFSET FLAT:??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@
	mov	rdx, rsi
	mov	rcx, rax
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
$LN24@GetFailure:

; 1882 :             }
; 1883 :             if (failure.pszCallContext != nullptr)

	mov	r9, QWORD PTR [rbx+72]
	test	r9, r9
	je	SHORT $LN25@GetFailure

; 1884 :             {
; 1885 :                 dest = details::LogStringPrintf(dest, destEnd, L"CallContext:[%hs] ", failure.pszCallContext);

	lea	r8, OFFSET FLAT:??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@
	mov	rdx, rsi
	mov	rcx, rax
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
$LN25@GetFailure:

; 1886 :             }
; 1887 : 
; 1888 :             if (failure.pszCode != nullptr)

	mov	rcx, QWORD PTR [rbx+40]
	mov	r9, QWORD PTR [rbx+48]
	mov	rdx, rsi
	test	rcx, rcx
	je	SHORT $LN26@GetFailure

; 1889 :             {
; 1890 :                 dest = details::LogStringPrintf(dest, destEnd, L"[%hs(%hs)]\n", failure.pszFunction, failure.pszCode);

	mov	QWORD PTR [rsp+32], rcx
	lea	r8, OFFSET FLAT:??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@
	mov	rcx, rax
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf

; 1891 :             }

	jmp	SHORT $LN33@GetFailure
$LN26@GetFailure:

; 1892 :             else if (failure.pszFunction != nullptr)

	mov	rcx, rax
	test	r9, r9
	je	SHORT $LN28@GetFailure

; 1893 :             {
; 1894 :                 dest = details::LogStringPrintf(dest, destEnd, L"[%hs]\n", failure.pszFunction);

	lea	r8, OFFSET FLAT:??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf

; 1895 :             }

	jmp	SHORT $LN33@GetFailure
$LN28@GetFailure:

; 1896 :             else
; 1897 :             {
; 1898 :                 dest = details::LogStringPrintf(dest, destEnd, L"\n");

	lea	r8, OFFSET FLAT:??_C@_13LBAGMAIH@?$AA?6@
	call	?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ ; wil::details::LogStringPrintf
$LN33@GetFailure:

; 1899 :             }
; 1900 :         }
; 1901 :     }
; 1902 : 
; 1903 :     // Explicitly choosing to return success in the event of truncation... Current callers
; 1904 :     // depend upon it or it would be eliminated.
; 1905 :     return S_OK;
; 1906 : }

	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+664]
	add	rsp, 592				; 00000250H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ENDP ; wil::GetFailureLogString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 48
_hr$ = 56
?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z PROC	; wil::details::ResultStatus::FromResult, COMDAT

; 1937 :         {

$LN4:
	sub	rsp, 40					; 00000028H
	mov	r9, rcx

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov	DWORD PTR [rcx], edx
	mov	ecx, edx
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR [r9+4], eax
	mov	rax, r9
	mov	DWORD PTR [r9+8], 0

; 1939 :         }

	add	rsp, 40					; 00000028H
	ret	0
?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z ENDP	; wil::details::ResultStatus::FromResult
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z
_TEXT	SEGMENT
__$ReturnAddress$ = 8
_failure$ = 16
?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z PROC ; wil::details::ResultStatus::FromFailureInfo, COMDAT

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+4]
	shr	eax, 3
	and	eax, 1
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx

; 1947 :         }

	ret	0
?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z ENDP ; wil::details::ResultStatus::FromFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0shared_buffer@details@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0shared_buffer@details@wil@@QEAA@XZ PROC		; wil::details::shared_buffer::shared_buffer, COMDAT

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 2251 :         }

	mov	rax, rcx
	ret	0
??0shared_buffer@details@wil@@QEAA@XZ ENDP		; wil::details::shared_buffer::shared_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0shared_buffer@details@wil@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 8
other$ = 16
??0shared_buffer@details@wil@@QEAA@AEBV012@@Z PROC	; wil::details::shared_buffer::shared_buffer, COMDAT

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax

; 2255 :             assign(other.m_pCopy, other.m_size);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdx+8]

; 2363 :             if (pCopy != nullptr)

	test	rax, rax
	je	SHORT $LN13@shared_buf

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rcx], rax

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rcx+8], r8

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [rax]
$LN13@shared_buf:

; 2256 :         }

	mov	rax, rcx
	ret	0
??0shared_buffer@details@wil@@QEAA@AEBV012@@Z ENDP	; wil::details::shared_buffer::shared_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??1shared_buffer@details@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1shared_buffer@details@wil@@QEAA@XZ PROC		; wil::details::shared_buffer::~shared_buffer, COMDAT

; 2265 :         {

$LN13:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN5@shared_buf

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN6@shared_buf
	mov	QWORD PTR [rsp+48], rbx

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
	mov	rbx, QWORD PTR [rsp+48]
$LN6@shared_buf:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], rax
$LN5@shared_buf:

; 2266 :             reset();
; 2267 :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1shared_buffer@details@wil@@QEAA@XZ ENDP		; wil::details::shared_buffer::~shared_buffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?reset@shared_buffer@details@wil@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?reset@shared_buffer@details@wil@@QEAAXXZ PROC		; wil::details::shared_buffer::reset, COMDAT

; 2292 :         {

$LN10:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@reset

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN3@reset
	mov	QWORD PTR [rsp+48], rbx

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
	mov	rbx, QWORD PTR [rsp+48]
$LN3@reset:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], rax
$LN2@reset:

; 2301 :             }
; 2302 :         }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?reset@shared_buffer@details@wil@@QEAAXXZ ENDP		; wil::details::shared_buffer::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z
_TEXT	SEGMENT
this$ = 48
pData$dead$ = 56
cbData$ = 64
?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z PROC	; wil::details::shared_buffer::create, COMDAT

; 2305 :         {

$LN39:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, r8
	mov	rdi, rcx

; 2306 :             if (cbData == 0)

	test	r8, r8
	jne	SHORT $LN2@create

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN8@create

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN9@create

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN9@create:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi], 0

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], 0
$LN8@create:

; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;

	mov	al, 1

; 2325 :         }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@create:
	mov	QWORD PTR [rsp+48], r14

; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));

	call	QWORD PTR __imp_GetProcessHeap
	lea	r8, QWORD PTR [rbp+4]
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapAlloc
	mov	r14, rax

; 2313 :             if (pCopyRefCount == nullptr)

	test	rax, rax
	je	SHORT $LN36@create

; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;

	mov	DWORD PTR [rax], 0

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN29@create

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN26@create

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN26@create:

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], 0
$LN29@create:

; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rdi], r14

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rdi+8], rbp

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [r14]

; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;

	mov	al, 1
$LN36@create:
	mov	r14, QWORD PTR [rsp+48]

; 2325 :         }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z ENDP	; wil::details::shared_buffer::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?create@shared_buffer@details@wil@@QEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
cbData$ = 56
?create@shared_buffer@details@wil@@QEAA_N_K@Z PROC	; wil::details::shared_buffer::create, COMDAT

; 2328 :         {

$LN42:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rdi, rcx

; 2306 :             if (cbData == 0)

	test	rdx, rdx
	jne	SHORT $LN5@create

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN11@create

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN12@create

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN12@create:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi], 0

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], 0
$LN11@create:

; 2329 :             return create(nullptr, cbData);

	mov	al, 1

; 2330 :         }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN5@create:
	mov	QWORD PTR [rsp+48], r14

; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));

	call	QWORD PTR __imp_GetProcessHeap
	lea	r8, QWORD PTR [rbp+4]
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapAlloc
	mov	r14, rax

; 2313 :             if (pCopyRefCount == nullptr)

	test	rax, rax
	je	SHORT $LN39@create

; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;

	mov	DWORD PTR [rax], 0

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN32@create

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN29@create

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN29@create:

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], 0
$LN32@create:

; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rdi], r14

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rdi+8], rbp

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [r14]

; 2329 :             return create(nullptr, cbData);

	mov	al, 1
$LN39@create:
	mov	r14, QWORD PTR [rsp+48]

; 2330 :         }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?create@shared_buffer@details@wil@@QEAA_N_K@Z ENDP	; wil::details::shared_buffer::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z
_TEXT	SEGMENT
this$ = 8
pSize$ = 16
?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z PROC	; wil::details::shared_buffer::get, COMDAT

; 2334 :             if (pSize != nullptr)

	test	rdx, rdx
	je	SHORT $LN2@get

; 2335 :             {
; 2336 :                 *pSize = m_size;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax
$LN2@get:

; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	mov	rdx, QWORD PTR [rcx]
	xor	eax, eax
	test	rdx, rdx
	lea	rcx, QWORD PTR [rdx+4]
	cmovne	rax, rcx

; 2339 :         }

	ret	0
?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z ENDP	; wil::details::shared_buffer::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?size@shared_buffer@details@wil@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@shared_buffer@details@wil@@QEBA_KXZ PROC		; wil::details::shared_buffer::size, COMDAT

; 2343 :             return m_size;

	mov	rax, QWORD PTR [rcx+8]

; 2344 :         }

	ret	0
?size@shared_buffer@details@wil@@QEBA_KXZ ENDP		; wil::details::shared_buffer::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??Bshared_buffer@details@wil@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bshared_buffer@details@wil@@QEBA_NXZ PROC		; wil::details::shared_buffer::operator bool, COMDAT

; 2348 :             return (m_pCopy != nullptr);

	cmp	QWORD PTR [rcx], 0
	setne	al

; 2349 :         }

	ret	0
??Bshared_buffer@details@wil@@QEBA_NXZ ENDP		; wil::details::shared_buffer::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?unique@shared_buffer@details@wil@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?unique@shared_buffer@details@wil@@QEBA_NXZ PROC	; wil::details::shared_buffer::unique, COMDAT

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN3@unique
	cmp	DWORD PTR [rax], 1
	jne	SHORT $LN3@unique
	mov	al, 1

; 2354 :         }

	ret	0
$LN3@unique:

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	xor	al, al

; 2354 :         }

	ret	0
?unique@shared_buffer@details@wil@@QEBA_NXZ ENDP	; wil::details::shared_buffer::unique
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z
_TEXT	SEGMENT
this$ = 48
pCopy$ = 56
cbSize$ = 64
?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z PROC	; wil::details::shared_buffer::assign, COMDAT

; 2361 :         {

$LN16:
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbp, r8

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx]

; 2361 :         {

	mov	rsi, rdx

; 2293 :             if (m_pCopy != nullptr)

	test	rcx, rcx
	je	SHORT $LN10@assign

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN7@assign
	mov	QWORD PTR [rsp+48], rbx

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
	mov	rbx, QWORD PTR [rsp+48]
$LN7@assign:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+8], rax
$LN10@assign:

; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)

	test	rsi, rsi
	je	SHORT $LN2@assign

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rdi], rsi

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rdi+8], rbp

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [rsi]
$LN2@assign:

; 2368 :             }
; 2369 :         }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z ENDP	; wil::details::shared_buffer::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?RecordFailFast@details@wil@@YAHJ@Z
_TEXT	SEGMENT
hr$ = 8
?RecordFailFast@details@wil@@YAHJ@Z PROC		; wil::details::RecordFailFast, COMDAT

; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;

	mov	DWORD PTR ?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC, ecx ; `wil::details::RecordFailFast'::`2'::s_hrErrorLast

; 2554 :         return 1;

	mov	eax, 1

; 2555 :     }

	ret	0
?RecordFailFast@details@wil@@YAHJ@Z ENDP		; wil::details::RecordFailFast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z
_TEXT	SEGMENT
hModule$ = 32
modulePath$3 = 48
__$ArrayPad$ = 320
address$ = 384
addressOffset$ = 392
name$ = 400
size$ = 408
?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z PROC ; wil::details::K32GetModuleInformation, COMDAT

; 2573 :     {

$LN61:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2574 :         HMODULE hModule = nullptr;

	xor	ebp, ebp
	mov	r14, rcx
	mov	ecx, ebp
	mov	rdi, r9
	mov	QWORD PTR hModule$[rsp], rcx
	mov	rbx, r8
	mov	rsi, rdx

; 2575 :         if (address && !GetModuleHandleExW(

	test	r14, r14
	je	SHORT $LN4@K32GetModu
	lea	r8, QWORD PTR hModule$[rsp]
	mov	rdx, r14
	mov	ecx, 6
	call	QWORD PTR __imp_GetModuleHandleExW
	test	eax, eax
	jne	SHORT $LN44@K32GetModu
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	rsi, rsi
	je	SHORT $LN41@K32GetModu

; 646  :     {
; 647  :         *outParam = val;

	mov	DWORD PTR [rsi], ebp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2594 :                 return false;

	jmp	$LN1@K32GetModu
$LN44@K32GetModu:

; 2575 :         if (address && !GetModuleHandleExW(

	mov	rcx, QWORD PTR hModule$[rsp]
$LN4@K32GetModu:

; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)

	test	rsi, rsi
	je	SHORT $LN5@K32GetModu

; 2584 :         {
; 2585 :             *addressOffset =

	mov	eax, r14d
	sub	eax, ecx
	test	r14, r14
	cmovne	ebp, eax
	mov	DWORD PTR [rsi], ebp
$LN5@K32GetModu:

; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)

	test	rbx, rbx
	je	$LN18@K32GetModu

; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))

	mov	r8d, 260				; 00000104H
	lea	rdx, QWORD PTR modulePath$3[rsp]
	call	QWORD PTR __imp_GetModuleFileNameA
	test	eax, eax
	jne	SHORT $LN7@K32GetModu
$LN41@K32GetModu:

; 2594 :                 return false;

	xor	al, al
	jmp	$LN1@K32GetModu
$LN7@K32GetModu:

; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);

	lea	rcx, QWORD PTR modulePath$3[rsp]
	mov	rax, -1
$LL43@K32GetModu:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL43@K32GetModu
	lea	rcx, QWORD PTR modulePath$3[rsp]
	add	rcx, rax

; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))

	lea	rax, QWORD PTR modulePath$3[rsp]
	cmp	rcx, rax
	jbe	SHORT $LN45@K32GetModu
$LL2@K32GetModu:
	cmp	BYTE PTR [rcx-1], 92			; 0000005cH
	je	SHORT $LN45@K32GetModu

; 2599 :             {
; 2600 :                 start--;

	dec	rcx
	lea	rax, QWORD PTR modulePath$3[rsp]
	cmp	rcx, rax
	ja	SHORT $LL2@K32GetModu
$LN45@K32GetModu:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	test	rdi, rdi
	je	SHORT $LN18@K32GetModu
	cmp	rdi, 2147483647				; 7fffffffH
	jbe	SHORT $LN40@K32GetModu

; 557  :         *pszDest = '\0';

	mov	BYTE PTR [rbx], 0
	jmp	SHORT $LN18@K32GetModu
$LN40@K32GetModu:

; 549  :         hr = StringCopyWorkerA(pszDest,

	mov	edx, 2147483646				; 7ffffffeH
	sub	rdx, rdi
	sub	rcx, rbx
$LL25@K32GetModu:

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	lea	rax, QWORD PTR [rdx+rdi]
	test	rax, rax
	je	SHORT $LN26@K32GetModu
	movzx	eax, BYTE PTR [rcx+rbx]
	test	al, al
	je	SHORT $LN26@K32GetModu

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	mov	BYTE PTR [rbx], al
	inc	rbx

; 9919 :         cchDest--;

	sub	rdi, 1
	jne	SHORT $LL25@K32GetModu
$LN26@K32GetModu:

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	test	rdi, rdi
	lea	rax, QWORD PTR [rbx-1]
	cmovne	rax, rbx
	mov	BYTE PTR [rax], 0
$LN18@K32GetModu:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2604 :         return true;

	mov	al, 1
$LN1@K32GetModu:

; 2605 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 336				; 00000150H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z ENDP ; wil::details::K32GetModuleInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?GetCurrentModuleName@details@wil@@YAPEBDXZ
_TEXT	SEGMENT
hModule$3 = 32
modulePath$4 = 48
__$ArrayPad$ = 320
?GetCurrentModuleName@details@wil@@YAPEBDXZ PROC	; wil::details::GetCurrentModuleName, COMDAT

; 2610 :     {

$LN58:
	push	rbx
	sub	rsp, 336				; 00000150H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable

	movzx	eax, BYTE PTR ?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid
	test	al, al
	jne	$LN45@GetCurrent

; 2575 :         if (address && !GetModuleHandleExW(

	lea	r8, QWORD PTR hModule$3[rsp]
	mov	QWORD PTR hModule$3[rsp], 0
	lea	rdx, OFFSET FLAT:?RecordFailFast@details@wil@@YAHJ@Z ; wil::details::RecordFailFast
	mov	ecx, 6
	call	QWORD PTR __imp_GetModuleHandleExW
	lea	rbx, OFFSET FLAT:?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA ; `wil::details::GetCurrentModuleName'::`2'::s_szModule
	test	eax, eax
	je	$LN22@GetCurrent

; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))

	mov	rcx, QWORD PTR hModule$3[rsp]
	lea	rdx, QWORD PTR modulePath$4[rsp]
	mov	r8d, 260				; 00000104H
	call	QWORD PTR __imp_GetModuleFileNameA
	test	eax, eax
	je	SHORT $LN22@GetCurrent

; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);

	lea	rcx, QWORD PTR modulePath$4[rsp]
	mov	rax, -1
	npad	1
$LL44@GetCurrent:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL44@GetCurrent
	lea	rcx, QWORD PTR modulePath$4[rsp]
	add	rcx, rax

; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))

	lea	rax, QWORD PTR modulePath$4[rsp]
	cmp	rcx, rax
	jbe	SHORT $LN46@GetCurrent
	npad	5
$LL6@GetCurrent:
	cmp	BYTE PTR [rcx-1], 92			; 0000005cH
	je	SHORT $LN46@GetCurrent

; 2599 :             {
; 2600 :                 start--;

	dec	rcx
	lea	rax, QWORD PTR modulePath$4[rsp]
	cmp	rcx, rax
	ja	SHORT $LL6@GetCurrent
$LN46@GetCurrent:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 549  :         hr = StringCopyWorkerA(pszDest,

	mov	r8d, 64					; 00000040H
	mov	rdx, rbx
	sub	rcx, rbx
	npad	1
$LL29@GetCurrent:

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	lea	rax, QWORD PTR [r8+2147483582]
	test	rax, rax
	je	SHORT $LN30@GetCurrent
	movzx	eax, BYTE PTR [rcx+rdx]
	test	al, al
	je	SHORT $LN30@GetCurrent

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	mov	BYTE PTR [rdx], al
	inc	rdx

; 9919 :         cchDest--;

	sub	r8, 1
	jne	SHORT $LL29@GetCurrent
$LN30@GetCurrent:

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	test	r8, r8
	lea	rcx, QWORD PTR [rdx-1]
	cmovne	rcx, rdx
	mov	BYTE PTR [rcx], 0
$LN22@GetCurrent:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2616 :             s_fModuleValid = true;

	mov	BYTE PTR ?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC, 1 ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid

; 2617 :         }
; 2618 :         return s_szModule;

	mov	rax, rbx
	jmp	SHORT $LN2@GetCurrent
$LN45@GetCurrent:
	lea	rax, OFFSET FLAT:?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA ; `wil::details::GetCurrentModuleName'::`2'::s_szModule
$LN2@GetCurrent:

; 2619 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 336				; 00000150H
	pop	rbx
	ret	0
?GetCurrentModuleName@details@wil@@YAPEBDXZ ENDP	; wil::details::GetCurrentModuleName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?DebugBreak@details@wil@@YAXXZ
_TEXT	SEGMENT
?DebugBreak@details@wil@@YAXXZ PROC			; wil::details::DebugBreak, COMDAT

; 2624 :         ::DebugBreak();

	rex_jmp	QWORD PTR __imp_DebugBreak
?DebugBreak@details@wil@@YAXXZ ENDP			; wil::details::DebugBreak
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z
_TEXT	SEGMENT
er$ = 48
cr$ = 56
flags$ = 64
?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z PROC ; wil::details::WilDynamicLoadRaiseFailFastException, COMDAT

; 2628 :     {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	ebx, r8d

; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");

	lea	rcx, OFFSET FLAT:??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@
	mov	rdi, rdx
	call	QWORD PTR __imp_GetModuleHandleW

; 1700 :         return reinterpret_cast<FuncPtr>(reinterpret_cast<void (*)()>(::GetProcAddress(module, procName)));

	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0BH@EEDPADAA@RaiseFailFastException@
	call	QWORD PTR __imp_GetProcAddress

; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)

	test	rax, rax
	je	SHORT $LN2@WilDynamic

; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);

	mov	r8d, ebx
	mov	rdx, rdi
	mov	rcx, rsi
	call	rax
$LN2@WilDynamic:

; 2636 :         }
; 2637 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z ENDP ; wil::details::WilDynamicLoadRaiseFailFastException
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?HrToNtStatus@details@wil@@YAJJ@Z
_TEXT	SEGMENT
hr$ = 8
?HrToNtStatus@details@wil@@YAJJ@Z PROC			; wil::details::HrToNtStatus, COMDAT

; 2689 :     {

	mov	edx, ecx

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	cmp	ecx, -2147024895			; ffffffff80070001H
	jg	SHORT $LN37@HrToNtStat
	je	SHORT $LN11@HrToNtStat
	cmp	ecx, -2147467259			; ffffffff80004005H
	jne	$LN25@HrToNtStat

; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;

	mov	edx, -1073741823			; ffffffffc0000001H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN11@HrToNtStat:

; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;

	mov	edx, -1073741822			; ffffffffc0000002H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN37@HrToNtStat:

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	cmp	edx, -2147024362			; ffffffff80070216H
	jg	$LN38@HrToNtStat
	je	SHORT $LN8@HrToNtStat
	lea	eax, DWORD PTR [rcx+2147024894]
	cmp	eax, 232				; 000000e8H
	ja	$LN25@HrToNtStat
	lea	r8, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN41@HrToNtStat[r8+rax]
	mov	ecx, DWORD PTR $LN42@HrToNtStat[r8+rax*4]
	add	rcx, r8
	jmp	rcx
$LN5@HrToNtStat:

; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;

	mov	edx, -1073741811			; ffffffffc000000dH

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN7@HrToNtStat:

; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;

	mov	edx, -1073741801			; ffffffffc0000017H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN9@HrToNtStat:

; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;

	mov	edx, -1073741766			; ffffffffc000003aH

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN10@HrToNtStat:

; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;

	mov	edx, -1073741772			; ffffffffc0000034H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN12@HrToNtStat:

; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;

	mov	edx, -2147483643			; ffffffff80000005H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN17@HrToNtStat:

; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;

	mov	edx, -1073741789			; ffffffffc0000023H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN18@HrToNtStat:

; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;

	mov	edx, -1073741697			; ffffffffc000007fH

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN19@HrToNtStat:

; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;

	mov	edx, -1073741773			; ffffffffc0000033H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN20@HrToNtStat:

; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;

	mov	edx, -1073741515			; ffffffffc0000135H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN8@HrToNtStat:

; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;

	mov	edx, -1073741675			; ffffffffc0000095H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN38@HrToNtStat:

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	cmp	edx, -2147023746			; ffffffff8007047eH
	jg	SHORT $LN39@HrToNtStat
	je	SHORT $LN21@HrToNtStat
	cmp	edx, -2147024322			; ffffffff8007023eH
	je	SHORT $LN24@HrToNtStat
	cmp	edx, -2147024314			; ffffffff80070246H
	je	SHORT $LN15@HrToNtStat
	cmp	edx, -2147024313			; ffffffff80070247H
	je	SHORT $LN16@HrToNtStat
	cmp	edx, -2147024270			; ffffffff80070272H
	jne	SHORT $LN25@HrToNtStat

; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;

	mov	edx, -1073741197			; ffffffffc0000273H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN16@HrToNtStat:

; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;

	mov	edx, -1073741469			; ffffffffc0000163H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN15@HrToNtStat:

; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;

	mov	edx, -1073741471			; ffffffffc0000161H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN24@HrToNtStat:

; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;

	mov	edx, -1073741787			; ffffffffc0000025H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN21@HrToNtStat:

; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;

	mov	edx, -1073741735			; ffffffffc0000059H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN39@HrToNtStat:

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	cmp	edx, -2147023604			; ffffffff8007050cH
	je	SHORT $LN13@HrToNtStat
	cmp	edx, -2147023537			; ffffffff8007054fH
	je	SHORT $LN6@HrToNtStat
	cmp	edx, -2147023431			; ffffffff800705b9H
	je	SHORT $LN23@HrToNtStat
	test	edx, edx
	je	SHORT $LN4@HrToNtStat
$LN25@HrToNtStat:

; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)

	bt	edx, 28
	jae	SHORT $LN26@HrToNtStat

; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);

	btr	edx, 28

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN26@HrToNtStat:

; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)

	mov	eax, edx
	and	eax, 536805376				; 1fff0000H
	cmp	eax, 458752				; 00070000H
	jne	SHORT $LN28@HrToNtStat

; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));

	movzx	edx, dx

; 2785 :             }

	mov	eax, edx
	or	eax, -1073283072			; ffffffffc0070000H
	test	edx, edx
	cmovne	edx, eax

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN28@HrToNtStat:

; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)

	cmp	eax, 589824				; 00090000H
	jne	SHORT $LN6@HrToNtStat

; 2787 :             {
; 2788 :                 status =

	test	edx, edx
	jle	SHORT $LN31@HrToNtStat
	movzx	edx, dx
	or	edx, -1073152000			; ffffffffc0090000H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN4@HrToNtStat:

; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;

	xor	edx, edx

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN23@HrToNtStat:

; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;

	mov	edx, -1073700733			; ffffffffc000a083H

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
$LN6@HrToNtStat:

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	edx, -1073741595			; ffffffffc00000e5H
	mov	eax, edx

; 2799 :     }

	ret	0
$LN13@HrToNtStat:

; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;

	mov	edx, -1073740757			; ffffffffc000042bH
$LN31@HrToNtStat:

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;

	mov	eax, edx

; 2799 :     }

	ret	0
	npad	3
$LN42@HrToNtStat:
	DD	$LN10@HrToNtStat
	DD	$LN9@HrToNtStat
	DD	$LN7@HrToNtStat
	DD	$LN5@HrToNtStat
	DD	$LN18@HrToNtStat
	DD	$LN17@HrToNtStat
	DD	$LN19@HrToNtStat
	DD	$LN20@HrToNtStat
	DD	$LN12@HrToNtStat
	DD	$LN25@HrToNtStat
$LN41@HrToNtStat:
	DB	0
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	6
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
?HrToNtStatus@details@wil@@YAJJ@Z ENDP			; wil::details::HrToNtStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?ResultStringSize@details@wil@@YA_KPEBD@Z
_TEXT	SEGMENT
psz$ = 8
?ResultStringSize@details@wil@@YA_KPEBD@Z PROC		; wil::details::ResultStringSize, COMDAT

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN3@ResultStri
	mov	eax, 1

; 3019 :     }

	ret	0
$LN3@ResultStri:

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, -1
$LL5@ResultStri:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL5@ResultStri
	inc	rax

; 3019 :     }

	ret	0
?ResultStringSize@details@wil@@YA_KPEBD@Z ENDP		; wil::details::ResultStringSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?ResultStringSize@details@wil@@YA_KPEB_W@Z
_TEXT	SEGMENT
psz$ = 8
?ResultStringSize@details@wil@@YA_KPEB_W@Z PROC		; wil::details::ResultStringSize, COMDAT

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	test	rcx, rcx
	jne	SHORT $LN3@ResultStri
	mov	eax, 2

; 3025 :     }

	ret	0
$LN3@ResultStri:

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov	rax, -1
$LL5@ResultStri:
	cmp	WORD PTR [rcx+rax*2+2], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL5@ResultStri
	lea	rax, QWORD PTR [rax*2+2]

; 3025 :     }

	ret	0
?ResultStringSize@details@wil@@YA_KPEB_W@Z ENDP		; wil::details::ResultStringSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ
_TEXT	SEGMENT
?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ PROC ; wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, COMDAT

; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }

	ret	0
?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ ENDP ; wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??R<lambda_1>@details@wil@@QEBA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??R<lambda_1>@details@wil@@QEBA@XZ PROC			; wil::details::<lambda_1>::operator(), COMDAT

; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {

	mov	eax, 1
	ret	0
??R<lambda_1>@details@wil@@QEBA@XZ ENDP			; wil::details::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z
_TEXT	SEGMENT
this$ = 48
other$ = 56
??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z PROC ; wil::StoredFailureInfo::StoredFailureInfo, COMDAT

; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	eax, eax

; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT

	mov	rbx, rcx

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	mov	QWORD PTR [rcx+152], rax
	mov	QWORD PTR [rcx+160], rax

; 3359 :     {
; 3360 :         SetFailureInfo(other);

	call	?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z ; wil::StoredFailureInfo::SetFailureInfo

; 3361 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z ENDP ; wil::StoredFailureInfo::StoredFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ
_TEXT	SEGMENT
this$ = 8
?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ PROC ; wil::StoredFailureInfo::GetFailureInfo, COMDAT

; 3365 :         return m_failureInfo;

	mov	rax, rcx

; 3366 :     }

	ret	0
?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ ENDP ; wil::StoredFailureInfo::GetFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z
_TEXT	SEGMENT
this$ = 80
$T34 = 80
failure$ = 88
?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z PROC ; wil::StoredFailureInfo::SetFailureInfo, COMDAT

; 3369 :     {

$LN480:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 3370 :         m_failureInfo = failure;

	movups	xmm0, XMMWORD PTR [rdx]
	mov	r15, rcx
	mov	rdi, rdx

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov	rsi, -1
	mov	r14d, 2

; 3370 :         m_failureInfo = failure;

	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR [rdx+64]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm1, XMMWORD PTR [rdx+80]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm0, XMMWORD PTR [rdx+96]
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	xmm1, XMMWORD PTR [rdx+112]
	movups	XMMWORD PTR [rcx+112], xmm1
	movups	xmm0, XMMWORD PTR [rdx+128]
	movups	XMMWORD PTR [rcx+128], xmm0
	movsd	xmm1, QWORD PTR [rdx+144]
	movsd	QWORD PTR [rcx+144], xmm1

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdx+24]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	test	rcx, rcx
	jne	SHORT $LN11@SetFailure
	mov	QWORD PTR $T34[rsp], r14
	jmp	SHORT $LN12@SetFailure
$LN11@SetFailure:
	mov	rax, rsi
	npad	2
$LL360@SetFailure:
	cmp	WORD PTR [rcx+rax*2+2], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL360@SetFailure
	lea	rax, QWORD PTR [rax*2+2]
	mov	QWORD PTR $T34[rsp], rax
$LN12@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdx+40]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	edx, 1
	test	rcx, rcx
	jne	SHORT $LN15@SetFailure
	mov	r13d, edx
	jmp	SHORT $LN16@SetFailure
$LN15@SetFailure:
	mov	rax, rsi
	npad	1
$LL359@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL359@SetFailure
	lea	r13, QWORD PTR [rax+1]
$LN16@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+48]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN19@SetFailure
	mov	r12, rdx
	jmp	SHORT $LN20@SetFailure
$LN19@SetFailure:
	mov	rax, rsi
$LL358@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL358@SetFailure
	lea	r12, QWORD PTR [rax+1]
$LN20@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+56]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN23@SetFailure
	mov	rbx, rdx
	jmp	SHORT $LN24@SetFailure
$LN23@SetFailure:
	mov	rax, rsi
$LL357@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL357@SetFailure
	lea	rbx, QWORD PTR [rax+1]
$LN24@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+72]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN27@SetFailure
	mov	r11, rdx
	jmp	SHORT $LN28@SetFailure
$LN27@SetFailure:
	mov	rax, rsi
$LL356@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL356@SetFailure
	lea	r11, QWORD PTR [rax+1]
$LN28@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+128]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN31@SetFailure
	mov	r10, rdx
	jmp	SHORT $LN32@SetFailure
$LN31@SetFailure:
	mov	rax, rsi
$LL355@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL355@SetFailure
	lea	r10, QWORD PTR [rax+1]
$LN32@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+112]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	jne	SHORT $LN35@SetFailure
	mov	r9, rdx
	jmp	SHORT $LN36@SetFailure
$LN35@SetFailure:
	mov	rax, rsi
$LL354@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL354@SetFailure
	lea	r9, QWORD PTR [rax+1]
$LN36@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+120]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	test	rcx, rcx
	jne	SHORT $LN39@SetFailure
	mov	r8, r14
	jmp	SHORT $LN40@SetFailure
$LN39@SetFailure:
	mov	rax, rsi
$LL353@SetFailure:
	cmp	WORD PTR [rcx+rax*2+2], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL353@SetFailure
	lea	r8, QWORD PTR [rax*2+2]
$LN40@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+88]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	test	rcx, rcx
	je	SHORT $LN44@SetFailure
	mov	rax, rsi
$LL352@SetFailure:
	cmp	BYTE PTR [rcx+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL352@SetFailure
	lea	rdx, QWORD PTR [rax+1]
$LN44@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	mov	rcx, QWORD PTR [rdi+96]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	test	rcx, rcx
	je	SHORT $LN48@SetFailure
	mov	rax, rsi
	npad	2
$LL351@SetFailure:
	cmp	WORD PTR [rcx+rax*2+2], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL351@SetFailure
	lea	r14, QWORD PTR [rax*2+2]
$LN48@SetFailure:

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	lea	rbp, QWORD PTR [r14+rdx]
	add	rbp, r8

; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))

	lea	r14, QWORD PTR [r15+152]

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	mov	rcx, QWORD PTR [r14]

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	add	rbp, r9
	add	rbp, r10
	add	rbp, r11
	add	rbp, rbx
	add	rbp, r12
	add	rbp, r13

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	xor	r13d, r13d

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	add	rbp, QWORD PTR $T34[rsp]

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	test	rcx, rcx
	je	SHORT $LN330@SetFailure
	cmp	DWORD PTR [rcx], 1
	jne	SHORT $LN325@SetFailure

; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))

	cmp	QWORD PTR [r15+160], rbp
	jae	SHORT $LN2@SetFailure
$LN325@SetFailure:

; 2293 :             if (m_pCopy != nullptr)

	test	rcx, rcx
	je	SHORT $LN330@SetFailure

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, esi
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN62@SetFailure

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [r14]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN62@SetFailure:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [r14], r13

; 2300 :                 m_size = 0;

	mov	QWORD PTR [r14+8], r13
$LN330@SetFailure:

; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);

	mov	rdx, rbp
	mov	rcx, r14
	call	?create@shared_buffer@details@wil@@QEAA_N_K@Z ; wil::details::shared_buffer::create
$LN2@SetFailure:

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	mov	rcx, QWORD PTR [r14]

; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;

	mov	rbx, r13

; 2336 :                 *pSize = m_size;

	mov	r8, QWORD PTR [r14+8]

; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;

	test	rcx, rcx
	lea	rax, QWORD PTR [rcx+4]
	cmovne	rbx, rax
	test	rbx, rbx
	je	$LN4@SetFailure

; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);

	mov	rdx, QWORD PTR [rdi+24]
	lea	rbp, QWORD PTR [rbx+r8]
	lea	r14, QWORD PTR [r15+24]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN67@SetFailure
	test	rdx, rdx
	je	SHORT $LN67@SetFailure
	cmp	WORD PTR [rdx], r13w
	je	SHORT $LN67@SetFailure

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov	rax, rsi
	npad	8
$LL350@SetFailure:
	cmp	WORD PTR [rdx+rax*2+2], r13w
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL350@SetFailure
	lea	r12, QWORD PTR [rax*2+2]

; 3049 :         if (bufferSize < stringSize)

	cmp	r8, r12
	jae	SHORT $LN68@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN78@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN78@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+40]
	lea	r14, QWORD PTR [r15+40]
	jmp	SHORT $LN339@SetFailure
$LN68@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN86@SetFailure

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN86@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN89@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN89@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN71@SetFailure
$LN67@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN71@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN71@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);

	mov	rdx, QWORD PTR [rdi+40]
	lea	r14, QWORD PTR [r15+40]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN93@SetFailure
$LN339@SetFailure:
	test	rdx, rdx
	je	SHORT $LN93@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN93@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
	npad	6
$LL349@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL349@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN94@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN104@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN104@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+48]
	lea	r14, QWORD PTR [r15+48]
	jmp	SHORT $LN338@SetFailure
$LN94@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN112@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN108@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN112@SetFailure
$LN108@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN112@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN115@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN115@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN97@SetFailure
$LN93@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN97@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN97@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);

	mov	rdx, QWORD PTR [rdi+48]
	lea	r14, QWORD PTR [r15+48]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN119@SetFailure
$LN338@SetFailure:
	test	rdx, rdx
	je	SHORT $LN119@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN119@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
$LL348@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL348@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN120@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN130@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN130@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+56]
	lea	r14, QWORD PTR [r15+56]
	jmp	SHORT $LN337@SetFailure
$LN120@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN138@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN134@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN138@SetFailure
$LN134@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN138@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN141@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN141@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN123@SetFailure
$LN119@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN123@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN123@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);

	mov	rdx, QWORD PTR [rdi+56]
	lea	r14, QWORD PTR [r15+56]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN145@SetFailure
$LN337@SetFailure:
	test	rdx, rdx
	je	SHORT $LN145@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN145@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
$LL347@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL347@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN146@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN156@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN156@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+72]
	lea	r14, QWORD PTR [r15+72]
	jmp	SHORT $LN336@SetFailure
$LN146@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN164@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN160@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN164@SetFailure
$LN160@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN164@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN167@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN167@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN149@SetFailure
$LN145@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN149@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN149@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);

	mov	rdx, QWORD PTR [rdi+72]
	lea	r14, QWORD PTR [r15+72]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN171@SetFailure
$LN336@SetFailure:
	test	rdx, rdx
	je	SHORT $LN171@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN171@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
	npad	10
$LL346@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL346@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN172@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN182@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN182@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+128]
	lea	r14, QWORD PTR [r15+128]
	jmp	SHORT $LN335@SetFailure
$LN172@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN190@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN186@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN190@SetFailure
$LN186@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN190@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN193@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN193@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN175@SetFailure
$LN171@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN175@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN175@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);

	mov	rdx, QWORD PTR [rdi+128]
	lea	r14, QWORD PTR [r15+128]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN197@SetFailure
$LN335@SetFailure:
	test	rdx, rdx
	je	SHORT $LN197@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN197@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
	npad	2
$LL345@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL345@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN198@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN208@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN208@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+112]
	lea	r14, QWORD PTR [r15+112]
	jmp	SHORT $LN334@SetFailure
$LN198@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN216@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN212@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN216@SetFailure
$LN212@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN216@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN219@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN219@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN201@SetFailure
$LN197@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN201@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN201@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3398 :             pBuffer = details::WriteResultString(

	mov	rdx, QWORD PTR [rdi+112]
	lea	r14, QWORD PTR [r15+112]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN223@SetFailure
$LN334@SetFailure:
	test	rdx, rdx
	je	SHORT $LN223@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN223@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
$LL344@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL344@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN224@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN234@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN234@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+120]
	lea	r14, QWORD PTR [r15+120]
	jmp	SHORT $LN333@SetFailure
$LN224@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN242@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN238@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN242@SetFailure
$LN238@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN242@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN245@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN245@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN227@SetFailure
$LN223@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN227@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN227@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3400 :             pBuffer = details::WriteResultString(

	mov	rdx, QWORD PTR [rdi+120]
	lea	r14, QWORD PTR [r15+120]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN249@SetFailure
$LN333@SetFailure:
	test	rdx, rdx
	je	SHORT $LN249@SetFailure
	cmp	WORD PTR [rdx], r13w
	je	SHORT $LN249@SetFailure

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov	rax, rsi
	npad	11
$LL343@SetFailure:
	cmp	WORD PTR [rdx+rax*2+2], r13w
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL343@SetFailure
	lea	r12, QWORD PTR [rax*2+2]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN250@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN260@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN260@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+88]
	lea	r14, QWORD PTR [r15+88]
	jmp	SHORT $LN332@SetFailure
$LN250@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN268@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN264@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN268@SetFailure
$LN264@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN268@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN271@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN271@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN253@SetFailure
$LN249@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN253@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN253@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3402 :             pBuffer = details::WriteResultString(

	mov	rdx, QWORD PTR [rdi+88]
	lea	r14, QWORD PTR [r15+88]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN275@SetFailure
$LN332@SetFailure:
	test	rdx, rdx
	je	SHORT $LN275@SetFailure
	cmp	BYTE PTR [rdx], r13b
	je	SHORT $LN275@SetFailure

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, rsi
	npad	9
$LL342@SetFailure:
	cmp	BYTE PTR [rdx+rax+1], r13b
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL342@SetFailure
	lea	r12, QWORD PTR [rax+1]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp
	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, r12
	jae	SHORT $LN276@SetFailure
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN286@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN286@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	mov	rdx, QWORD PTR [rdi+96]
	lea	r14, QWORD PTR [r15+96]
	jmp	SHORT $LN331@SetFailure
$LN276@SetFailure:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	r12, r12
	je	SHORT $LN294@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN290@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN294@SetFailure
$LN290@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, r12
	mov	rcx, rbx
	call	memcpy
$LN294@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN297@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN297@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, r12
	jmp	SHORT $LN279@SetFailure
$LN275@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN279@SetFailure

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [r14], r13
$LN279@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3404 :             pBuffer = details::WriteResultString(

	mov	rdx, QWORD PTR [rdi+96]
	lea	r14, QWORD PTR [r15+96]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rbx, rbp
	je	SHORT $LN301@SetFailure
$LN331@SetFailure:
	test	rdx, rdx
	je	SHORT $LN301@SetFailure
	cmp	WORD PTR [rdx], r13w
	je	SHORT $LN301@SetFailure
$LL341@SetFailure:

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	cmp	WORD PTR [rdx+rsi*2+2], r13w
	lea	rsi, QWORD PTR [rsi+1]
	jne	SHORT $LL341@SetFailure

; 3048 :         size_t const bufferSize = pEnd - pStart;

	mov	rax, rbp

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	lea	rsi, QWORD PTR [rsi*2+2]

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub	rax, rbx

; 3049 :         if (bufferSize < stringSize)

	cmp	rax, rsi
	jb	SHORT $LN301@SetFailure
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	rsi, rsi
	je	SHORT $LN320@SetFailure

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rbx, rbx
	jne	SHORT $LN316@SetFailure
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN320@SetFailure
$LN316@SetFailure:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, rsi
	mov	rcx, rbx
	call	memcpy
$LN320@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	r14, r14
	je	SHORT $LN323@SetFailure

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [r14], rbx
$LN323@SetFailure:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add	rbx, rsi
	jmp	SHORT $LN305@SetFailure
$LN301@SetFailure:

; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);

	test	r14, r14
	je	SHORT $LN305@SetFailure
	mov	QWORD PTR [r14], r13
$LN305@SetFailure:
	sub	rbp, rbx
	xor	edx, edx
	mov	r8, rbp
	mov	rcx, rbx
	call	memset
$LN4@SetFailure:

; 3407 :         }
; 3408 :     }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z ENDP ; wil::StoredFailureInfo::SetFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z
_TEXT	SEGMENT
this$ = 48
failure$ = 56
??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z PROC	; wil::ResultException::ResultException, COMDAT

; 3430 :     {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	edi, edi

; 3430 :     {

	lea	rax, OFFSET FLAT:??_7ResultException@wil@@6B@
	xorps	xmm0, xmm0
	mov	rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 54   :         : _Data()

	movups	XMMWORD PTR [rcx+8], xmm0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3430 :     {

	mov	QWORD PTR [rcx], rax
	add	rcx, 24

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	mov	QWORD PTR [rcx+152], rdi
	mov	QWORD PTR [rcx+160], rdi

; 3360 :         SetFailureInfo(other);

	call	?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z ; wil::StoredFailureInfo::SetFailureInfo

; 3431 :     }

	mov	rax, rbx

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	mov	QWORD PTR [rbx+192], rdi
	mov	QWORD PTR [rbx+200], rdi

; 3431 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z ENDP	; wil::ResultException::ResultException
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ
_TEXT	SEGMENT
this$ = 8
?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ PROC ; wil::ResultException::GetFailureInfo, COMDAT

; 3457 :         return m_failure.GetFailureInfo();

	lea	rax, QWORD PTR [rcx+24]

; 3458 :     }

	ret	0
?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ ENDP ; wil::ResultException::GetFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?what@ResultException@wil@@UEBAPEBDXZ
_TEXT	SEGMENT
message$6 = 64
__$ArrayPad$ = 4160
this$ = 4192
?what@ResultException@wil@@UEBAPEBDXZ PROC		; wil::ResultException::what, COMDAT

; 3468 :     {

$LN25:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	mov	eax, 4176				; 00001050H
	call	__chkstk
	sub	rsp, rax
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)

	lea	rdi, QWORD PTR [rcx+192]
	xor	ebx, ebx
	cmp	QWORD PTR [rdi], rbx
	jne	$LN2@what

; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());

	lea	r8, QWORD PTR [rcx+24]
	mov	edx, 2048				; 00000800H
	lea	rcx, QWORD PTR message$6[rsp]
	call	?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ; wil::GetFailureLogString

; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);

	mov	QWORD PTR [rsp+56], rbx
	lea	r8, QWORD PTR message$6[rsp]
	mov	QWORD PTR [rsp+48], rbx
	mov	r9d, -1
	mov	DWORD PTR [rsp+40], ebx
	xor	edx, edx
	xor	ecx, ecx
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp_WideCharToMultiByte
	movsxd	rsi, eax

; 3476 :             if (!m_what.create(len))

	mov	rcx, rdi
	mov	rdx, rsi
	call	?create@shared_buffer@details@wil@@QEAA_N_K@Z ; wil::details::shared_buffer::create
	test	al, al
	jne	SHORT $LN3@what

; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";

	lea	rax, OFFSET FLAT:??_C@_0O@KIMGFJMA@WIL?5Exception@
	jmp	SHORT $LN1@what
$LN3@what:

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	mov	rcx, QWORD PTR [rdi]

; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);

	lea	r8, QWORD PTR message$6[rsp]
	test	rcx, rcx
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+48], rbx
	mov	rdx, rbx
	mov	DWORD PTR [rsp+40], esi
	mov	r9d, -1
	lea	rax, QWORD PTR [rcx+4]
	cmovne	rdx, rax
	xor	ecx, ecx
	mov	QWORD PTR [rsp+32], rdx
	xor	edx, edx
	call	QWORD PTR __imp_WideCharToMultiByte
$LN2@what:

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	mov	rdx, QWORD PTR [rdi]

; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());

	test	rdx, rdx
	lea	rcx, QWORD PTR [rdx+4]
	cmovne	rbx, rcx
	mov	rax, rbx
$LN1@what:

; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+4176]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?what@ResultException@wil@@UEBAPEBDXZ ENDP		; wil::ResultException::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??_GResultException@wil@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GResultException@wil@@UEAAPEAXI@Z PROC		; wil::ResultException::`scalar deleting destructor', COMDAT
$LN42:
	push	rdi
	sub	rsp, 32					; 00000020H
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2293 :             if (m_pCopy != nullptr)

	mov	QWORD PTR [rsp+48], rbx
	mov	rdi, rcx
	mov	rcx, QWORD PTR [rcx+192]
	mov	QWORD PTR [rsp+56], rbp
	mov	ebp, edx
	mov	QWORD PTR [rsp+64], rsi
	mov	esi, -1
	mov	QWORD PTR [rsp+72], r14
	xor	r14d, r14d
	test	rcx, rcx
	je	SHORT $LN14@scalar

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, esi
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN15@scalar

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi+192]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN15@scalar:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi+192], r14

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+200], r14
$LN14@scalar:

; 2293 :             if (m_pCopy != nullptr)

	mov	rax, QWORD PTR [rdi+176]
	test	rax, rax
	je	SHORT $LN27@scalar

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	lock xadd DWORD PTR [rax], esi
	cmp	esi, 1
	jne	SHORT $LN28@scalar

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi+176]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN28@scalar:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi+176], r14

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+184], r14
$LN27@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rdi], rax
	call	__std_exception_destroy
	mov	r14, QWORD PTR [rsp+72]
	test	bpl, 1
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+48]
	je	SHORT $LN34@scalar
	mov	edx, 208				; 000000d0H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN34@scalar:
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GResultException@wil@@UEAAPEAXI@Z ENDP		; wil::ResultException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
;	COMDAT ??1ResultException@wil@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ResultException@wil@@UEAA@XZ PROC			; wil::ResultException::~ResultException, COMDAT
$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2293 :             if (m_pCopy != nullptr)

	xor	ebp, ebp
	mov	rcx, QWORD PTR [rcx+192]
	mov	esi, -1
	test	rcx, rcx
	je	SHORT $LN8@ResultExce

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, esi
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN9@ResultExce

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi+192]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN9@ResultExce:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi+192], rbp

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+200], rbp
$LN8@ResultExce:

; 2293 :             if (m_pCopy != nullptr)

	mov	rax, QWORD PTR [rdi+176]
	test	rax, rax
	je	SHORT $LN21@ResultExce

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	lock xadd DWORD PTR [rax], esi
	cmp	esi, 1
	jne	SHORT $LN22@ResultExce

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi+176]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
$LN22@ResultExce:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	mov	QWORD PTR [rdi+176], rbp

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+184], rbp
$LN21@ResultExce:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 90   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rdi+8]
	mov	QWORD PTR [rdi], rax
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	__std_exception_destroy
??1ResultException@wil@@UEAA@XZ ENDP			; wil::ResultException::~ResultException
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??1StoredFailureInfo@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1StoredFailureInfo@wil@@QEAA@XZ PROC			; wil::StoredFailureInfo::~StoredFailureInfo, COMDAT
$LN16:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 2293 :             if (m_pCopy != nullptr)

	mov	rcx, QWORD PTR [rcx+152]
	test	rcx, rcx
	je	SHORT $LN8@StoredFail

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	mov	eax, -1
	lock xadd DWORD PTR [rcx], eax
	cmp	eax, 1
	jne	SHORT $LN9@StoredFail
	mov	QWORD PTR [rsp+48], rbx

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	mov	rbx, QWORD PTR [rdi+152]
	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree
	mov	rbx, QWORD PTR [rsp+48]
$LN9@StoredFail:

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi+152], rax

; 2300 :                 m_size = 0;

	mov	QWORD PTR [rdi+160], rax
$LN8@StoredFail:
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1StoredFailureInfo@wil@@QEAA@XZ ENDP			; wil::StoredFailureInfo::~StoredFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z
_TEXT	SEGMENT
exception$ = 8
debugString$ = 16
debugStringChars$ = 24
?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z PROC ; wil::details::MaybeGetExceptionString, COMDAT

; 3595 :     {

	mov	r9, r8
	mov	rax, rdx

; 3596 :         if (debugString)

	test	rdx, rdx
	je	SHORT $LN2@MaybeGetEx

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	lea	r8, QWORD PTR [rcx+24]
	mov	rdx, r9
	mov	rcx, rax
	jmp	?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ; wil::GetFailureLogString
$LN2@MaybeGetEx:

; 3599 :         }
; 3600 :     }

	ret	0
?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z ENDP ; wil::details::MaybeGetExceptionString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z
_TEXT	SEGMENT
exception$ = 48
debugString$ = 56
debugStringChars$ = 64
?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z PROC ; wil::details::MaybeGetExceptionString, COMDAT

; 3606 :     {

$LN7:

; 3607 :         if (debugString)

	test	rdx, rdx
	je	SHORT $LN5@MaybeGetEx
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	mov	rax, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rbx, rdx
	call	QWORD PTR [rax+8]
	lea	r8, OFFSET FLAT:??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	mov	rdx, rdi
	mov	r9, rax
	mov	rcx, rbx
	call	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ	; StringCchPrintfW

; 3610 :         }
; 3611 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN5@MaybeGetEx:
	ret	0
?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z ENDP ; wil::details::MaybeGetExceptionString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z
_TEXT	SEGMENT
exception$1 = 32
debugString$ = 64
debugStringChars$ = 72
hr$ = 80
?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z PROC ; wil::details::RecognizeCaughtExceptionFromCallback, COMDAT

; 3663 :     {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();

	call	QWORD PTR ?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA ; wil::g_pfnResultFromCaughtException
	mov	DWORD PTR hr$[rsp], eax

; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)

	test	eax, eax
	jns	SHORT $LN3@RecognizeC
	test	rbx, rbx
	jne	SHORT $LN3@RecognizeC
	jmp	SHORT $LN10@RecognizeC
$LN13@RecognizeC:

; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }

	mov	eax, DWORD PTR hr$[rsp]
$LN10@RecognizeC:
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN3@RecognizeC:

; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	int	3
$LN17@RecognizeC:
	int	3
?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z ENDP ; wil::details::RecognizeCaughtExceptionFromCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$1 = 32
debugString$ = 64
debugStringChars$ = 72
hr$ = 80
?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA PROC ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$0

; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z$0:

; 3607 :         if (debugString)

	mov	rbx, QWORD PTR debugString$[rbp]
	test	rbx, rbx
	je	SHORT $LN15@catch$0

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	mov	rcx, QWORD PTR exception$1[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	r9, rax
	lea	r8, OFFSET FLAT:??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	mov	rcx, rbx
	call	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ	; StringCchPrintfW
$LN15@catch$0:

; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))

	mov	eax, DWORD PTR hr$[rbp]
	mov	ecx, -2147024322			; ffffffff8007023eH
	test	eax, eax
	cmovns	eax, ecx
	mov	DWORD PTR hr$[rbp], eax

; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA ENDP ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$1 = 32
debugString$ = 64
debugStringChars$ = 72
hr$ = 80
?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA PROC ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$1

; 3684 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z$1:

; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }

	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA ENDP ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?Rethrow@details@wil@@YAXXZ
_TEXT	SEGMENT
?Rethrow@details@wil@@YAXXZ PROC			; wil::details::Rethrow, COMDAT

; 3925 :     {

$LN4:
	sub	rsp, 40					; 00000028H

; 3926 :         throw;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	int	3
$LN3@Rethrow:
?Rethrow@details@wil@@YAXXZ ENDP			; wil::details::Rethrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z
_TEXT	SEGMENT
$T1 = 32
failure$ = 256
?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z PROC ; wil::details::ThrowResultExceptionInternal, COMDAT

; 3930 :     {

$LN4:
	sub	rsp, 248				; 000000f8H

; 3931 :         throw ResultException(failure);

	mov	rdx, rcx
	lea	rcx, QWORD PTR $T1[rsp]
	call	??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z ; wil::ResultException::ResultException
	lea	rdx, OFFSET FLAT:_TI2?AVResultException@wil@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@ThrowResul:
?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z ENDP ; wil::details::ThrowResultExceptionInternal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0ResultException@wil@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ResultException@wil@@QEAA@AEBV01@@Z PROC		; wil::ResultException::ResultException, COMDAT
$LN41:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 73   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rbx, rcx
	xorps	xmm0, xmm0

; 72   :         : _Data()

	movups	XMMWORD PTR [rdx], xmm0

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rdi+8]
	call	__std_exception_copy
	lea	rax, OFFSET FLAT:??_7ResultException@wil@@6B@
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	edx, edx
	mov	QWORD PTR [rbx], rax
	movups	xmm0, XMMWORD PTR [rdi+24]
	movups	XMMWORD PTR [rbx+24], xmm0
	movups	xmm1, XMMWORD PTR [rdi+40]
	movups	XMMWORD PTR [rbx+40], xmm1
	movups	xmm0, XMMWORD PTR [rdi+56]
	movups	XMMWORD PTR [rbx+56], xmm0
	movups	xmm1, XMMWORD PTR [rdi+72]
	movups	XMMWORD PTR [rbx+72], xmm1
	movups	xmm0, XMMWORD PTR [rdi+88]
	movups	XMMWORD PTR [rbx+88], xmm0
	movups	xmm1, XMMWORD PTR [rdi+104]
	movups	XMMWORD PTR [rbx+104], xmm1
	movups	xmm0, XMMWORD PTR [rdi+120]
	movups	XMMWORD PTR [rbx+120], xmm0
	movups	xmm1, XMMWORD PTR [rdi+136]
	movups	XMMWORD PTR [rbx+136], xmm1
	movups	xmm0, XMMWORD PTR [rdi+152]
	movups	XMMWORD PTR [rbx+152], xmm0
	movsd	xmm1, QWORD PTR [rdi+168]
	movsd	QWORD PTR [rbx+168], xmm1
	mov	QWORD PTR [rbx+176], rdx
	mov	QWORD PTR [rbx+184], rdx

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	mov	rax, QWORD PTR [rdi+176]
	mov	rcx, QWORD PTR [rdi+184]

; 2363 :             if (pCopy != nullptr)

	test	rax, rax
	je	SHORT $LN16@ResultExce

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rbx+176], rax

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rbx+184], rcx

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [rax]
$LN16@ResultExce:

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	mov	QWORD PTR [rbx+192], rdx
	mov	QWORD PTR [rbx+200], rdx

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	mov	rax, QWORD PTR [rdi+192]
	mov	rcx, QWORD PTR [rdi+200]

; 2363 :             if (pCopy != nullptr)

	test	rax, rax
	je	SHORT $LN36@ResultExce

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rbx+192], rax

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rbx+200], rcx

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [rax]
$LN36@ResultExce:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0ResultException@wil@@QEAA@AEBV01@@Z ENDP		; wil::ResultException::ResultException
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z PROC		; wil::StoredFailureInfo::StoredFailureInfo, COMDAT
	movups	xmm0, XMMWORD PTR [rdx]

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR [rdx+64]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm1, XMMWORD PTR [rdx+80]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm0, XMMWORD PTR [rdx+96]
	movups	XMMWORD PTR [rcx+96], xmm0
	movups	xmm1, XMMWORD PTR [rdx+112]
	movups	XMMWORD PTR [rcx+112], xmm1
	movups	xmm0, XMMWORD PTR [rdx+128]
	movups	XMMWORD PTR [rcx+128], xmm0
	movsd	xmm1, QWORD PTR [rdx+144]
	movsd	QWORD PTR [rcx+144], xmm1
	mov	QWORD PTR [rcx+152], rax
	mov	QWORD PTR [rcx+160], rax

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	mov	rax, QWORD PTR [rdx+152]
	mov	r8, QWORD PTR [rdx+160]

; 2363 :             if (pCopy != nullptr)

	test	rax, rax
	je	SHORT $LN16@StoredFail

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	mov	QWORD PTR [rcx+152], rax

; 2366 :                 m_size = cbSize;

	mov	QWORD PTR [rcx+160], r8

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	lock inc DWORD PTR [rax]
$LN16@StoredFail:
	mov	rax, rcx
	ret	0
??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z ENDP		; wil::StoredFailureInfo::StoredFailureInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z
_TEXT	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z PROC ; wil::details::ResultFromCaughtExceptionInternal, COMDAT

; 3938 :     {

$LN85:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H
	mov	r14, r9
	mov	r15, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 3939 :         if (debugString)

	xor	ebx, ebx
	test	rdx, rdx
	je	SHORT $LN2@ResultFrom

; 3940 :         {
; 3941 :             *debugString = L'\0';

	mov	WORD PTR [rdx], bx
$LN2@ResultFrom:

; 3942 :         }
; 3943 :         *isNormalized = false;

	mov	BYTE PTR [r9], 0

; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)

	mov	rax, QWORD PTR g_pfnResultFromCaughtException_CppWinRt
	test	rax, rax
	je	SHORT $LN4@ResultFrom

; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);

	mov	r8, r14
	mov	rdx, r15
	mov	rcx, rsi
	call	rax

; 3948 :             if (FAILED(hr))

	test	eax, eax
	js	SHORT $LN75@ResultFrom
$LN4@ResultFrom:

; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)

	mov	rax, QWORD PTR g_pfnResultFromCaughtException_WinRt
	test	rax, rax
	je	SHORT $LN5@ResultFrom

; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);

	mov	r8, r14
	mov	rdx, r15
	mov	rcx, rsi
	call	rax
$LN75@ResultFrom:

; 4016 :     }

	mov	DWORD PTR [rdi], eax
	mov	ecx, eax
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR [rdi+4], eax
	mov	DWORD PTR [rdi+8], ebx
	mov	rax, rdi
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@ResultFrom:

; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)

	cmp	QWORD PTR ?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA, 0 ; wil::g_pfnResultFromCaughtException
	jne	SHORT $LN84@ResultFrom
	jmp	SHORT $LN6@ResultFrom
$LN23@ResultFrom:

; 4016 :     }

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	movsd	xmm0, QWORD PTR $T5[rsp]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR $T5[rsp+8]
	mov	DWORD PTR [rax+8], ecx
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN37@ResultFrom:

; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {
; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));
; 4007 :             }
; 4008 :             catch (...)
; 4009 :             {
; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }
; 4012 :         }
; 4013 : 
; 4014 :         // Tell the caller that we were unable to map the exception by succeeding...
; 4015 :         return ResultStatus::FromResult(S_OK);

	xor	ebx, ebx
	mov	r9, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [r9], ebx

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	xor	ecx, ecx
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus

; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {
; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));
; 4007 :             }
; 4008 :             catch (...)
; 4009 :             {
; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }
; 4012 :         }
; 4013 : 
; 4014 :         // Tell the caller that we were unable to map the exception by succeeding...
; 4015 :         return ResultStatus::FromResult(S_OK);

	mov	DWORD PTR [r9+4], eax
	mov	DWORD PTR [r9+8], ebx
	mov	rax, r9

; 4016 :     }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN6@ResultFrom:

; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
$LN84@ResultFrom:

; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	int	3
$LN74@ResultFrom:
	int	3
?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z ENDP ; wil::details::ResultFromCaughtExceptionInternal
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$0

; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$0:

; 3968 :                 *isNormalized = true;

	mov	rax, QWORD PTR isNormalized$[rbp]
	mov	BYTE PTR [rax], 1

; 3596 :         if (debugString)

	mov	rcx, QWORD PTR debugString$[rbp]
	mov	rbx, QWORD PTR exception$25[rbp]
	test	rcx, rcx
	je	SHORT $LN43@catch$0

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	lea	r8, QWORD PTR [rbx+24]
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	call	?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ; wil::GetFailureLogString
$LN43@catch$0:

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR $T5[rbp], eax
	mov	eax, DWORD PTR [rbx+36]
	mov	DWORD PTR $T5[rbp+4], eax
	mov	eax, DWORD PTR [rbx+28]
	shr	eax, 3
	and	eax, 1
	mov	DWORD PTR $T5[rbp+8], eax

; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$1

; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$1:

; 3607 :         if (debugString)

	mov	rbx, QWORD PTR debugString$[rbp]
	test	rbx, rbx
	je	SHORT $LN48@catch$1

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	mov	rcx, QWORD PTR exception$27[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	r9, rax
	lea	r8, OFFSET FLAT:??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	mov	rcx, rbx
	call	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ	; StringCchPrintfW
$LN48@catch$1:

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov	DWORD PTR $T8[rbp], -2147024882		; ffffffff8007000eH
	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR $T8[rbp+4], eax
	mov	DWORD PTR $T8[rbp+8], 0

; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$2

; 1939 :         }
; 1940 :         static ResultStatus FromStatus(const NTSTATUS _status)
; 1941 :         {
; 1942 :             return {wil::details::NtStatusToHr(_status), _status, Kind::NtStatus};
; 1943 :         }
; 1944 :         static ResultStatus FromFailureInfo(const FailureInfo& _failure)
; 1945 :         {
; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};
; 1947 :         }
; 1948 :         HRESULT hr = S_OK;
; 1949 :         NTSTATUS status = STATUS_SUCCESS;
; 1950 :         Kind kind = Kind::NtStatus;
; 1951 :     };
; 1952 : 
; 1953 :     // Fallback telemetry provider callback (set with wil::SetResultTelemetryFallback)
; 1954 :     __declspec(selectany) void(__stdcall* g_pfnTelemetryCallback)(bool alreadyReported, wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1955 : 
; 1956 :     // Result.h plug-in (WIL use only)
; 1957 :     __declspec(selectany) void(__stdcall* g_pfnNotifyFailure)(_Inout_ FailureInfo* pFailure) WI_PFN_NOEXCEPT = nullptr;
; 1958 :     __declspec(selectany) void(__stdcall* g_pfnGetContextAndNotifyFailure)(
; 1959 :         _Inout_ FailureInfo* pFailure,
; 1960 :         _Out_writes_(callContextStringLength) _Post_z_ PSTR callContextString,
; 1961 :         _Pre_satisfies_(callContextStringLength > 0) size_t callContextStringLength) WI_PFN_NOEXCEPT = nullptr;
; 1962 : 
; 1963 :     // Observe all errors flowing through the system with this callback (set with wil::SetResultLoggingCallback); use with custom logging
; 1964 :     __declspec(selectany) void(__stdcall* g_pfnLoggingCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1965 : 
; 1966 :     // Desktop/System Only:  Module fetch function (automatically setup)
; 1967 :     __declspec(selectany) PCSTR(__stdcall* g_pfnGetModuleName)() WI_PFN_NOEXCEPT = nullptr;
; 1968 : 
; 1969 :     // Desktop/System Only:  Retrieve address offset and modulename
; 1970 :     __declspec(selectany) bool(__stdcall* g_pfnGetModuleInformation)(
; 1971 :         void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_PFN_NOEXCEPT = nullptr;
; 1972 : 
; 1973 :     // Called with the expectation that the program will terminate when called inside of a loader callout.
; 1974 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1975 :     __declspec(selectany) void(__stdcall* g_pfnFailFastInLoaderCallout)() WI_PFN_NOEXCEPT = nullptr;
; 1976 : 
; 1977 :     // Called to translate an NTSTATUS value to a Win32 error code
; 1978 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1979 :     __declspec(selectany) ULONG(__stdcall* g_pfnRtlNtStatusToDosErrorNoTeb)(NTSTATUS) WI_PFN_NOEXCEPT = nullptr;
; 1980 : 
; 1981 :     // Desktop/System Only: Call to DebugBreak
; 1982 :     __declspec(selectany) void(__stdcall* g_pfnDebugBreak)() WI_PFN_NOEXCEPT = nullptr;
; 1983 : 
; 1984 :     // Called to determine whether or not termination is happening
; 1985 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1986 :     __declspec(selectany) BOOLEAN(__stdcall* g_pfnDllShutdownInProgress)() WI_PFN_NOEXCEPT = nullptr;
; 1987 :     __declspec(selectany) bool g_processShutdownInProgress = false;
; 1988 : 
; 1989 :     // On Desktop/System WINAPI family: dynalink RaiseFailFastException because we may encounter modules
; 1990 :     // that do not have RaiseFailFastException in kernelbase.  UWP apps will directly link.
; 1991 :     __declspec(selectany) void(__stdcall* g_pfnRaiseFailFastException)(PEXCEPTION_RECORD, PCONTEXT, DWORD) = nullptr;
; 1992 : 
; 1993 :     // Exception-based compiled additions
; 1994 :     __declspec(selectany) HRESULT(__stdcall* g_pfnRunFunctorWithExceptionFilter)(IFunctor& functor, IFunctorHost& host, void* returnAddress) = nullptr;
; 1995 :     __declspec(selectany) void(__stdcall* g_pfnRethrow)() = nullptr;
; 1996 :     __declspec(selectany) void(__stdcall* g_pfnThrowResultException)(const FailureInfo& failure) = nullptr;
; 1997 :     extern "C" __declspec(selectany) ResultStatus(__stdcall* g_pfnResultFromCaughtExceptionInternal)(
; 1998 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 1999 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2000 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2001 : 
; 2002 :     // C++/WinRT additions
; 2003 :     extern "C" __declspec(selectany) HRESULT(__stdcall* g_pfnResultFromCaughtException_CppWinRt)(
; 2004 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 2005 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2006 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2007 : 
; 2008 :     // C++/cx compiled additions
; 2009 :     extern "C" __declspec(selectany) void(__stdcall* g_pfnThrowPlatformException)(FailureInfo const& failure, PCWSTR debugString) = nullptr;
; 2010 :     extern "C" __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromCaughtException_WinRt)(
; 2011 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 2012 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2013 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2014 :     __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromKnownExceptions_WinRt)(
; 2015 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor) = nullptr;
; 2016 : 
; 2017 :     // Plugin to call RoOriginateError (WIL use only)
; 2018 :     __declspec(selectany) void(__stdcall* g_pfnOriginateCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2019 : 
; 2020 :     // Plugin to call RoFailFastWithErrorContext (WIL use only)
; 2021 :     __declspec(selectany) void(__stdcall* g_pfnFailfastWithContextCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2022 : 
; 2023 :     // Allocate and disown the allocation so that Appverifier does not complain about a false leak
; 2024 :     inline PVOID ProcessHeapAlloc(_In_ DWORD flags, _In_ size_t size) WI_NOEXCEPT
; 2025 :     {
; 2026 :         const HANDLE processHeap = ::GetProcessHeap();
; 2027 :         const PVOID allocation = ::HeapAlloc(processHeap, flags, size);
; 2028 : 
; 2029 :         static bool fetchedRtlDisownModuleHeapAllocation = false;
; 2030 :         static NTSTATUS(__stdcall * pfnRtlDisownModuleHeapAllocation)(HANDLE, PVOID) WI_PFN_NOEXCEPT = nullptr;
; 2031 : 
; 2032 :         if (pfnRtlDisownModuleHeapAllocation)
; 2033 :         {
; 2034 :             (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2035 :         }
; 2036 :         else if (!fetchedRtlDisownModuleHeapAllocation)
; 2037 :         {
; 2038 :             if (auto ntdllModule = ::GetModuleHandleW(L"ntdll.dll"))
; 2039 :             {
; 2040 :                 pfnRtlDisownModuleHeapAllocation =
; 2041 :                     details::GetProcAddress<decltype(pfnRtlDisownModuleHeapAllocation)>(ntdllModule, "RtlDisownModuleHeapAllocation");
; 2042 :             }
; 2043 :             fetchedRtlDisownModuleHeapAllocation = true;
; 2044 : 
; 2045 :             if (pfnRtlDisownModuleHeapAllocation)
; 2046 :             {
; 2047 :                 (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2048 :             }
; 2049 :         }
; 2050 : 
; 2051 :         return allocation;
; 2052 :     }
; 2053 : 
; 2054 :     enum class ReportFailureOptions
; 2055 :     {
; 2056 :         None = 0x00,
; 2057 :         ForcePlatformException = 0x01,
; 2058 :         MayRethrow = 0x02,
; 2059 :     };
; 2060 :     DEFINE_ENUM_FLAG_OPERATORS(ReportFailureOptions);
; 2061 : 
; 2062 :     template <typename TFunctor>
; 2063 :     using functor_return_type = decltype((*static_cast<TFunctor*>(nullptr))());
; 2064 : 
; 2065 :     template <typename TFunctor>
; 2066 :     struct functor_wrapper_void : public IFunctor
; 2067 :     {
; 2068 :         TFunctor&& functor;
; 2069 :         functor_wrapper_void(TFunctor&& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2070 :         {
; 2071 :         }
; 2072 : #pragma warning(push)
; 2073 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2074 :         HRESULT Run() override
; 2075 :         {
; 2076 :             functor();
; 2077 :             return S_OK;
; 2078 :         }
; 2079 : #pragma warning(pop)
; 2080 :     };
; 2081 : 
; 2082 :     template <typename TFunctor>
; 2083 :     struct functor_wrapper_HRESULT : public IFunctor
; 2084 :     {
; 2085 :         TFunctor&& functor;
; 2086 :         functor_wrapper_HRESULT(TFunctor& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2087 :         {
; 2088 :         }
; 2089 :         HRESULT Run() override
; 2090 :         {
; 2091 :             return functor();
; 2092 :         }
; 2093 :     };
; 2094 : 
; 2095 :     template <typename TFunctor, typename TReturn>
; 2096 :     struct functor_wrapper_other : public IFunctor
; 2097 :     {
; 2098 :         TFunctor&& functor;
; 2099 :         TReturn& retVal;
; 2100 :         functor_wrapper_other(TFunctor& functor_, TReturn& retval_) : functor(wistd::forward<TFunctor>(functor_)), retVal(retval_)
; 2101 :         {
; 2102 :         }
; 2103 : #pragma warning(push)
; 2104 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2105 :         HRESULT Run() override
; 2106 :         {
; 2107 :             retVal = functor();
; 2108 :             return S_OK;
; 2109 :         }
; 2110 : #pragma warning(pop)
; 2111 :     };
; 2112 : 
; 2113 :     struct tag_return_void : public wistd::integral_constant<size_t, 0>
; 2114 :     {
; 2115 :         template <typename TFunctor>
; 2116 :         using functor_wrapper = functor_wrapper_void<TFunctor>;
; 2117 :     };
; 2118 : 
; 2119 :     struct tag_return_HRESULT : public wistd::integral_constant<size_t, 1>
; 2120 :     {
; 2121 :         template <typename TFunctor>
; 2122 :         using functor_wrapper = functor_wrapper_HRESULT<TFunctor>;
; 2123 :     };
; 2124 : 
; 2125 :     struct tag_return_other : public wistd::integral_constant<size_t, 2>
; 2126 :     {
; 2127 :         template <typename TFunctor, typename TReturn>
; 2128 :         using functor_wrapper = functor_wrapper_other<TFunctor, TReturn>;
; 2129 :     };
; 2130 : 
; 2131 :     // type-trait to help discover the return type of a functor for tag/dispatch.
; 2132 : 
; 2133 :     template <ErrorReturn errorReturn, typename T>
; 2134 :     struct return_type
; 2135 :     {
; 2136 :         using type = tag_return_other;
; 2137 :     };
; 2138 : 
; 2139 :     template <>
; 2140 :     struct return_type<ErrorReturn::Auto, HRESULT>
; 2141 :     {
; 2142 :         using type = tag_return_HRESULT;
; 2143 :     };
; 2144 : 
; 2145 :     template <>
; 2146 :     struct return_type<ErrorReturn::Auto, void>
; 2147 :     {
; 2148 :         using type = tag_return_void;
; 2149 :     };
; 2150 : 
; 2151 :     template <>
; 2152 :     struct return_type<ErrorReturn::None, void>
; 2153 :     {
; 2154 :         using type = tag_return_void;
; 2155 :     };
; 2156 : 
; 2157 :     template <ErrorReturn errorReturn, typename Functor>
; 2158 :     using functor_tag = typename return_type<errorReturn, functor_return_type<Functor>>::type;
; 2159 : 
; 2160 :     // Forward declarations to enable use of fail fast and reporting internally...
; 2161 :     namespace __R_NS_NAME
; 2162 :     {
; 2163 :         _Post_satisfies_(return == hr) __R_DIRECT_METHOD(HRESULT, Log_Hr)(__R_DIRECT_FN_PARAMS HRESULT hr) WI_NOEXCEPT;
; 2164 :         _Post_satisfies_(return == hr)
; 2165 :             __R_DIRECT_METHOD(HRESULT, Log_HrMsg)(__R_DIRECT_FN_PARAMS HRESULT hr, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2166 :         _Post_satisfies_(return == err)
; 2167 :             __R_DIRECT_METHOD(DWORD, Log_Win32Msg)(__R_DIRECT_FN_PARAMS DWORD err, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2168 :     } // namespace __R_NS_NAME
; 2169 :     namespace __RFF_NS_NAME
; 2170 :     {
; 2171 :         __RFF_DIRECT_NORET_METHOD(void, FailFast_Unexpected)(__RFF_DIRECT_FN_PARAMS_ONLY) WI_NOEXCEPT;
; 2172 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2173 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_If)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2174 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2175 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_HrIf)(__RFF_CONDITIONAL_FN_PARAMS HRESULT hr, bool condition) WI_NOEXCEPT;
; 2176 :         _Post_satisfies_(return == condition) _When_(!condition, _Analysis_noreturn_)
; 2177 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_IfFalse)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2178 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2179 :         __RFF_CONDITIONAL_METHOD(bool, FailFastImmediate_If)(bool condition) WI_NOEXCEPT;
; 2180 :     } // namespace __RFF_NS_NAME
; 2181 : 
; 2182 :     RESULT_NORETURN inline void __stdcall WilFailFast(const FailureInfo& info);
; 2183 :     inline void LogFailure(
; 2184 :         __R_FN_PARAMS_FULL,
; 2185 :         FailureType type,
; 2186 :         const ResultStatus& resultPair,
; 2187 :         _In_opt_ PCWSTR message,
; 2188 :         bool fWantDebugString,
; 2189 :         _Out_writes_(debugStringSizeChars) _Post_z_ PWSTR debugString,
; 2190 :         _Pre_satisfies_(debugStringSizeChars > 0) size_t debugStringSizeChars,
; 2191 :         _Out_writes_(callContextStringSizeChars) _Post_z_ PSTR callContextString,
; 2192 :         _Pre_satisfies_(callContextStringSizeChars > 0) size_t callContextStringSizeChars,
; 2193 :         FailureFlags flags,
; 2194 :         _Out_ FailureInfo* failure) WI_NOEXCEPT;
; 2195 : 
; 2196 :     __declspec(noinline) inline void ReportFailure(
; 2197 :         __R_FN_PARAMS_FULL,
; 2198 :         FailureType type,
; 2199 :         const ResultStatus& resultPair,
; 2200 :         _In_opt_ PCWSTR message = nullptr,
; 2201 :         ReportFailureOptions options = ReportFailureOptions::None);
; 2202 :     template <FailureType, bool = false>
; 2203 :     __declspec(noinline) inline void ReportFailure_Base(
; 2204 :         __R_FN_PARAMS_FULL,
; 2205 :         const ResultStatus& resultPair,
; 2206 :         _In_opt_ PCWSTR message = nullptr,
; 2207 :         ReportFailureOptions options = ReportFailureOptions::None,
; 2208 :         FailureFlags flags = FailureFlags::None);
; 2209 :     template <FailureType>
; 2210 :     inline void ReportFailure_ReplaceMsg(__R_FN_PARAMS_FULL, HRESULT hr, _Printf_format_string_ PCSTR formatString, ...);
; 2211 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, FailureType type, HRESULT hr);
; 2212 :     template <FailureType>
; 2213 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, HRESULT hr, FailureFlags flags = FailureFlags::None);
; 2214 :     template <FailureType>
; 2215 :     __declspec(noinline) inline HRESULT ReportFailure_CaughtException(
; 2216 :         __R_FN_PARAMS_FULL, SupportedExceptions supported = SupportedExceptions::Default);
; 2217 : 
; 2218 : //*****************************************************************************
; 2219 : // Fail fast helpers (for use only internally to WIL)
; 2220 : //*****************************************************************************
; 2221 : 
; 2222 : /// @cond
; 2223 : #define __FAIL_FAST_ASSERT__(condition) \
; 2224 :     do \
; 2225 :     { \
; 2226 :         if (!(condition)) \
; 2227 :         { \
; 2228 :             __RFF_FN(FailFast_Unexpected)(__RFF_INFO_ONLY(#condition)); \
; 2229 :         } \
; 2230 :     } while ((void)0, 0)
; 2231 : #define __FAIL_FAST_IMMEDIATE_ASSERT__(condition) \
; 2232 :     do \
; 2233 :     { \
; 2234 :         if (!(condition)) \
; 2235 :         { \
; 2236 :             wil::FailureInfo failure{}; \
; 2237 :             wil::details::WilFailFast(failure); \
; 2238 :         } \
; 2239 :     } while ((void)0, 0)
; 2240 : #define __FAIL_FAST_ASSERT_WIN32_BOOL_FALSE__(condition) \
; 2241 :     __RFF_FN(FailFast_IfWin32BoolFalse)(__RFF_INFO(#condition) wil::verify_BOOL(condition))
; 2242 : 
; 2243 :     // A simple ref-counted buffer class.  The interface is very similar to shared_ptr<>, only it manages
; 2244 :     // an allocated buffer and maintains the size.
; 2245 : 
; 2246 :     class shared_buffer
; 2247 :     {
; 2248 :     public:
; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2250 :         {
; 2251 :         }
; 2252 : 
; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);
; 2256 :         }
; 2257 : 
; 2258 :         shared_buffer(shared_buffer&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy), m_size(other.m_size)
; 2259 :         {
; 2260 :             other.m_pCopy = nullptr;
; 2261 :             other.m_size = 0;
; 2262 :         }
; 2263 : 
; 2264 :         ~shared_buffer() WI_NOEXCEPT
; 2265 :         {
; 2266 :             reset();
; 2267 :         }
; 2268 : 
; 2269 :         shared_buffer& operator=(shared_buffer const& other) WI_NOEXCEPT
; 2270 :         {
; 2271 :             if (this != wistd::addressof(other))
; 2272 :             {
; 2273 :                 assign(other.m_pCopy, other.m_size);
; 2274 :             }
; 2275 :             return *this;
; 2276 :         }
; 2277 : 
; 2278 :         shared_buffer& operator=(shared_buffer&& other) WI_NOEXCEPT
; 2279 :         {
; 2280 :             if (this != wistd::addressof(other))
; 2281 :             {
; 2282 :                 reset();
; 2283 :                 m_pCopy = other.m_pCopy;
; 2284 :                 m_size = other.m_size;
; 2285 :                 other.m_pCopy = nullptr;
; 2286 :                 other.m_size = 0;
; 2287 :             }
; 2288 :             return *this;
; 2289 :         }
; 2290 : 
; 2291 :         void reset() WI_NOEXCEPT
; 2292 :         {
; 2293 :             if (m_pCopy != nullptr)
; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))
; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);
; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;
; 2300 :                 m_size = 0;
; 2301 :             }
; 2302 :         }
; 2303 : 
; 2304 :         bool create(_In_reads_bytes_opt_(cbData) void const* pData, size_t cbData) WI_NOEXCEPT
; 2305 :         {
; 2306 :             if (cbData == 0)
; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));
; 2313 :             if (pCopyRefCount == nullptr)
; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;
; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }
; 2326 : 
; 2327 :         bool create(size_t cbData) WI_NOEXCEPT
; 2328 :         {
; 2329 :             return create(nullptr, cbData);
; 2330 :         }
; 2331 : 
; 2332 :         WI_NODISCARD void* get(_Out_opt_ size_t* pSize = nullptr) const WI_NOEXCEPT
; 2333 :         {
; 2334 :             if (pSize != nullptr)
; 2335 :             {
; 2336 :                 *pSize = m_size;
; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);
; 2339 :         }
; 2340 : 
; 2341 :         WI_NODISCARD size_t size() const WI_NOEXCEPT
; 2342 :         {
; 2343 :             return m_size;
; 2344 :         }
; 2345 : 
; 2346 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2347 :         {
; 2348 :             return (m_pCopy != nullptr);
; 2349 :         }
; 2350 : 
; 2351 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2352 :         {
; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));
; 2354 :         }
; 2355 : 
; 2356 :     private:
; 2357 :         long* m_pCopy; // pointer to allocation: refcount + data
; 2358 :         size_t m_size; // size of the data from m_pCopy
; 2359 : 
; 2360 :         void assign(_In_opt_ long* pCopy, size_t cbSize) WI_NOEXCEPT
; 2361 :         {
; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)
; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);
; 2368 :             }
; 2369 :         }
; 2370 :     };
; 2371 : 
; 2372 :     inline shared_buffer make_shared_buffer_nothrow(_In_reads_bytes_opt_(countBytes) void* pData, size_t countBytes) WI_NOEXCEPT
; 2373 :     {
; 2374 :         shared_buffer buffer;
; 2375 :         buffer.create(pData, countBytes);
; 2376 :         return buffer;
; 2377 :     }
; 2378 : 
; 2379 :     inline shared_buffer make_shared_buffer_nothrow(size_t countBytes) WI_NOEXCEPT
; 2380 :     {
; 2381 :         shared_buffer buffer;
; 2382 :         buffer.create(countBytes);
; 2383 :         return buffer;
; 2384 :     }
; 2385 : 
; 2386 :     // A small mimic of the STL shared_ptr class, but unlike shared_ptr, a pointer is not attached to the class, but is
; 2387 :     // always simply contained within (it cannot be attached or detached).
; 2388 : 
; 2389 :     template <typename object_t>
; 2390 :     class shared_object
; 2391 :     {
; 2392 :     public:
; 2393 :         shared_object() WI_NOEXCEPT : m_pCopy(nullptr)
; 2394 :         {
; 2395 :         }
; 2396 : 
; 2397 :         shared_object(shared_object const& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2398 :         {
; 2399 :             if (m_pCopy != nullptr)
; 2400 :             {
; 2401 :                 ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2402 :             }
; 2403 :         }
; 2404 : 
; 2405 :         shared_object(shared_object&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2406 :         {
; 2407 :             other.m_pCopy = nullptr;
; 2408 :         }
; 2409 : 
; 2410 :         ~shared_object() WI_NOEXCEPT
; 2411 :         {
; 2412 :             reset();
; 2413 :         }
; 2414 : 
; 2415 :         shared_object& operator=(shared_object const& other) WI_NOEXCEPT
; 2416 :         {
; 2417 :             if (this != wistd::addressof(other))
; 2418 :             {
; 2419 :                 reset();
; 2420 :                 m_pCopy = other.m_pCopy;
; 2421 :                 if (m_pCopy != nullptr)
; 2422 :                 {
; 2423 :                     ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2424 :                 }
; 2425 :             }
; 2426 :             return *this;
; 2427 :         }
; 2428 : 
; 2429 :         shared_object& operator=(shared_object&& other) WI_NOEXCEPT
; 2430 :         {
; 2431 :             if (this != wistd::addressof(other))
; 2432 :             {
; 2433 :                 reset();
; 2434 :                 m_pCopy = other.m_pCopy;
; 2435 :                 other.m_pCopy = nullptr;
; 2436 :             }
; 2437 :             return *this;
; 2438 :         }
; 2439 : 
; 2440 :         void reset() WI_NOEXCEPT
; 2441 :         {
; 2442 :             if (m_pCopy != nullptr)
; 2443 :             {
; 2444 :                 if (0 == ::InterlockedDecrementRelease(&m_pCopy->m_refCount))
; 2445 :                 {
; 2446 :                     delete m_pCopy;
; 2447 :                 }
; 2448 :                 m_pCopy = nullptr;
; 2449 :             }
; 2450 :         }
; 2451 : 
; 2452 :         bool create()
; 2453 :         {
; 2454 :             RefAndObject* pObject = new (std::nothrow) RefAndObject();
; 2455 :             if (pObject == nullptr)
; 2456 :             {
; 2457 :                 return false;
; 2458 :             }
; 2459 :             reset();
; 2460 :             m_pCopy = pObject;
; 2461 :             return true;
; 2462 :         }
; 2463 : 
; 2464 :         template <typename param_t>
; 2465 :         bool create(param_t&& param1)
; 2466 :         {
; 2467 :             RefAndObject* pObject = new (std::nothrow) RefAndObject(wistd::forward<param_t>(param1));
; 2468 :             if (pObject == nullptr)
; 2469 :             {
; 2470 :                 return false;
; 2471 :             }
; 2472 :             reset();
; 2473 :             m_pCopy = pObject;
; 2474 :             return true;
; 2475 :         }
; 2476 : 
; 2477 :         WI_NODISCARD object_t* get() const WI_NOEXCEPT
; 2478 :         {
; 2479 :             return (m_pCopy == nullptr) ? nullptr : &m_pCopy->m_object;
; 2480 :         }
; 2481 : 
; 2482 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2483 :         {
; 2484 :             return (m_pCopy != nullptr);
; 2485 :         }
; 2486 : 
; 2487 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2488 :         {
; 2489 :             return ((m_pCopy != nullptr) && (m_pCopy->m_refCount == 1));
; 2490 :         }
; 2491 : 
; 2492 :         WI_NODISCARD object_t* operator->() const WI_NOEXCEPT
; 2493 :         {
; 2494 :             return get();
; 2495 :         }
; 2496 : 
; 2497 :     private:
; 2498 :         struct RefAndObject
; 2499 :         {
; 2500 :             long m_refCount;
; 2501 :             object_t m_object;
; 2502 : 
; 2503 :             RefAndObject() : m_refCount(1), m_object()
; 2504 :             {
; 2505 :             }
; 2506 : 
; 2507 :             template <typename param_t>
; 2508 :             RefAndObject(param_t&& param1) : m_refCount(1), m_object(wistd::forward<param_t>(param1))
; 2509 :             {
; 2510 :             }
; 2511 :         };
; 2512 : 
; 2513 :         RefAndObject* m_pCopy;
; 2514 :     };
; 2515 : 
; 2516 :     // The following functions are basically the same, but are kept separated to:
; 2517 :     // 1) Provide a unique count and last error code per-type
; 2518 :     // 2) Avoid merging the types to allow easy debugging (breakpoints, conditional breakpoints based
; 2519 :     //      upon count of errors from a particular type, etc)
; 2520 :     __WI_PUSH_WARNINGS
; 2521 : #if __clang_major__ >= 13
; 2522 :     __WI_CLANG_DISABLE_WARNING(-Wunused-but-set-variable) // s_hrErrorLast used for debugging. We intentionally only assign to it
; 2523 : #endif
; 2524 :     __WI_MSVC_DISABLE_WARNING(4746) // s_hrErrorLast' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2525 : 
; 2526 :     __declspec(noinline) inline int RecordException(HRESULT hr) WI_NOEXCEPT
; 2527 :     {
; 2528 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2529 :         static long volatile s_cErrorCount = 0;
; 2530 :         s_hrErrorLast = hr;
; 2531 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2532 :     }
; 2533 : 
; 2534 :     __declspec(noinline) inline int RecordReturn(HRESULT hr) WI_NOEXCEPT
; 2535 :     {
; 2536 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2537 :         static long volatile s_cErrorCount = 0;
; 2538 :         s_hrErrorLast = hr;
; 2539 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2540 :     }
; 2541 : 
; 2542 :     __declspec(noinline) inline int RecordLog(HRESULT hr) WI_NOEXCEPT
; 2543 :     {
; 2544 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2545 :         static long volatile s_cErrorCount = 0;
; 2546 :         s_hrErrorLast = hr;
; 2547 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2548 :     }
; 2549 : 
; 2550 :     __declspec(noinline) inline int RecordFailFast(HRESULT hr) WI_NOEXCEPT
; 2551 :     {
; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;
; 2554 :         return 1;
; 2555 :     }
; 2556 :     __WI_POP_WARNINGS
; 2557 : 
; 2558 :     inline RESULT_NORETURN void __stdcall WilRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_opt_ PCONTEXT cr, _In_ DWORD flags)
; 2559 :     {
; 2560 :         // if we managed to load the pointer either through WilDynamicRaiseFailFastException (PARTITION_DESKTOP etc.)
; 2561 :         // or via direct linkage (e.g. UWP apps), then use it.
; 2562 :         if (g_pfnRaiseFailFastException)
; 2563 :         {
; 2564 :             g_pfnRaiseFailFastException(er, cr, flags);
; 2565 :         }
; 2566 :         // if not, as a best effort, we are just going to call the intrinsic.
; 2567 :         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
; 2568 :     }
; 2569 : 
; 2570 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2571 :     inline bool __stdcall GetModuleInformation(
; 2572 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_NOEXCEPT
; 2573 :     {
; 2574 :         HMODULE hModule = nullptr;
; 2575 :         if (address && !GetModuleHandleExW(
; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))
; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);
; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))
; 2599 :             {
; 2600 :                 start--;
; 2601 :             }
; 2602 :             StringCchCopyA(name, size, start);
; 2603 :         }
; 2604 :         return true;
; 2605 :     }
; 2606 : 
; 2607 :     __WI_PUSH_WARNINGS
; 2608 :     __WI_MSVC_DISABLE_WARNING(4746) // s_fModuleValid' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2609 :     inline PCSTR __stdcall GetCurrentModuleName() WI_NOEXCEPT
; 2610 :     {
; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable
; 2614 :         {
; 2615 :             GetModuleInformation(reinterpret_cast<void*>(&RecordFailFast), nullptr, s_szModule, ARRAYSIZE(s_szModule));
; 2616 :             s_fModuleValid = true;
; 2617 :         }
; 2618 :         return s_szModule;
; 2619 :     }
; 2620 :     __WI_POP_WARNINGS
; 2621 : 
; 2622 :     inline void __stdcall DebugBreak() WI_NOEXCEPT
; 2623 :     {
; 2624 :         ::DebugBreak();
; 2625 :     }
; 2626 : 
; 2627 :     inline void __stdcall WilDynamicLoadRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_ PCONTEXT cr, _In_ DWORD flags)
; 2628 :     {
; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");
; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)
; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);
; 2636 :         }
; 2637 :     }
; 2638 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2639 : 
; 2640 :     inline bool __stdcall GetModuleInformationFromAddress(
; 2641 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* buffer, size_t size) WI_NOEXCEPT
; 2642 :     {
; 2643 :         if (size > 0)
; 2644 :         {
; 2645 :             assign_to_opt_param(buffer, '\0');
; 2646 :         }
; 2647 :         if (addressOffset)
; 2648 :         {
; 2649 :             *addressOffset = 0;
; 2650 :         }
; 2651 :         if (g_pfnGetModuleInformation)
; 2652 :         {
; 2653 :             return g_pfnGetModuleInformation(address, addressOffset, buffer, size);
; 2654 :         }
; 2655 :         return false;
; 2656 :     }
; 2657 : 
; 2658 :     __declspec(noinline) inline HRESULT NtStatusToHr(NTSTATUS status) WI_NOEXCEPT
; 2659 :     {
; 2660 :         // The following conversions are the only known incorrect mappings in RtlNtStatusToDosErrorNoTeb
; 2661 :         if (SUCCEEDED_NTSTATUS(status))
; 2662 :         {
; 2663 :             // All successful status codes have only one hresult equivalent, S_OK
; 2664 :             return S_OK;
; 2665 :         }
; 2666 :         if (status == static_cast<NTSTATUS>(STATUS_NO_MEMORY))
; 2667 :         {
; 2668 :             // RtlNtStatusToDosErrorNoTeb maps STATUS_NO_MEMORY to the less popular of two Win32 no memory error codes resulting in an unexpected mapping
; 2669 :             return E_OUTOFMEMORY;
; 2670 :         }
; 2671 : 
; 2672 :         if (g_pfnRtlNtStatusToDosErrorNoTeb != nullptr)
; 2673 :         {
; 2674 :             DWORD err = g_pfnRtlNtStatusToDosErrorNoTeb(status);
; 2675 : 
; 2676 :             // ERROR_MR_MID_NOT_FOUND indicates a bug in the originator of the error (failure to add a mapping to the Win32 error codes).
; 2677 :             // There are known instances of this bug which are unlikely to be fixed soon, and it's always possible that additional instances
; 2678 :             // could be added in the future. In these cases, it's better to use HRESULT_FROM_NT rather than returning a meaningless error.
; 2679 :             if ((err != 0) && (err != ERROR_MR_MID_NOT_FOUND))
; 2680 :             {
; 2681 :                 return __HRESULT_FROM_WIN32(err);
; 2682 :             }
; 2683 :         }
; 2684 : 
; 2685 :         return HRESULT_FROM_NT(status);
; 2686 :     }
; 2687 : 
; 2688 :     __declspec(noinline) inline NTSTATUS HrToNtStatus(HRESULT hr) WI_NOEXCEPT
; 2689 :     {
; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)
; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;
; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;
; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;
; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;
; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;
; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;
; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;
; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;
; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;
; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;
; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;
; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;
; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;
; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;
; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;
; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;
; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;
; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;
; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;
; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;
; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)
; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);
; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));
; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)
; 2787 :             {
; 2788 :                 status =
; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }
; 2800 : 
; 2801 :     // The following set of functions all differ only based upon number of arguments.  They are unified in their handling
; 2802 :     // of data from each of the various error-handling types (fast fail, exceptions, etc.).
; 2803 :     _Post_equals_last_error_ inline DWORD GetLastErrorFail(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2804 :     {
; 2805 :         __R_FN_UNREFERENCED;
; 2806 :         auto err = ::GetLastError();
; 2807 :         if (SUCCEEDED_WIN32(err))
; 2808 :         {
; 2809 :             // This function should only be called when GetLastError() is set to a FAILURE.
; 2810 :             // If you hit this assert (or are reviewing this failure telemetry), then there are one of three issues:
; 2811 :             //  1) Your code is using a macro (such as RETURN_IF_WIN32_BOOL_FALSE()) on a function that does not actually
; 2812 :             //      set the last error (consult MSDN).
; 2813 :             //  2) Your macro check against the error is not immediately after the API call.  Pushing it later can result
; 2814 :             //      in another API call between the previous one and the check resetting the last error.
; 2815 :             //  3) The API you're calling has a bug in it and does not accurately set the last error (there are a few
; 2816 :             //      examples here, such as SendMessageTimeout() that don't accurately set the last error).
; 2817 :             //      [MSFT internal] For these, please send mail to 'wildisc' when found and work-around with win32errorhelpers.
; 2818 : 
; 2819 :             WI_USAGE_ERROR_FORWARD("CALLER BUG: Macro usage error detected.  GetLastError() does not have an error.");
; 2820 :             return ERROR_ASSERTION_FAILURE;
; 2821 :         }
; 2822 :         return err;
; 2823 :     }
; 2824 : 
; 2825 :     inline __declspec(noinline) DWORD GetLastErrorFail() WI_NOEXCEPT
; 2826 :     {
; 2827 :         __R_FN_LOCALS_FULL_RA;
; 2828 :         return GetLastErrorFail(__R_FN_CALL_FULL);
; 2829 :     }
; 2830 : 
; 2831 :     _Translates_last_error_to_HRESULT_
; 2832 :     inline HRESULT GetLastErrorFailHr(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2833 :     {
; 2834 :         return HRESULT_FROM_WIN32(GetLastErrorFail(__R_FN_CALL_FULL));
; 2835 :     }
; 2836 : 
; 2837 :     _Translates_last_error_to_HRESULT_
; 2838 :     inline __declspec(noinline) HRESULT GetLastErrorFailHr() WI_NOEXCEPT
; 2839 :     {
; 2840 :         __R_FN_LOCALS_FULL_RA;
; 2841 :         return GetLastErrorFailHr(__R_FN_CALL_FULL);
; 2842 :     }
; 2843 : 
; 2844 :     inline void PrintLoggingMessage(
; 2845 :         _Out_writes_(cchDest) _Post_z_ PWSTR pszDest,
; 2846 :         _Pre_satisfies_(cchDest > 0) size_t cchDest,
; 2847 :         _In_opt_ _Printf_format_string_ PCSTR formatString,
; 2848 :         _In_opt_ va_list argList) WI_NOEXCEPT
; 2849 :     {
; 2850 :         if (formatString == nullptr)
; 2851 :         {
; 2852 :             pszDest[0] = L'\0';
; 2853 :         }
; 2854 :         else if (argList == nullptr)
; 2855 :         {
; 2856 :             StringCchPrintfW(pszDest, cchDest, L"%hs", formatString);
; 2857 :         }
; 2858 :         else
; 2859 :         {
; 2860 :             wchar_t szFormatWide[2048];
; 2861 :             StringCchPrintfW(szFormatWide, ARRAYSIZE(szFormatWide), L"%hs", formatString);
; 2862 :             StringCchVPrintfW(pszDest, cchDest, szFormatWide, argList);
; 2863 :         }
; 2864 :     }
; 2865 : 
; 2866 : #pragma warning(push)
; 2867 : #pragma warning(disable : __WARNING_RETURNING_BAD_RESULT)
; 2868 :     // NOTE: The following two functions are unfortunate copies of strsafe.h functions that have been copied to reduce the friction associated with using
; 2869 :     // Result.h and ResultException.h in a build that does not have WINAPI_PARTITION_DESKTOP defined (where these are conditionally enabled).
; 2870 : 
; 2871 :     inline HRESULT WilStringLengthWorkerA(
; 2872 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2873 :         _In_ _In_range_(<=, STRSAFE_MAX_CCH) size_t cchMax,
; 2874 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2875 :     {
; 2876 :         HRESULT hr = S_OK;
; 2877 :         size_t cchOriginalMax = cchMax;
; 2878 :         while (cchMax && (*psz != '\0'))
; 2879 :         {
; 2880 :             psz++;
; 2881 :             cchMax--;
; 2882 :         }
; 2883 :         if (cchMax == 0)
; 2884 :         {
; 2885 :             // the string is longer than cchMax
; 2886 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2887 :         }
; 2888 :         if (pcchLength)
; 2889 :         {
; 2890 :             if (SUCCEEDED(hr))
; 2891 :             {
; 2892 :                 *pcchLength = cchOriginalMax - cchMax;
; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 *pcchLength = 0;
; 2897 :             }
; 2898 :         }
; 2899 :         return hr;
; 2900 :     }
; 2901 : 
; 2902 :     _Must_inspect_result_
; 2903 :     inline HRESULT StringCchLengthA(
; 2904 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2905 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
; 2906 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2907 :     {
; 2908 :         HRESULT hr = S_OK;
; 2909 :         if ((psz == nullptr) || (cchMax > STRSAFE_MAX_CCH))
; 2910 :         {
; 2911 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2912 :         }
; 2913 :         else
; 2914 :         {
; 2915 :             hr = WilStringLengthWorkerA(psz, cchMax, pcchLength);
; 2916 :         }
; 2917 :         if (FAILED(hr) && pcchLength)
; 2918 :         {
; 2919 :             *pcchLength = 0;
; 2920 :         }
; 2921 :         return hr;
; 2922 :     }
; 2923 : #pragma warning(pop)
; 2924 : 
; 2925 :     _Post_satisfies_(cchDest > 0 && cchDest <= cchMax) inline HRESULT
; 2926 :         WilStringValidateDestA(_In_reads_opt_(cchDest) PCNZCH /*pszDest*/, _In_ size_t cchDest, _In_ const size_t cchMax)
; 2927 :     {
; 2928 :         HRESULT hr = S_OK;
; 2929 :         if ((cchDest == 0) || (cchDest > cchMax))
; 2930 :         {
; 2931 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2932 :         }
; 2933 :         return hr;
; 2934 :     }
; 2935 : 
; 2936 :     inline HRESULT WilStringVPrintfWorkerA(
; 2937 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2938 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchDest,
; 2939 :         _Always_(_Out_opt_ _Deref_out_range_(<=, cchDest - 1)) size_t* pcchNewDestLength,
; 2940 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2941 :         _In_ va_list argList)
; 2942 :     {
; 2943 :         HRESULT hr = S_OK;
; 2944 :         int iRet{};
; 2945 : 
; 2946 :         // leave the last space for the null terminator
; 2947 :         size_t cchMax = cchDest - 1;
; 2948 :         size_t cchNewDestLength = 0;
; 2949 : #undef STRSAFE_USE_SECURE_CRT
; 2950 : #define STRSAFE_USE_SECURE_CRT 1
; 2951 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 2952 :         iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 2953 : #else
; 2954 : #pragma warning(push)
; 2955 : #pragma warning(disable : __WARNING_BANNED_API_USAGE) // "STRSAFE not included"
; 2956 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
; 2957 : #pragma warning(pop)
; 2958 : #endif
; 2959 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 2960 : 
; 2961 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))
; 2962 :         {
; 2963 :             // need to null terminate the string
; 2964 :             pszDest += cchMax;
; 2965 :             *pszDest = '\0';
; 2966 : 
; 2967 :             cchNewDestLength = cchMax;
; 2968 : 
; 2969 :             // we have truncated pszDest
; 2970 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 2971 :         }
; 2972 :         else if (((size_t)iRet) == cchMax)
; 2973 :         {
; 2974 :             // need to null terminate the string
; 2975 :             pszDest += cchMax;
; 2976 :             *pszDest = '\0';
; 2977 : 
; 2978 :             cchNewDestLength = cchMax;
; 2979 :         }
; 2980 :         else
; 2981 :         {
; 2982 :             cchNewDestLength = (size_t)iRet;
; 2983 :         }
; 2984 : 
; 2985 :         if (pcchNewDestLength)
; 2986 :         {
; 2987 :             *pcchNewDestLength = cchNewDestLength;
; 2988 :         }
; 2989 : 
; 2990 :         return hr;
; 2991 :     }
; 2992 : 
; 2993 :     inline HRESULT StringCchPrintfA(
; 2994 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2995 :         _In_ size_t cchDest,
; 2996 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2997 :         ...)
; 2998 :     {
; 2999 :         HRESULT hr;
; 3000 :         hr = wil::details::WilStringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 3001 :         if (SUCCEEDED(hr))
; 3002 :         {
; 3003 :             va_list argList;
; 3004 :             va_start(argList, pszFormat);
; 3005 :             hr = wil::details::WilStringVPrintfWorkerA(pszDest, cchDest, nullptr, pszFormat, argList);
; 3006 :             va_end(argList);
; 3007 :         }
; 3008 :         else if (cchDest > 0)
; 3009 :         {
; 3010 :             *pszDest = '\0';
; 3011 :         }
; 3012 :         return hr;
; 3013 :     }
; 3014 : 
; 3015 :     _Ret_range_(sizeof(char), (psz == nullptr) ? sizeof(char) : (_String_length_(psz) + sizeof(char)))
; 3016 :     inline size_t ResultStringSize(_In_opt_ PCSTR psz)
; 3017 :     {
; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));
; 3019 :     }
; 3020 : 
; 3021 :     _Ret_range_(sizeof(wchar_t), (psz == nullptr) ? sizeof(wchar_t) : ((_String_length_(psz) + 1) * sizeof(wchar_t)))
; 3022 :     inline size_t ResultStringSize(_In_opt_ PCWSTR psz)
; 3023 :     {
; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);
; 3025 :     }
; 3026 : 
; 3027 :     template <typename TString>
; 3028 :     _Ret_range_(pStart, pEnd)
; 3029 :     inline unsigned char* WriteResultString(
; 3030 :         _Pre_satisfies_(pStart <= pEnd) _When_((pStart == pEnd) || (pszString == nullptr) || (pszString[0] == 0), _In_opt_) _When_(
; 3031 :             (pStart != pEnd) && (pszString != nullptr) && (pszString[0] != 0),
; 3032 :             _Out_writes_bytes_opt_(_String_length_(pszString) * sizeof(pszString[0]))) unsigned char* pStart,
; 3033 :         _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd,
; 3034 :         _In_opt_z_ TString pszString,
; 3035 :         _Outptr_result_maybenull_z_ TString* ppszBufferString)
; 3036 :     {
; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)
; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;
; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;
; 3049 :         if (bufferSize < stringSize)
; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);
; 3056 :         assign_to_opt_param(
; 3057 :             ppszBufferString,
; 3058 :             reinterpret_cast<TString>(
; 3059 :                 pStart)); // lgtm[cpp/incorrect-string-type-conversion] False positive - The query is misinterpreting a buffer (char *) with a MBS string, the cast to TString is expected.
; 3060 :         return pStart + stringSize;
; 3061 :     }
; 3062 : 
; 3063 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3064 :     inline size_t UntrustedStringLength(_In_ PCSTR psz, _In_ size_t cchMax)
; 3065 :     {
; 3066 :         size_t cbLength;
; 3067 :         return SUCCEEDED(wil::details::StringCchLengthA(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3068 :     }
; 3069 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3070 :     inline size_t UntrustedStringLength(_In_ PCWSTR psz, _In_ size_t cchMax)
; 3071 :     {
; 3072 :         size_t cbLength;
; 3073 :         return SUCCEEDED(::StringCchLengthW(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3074 :     }
; 3075 : 
; 3076 :     template <typename TString>
; 3077 :     _Ret_range_(pStart, pEnd)
; 3078 :     inline unsigned char* GetResultString(
; 3079 :         _In_reads_to_ptr_opt_(pEnd) unsigned char* pStart, _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd, _Out_ TString* ppszBufferString)
; 3080 :     {
; 3081 :         size_t cchLen = UntrustedStringLength(reinterpret_cast<TString>(pStart), (pEnd - pStart) / sizeof((*ppszBufferString)[0]));
; 3082 :         *ppszBufferString = (cchLen > 0) ? reinterpret_cast<TString>(pStart) : nullptr;
; 3083 :         auto pReturn = (wistd::min)(pEnd, pStart + ((cchLen + 1) * sizeof((*ppszBufferString)[0])));
; 3084 :         __analysis_assume((pReturn >= pStart) && (pReturn <= pEnd));
; 3085 :         return pReturn;
; 3086 :     }
; 3087 : } // namespace details
; 3088 : /// @endcond
; 3089 : 
; 3090 : //*****************************************************************************
; 3091 : // WIL result handling initializers
; 3092 : //
; 3093 : // Generally, callers do not need to manually initialize WIL. This header creates
; 3094 : // the appropriate .CRT init section pieces through global objects to ensure that
; 3095 : // WilInitialize... is called before DllMain or main().
; 3096 : //
; 3097 : // Certain binaries do not link with the CRT or do not support .CRT-section based
; 3098 : // initializers. Those binaries must link only with other static libraries that
; 3099 : // also set RESULT_SUPPRESS_STATIC_INITIALIZERS to ensure no .CRT inits are left,
; 3100 : // and they should call one of the WilInitialize_ResultMacros_??? methods during
; 3101 : // their initialization phase.  Skipping this initialization path is OK as well,
; 3102 : // but results in a slightly degraded experience with result reporting.
; 3103 : //
; 3104 : // Calling WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse provides:
; 3105 : // - The name of the current module in wil::FailureInfo::pszModule
; 3106 : // - The name of the returning-to module during wil/staging.h failures
; 3107 : //*****************************************************************************
; 3108 : 
; 3109 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3110 : //! Call this method to initialize WIL manually in a module where RESULT_SUPPRESS_STATIC_INITIALIZERS is required. WIL will
; 3111 : //! only use publicly documented APIs.
; 3112 : inline void WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse()
; 3113 : {
; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }
; 3119 : 
; 3120 : /// @cond
; 3121 : namespace details
; 3122 : {
; 3123 : #ifndef RESULT_SUPPRESS_STATIC_INITIALIZERS
; 3124 : #if !defined(BUILD_WINDOWS) || defined(WIL_SUPPRESS_PRIVATE_API_USE)
; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {
; 3126 :         ::wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse();
; 3127 :         return 1;
; 3128 :     });
; 3129 : #endif
; 3130 : #endif
; 3131 : } // namespace details
; 3132 : /// @endcond
; 3133 : #else  // !WINAPI_PARTITION_DESKTOP, !WINAPI_PARTITION_SYSTEM, explicitly assume these modules can direct link
; 3134 : namespace details
; 3135 : {
; 3136 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_AppOnly, [] {
; 3137 :         g_pfnRaiseFailFastException = ::RaiseFailFastException;
; 3138 :         return 1;
; 3139 :     });
; 3140 : } // namespace details
; 3141 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3142 : 
; 3143 : //*****************************************************************************
; 3144 : // Public Error Handling Helpers
; 3145 : //*****************************************************************************
; 3146 : 
; 3147 : //! Call this method to determine if process shutdown is in progress (allows avoiding work during dll unload).
; 3148 : inline bool ProcessShutdownInProgress()
; 3149 : {
; 3150 :     return (details::g_processShutdownInProgress || (details::g_pfnDllShutdownInProgress ? details::g_pfnDllShutdownInProgress() : false));
; 3151 : }
; 3152 : 
; 3153 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down,
; 3154 : but the hosting DLL doesn't support CRT initializers (such as kernelbase.dll).  The hosting DLL is responsible for calling
; 3155 : Construct() and Destroy() to manually run the constructor and destructor during DLL load & unload.
; 3156 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3157 : called as is typical. */
; 3158 : template <class T>
; 3159 : class manually_managed_shutdown_aware_object
; 3160 : {
; 3161 : public:
; 3162 :     manually_managed_shutdown_aware_object() = default;
; 3163 :     manually_managed_shutdown_aware_object(manually_managed_shutdown_aware_object const&) = delete;
; 3164 :     void operator=(manually_managed_shutdown_aware_object const&) = delete;
; 3165 : 
; 3166 :     void construct()
; 3167 :     {
; 3168 :         void* var = &m_raw;
; 3169 :         ::new (var) T();
; 3170 :     }
; 3171 : 
; 3172 :     void destroy()
; 3173 :     {
; 3174 :         if (ProcessShutdownInProgress())
; 3175 :         {
; 3176 :             get().ProcessShutdown();
; 3177 :         }
; 3178 :         else
; 3179 :         {
; 3180 :             (&get())->~T();
; 3181 :         }
; 3182 :     }
; 3183 : 
; 3184 :     //! Retrieves a reference to the contained object
; 3185 :     T& get() WI_NOEXCEPT
; 3186 :     {
; 3187 :         return *reinterpret_cast<T*>(&m_raw);
; 3188 :     }
; 3189 : 
; 3190 : private:
; 3191 :     alignas(T) unsigned char m_raw[sizeof(T)];
; 3192 : };
; 3193 : 
; 3194 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down.
; 3195 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3196 : called as is typical. */
; 3197 : template <class T>
; 3198 : class shutdown_aware_object
; 3199 : {
; 3200 : public:
; 3201 :     shutdown_aware_object()
; 3202 :     {
; 3203 :         m_object.construct();
; 3204 :     }
; 3205 : 
; 3206 :     ~shutdown_aware_object()
; 3207 :     {
; 3208 :         m_object.destroy();
; 3209 :     }
; 3210 : 
; 3211 :     shutdown_aware_object(shutdown_aware_object const&) = delete;
; 3212 :     void operator=(shutdown_aware_object const&) = delete;
; 3213 : 
; 3214 :     //! Retrieves a reference to the contained object
; 3215 :     T& get() WI_NOEXCEPT
; 3216 :     {
; 3217 :         return m_object.get();
; 3218 :     }
; 3219 : 
; 3220 : private:
; 3221 :     manually_managed_shutdown_aware_object<T> m_object;
; 3222 : };
; 3223 : 
; 3224 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down. */
; 3225 : template <class T>
; 3226 : class object_without_destructor_on_shutdown
; 3227 : {
; 3228 : public:
; 3229 :     object_without_destructor_on_shutdown()
; 3230 :     {
; 3231 :         void* var = &m_raw;
; 3232 :         ::new (var) T();
; 3233 :     }
; 3234 : 
; 3235 :     ~object_without_destructor_on_shutdown()
; 3236 :     {
; 3237 :         if (!ProcessShutdownInProgress())
; 3238 :         {
; 3239 :             get().~T();
; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     object_without_destructor_on_shutdown(object_without_destructor_on_shutdown const&) = delete;
; 3244 :     void operator=(object_without_destructor_on_shutdown const&) = delete;
; 3245 : 
; 3246 :     //! Retrieves a reference to the contained object
; 3247 :     T& get() WI_NOEXCEPT
; 3248 :     {
; 3249 :         return *reinterpret_cast<T*>(&m_raw);
; 3250 :     }
; 3251 : 
; 3252 : private:
; 3253 :     alignas(T) unsigned char m_raw[sizeof(T)]{};
; 3254 : };
; 3255 : 
; 3256 : /** Forward your DLLMain to this function so that WIL can have visibility into whether a DLL unload is because
; 3257 : of termination or normal unload.  Note that when g_pfnDllShutdownInProgress is set, WIL attempts to make this
; 3258 : determination on its own without this callback.  Suppressing private APIs requires use of this. */
; 3259 : inline void DLLMain(HINSTANCE, DWORD reason, _In_opt_ LPVOID reserved)
; 3260 : {
; 3261 :     if (!details::g_processShutdownInProgress)
; 3262 :     {
; 3263 :         if ((reason == DLL_PROCESS_DETACH) && (reserved != nullptr))
; 3264 :         {
; 3265 :             details::g_processShutdownInProgress = true;
; 3266 :         }
; 3267 :     }
; 3268 : }
; 3269 : 
; 3270 : // [optionally] Plug in fallback telemetry reporting
; 3271 : // Normally, the callback is owned by including ResultLogging.h in the including module.  Alternatively a module
; 3272 : // could re-route fallback telemetry to any ONE specific provider by calling this method.
; 3273 : inline void SetResultTelemetryFallback(_In_opt_ decltype(details::g_pfnTelemetryCallback) callbackFunction)
; 3274 : {
; 3275 :     // Only ONE telemetry provider can own the fallback telemetry callback.
; 3276 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3277 :         (details::g_pfnTelemetryCallback == nullptr) || (callbackFunction == nullptr) ||
; 3278 :         (details::g_pfnTelemetryCallback == callbackFunction));
; 3279 :     details::g_pfnTelemetryCallback = callbackFunction;
; 3280 : }
; 3281 : 
; 3282 : // [optionally] Plug in result logging (do not use for telemetry)
; 3283 : // This provides the ability for a module to hook all failures flowing through the system for inspection
; 3284 : // and/or logging.
; 3285 : inline void SetResultLoggingCallback(_In_opt_ decltype(details::g_pfnLoggingCallback) callbackFunction)
; 3286 : {
; 3287 :     // Only ONE function can own the result logging callback
; 3288 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3289 :         (details::g_pfnLoggingCallback == nullptr) || (callbackFunction == nullptr) ||
; 3290 :         (details::g_pfnLoggingCallback == callbackFunction));
; 3291 :     details::g_pfnLoggingCallback = callbackFunction;
; 3292 : }
; 3293 : 
; 3294 : // [optionally] Plug in custom result messages
; 3295 : // There are some purposes that require translating the full information that is known about a failure
; 3296 : // into a message to be logged (either through the console for debugging OR as the message attached
; 3297 : // to a Platform::Exception^).  This callback allows a module to format the string itself away from the
; 3298 : // default.
; 3299 : inline void SetResultMessageCallback(_In_opt_ decltype(wil::g_pfnResultLoggingCallback) callbackFunction)
; 3300 : {
; 3301 :     // Only ONE function can own the result message callback
; 3302 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3303 :         (g_pfnResultLoggingCallback == nullptr) || (callbackFunction == nullptr) || (g_pfnResultLoggingCallback == callbackFunction));
; 3304 :     details::g_resultMessageCallbackSet = true;
; 3305 :     g_pfnResultLoggingCallback = callbackFunction;
; 3306 : }
; 3307 : 
; 3308 : // [optionally] Plug in exception remapping
; 3309 : // A module can plug a callback in using this function to setup custom exception handling to allow any
; 3310 : // exception type to be converted into an HRESULT from exception barriers.
; 3311 : inline void SetResultFromCaughtExceptionCallback(_In_opt_ decltype(wil::g_pfnResultFromCaughtException) callbackFunction)
; 3312 : {
; 3313 :     // Only ONE function can own the exception conversion
; 3314 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3315 :         (g_pfnResultFromCaughtException == nullptr) || (callbackFunction == nullptr) ||
; 3316 :         (g_pfnResultFromCaughtException == callbackFunction));
; 3317 :     g_pfnResultFromCaughtException = callbackFunction;
; 3318 : }
; 3319 : 
; 3320 : // [optionally] Plug in exception remapping
; 3321 : // This provides the ability for a module to call RoOriginateError in case of a failure.
; 3322 : // Normally, the callback is owned by including result_originate.h in the including module.  Alternatively a module
; 3323 : // could re-route error origination callback to its own implementation.
; 3324 : inline void SetOriginateErrorCallback(_In_opt_ decltype(details::g_pfnOriginateCallback) callbackFunction)
; 3325 : {
; 3326 :     // Only ONE function can own the error origination callback
; 3327 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3328 :         (details::g_pfnOriginateCallback == nullptr) || (callbackFunction == nullptr) ||
; 3329 :         (details::g_pfnOriginateCallback == callbackFunction));
; 3330 :     details::g_pfnOriginateCallback = callbackFunction;
; 3331 : }
; 3332 : 
; 3333 : // [optionally] Plug in failfast callback
; 3334 : // This provides the ability for a module to call RoFailFastWithErrorContext in the failfast handler -if- there is stowed
; 3335 : // exception data available.  Normally, the callback is owned by including result_originate.h in the including module.
; 3336 : // Alternatively a module could re-route to its own implementation.
; 3337 : inline void SetFailfastWithContextCallback(_In_opt_ decltype(details::g_pfnFailfastWithContextCallback) callbackFunction)
; 3338 : {
; 3339 :     // Only ONE function can own the failfast with context callback
; 3340 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3341 :         (details::g_pfnFailfastWithContextCallback == nullptr) || (callbackFunction == nullptr) ||
; 3342 :         (details::g_pfnFailfastWithContextCallback == callbackFunction));
; 3343 :     details::g_pfnFailfastWithContextCallback = callbackFunction;
; 3344 : }
; 3345 : 
; 3346 : // A RAII wrapper around the storage of a FailureInfo struct (which is normally meant to be consumed
; 3347 : // on the stack or from the caller).  The storage of FailureInfo needs to copy some data internally
; 3348 : // for lifetime purposes.
; 3349 : 
; 3350 : class StoredFailureInfo
; 3351 : {
; 3352 : public:
; 3353 :     StoredFailureInfo() WI_NOEXCEPT
; 3354 :     {
; 3355 :         ::ZeroMemory(&m_failureInfo, sizeof(m_failureInfo));
; 3356 :     }
; 3357 : 
; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT
; 3359 :     {
; 3360 :         SetFailureInfo(other);
; 3361 :     }
; 3362 : 
; 3363 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3364 :     {
; 3365 :         return m_failureInfo;
; 3366 :     }
; 3367 : 
; 3368 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3369 :     {
; 3370 :         m_failureInfo = failure;
; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +
; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))
; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);
; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;
; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);
; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);
; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);
; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);
; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);
; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);
; 3398 :             pBuffer = details::WriteResultString(
; 3399 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextName, &m_failureInfo.callContextCurrent.contextName);
; 3400 :             pBuffer = details::WriteResultString(
; 3401 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextMessage, &m_failureInfo.callContextCurrent.contextMessage);
; 3402 :             pBuffer = details::WriteResultString(
; 3403 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextName, &m_failureInfo.callContextOriginating.contextName);
; 3404 :             pBuffer = details::WriteResultString(
; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);
; 3407 :         }
; 3408 :     }
; 3409 : 
; 3410 :     // Relies upon generated copy constructor and assignment operator
; 3411 : 
; 3412 : protected:
; 3413 :     FailureInfo m_failureInfo;
; 3414 :     details::shared_buffer m_spStrings;
; 3415 : };
; 3416 : 
; 3417 : #if defined(WIL_ENABLE_EXCEPTIONS) || defined(WIL_FORCE_INCLUDE_RESULT_EXCEPTION)
; 3418 : 
; 3419 : //! This is WIL's default exception class thrown from all THROW_XXX macros (outside of c++/cx).
; 3420 : //! This class stores all of the FailureInfo context that is available when the exception is thrown.  It's also caught by
; 3421 : //! exception guards for automatic conversion to HRESULT.
; 3422 : //!
; 3423 : //! In c++/cx, Platform::Exception^ is used instead of this class (unless @ref wil::g_fResultThrowPlatformException has been
; 3424 : //! changed).
; 3425 : class ResultException : public std::exception
; 3426 : {
; 3427 : public:
; 3428 :     //! Constructs a new ResultException from an existing FailureInfo.
; 3429 :     ResultException(const FailureInfo& failure) WI_NOEXCEPT : m_failure(failure)
; 3430 :     {
; 3431 :     }
; 3432 : 
; 3433 :     //! Constructs a new exception type from a given HRESULT (use only for constructing custom exception types).
; 3434 :     ResultException(_Pre_satisfies_(hr < 0) HRESULT hr) WI_NOEXCEPT : m_failure(CustomExceptionFailureInfo(hr))
; 3435 :     {
; 3436 :     }
; 3437 : 
; 3438 :     //! Returns the failed HRESULT that this exception represents.
; 3439 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) HRESULT GetErrorCode() const WI_NOEXCEPT
; 3440 :     {
; 3441 :         HRESULT const hr = m_failure.GetFailureInfo().hr;
; 3442 :         __analysis_assume(hr < 0);
; 3443 :         return hr;
; 3444 :     }
; 3445 : 
; 3446 :     //! Returns the failed NTSTATUS that this exception represents.
; 3447 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) NTSTATUS GetStatusCode() const WI_NOEXCEPT
; 3448 :     {
; 3449 :         NTSTATUS const status = m_failure.GetFailureInfo().status;
; 3450 :         __analysis_assume(status < 0);
; 3451 :         return status;
; 3452 :     }
; 3453 : 
; 3454 :     //! Get a reference to the stored FailureInfo.
; 3455 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3456 :     {
; 3457 :         return m_failure.GetFailureInfo();
; 3458 :     }
; 3459 : 
; 3460 :     //! Sets the stored FailureInfo (use primarily only when constructing custom exception types).
; 3461 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3462 :     {
; 3463 :         m_failure.SetFailureInfo(failure);
; 3464 :     }
; 3465 : 
; 3466 :     //! Provides a string representing the FailureInfo from this exception.
; 3467 :     WI_NODISCARD inline const char* __CLR_OR_THIS_CALL what() const WI_NOEXCEPT override
; 3468 :     {
; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)
; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);
; 3476 :             if (!m_what.create(len))
; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";
; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);
; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());
; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }
; 3498 : 
; 3499 :     // Relies upon auto-generated copy constructor and assignment operator
; 3500 : protected:
; 3501 :     StoredFailureInfo m_failure;           //!< The failure information for this exception
; 3502 :     mutable details::shared_buffer m_what; //!< The on-demand generated what() string
; 3503 : 
; 3504 :     //! Use to produce a custom FailureInfo from an HRESULT (use only when constructing custom exception types).
; 3505 :     static FailureInfo CustomExceptionFailureInfo(HRESULT hr) WI_NOEXCEPT
; 3506 :     {
; 3507 :         FailureInfo fi = {};
; 3508 :         fi.type = FailureType::Exception;
; 3509 :         fi.hr = hr;
; 3510 :         return fi;
; 3511 :     }
; 3512 : };
; 3513 : #endif
; 3514 : 
; 3515 : //*****************************************************************************
; 3516 : // Public Helpers that catch -- mostly only enabled when exceptions are enabled
; 3517 : //*****************************************************************************
; 3518 : 
; 3519 : // ResultFromCaughtException is a function that is meant to be called from within a catch(...) block.  Internally
; 3520 : // it re-throws and catches the exception to convert it to an HRESULT.  If an exception is of an unrecognized type
; 3521 : // the function will fail fast.
; 3522 : //
; 3523 : // try
; 3524 : // {
; 3525 : //     // Code
; 3526 : // }
; 3527 : // catch (...)
; 3528 : // {
; 3529 : //     hr = wil::ResultFromCaughtException();
; 3530 : // }
; 3531 : _Always_(_Post_satisfies_(return < 0)) __declspec(noinline) inline HRESULT ResultFromCaughtException() WI_NOEXCEPT
; 3532 : {
; 3533 :     bool isNormalized = false;
; 3534 :     HRESULT hr = S_OK;
; 3535 :     if (details::g_pfnResultFromCaughtExceptionInternal)
; 3536 :     {
; 3537 :         hr = details::g_pfnResultFromCaughtExceptionInternal(nullptr, 0, &isNormalized).hr;
; 3538 :     }
; 3539 :     if (FAILED(hr))
; 3540 :     {
; 3541 :         return hr;
; 3542 :     }
; 3543 : 
; 3544 :     // Caller bug: an unknown exception was thrown
; 3545 :     __WIL_PRIVATE_FAIL_FAST_HR_IF(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION), g_fResultFailFastUnknownExceptions);
; 3546 :     return __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3547 : }
; 3548 : 
; 3549 : //! Identical to 'throw;', but can be called from error-code neutral code to rethrow in code that *may* be running under an
; 3550 : //! exception context
; 3551 : inline void RethrowCaughtException()
; 3552 : {
; 3553 :     // We always want to rethrow the exception under normal circumstances.  Ordinarily, we could actually guarantee
; 3554 :     // this as we should be able to rethrow if we caught an exception, but if we got here in the middle of running
; 3555 :     // dynamic initializers, then it's possible that we haven't yet setup the rethrow function pointer, thus the
; 3556 :     // runtime check without the noreturn annotation.
; 3557 : 
; 3558 :     if (details::g_pfnRethrow)
; 3559 :     {
; 3560 :         details::g_pfnRethrow();
; 3561 :     }
; 3562 : }
; 3563 : 
; 3564 : //! Identical to 'throw ResultException(failure);', but can be referenced from error-code neutral code
; 3565 : inline void ThrowResultException(const FailureInfo& failure)
; 3566 : {
; 3567 :     if (details::g_pfnThrowResultException)
; 3568 :     {
; 3569 :         details::g_pfnThrowResultException(failure);
; 3570 :     }
; 3571 : }
; 3572 : 
; 3573 : /// @cond
; 3574 : namespace details
; 3575 : {
; 3576 : #ifdef WIL_ENABLE_EXCEPTIONS
; 3577 :     //*****************************************************************************
; 3578 :     // Private helpers to catch and propagate exceptions
; 3579 :     //*****************************************************************************
; 3580 : 
; 3581 :     RESULT_NORETURN inline void TerminateAndReportError(_In_opt_ PEXCEPTION_POINTERS)
; 3582 :     {
; 3583 :         // This is an intentional fail-fast that was caught by an exception guard with WIL.  Look back up the callstack to
; 3584 :         // determine the source of the actual exception being thrown.  The exception guard used by the calling code did not expect
; 3585 :         // this exception type to be thrown or is specifically requesting fail-fast for this class of exception.
; 3586 : 
; 3587 :         FailureInfo failure{};
; 3588 :         WilFailFast(failure);
; 3589 :     }
; 3590 : 
; 3591 :     inline void MaybeGetExceptionString(
; 3592 :         const ResultException& exception,
; 3593 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3594 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3595 :     {
; 3596 :         if (debugString)
; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());
; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$2:

; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);

	mov	rdx, QWORD PTR debugStringChars$[rbp]
	mov	rcx, QWORD PTR debugString$[rbp]
	call	?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z ; wil::details::RecognizeCaughtExceptionFromCallback

; 3980 :                 if (FAILED(hr))

	test	eax, eax
	jns	SHORT $LN9@catch$2

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov	DWORD PTR $T11[rbp], eax
	mov	ecx, eax
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR $T11[rbp+4], eax
	mov	DWORD PTR $T11[rbp+8], 0

; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);

	mov	rax, 0
	jmp	SHORT $LN78@catch$2
$LN9@catch$2:

; 3983 :                 }
; 3984 :             }

	mov	rax, 1
$LN78@catch$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$3

; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$4:

; 3994 :                 *isNormalized = true;

	mov	rax, QWORD PTR isNormalized$[rbp]
	mov	BYTE PTR [rax], 1

; 3596 :         if (debugString)

	mov	rcx, QWORD PTR debugString$[rbp]
	mov	rbx, QWORD PTR exception$26[rbp]
	test	rcx, rcx
	je	SHORT $LN55@catch$3

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	lea	r8, QWORD PTR [rbx+24]
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	call	?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z ; wil::GetFailureLogString
$LN55@catch$3:

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR $T14[rbp], eax
	mov	eax, DWORD PTR [rbx+36]
	mov	DWORD PTR $T14[rbp+4], eax
	mov	eax, DWORD PTR [rbx+28]
	shr	eax, 3
	and	eax, 1
	mov	DWORD PTR $T14[rbp+8], eax

; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$4

; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$5:

; 3607 :         if (debugString)

	mov	rbx, QWORD PTR debugString$[rbp]
	test	rbx, rbx
	je	SHORT $LN60@catch$4

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	mov	rcx, QWORD PTR exception$28[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	r9, rax
	lea	r8, OFFSET FLAT:??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	mov	rcx, rbx
	call	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ	; StringCchPrintfW
$LN60@catch$4:

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov	DWORD PTR $T17[rbp], -2147024882	; ffffffff8007000eH
	mov	ecx, -2147024882			; ffffffff8007000eH
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR $T17[rbp+4], eax
	mov	DWORD PTR $T17[rbp+8], 0

; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$5

; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	sub	rsp, 40					; 00000028H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$6:

; 3607 :         if (debugString)

	mov	rbx, QWORD PTR debugString$[rbp]
	test	rbx, rbx
	je	SHORT $LN65@catch$5

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	mov	rcx, QWORD PTR exception$29[rbp]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	r9, rax
	lea	r8, OFFSET FLAT:??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	mov	rdx, QWORD PTR debugStringChars$[rbp]
	mov	rcx, rbx
	call	?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ	; StringCchPrintfW
$LN65@catch$5:

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov	DWORD PTR $T20[rbp], -2147024322	; ffffffff8007023eH
	mov	ecx, -2147024322			; ffffffff8007023eH
	call	?HrToNtStatus@details@wil@@YAJJ@Z	; wil::details::HrToNtStatus
	mov	DWORD PTR $T20[rbp+4], eax
	mov	DWORD PTR $T20[rbp+8], 0

; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));

	mov	rax, 0
	add	rsp, 40					; 00000028H
	pop	rbp
	pop	rbx
	ret	0
	int	3
?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
exception$25 = 32
exception$26 = 40
exception$27 = 48
exception$28 = 56
exception$29 = 64
$T5 = 72
$T8 = 72
$T11 = 72
$T14 = 72
$T17 = 72
$T20 = 72
__$ReturnAddress$ = 144
debugString$ = 152
debugStringChars$ = 160
isNormalized$ = 168
?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$6

; 4009 :             {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$7:

; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }

	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA ENDP ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$6
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z
_TEXT	SEGMENT
functor$ = 48
host$ = 56
$T1 = 56
returnAddress$ = 64
?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z PROC ; wil::details::RunFunctorWithExceptionFilter, COMDAT

; 4155 :     {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 40					; 00000028H
	mov	r8, rdx

; 4156 :         try
; 4157 :         {
; 4158 :             return host.Run(functor);

	mov	rax, QWORD PTR [rdx]
	mov	rdx, rcx
	mov	rcx, r8
	call	QWORD PTR [rax]
	jmp	SHORT $LN6@RunFunctor
$LN7@RunFunctor:

; 4159 :         }
; 4160 :         catch (...)
; 4161 :         {
; 4162 :             // Note that the host may choose to re-throw, throw a normalized exception, return S_OK and eat the exception or
; 4163 :             // return the remapped failure.
; 4164 :             return host.ExceptionThrown(returnAddress);

	mov	eax, DWORD PTR $T1[rsp]
$LN6@RunFunctor:

; 4165 :         }
; 4166 :     }

	add	rsp, 40					; 00000028H
	ret	0
	int	3
?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z ENDP ; wil::details::RunFunctorWithExceptionFilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
functor$ = 48
host$ = 56
$T1 = 56
returnAddress$ = 64
?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA PROC ; `wil::details::RunFunctorWithExceptionFilter'::`1'::catch$0

; 4161 :         {

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z$0:

; 4162 :             // Note that the host may choose to re-throw, throw a normalized exception, return S_OK and eat the exception or
; 4163 :             // return the remapped failure.
; 4164 :             return host.ExceptionThrown(returnAddress);

	mov	rcx, QWORD PTR host$[rbp]
	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR returnAddress$[rbp]
	call	QWORD PTR [rax+8]
	mov	DWORD PTR $T1[rbp], eax
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA ENDP ; `wil::details::RunFunctorWithExceptionFilter'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??R<lambda_2>@details@wil@@QEBA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??R<lambda_2>@details@wil@@QEBA@XZ PROC			; wil::details::<lambda_2>::operator(), COMDAT

; 4168 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeResultExceptions, [] {

	mov	eax, 1
	ret	0
??R<lambda_2>@details@wil@@QEBA@XZ ENDP			; wil::details::<lambda_2>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
pcs$ = 56
?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z PROC ; wil::EnterCriticalSection, COMDAT

; 3353 : {

$LN14:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, rdx

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdx
	call	QWORD PTR __imp_EnterCriticalSection

; 3355 :     return cs_leave_scope_exit(pcs);

	mov	rax, rbx

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR [rbx], rdi

; 3356 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; wil::EnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >, COMDAT

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	mov	rcx, QWORD PTR [rcx]

; 222  :             if (policy::is_valid(m_ptr))

	test	rcx, rcx
	je	SHORT $LN12@unique_any

; 154  :             close_fn(value);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
$LN12@unique_any:
	ret	0
??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ ENDP ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??0critical_section@wil@@QEAA@K@Z
_TEXT	SEGMENT
this$ = 48
spincount$dead$ = 56
??0critical_section@wil@@QEAA@K@Z PROC			; wil::critical_section::critical_section, COMDAT

; 3373 :     critical_section(ULONG spincount = 0) WI_NOEXCEPT

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3374 :     {
; 3375 :         // Initialization will not fail without invalid params...
; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rbx, rcx
	call	QWORD PTR __imp_InitializeCriticalSectionEx

; 3377 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0critical_section@wil@@QEAA@K@Z ENDP			; wil::critical_section::critical_section
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??1critical_section@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1critical_section@wil@@QEAA@XZ PROC			; wil::critical_section::~critical_section, COMDAT

; 3381 :         ::DeleteCriticalSection(&m_cs);

	rex_jmp	QWORD PTR __imp_DeleteCriticalSection
??1critical_section@wil@@QEAA@XZ ENDP			; wil::critical_section::~critical_section
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ PROC ; wil::critical_section::lock, COMDAT

; 3385 :     {

$LN19:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 3354 :     ::EnterCriticalSection(pcs);

	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR [rdi], rbx

; 3386 :         return wil::EnterCriticalSection(&m_cs);

	mov	rax, rdi

; 3387 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ ENDP ; wil::critical_section::lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h
;	COMDAT ?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ
_TEXT	SEGMENT
this$ = 8
?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ PROC		; CUnknown::GetOwner, COMDAT

; 197  :         return m_pUnknown;

	mov	rax, QWORD PTR [rcx+8]

; 198  :     };

	ret	0
?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ ENDP		; CUnknown::GetOwner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h
;	COMDAT ?toULong@@YAKW4UACSampleFormat@@@Z
_TEXT	SEGMENT
sampleFormat$ = 8
?toULong@@YAKW4UACSampleFormat@@@Z PROC			; toULong, COMDAT

; 82   :     return static_cast<ULONG>(sampleFormat);

	mov	eax, ecx

; 83   : }

	ret	0
?toULong@@YAKW4UACSampleFormat@@@Z ENDP			; toULong
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h
;	COMDAT ?toInt@@YAHW4DeviceStatuses@@@Z
_TEXT	SEGMENT
Status$ = 8
?toInt@@YAHW4DeviceStatuses@@@Z PROC			; toInt, COMDAT

; 100  :     return static_cast<int>(Status);

	mov	eax, ecx

; 101  : }

	ret	0
?toInt@@YAHW4DeviceStatuses@@@Z ENDP			; toInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h
;	COMDAT ?toInt@@YAHW4UserThreadStatuses@@@Z
_TEXT	SEGMENT
Statuses$ = 8
?toInt@@YAHW4UserThreadStatuses@@@Z PROC		; toInt, COMDAT

; 139  :     return static_cast<int>(Statuses);

	mov	eax, ecx

; 140  : }

	ret	0
?toInt@@YAHW4UserThreadStatuses@@@Z ENDP		; toInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h
;	COMDAT ?toInt@@YAHW4UACSampleType@@@Z
_TEXT	SEGMENT
sampleType$ = 8
?toInt@@YAHW4UACSampleType@@@Z PROC			; toInt, COMDAT

; 170  :     return static_cast<int>(sampleType);

	mov	eax, ecx

; 171  : }

	ret	0
?toInt@@YAHW4UACSampleType@@@Z ENDP			; toInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
;	COMDAT ?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
riid$ = 16
ppv$ = 24
?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z PROC ; CUSBAsio::QueryInterface, COMDAT

; 69   :     DECLARE_IUNKNOWN

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax]
?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z ENDP ; CUSBAsio::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
;	COMDAT ?AddRef@CUSBAsio@@UEAAKXZ
_TEXT	SEGMENT
this$ = 8
?AddRef@CUSBAsio@@UEAAKXZ PROC				; CUSBAsio::AddRef, COMDAT

; 69   :     DECLARE_IUNKNOWN

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
?AddRef@CUSBAsio@@UEAAKXZ ENDP				; CUSBAsio::AddRef
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
;	COMDAT ?Release@CUSBAsio@@UEAAKXZ
_TEXT	SEGMENT
this$ = 8
?Release@CUSBAsio@@UEAAKXZ PROC				; CUSBAsio::Release, COMDAT

; 69   :     DECLARE_IUNKNOWN

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+16]
?Release@CUSBAsio@@UEAAKXZ ENDP				; CUSBAsio::Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z
_TEXT	SEGMENT
timeStamp$ = 48
?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z PROC		; getNanoSeconds, COMDAT

; 100  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 101  :     double nanoSeconds = (double)((unsigned long)timeGetTime()) * 1000000.;

	call	QWORD PTR __imp_timeGetTime
	mov	eax, eax
	xorps	xmm1, xmm1
	cvtsi2sd xmm1, rax
	mulsd	xmm1, QWORD PTR __real@412e848000000000

; 102  :     timeStamp->hi = (unsigned long)(nanoSeconds / c_TwoRaisedTo32);

	movaps	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3df0000000000000
	cvttsd2si rax, xmm0
	xorps	xmm0, xmm0
	mov	DWORD PTR [rbx], eax

; 103  :     timeStamp->lo = (unsigned long)(nanoSeconds - (timeStamp->hi * c_TwoRaisedTo32));

	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@41f0000000000000
	subsd	xmm1, xmm0
	cvttsd2si rax, xmm1
	mov	DWORD PTR [rbx+4], eax

; 104  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z ENDP		; getNanoSeconds
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z
_TEXT	SEGMENT
unknown$ = 48
result$ = 56
$T1 = 64
?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z PROC ; CUSBAsio::CreateInstance, COMDAT

; 159  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 160  :     return (CUnknown *)new CUSBAsio(unknown, result);

	mov	ecx, 3736				; 00000e98H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	mov	QWORD PTR $T1[rsp], rax
	xor	edx, edx
	mov	r8d, 3736				; 00000e98H
	mov	rcx, rax
	call	memset
	mov	rdx, rdi
	mov	rcx, rbx
	call	??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z	; CUSBAsio::CUSBAsio
	mov	rcx, rax
	add	rax, 8
	xor	edx, edx
	test	rcx, rcx
	cmove	rax, rdx

; 161  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z ENDP ; CUSBAsio::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
unknown$ = 48
result$ = 56
$T1 = 64
?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 3736				; 00000e98H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA ENDP ; `CUSBAsio::CreateInstance'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@CUSBAsio@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@CUSBAsio@@QEAAX_K@Z PROC		; CUSBAsio::__autoclassinit2, COMDAT
	xor	edx, edx
	mov	r8d, 3736				; 00000e98H
	jmp	memset
?__autoclassinit2@CUSBAsio@@QEAAX_K@Z ENDP		; CUSBAsio::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
riid$ = 56
object$ = 64
?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z PROC ; CUSBAsio::NonDelegatingQueryInterface, COMDAT

; 169  : {

$LN25:
	sub	rsp, 40					; 00000028H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	rax, QWORD PTR [rdx]
	cmp	rax, QWORD PTR ?IID_ASIO_DRIVER@@3U_GUID@@A
	jne	SHORT $LN2@NonDelegat
	mov	rax, QWORD PTR [rdx+8]
	cmp	rax, QWORD PTR ?IID_ASIO_DRIVER@@3U_GUID@@A+8
	jne	SHORT $LN2@NonDelegat
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 172  :         return GetInterface(this, object);

	add	rcx, -8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 160  :     CheckPointer(ppv, E_POINTER);

	test	r8, r8
	jne	SHORT $LN9@NonDelegat
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 175  : }

	mov	eax, -2147467261			; ffffffff80004003H
	add	rsp, 40					; 00000028H
	ret	0
$LN2@NonDelegat:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 80   :     CheckPointer(ppv,E_POINTER);

	test	r8, r8
	jne	SHORT $LN12@NonDelegat
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 175  : }

	mov	eax, -2147467261			; ffffffff80004003H
	add	rsp, 40					; 00000028H
	ret	0
$LN12@NonDelegat:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	rax, QWORD PTR [rdx]
	cmp	rax, QWORD PTR IID_IUnknown
	jne	SHORT $LN13@NonDelegat
	mov	rax, QWORD PTR [rdx+8]
	cmp	rax, QWORD PTR IID_IUnknown+8
	jne	SHORT $LN13@NonDelegat
$LN9@NonDelegat:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 175  : }

	mov	QWORD PTR [r8], rcx
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	xor	eax, eax
	add	rsp, 40					; 00000028H
	ret	0
$LN13@NonDelegat:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 89   :         *ppv = NULL;

	xor	eax, eax
	mov	QWORD PTR [r8], rax

; 90   :         return E_NOINTERFACE;

	mov	eax, -2147467262			; ffffffff80004002H
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 175  : }

	add	rsp, 40					; 00000028H
	ret	0
?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z ENDP ; CUSBAsio::NonDelegatingQueryInterface
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z
_TEXT	SEGMENT
this$GSCopy$ = 64
$T17 = 72
hKey$18 = 480
bytesReturned$19 = 488
bytesReturned$20 = 488
size$21 = 488
privateProperty$22 = 496
privateProperty$23 = 496
messageString$24 = 528
messageString$25 = 528
__$ArrayPad$ = 656
this$ = 704
unknown$ = 712
result$dead$ = 720
??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z PROC		; CUSBAsio::CUSBAsio, COMDAT

; 183  : {

$LN209:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-416]
	sub	rsp, 672				; 000002a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	lea	rax, OFFSET FLAT:??_7IASIO@@6B@
	mov	QWORD PTR [rcx], rax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 30   :     InterlockedIncrement(&m_cObjects);

	lock inc DWORD PTR ?m_cObjects@CBaseObject@@0JA	; CBaseObject::m_cObjects

; 71   : {

	lea	rax, OFFSET FLAT:??_7CUnknown@@6B@
	mov	QWORD PTR [rcx+8], rax

; 62   : /* Set our pointer to our IUnknown interface.                      */
; 63   : /* If we have an outer, use its, otherwise use ours.               */
; 64   : /* This pointer effectivly points to the owner of                  */
; 65   : /* this object and can be accessed by the GetOwner() method.       */
; 66   : , m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )

	lea	rax, QWORD PTR [rcx+8]
	test	rdx, rdx
	cmovne	rax, rdx
	mov	QWORD PTR [rcx+16], rax

; 31   : 
; 32   : #ifdef DEBUG
; 33   :     m_dwCookie = DbgRegisterObjectCreation(pName);
; 34   : #endif
; 35   : }
; 36   : 
; 37   : 
; 38   : /* Destructor */
; 39   : 
; 40   : CBaseObject::~CBaseObject()
; 41   : {
; 42   :     /* Decrement the number of objects active */
; 43   :     InterlockedDecrement(&m_cObjects);
; 44   : 
; 45   : #ifdef DEBUG
; 46   :     DbgRegisterObjectDestruction(m_dwCookie);
; 47   : #endif
; 48   : }
; 49   : 
; 50   : 
; 51   : /* Constructor */
; 52   : 
; 53   : // We know we use "this" in the initialization list, we also know we don't modify *phr.
; 54   : #pragma warning( disable : 4355 4100 ) 
; 55   : CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) 
; 56   : : CBaseObject(pName)
; 57   : /* Start the object with a reference count of zero - when the      */
; 58   : /* object is queried for it's first interface this may be          */
; 59   : /* incremented depending on whether or not this object is          */
; 60   : /* currently being aggregated upon                                 */
; 61   : , m_cRef(0)

	xor	r15d, r15d
	mov	DWORD PTR [rcx+24], r15d
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BIASIO@@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BCUnknown@@@
	mov	QWORD PTR [rcx+8], rax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 159  :     double                        m_samplePosition{0};

	mov	QWORD PTR [rcx+32], r15

; 160  :     double                        m_sampleRate{UAC_DEFAULT_SAMPLE_RATE};

	mov	rax, 4676293871431319552		; 40e5888000000000H
	mov	QWORD PTR [rcx+40], rax

; 161  :     ASIOCallbacks *               m_callbacks{nullptr};

	mov	QWORD PTR [rcx+48], r15
	xorps	xmm0, xmm0

; 162  :     ASIOTime                      m_asioTime{0};

	xor	eax, eax
	movups	XMMWORD PTR [rcx+56], xmm0
	movups	XMMWORD PTR [rcx+72], xmm0
	movups	XMMWORD PTR [rcx+88], xmm0
	movups	XMMWORD PTR [rcx+104], xmm0
	movups	XMMWORD PTR [rcx+120], xmm0
	movups	XMMWORD PTR [rcx+136], xmm0
	movups	XMMWORD PTR [rcx+152], xmm0
	movups	XMMWORD PTR [rcx+168], xmm0
	movups	XMMWORD PTR [rcx+184], xmm0
	mov	DWORD PTR [rcx+200], eax

; 163  :     ASIOTimeStamp                 m_theSystemTime{0};

	mov	QWORD PTR [rcx+204], rax

; 164  :     volatile UCHAR *              m_inputBuffers[NUMOFINPUTS * 2]{};

	add	rcx, 216				; 000000d8H
	xor	edx, edx
	mov	r8d, 1024				; 00000400H
	call	memset

; 165  :     UCHAR *                       m_outputBuffers[NUMOFOUTPUTS * 2]{};

	lea	rcx, QWORD PTR [rbx+1240]
	xor	edx, edx
	mov	r8d, 1024				; 00000400H
	call	memset

; 166  :     DWORD                         m_initialSystemTime{0};

	mov	QWORD PTR [rbx+2264], r15

; 167  :     DWORD                         m_calculatedSystemTime{0};
; 168  :     ULONGLONG                     m_initialKernelTime{0};

	mov	QWORD PTR [rbx+2272], r15

; 169  :     TCHAR *                       m_desiredPath{nullptr};

	mov	QWORD PTR [rbx+2280], r15

; 170  :     long                          m_inMap[NUMOFINPUTS]{};

	lea	rcx, QWORD PTR [rbx+2288]
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	call	memset

; 171  :     long                          m_outMap[NUMOFOUTPUTS]{};

	lea	rcx, QWORD PTR [rbx+2544]
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	call	memset

; 172  :     long                          m_blockFrames{UAC_DEFAULT_ASIO_BUFFER_SIZE};

	mov	QWORD PTR [rbx+2800], 512		; 00000200H

; 173  :     long                          m_inputLatency{0};
; 174  :     long                          m_outputLatency{0};

	mov	QWORD PTR [rbx+2808], r15

; 175  :     ULONG                         m_activeInputs{0};
; 176  :     ULONG                         m_activeOutputs{0};

	mov	QWORD PTR [rbx+2816], r15

; 177  :     long                          m_toggle{0};
; 178  :     bool                          m_isActive{false};

	mov	DWORD PTR [rbx+2824], r15d

; 179  :     bool                          m_isStarted{false};
; 180  :     bool                          m_isTimeInfoMode{false};
; 181  :     bool                          m_isTcRead{false};
; 182  :     TCHAR                         m_errorMessage[ERROR_MESSAGE_LENGTH]{};

	lea	r14, QWORD PTR [rbx+2828]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [r14], xmm0
	movups	XMMWORD PTR [r14+16], xmm0
	movups	XMMWORD PTR [r14+32], xmm0
	movups	XMMWORD PTR [r14+48], xmm0
	movups	XMMWORD PTR [r14+64], xmm0
	movups	XMMWORD PTR [r14+80], xmm0
	movups	XMMWORD PTR [r14+96], xmm0
	movups	XMMWORD PTR [r14+112], xmm0

; 183  :     bool                          m_requireSampleRateChange{0.};

	mov	BYTE PTR [rbx+2956], r15b

; 184  :     ASIOSampleRate                m_nextSampleRate{0.};

	mov	QWORD PTR [rbx+2960], r15

; 185  :     bool                          m_isRequireAsioReset{false};

	mov	DWORD PTR [rbx+2968], 256		; 00000100H

; 186  :     bool                          m_isDropoutDetectionSetting{true};
; 187  :     bool                          m_isSupportDropoutDetection{false};
; 188  :     bool                          m_isRequireReportDropout{false};
; 189  :     bool                          m_isRequireLatencyChange{false};

	mov	BYTE PTR [rbx+2972], r15b

; 190  :     LONG                          m_outputReadyBlock{0};

	mov	DWORD PTR [rbx+2976], r15d

; 191  :     HANDLE                        m_usbDeviceHandle{INVALID_HANDLE_VALUE};

	mov	rsi, -1
	mov	QWORD PTR [rbx+2984], rsi

; 192  :     UAC_AUDIO_PROPERTY            m_audioProperty{0};

	xor	edx, edx
	mov	r8d, 408				; 00000198H
	lea	rcx, QWORD PTR [rbx+2992]
	call	memset
	lea	rax, QWORD PTR [rbx+2992]
	lea	rcx, QWORD PTR $T17[rsp]
	mov	edx, 3
	npad	6
$LL204@CUSBAsio:
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm0, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm1, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm0, XMMWORD PTR [rax+96]
	movups	XMMWORD PTR [rcx+96], xmm0
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm1, XMMWORD PTR [rax+112]
	movups	XMMWORD PTR [rcx-16], xmm1
	lea	rax, QWORD PTR [rax+128]
	sub	rdx, 1
	jne	SHORT $LL204@CUSBAsio
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx], xmm0
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rcx+16], rax
	xorps	xmm0, xmm0

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	xor	eax, eax
	movups	XMMWORD PTR [rbx+3400], xmm0
	movups	XMMWORD PTR [rbx+3416], xmm0
	movups	XMMWORD PTR [rbx+3432], xmm0
	mov	QWORD PTR [rbx+3448], rax
	mov	QWORD PTR [rbx+3456], rax

; 194  :     ULONG                         m_fixedSamplingRate{0};
; 195  :     ASIOIoFormatType              m_requestedSampleFormat{0};

	mov	QWORD PTR [rbx+3464], r15

; 196  :     ULONG                         m_inAvailableChannels{0};
; 197  :     ULONG                         m_outAvailableChannels{0};

	mov	DWORD PTR [rbx+3472], r15d

; 198  :     PUAC_GET_CHANNEL_INFO_CONTEXT m_channelInfo{nullptr};

	mov	QWORD PTR [rbx+3480], r15

; 199  :     PUAC_GET_CLOCK_INFO_CONTEXT   m_clockInfo{nullptr};

	mov	QWORD PTR [rbx+3488], r15
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	lea	rcx, QWORD PTR [rbx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	xor	r8d, r8d
	call	QWORD PTR __imp_InitializeCriticalSectionEx
	npad	1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	lea	rcx, QWORD PTR [rbx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_InitializeCriticalSectionEx
	npad	1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	lea	rcx, QWORD PTR [rbx+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_InitializeCriticalSectionEx
	npad	1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 203  :     UCHAR *                       m_driverPlayBufferWithKsProperty{nullptr};

	mov	QWORD PTR [rbx+3616], r15

; 204  :     UCHAR *                       m_driverPlayBuffer{nullptr};

	mov	QWORD PTR [rbx+3624], r15

; 205  :     volatile UCHAR *              m_driverRecBuffer{nullptr};

	mov	QWORD PTR [rbx+3632], r15

; 206  :     LONGLONG                      m_playReadyPosition{0};

	mov	QWORD PTR [rbx+3640], r15

; 207  :     HANDLE                        m_notificationEvent{nullptr};

	mov	QWORD PTR [rbx+3648], r15

; 208  :     HANDLE                        m_outputReadyEvent{nullptr};

	mov	QWORD PTR [rbx+3656], r15

; 209  :     HANDLE                        m_deviceReadyEvent{nullptr};

	mov	QWORD PTR [rbx+3664], r15

; 210  :     HANDLE                        m_stopEvent{nullptr};

	mov	QWORD PTR [rbx+3672], r15

; 211  :     HANDLE                        m_workerThread{nullptr};

	mov	QWORD PTR [rbx+3680], r15

; 212  :     LONG                          m_threadPriority{-2};

	mov	DWORD PTR [rbx+3688], -2

; 213  :     HANDLE                        m_asioResetEvent{nullptr};

	mov	QWORD PTR [rbx+3696], r15

; 214  :     HANDLE                        m_terminateAsioResetEvent{nullptr};

	mov	QWORD PTR [rbx+3704], r15

; 215  :     HANDLE                        m_asioResetThread{nullptr};

	mov	QWORD PTR [rbx+3712], r15

; 216  :     HANDLE                        m_outputReadyBlockEvent{nullptr};

	mov	QWORD PTR [rbx+3720], r15
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 191  :     m_InstanceIndex = InterlockedIncrement(&g_Instance);

	mov	eax, 1
	lock xadd DWORD PTR ?g_Instance@@3JA, eax
	inc	eax
	mov	DWORD PTR [rbx+3728], eax

; 192  : 
; 193  :     info_print_("USB ASIO created, instance %d.\n", InterlockedCompareExchange(&g_Instance, 0, 0));
; 194  : 
; 195  :     RtlZeroMemory(&m_audioProperty, sizeof(UAC_AUDIO_PROPERTY));

	xor	edx, edx
	mov	r8d, 408				; 00000198H
	lea	rcx, QWORD PTR [rbx+2992]
	call	memset

; 1679 :     if (m_desiredPath != nullptr)

	mov	rcx, QWORD PTR [rbx+2280]
	test	rcx, rcx
	je	SHORT $LN56@CUSBAsio

; 1680 :     {
; 1681 :         delete[] m_desiredPath;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 1682 :         m_desiredPath = nullptr;

	mov	QWORD PTR [rbx+2280], r15
$LN56@CUSBAsio:

; 1683 :     }
; 1684 : 
; 1685 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	lea	rax, QWORD PTR hKey$18[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 131097				; 00020019H
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@
	mov	rcx, -2147483647			; ffffffff80000001H
	call	QWORD PTR __imp_RegOpenKeyExA

; 1686 :     if (result != ERROR_SUCCESS)

	test	eax, eax
	jne	$LN55@CUSBAsio

; 1687 :     {
; 1688 :         return false;
; 1689 :     }
; 1690 : 
; 1691 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, nullptr, &size);

	lea	rax, QWORD PTR size$21[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], r15
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0L@ONBBLLLB@AsioDevice@
	mov	rcx, QWORD PTR hKey$18[rbp-256]
	call	QWORD PTR __imp_RegQueryValueExA

; 1692 :     if (result != ERROR_SUCCESS || size == 0)

	test	eax, eax
	jne	SHORT $LN59@CUSBAsio
	mov	eax, DWORD PTR size$21[rbp-256]
	test	eax, eax
	je	SHORT $LN59@CUSBAsio

; 1695 :         return false;
; 1696 :     }
; 1697 : 
; 1698 :     m_desiredPath = new TCHAR[size / sizeof(TCHAR)];

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR [rbx+2280], rax

; 1699 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, (LPBYTE)m_desiredPath, &size);

	lea	rcx, QWORD PTR size$21[rbp-256]
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_0L@ONBBLLLB@AsioDevice@
	mov	rcx, QWORD PTR hKey$18[rbp-256]
	call	QWORD PTR __imp_RegQueryValueExA

; 1700 :     if (result != ERROR_SUCCESS)

	mov	rcx, QWORD PTR hKey$18[rbp-256]
	test	eax, eax
	je	SHORT $LN60@CUSBAsio

; 1701 :     {
; 1702 :         RegCloseKey(hKey);

	call	QWORD PTR __imp_RegCloseKey

; 1703 :         delete[] m_desiredPath;

	mov	rcx, QWORD PTR [rbx+2280]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 1704 :         m_desiredPath = nullptr;

	mov	QWORD PTR [rbx+2280], r15

; 1705 :         return false;

	jmp	SHORT $LN55@CUSBAsio
$LN59@CUSBAsio:

; 1693 :     {
; 1694 :         RegCloseKey(hKey);

	mov	rcx, QWORD PTR hKey$18[rbp-256]
$LN60@CUSBAsio:

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	call	QWORD PTR __imp_RegCloseKey
$LN55@CUSBAsio:
	mov	rdi, QWORD PTR [rbx+2280]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 157  :     HANDLE targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, desiredPath);

	mov	r9, rdi
	call	?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z ; OpenUsbDeviceCore

; 158  : 
; 159  :     if ((targetHandle == INVALID_HANDLE_VALUE) && (desiredPath != nullptr))

	cmp	rax, -1
	jne	SHORT $LN63@CUSBAsio
	test	rdi, rdi
	je	SHORT $LN63@CUSBAsio

; 160  :     {
; 161  :         // force open
; 162  :         targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, nullptr);

	xor	r9d, r9d
	call	?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z ; OpenUsbDeviceCore
$LN63@CUSBAsio:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	mov	QWORD PTR [rbx+2984], rax

; 200  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE)

	cmp	rax, -1
	jne	SHORT $LN13@CUSBAsio
	xorps	xmm0, xmm0

; 201  :     {
; 202  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	movups	XMMWORD PTR messageString$24[rbp-256], xmm0
	movups	XMMWORD PTR messageString$24[rbp-240], xmm0
	movups	XMMWORD PTR messageString$24[rbp-224], xmm0
	movups	XMMWORD PTR messageString$24[rbp-208], xmm0
	movups	XMMWORD PTR messageString$24[rbp-192], xmm0
	movups	XMMWORD PTR messageString$24[rbp-176], xmm0
	movups	XMMWORD PTR messageString$24[rbp-160], xmm0
	movups	XMMWORD PTR messageString$24[rbp-144], xmm0

; 203  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rcx, rax
	mov	r9d, 128				; 00000080H
	lea	r8, QWORD PTR messageString$24[rbp-256]
	mov	edx, 102				; 00000066H
	call	QWORD PTR __imp_LoadStringA

; 204  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	lea	r8, QWORD PTR messageString$24[rbp-256]
	mov	edx, 128				; 00000080H
	mov	rcx, r14
	call	strcpy_s

; 205  :         return;

	jmp	$LN205@CUSBAsio
$LN13@CUSBAsio:

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	mov	edi, r15d
$LL4@CUSBAsio:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 371  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$19[rbp-256], r15d

; 372  : 
; 373  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$22[rbp-256], xmm0

; 374  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$22[rbp-236], 2

; 375  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAsioOwnership);

	mov	DWORD PTR privateProperty$22[rbp-240], 8

; 376  : 
; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r15
	lea	rax, QWORD PTR bytesReturned$19[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], r15d
	mov	QWORD PTR [rsp+32], r15
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$22[rbp-256]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 212  :         if (isSuccess)

	test	eax, eax
	jne	$LN16@CUSBAsio

; 213  :         {
; 214  :             break;
; 215  :         }
; 216  :         if (retry < maxRetry - 1)

	cmp	edi, 5
	jae	SHORT $LN2@CUSBAsio

; 217  :         {
; 218  :             Sleep(500);

	mov	ecx, 500				; 000001f4H
	call	QWORD PTR __imp_Sleep
$LN2@CUSBAsio:

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	inc	edi
	cmp	edi, 6
	jb	$LL4@CUSBAsio
	xorps	xmm0, xmm0

; 219  :         }
; 220  :     }
; 221  : 
; 222  :     if (!isSuccess)
; 223  :     {
; 224  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	movups	XMMWORD PTR messageString$25[rbp-256], xmm0
	movups	XMMWORD PTR messageString$25[rbp-240], xmm0
	movups	XMMWORD PTR messageString$25[rbp-224], xmm0
	movups	XMMWORD PTR messageString$25[rbp-208], xmm0
	movups	XMMWORD PTR messageString$25[rbp-192], xmm0
	movups	XMMWORD PTR messageString$25[rbp-176], xmm0
	movups	XMMWORD PTR messageString$25[rbp-160], xmm0
	movups	XMMWORD PTR messageString$25[rbp-144], xmm0

; 225  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rcx, rax
	mov	r9d, 128				; 00000080H
	lea	r8, QWORD PTR messageString$25[rbp-256]
	mov	edx, 102				; 00000066H
	call	QWORD PTR __imp_LoadStringA

; 226  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	lea	r8, QWORD PTR messageString$25[rbp-256]
	mov	edx, 128				; 00000080H
	mov	rcx, r14
	call	strcpy_s

; 227  :         CloseHandle(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_CloseHandle

; 228  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov	QWORD PTR [rbx+2984], rsi
$LN16@CUSBAsio:

; 229  :     }
; 230  : 
; 231  :     ApplySettings();

	mov	rcx, rbx
	call	?ApplySettings@CUSBAsio@@AEAA_NXZ	; CUSBAsio::ApplySettings

; 232  : 
; 233  :     m_callbacks = 0;

	mov	QWORD PTR [rbx+48], r15

; 234  : 
; 235  :     isSuccess = ObtainDeviceParameter();

	mov	rcx, rbx
	call	?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ ; CUSBAsio::ObtainDeviceParameter

; 236  :     if (!isSuccess)

	test	al, al
	je	$LN205@CUSBAsio

; 237  :     {
; 238  :         return;
; 239  :     }
; 240  : 
; 241  :     switch (m_audioProperty.CurrentSampleFormat)

	mov	ecx, DWORD PTR [rbx+3288]
	test	ecx, ecx
	je	SHORT $LN18@CUSBAsio
	sub	ecx, 4
	je	SHORT $LN5@CUSBAsio
	cmp	ecx, 1
	jne	SHORT $LN5@CUSBAsio
$LN18@CUSBAsio:

; 242  :     {
; 243  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM:
; 244  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT:
; 245  :         m_requestedSampleFormat = kASIOPCMFormat;

	mov	esi, r15d
$LN5@CUSBAsio:

; 246  :         break;
; 247  :     default:
; 248  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM8:
; 249  :         m_requestedSampleFormat = kASIOFormatInvalid;
; 250  :         break;
; 251  :     }
; 252  : 
; 253  :     GetClockInfo(m_usbDeviceHandle, &m_clockInfo);

	mov	DWORD PTR [rbx+3464], esi
	lea	rdi, QWORD PTR [rbx+3488]
	mov	rsi, QWORD PTR [rbx+2984]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 242  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$20[rbp-256], r15d

; 243  : 
; 244  :     if (clockInfo == nullptr)

	test	rdi, rdi
	je	$LN37@CUSBAsio

; 245  :     {
; 246  :         return result;
; 247  :     }
; 248  : 
; 249  :     *clockInfo = {};

	mov	QWORD PTR [rdi], r15

; 250  : 
; 251  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$23[rbp-256], xmm0

; 252  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;

	mov	DWORD PTR privateProperty$23[rbp-236], 1

; 253  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetClockInfo);

	mov	DWORD PTR privateProperty$23[rbp-240], 2

; 254  : 
; 255  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r15
	lea	rax, QWORD PTR bytesReturned$20[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], r15d
	mov	QWORD PTR [rsp+32], r15
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$23[rbp-256]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, rsi
	call	QWORD PTR __imp_DeviceIoControl

; 256  : 
; 257  :     if (!result)

	test	eax, eax
	jne	SHORT $LN37@CUSBAsio

; 258  :     {
; 259  :         DWORD error = GetLastError();

	call	QWORD PTR __imp_GetLastError

; 260  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CLOCK_INFO_CONTEXT)))

	cmp	eax, 234				; 000000eaH
	jne	SHORT $LN37@CUSBAsio
	mov	eax, DWORD PTR bytesReturned$20[rbp-256]
	cmp	eax, 88					; 00000058H
	jb	SHORT $LN37@CUSBAsio

; 261  :         {
; 262  :             *clockInfo = (PUAC_GET_CLOCK_INFO_CONTEXT)(new BYTE[bytesReturned]);

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR [rdi], rax

; 263  :             if (clockInfo != nullptr)
; 264  :             {
; 265  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *clockInfo, bytesReturned, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r15
	lea	rcx, QWORD PTR bytesReturned$20[rbp-256]
	mov	QWORD PTR [rsp+48], rcx
	mov	r8d, DWORD PTR bytesReturned$20[rbp-256]
	mov	DWORD PTR [rsp+40], r8d
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$23[rbp-256]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, rsi
	call	QWORD PTR __imp_DeviceIoControl

; 266  :                 if (!result)

	test	eax, eax
	jne	SHORT $LN37@CUSBAsio

; 267  :                 {
; 268  :                     delete[] (BYTE *)(*clockInfo);

	mov	rcx, QWORD PTR [rdi]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 269  :                     *clockInfo = nullptr;

	mov	QWORD PTR [rdi], r15
$LN37@CUSBAsio:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 255  :     m_stopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3672], rax

; 256  : 
; 257  :     m_asioResetEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3696], rax

; 258  :     m_terminateAsioResetEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3704], rax

; 259  : 
; 260  :     m_outputReadyBlockEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3720], rax

; 261  : 
; 262  :     auto beginThreadResult = _beginthreadex(nullptr, 0, AsioResetThread, this, 0, nullptr);

	mov	QWORD PTR [rsp+40], r15
	mov	DWORD PTR [rsp+32], r15d
	mov	r9, rbx
	lea	r8, OFFSET FLAT:?AsioResetThread@CUSBAsio@@CAIPEAX@Z ; CUSBAsio::AsioResetThread
	xor	edx, edx
	xor	ecx, ecx
	call	_beginthreadex

; 263  :     ;
; 264  :     if (beginThreadResult <= 0)

	test	rax, rax
	je	$LN205@CUSBAsio

; 265  :     {
; 266  :         return;
; 267  :     }
; 268  :     m_asioResetThread = (HANDLE)beginThreadResult;

	mov	QWORD PTR [rbx+3712], rax

; 269  :     SetThreadPriority(m_asioResetThread, THREAD_PRIORITY_ABOVE_NORMAL);

	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR __imp_SetThreadPriority

; 270  : 
; 271  :     m_samplePosition = 0;

	mov	QWORD PTR [rbx+32], r15

; 272  :     m_isActive = false;

	mov	DWORD PTR [rbx+2824], 0

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+216], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2288], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+224], r15
	mov	QWORD PTR [rbx+232], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2296], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+240], r15
	mov	QWORD PTR [rbx+248], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2304], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+256], r15
	mov	QWORD PTR [rbx+264], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2312], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+272], r15
	mov	QWORD PTR [rbx+280], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2320], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+288], r15
	mov	QWORD PTR [rbx+296], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2328], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+304], r15
	mov	QWORD PTR [rbx+312], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2336], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+320], r15
	mov	QWORD PTR [rbx+328], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2344], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+336], r15
	mov	QWORD PTR [rbx+344], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2352], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+352], r15
	mov	QWORD PTR [rbx+360], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2360], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+368], r15
	mov	QWORD PTR [rbx+376], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2368], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+384], r15
	mov	QWORD PTR [rbx+392], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2376], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+400], r15
	mov	QWORD PTR [rbx+408], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2384], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+416], r15
	mov	QWORD PTR [rbx+424], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2392], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+432], r15
	mov	QWORD PTR [rbx+440], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2400], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+448], r15
	mov	QWORD PTR [rbx+456], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2408], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+464], r15
	mov	QWORD PTR [rbx+472], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2416], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+480], r15
	mov	QWORD PTR [rbx+488], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2424], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+496], r15
	mov	QWORD PTR [rbx+504], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2432], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+512], r15
	mov	QWORD PTR [rbx+520], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2440], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+528], r15
	mov	QWORD PTR [rbx+536], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2448], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+544], r15
	mov	QWORD PTR [rbx+552], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2456], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+560], r15
	mov	QWORD PTR [rbx+568], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2464], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+576], r15
	mov	QWORD PTR [rbx+584], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2472], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+592], r15
	mov	QWORD PTR [rbx+600], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2480], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+608], r15
	mov	QWORD PTR [rbx+616], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2488], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+624], r15
	mov	QWORD PTR [rbx+632], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2496], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+640], r15
	mov	QWORD PTR [rbx+648], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2504], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+656], r15
	mov	QWORD PTR [rbx+664], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2512], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+672], r15
	mov	QWORD PTR [rbx+680], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2520], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+688], r15
	mov	QWORD PTR [rbx+696], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2528], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+704], r15
	mov	QWORD PTR [rbx+712], r15

; 279  :         m_inMap[i] = 0;

	mov	QWORD PTR [rbx+2536], r15

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	mov	QWORD PTR [rbx+720], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1240], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2544], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1248], r15
	mov	QWORD PTR [rbx+1256], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2552], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1264], r15
	mov	QWORD PTR [rbx+1272], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2560], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1280], r15
	mov	QWORD PTR [rbx+1288], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2568], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1296], r15
	mov	QWORD PTR [rbx+1304], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2576], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1312], r15
	mov	QWORD PTR [rbx+1320], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2584], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1328], r15
	mov	QWORD PTR [rbx+1336], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2592], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1344], r15
	mov	QWORD PTR [rbx+1352], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2600], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1360], r15
	mov	QWORD PTR [rbx+1368], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2608], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1376], r15
	mov	QWORD PTR [rbx+1384], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2616], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1392], r15
	mov	QWORD PTR [rbx+1400], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2624], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1408], r15
	mov	QWORD PTR [rbx+1416], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2632], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1424], r15
	mov	QWORD PTR [rbx+1432], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2640], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1440], r15
	mov	QWORD PTR [rbx+1448], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2648], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1456], r15
	mov	QWORD PTR [rbx+1464], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2656], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1472], r15
	mov	QWORD PTR [rbx+1480], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2664], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1488], r15
	mov	QWORD PTR [rbx+1496], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2672], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1504], r15
	mov	QWORD PTR [rbx+1512], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2680], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1520], r15
	mov	QWORD PTR [rbx+1528], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2688], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1536], r15
	mov	QWORD PTR [rbx+1544], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2696], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1552], r15
	mov	QWORD PTR [rbx+1560], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2704], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1568], r15
	mov	QWORD PTR [rbx+1576], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2712], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1584], r15
	mov	QWORD PTR [rbx+1592], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2720], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1600], r15
	mov	QWORD PTR [rbx+1608], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2728], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1616], r15
	mov	QWORD PTR [rbx+1624], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2736], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1632], r15
	mov	QWORD PTR [rbx+1640], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2744], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1648], r15
	mov	QWORD PTR [rbx+1656], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2752], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1664], r15
	mov	QWORD PTR [rbx+1672], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2760], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1680], r15
	mov	QWORD PTR [rbx+1688], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2768], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1696], r15
	mov	QWORD PTR [rbx+1704], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2776], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1712], r15
	mov	QWORD PTR [rbx+1720], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2784], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1728], r15
	mov	QWORD PTR [rbx+1736], r15

; 284  :         m_outMap[i] = 0;

	mov	QWORD PTR [rbx+2792], r15

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	mov	QWORD PTR [rbx+1744], r15

; 285  :     }
; 286  :     m_toggle = 0;

	mov	DWORD PTR [rbx+2820], r15d
$LN205@CUSBAsio:

; 287  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+672]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rbp
	ret	0
??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z ENDP		; CUSBAsio::CUSBAsio
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 64
$T17 = 72
hKey$18 = 480
bytesReturned$19 = 488
bytesReturned$20 = 488
size$21 = 488
privateProperty$22 = 496
privateProperty$23 = 496
messageString$24 = 528
messageString$25 = 528
__$ArrayPad$ = 656
this$ = 704
unknown$ = 712
result$dead$ = 720
?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 8
	jmp	??1CUnknown@@UEAA@XZ			; CUnknown::~CUnknown
?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA ENDP ; `CUSBAsio::CUSBAsio'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 64
$T17 = 72
hKey$18 = 480
bytesReturned$19 = 488
bytesReturned$20 = 488
size$21 = 488
privateProperty$22 = 496
privateProperty$23 = 496
messageString$24 = 528
messageString$25 = 528
__$ArrayPad$ = 656
this$ = 704
unknown$ = 712
result$dead$ = 720
?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 3496				; 00000da8H
	jmp	??1critical_section@wil@@QEAA@XZ	; wil::critical_section::~critical_section
?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA ENDP ; `CUSBAsio::CUSBAsio'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 64
$T17 = 72
hKey$18 = 480
bytesReturned$19 = 488
bytesReturned$20 = 488
size$21 = 488
privateProperty$22 = 496
privateProperty$23 = 496
messageString$24 = 528
messageString$25 = 528
__$ArrayPad$ = 656
this$ = 704
unknown$ = 712
result$dead$ = 720
?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 3536				; 00000dd0H
	jmp	??1critical_section@wil@@QEAA@XZ	; wil::critical_section::~critical_section
?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA ENDP ; `CUSBAsio::CUSBAsio'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 64
$T17 = 72
hKey$18 = 480
bytesReturned$19 = 488
bytesReturned$20 = 488
size$21 = 488
privateProperty$22 = 496
privateProperty$23 = 496
messageString$24 = 528
messageString$25 = 528
__$ArrayPad$ = 656
this$ = 704
unknown$ = 712
result$dead$ = 720
?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$3
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 3576				; 00000df8H
	jmp	??1critical_section@wil@@QEAA@XZ	; wil::critical_section::~critical_section
?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA ENDP ; `CUSBAsio::CUSBAsio'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
;	COMDAT ??_GCUSBAsio@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCUSBAsio@@UEAAPEAXI@Z PROC				; CUSBAsio::`scalar deleting destructor', COMDAT
$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 290  : {

	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BIASIO@@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BCUnknown@@@
	mov	QWORD PTR [rcx+8], rax

; 291  :     DWORD result = 0;
; 292  : 
; 293  :     disposeBuffers();

	call	?disposeBuffers@CUSBAsio@@UEAAJXZ	; CUSBAsio::disposeBuffers

; 294  : 
; 295  :     if (m_channelInfo != nullptr)

	mov	rcx, QWORD PTR [rbx+3480]
	test	rcx, rcx
	je	SHORT $LN6@scalar

; 296  :     {
; 297  :         delete[] ((UCHAR *)m_channelInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN6@scalar:

; 298  :     }
; 299  :     if (m_clockInfo != nullptr)

	mov	rcx, QWORD PTR [rbx+3488]
	test	rcx, rcx
	je	SHORT $LN7@scalar

; 300  :     {
; 301  :         delete[] ((UCHAR *)m_clockInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN7@scalar:

; 302  :     }
; 303  :     if (m_desiredPath != nullptr)

	mov	rcx, QWORD PTR [rbx+2280]
	test	rcx, rcx
	je	SHORT $LN8@scalar

; 304  :     {
; 305  :         delete[] m_desiredPath;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN8@scalar:

; 306  :     }
; 307  :     if (m_usbDeviceHandle != INVALID_HANDLE_VALUE)

	mov	rcx, QWORD PTR [rbx+2984]
	cmp	rcx, -1
	je	SHORT $LN9@scalar

; 308  :     {
; 309  :         ReleaseAsioOwnership(m_usbDeviceHandle);

	call	?ReleaseAsioOwnership@@YAHPEAX@Z	; ReleaseAsioOwnership

; 310  :         CloseHandle(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_CloseHandle

; 311  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov	QWORD PTR [rbx+2984], -1
$LN9@scalar:

; 312  :     }
; 313  :     if (m_terminateAsioResetEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3704]
	test	rcx, rcx
	je	SHORT $LN10@scalar

; 314  :     {
; 315  :         if (m_asioResetThread != nullptr)

	cmp	QWORD PTR [rbx+3712], 0
	je	SHORT $LN12@scalar

; 316  :         {
; 317  :             DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 318  :             SetEvent(m_terminateAsioResetEvent);

	call	QWORD PTR __imp_SetEvent

; 319  :             result = WaitForSingleObject(m_asioResetThread, timeout);

	mov	edx, 6000				; 00001770H
	mov	rcx, QWORD PTR [rbx+3712]
	call	QWORD PTR __imp_WaitForSingleObject

; 320  :             if (result == WAIT_OBJECT_0)

	test	eax, eax
	jne	SHORT $LN12@scalar

; 321  :             {
; 322  :                 CloseHandle(m_asioResetThread);

	mov	rcx, QWORD PTR [rbx+3712]
	call	QWORD PTR __imp_CloseHandle
$LN12@scalar:

; 323  :             }
; 324  :         }
; 325  :         CloseHandle(m_terminateAsioResetEvent);

	mov	rcx, QWORD PTR [rbx+3704]
	call	QWORD PTR __imp_CloseHandle
$LN10@scalar:

; 326  :     }
; 327  :     if (m_asioResetEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3696]
	test	rcx, rcx
	je	SHORT $LN13@scalar

; 328  :     {
; 329  :         CloseHandle(m_asioResetEvent);

	call	QWORD PTR __imp_CloseHandle
$LN13@scalar:

; 330  :     }
; 331  :     if (m_stopEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3672]
	test	rcx, rcx
	je	SHORT $LN14@scalar

; 332  :     {
; 333  :         CloseHandle(m_stopEvent);

	call	QWORD PTR __imp_CloseHandle
$LN14@scalar:

; 334  :     }
; 335  :     if (m_outputReadyBlockEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3720]
	test	rcx, rcx
	je	SHORT $LN15@scalar

; 336  :     {
; 337  :         CloseHandle(m_outputReadyBlockEvent);

	call	QWORD PTR __imp_CloseHandle
$LN15@scalar:

; 338  :     }
; 339  : 
; 340  :     InterlockedDecrement(&g_Instance);

	lock dec DWORD PTR ?g_Instance@@3JA
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3381 :         ::DeleteCriticalSection(&m_cs);

	lea	rcx, QWORD PTR [rbx+3576]
	call	QWORD PTR __imp_DeleteCriticalSection
	lea	rcx, QWORD PTR [rbx+3536]
	call	QWORD PTR __imp_DeleteCriticalSection
	lea	rcx, QWORD PTR [rbx+3496]
	call	QWORD PTR __imp_DeleteCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h

; 192  :     virtual ~CUnknown() {};

	lea	rax, OFFSET FLAT:??_7CUnknown@@6B@
	mov	QWORD PTR [rbx+8], rax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 43   :     InterlockedDecrement(&m_cObjects);

	lock dec DWORD PTR ?m_cObjects@CBaseObject@@0JA	; CBaseObject::m_cObjects
	test	dil, 1
	je	SHORT $LN37@scalar
	mov	edx, 3736				; 00000e98H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN37@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCUSBAsio@@UEAAPEAXI@Z ENDP				; CUSBAsio::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0IASIO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0IASIO@@QEAA@XZ PROC					; IASIO::IASIO, COMDAT
	lea	rax, OFFSET FLAT:??_7IASIO@@6B@
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0IASIO@@QEAA@XZ ENDP					; IASIO::IASIO
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ??1CUSBAsio@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CUSBAsio@@UEAA@XZ PROC				; CUSBAsio::~CUSBAsio, COMDAT

; 290  : {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BIASIO@@@
	mov	QWORD PTR [rcx], rax
	lea	rax, OFFSET FLAT:??_7CUSBAsio@@6BCUnknown@@@
	mov	QWORD PTR [rcx+8], rax

; 291  :     DWORD result = 0;
; 292  : 
; 293  :     disposeBuffers();

	call	?disposeBuffers@CUSBAsio@@UEAAJXZ	; CUSBAsio::disposeBuffers

; 294  : 
; 295  :     if (m_channelInfo != nullptr)

	mov	rcx, QWORD PTR [rbx+3480]
	test	rcx, rcx
	je	SHORT $LN2@CUSBAsio

; 296  :     {
; 297  :         delete[] ((UCHAR *)m_channelInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@CUSBAsio:

; 298  :     }
; 299  :     if (m_clockInfo != nullptr)

	mov	rcx, QWORD PTR [rbx+3488]
	test	rcx, rcx
	je	SHORT $LN3@CUSBAsio

; 300  :     {
; 301  :         delete[] ((UCHAR *)m_clockInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@CUSBAsio:

; 302  :     }
; 303  :     if (m_desiredPath != nullptr)

	mov	rcx, QWORD PTR [rbx+2280]
	test	rcx, rcx
	je	SHORT $LN4@CUSBAsio

; 304  :     {
; 305  :         delete[] m_desiredPath;

	call	??_V@YAXPEAX@Z				; operator delete[]
$LN4@CUSBAsio:

; 306  :     }
; 307  :     if (m_usbDeviceHandle != INVALID_HANDLE_VALUE)

	mov	rcx, QWORD PTR [rbx+2984]
	cmp	rcx, -1
	je	SHORT $LN5@CUSBAsio

; 308  :     {
; 309  :         ReleaseAsioOwnership(m_usbDeviceHandle);

	call	?ReleaseAsioOwnership@@YAHPEAX@Z	; ReleaseAsioOwnership

; 310  :         CloseHandle(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_CloseHandle

; 311  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov	QWORD PTR [rbx+2984], -1
$LN5@CUSBAsio:

; 312  :     }
; 313  :     if (m_terminateAsioResetEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3704]
	test	rcx, rcx
	je	SHORT $LN6@CUSBAsio

; 314  :     {
; 315  :         if (m_asioResetThread != nullptr)

	cmp	QWORD PTR [rbx+3712], 0
	je	SHORT $LN8@CUSBAsio

; 316  :         {
; 317  :             DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 318  :             SetEvent(m_terminateAsioResetEvent);

	call	QWORD PTR __imp_SetEvent

; 319  :             result = WaitForSingleObject(m_asioResetThread, timeout);

	mov	edx, 6000				; 00001770H
	mov	rcx, QWORD PTR [rbx+3712]
	call	QWORD PTR __imp_WaitForSingleObject

; 320  :             if (result == WAIT_OBJECT_0)

	test	eax, eax
	jne	SHORT $LN8@CUSBAsio

; 321  :             {
; 322  :                 CloseHandle(m_asioResetThread);

	mov	rcx, QWORD PTR [rbx+3712]
	call	QWORD PTR __imp_CloseHandle
$LN8@CUSBAsio:

; 323  :             }
; 324  :         }
; 325  :         CloseHandle(m_terminateAsioResetEvent);

	mov	rcx, QWORD PTR [rbx+3704]
	call	QWORD PTR __imp_CloseHandle
$LN6@CUSBAsio:

; 326  :     }
; 327  :     if (m_asioResetEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3696]
	test	rcx, rcx
	je	SHORT $LN9@CUSBAsio

; 328  :     {
; 329  :         CloseHandle(m_asioResetEvent);

	call	QWORD PTR __imp_CloseHandle
$LN9@CUSBAsio:

; 330  :     }
; 331  :     if (m_stopEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3672]
	test	rcx, rcx
	je	SHORT $LN10@CUSBAsio

; 332  :     {
; 333  :         CloseHandle(m_stopEvent);

	call	QWORD PTR __imp_CloseHandle
$LN10@CUSBAsio:

; 334  :     }
; 335  :     if (m_outputReadyBlockEvent != nullptr)

	mov	rcx, QWORD PTR [rbx+3720]
	test	rcx, rcx
	je	SHORT $LN11@CUSBAsio

; 336  :     {
; 337  :         CloseHandle(m_outputReadyBlockEvent);

	call	QWORD PTR __imp_CloseHandle
$LN11@CUSBAsio:

; 338  :     }
; 339  : 
; 340  :     InterlockedDecrement(&g_Instance);

	lock dec DWORD PTR ?g_Instance@@3JA
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3381 :         ::DeleteCriticalSection(&m_cs);

	lea	rcx, QWORD PTR [rbx+3576]
	call	QWORD PTR __imp_DeleteCriticalSection
	lea	rcx, QWORD PTR [rbx+3536]
	call	QWORD PTR __imp_DeleteCriticalSection
	lea	rcx, QWORD PTR [rbx+3496]
	call	QWORD PTR __imp_DeleteCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h

; 192  :     virtual ~CUnknown() {};

	lea	rax, OFFSET FLAT:??_7CUnknown@@6B@
	mov	QWORD PTR [rbx+8], rax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 43   :     InterlockedDecrement(&m_cObjects);

	lock dec DWORD PTR ?m_cObjects@CBaseObject@@0JA	; CBaseObject::m_cObjects
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 343  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CUSBAsio@@UEAA@XZ ENDP				; CUSBAsio::~CUSBAsio
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getDriverName@CUSBAsio@@UEAAXPEAD@Z
_TEXT	SEGMENT
this$ = 8
name$ = 16
?getDriverName@CUSBAsio@@UEAAXPEAD@Z PROC		; CUSBAsio::getDriverName, COMDAT

; 347  : {

	mov	rcx, rdx

; 348  :     strcpy_s(name, DRIVER_NAME_LENGTH, DRIVER_NAME_8b);

	lea	r8, OFFSET FLAT:??_C@_08JKCDEOBL@USB?5ASIO@
	mov	edx, 31
	jmp	strcpy_s
?getDriverName@CUSBAsio@@UEAAXPEAD@Z ENDP		; CUSBAsio::getDriverName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getDriverVersion@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
this$ = 8
?getDriverVersion@CUSBAsio@@UEAAJXZ PROC		; CUSBAsio::getDriverVersion, COMDAT

; 353  :     info_print_("getDriverVersion\n");
; 354  :     return 0x00010000L;

	mov	eax, 65536				; 00010000H

; 355  : }

	ret	0
?getDriverVersion@CUSBAsio@@UEAAJXZ ENDP		; CUSBAsio::getDriverVersion
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z
_TEXT	SEGMENT
this$ = 8
errorMessage$ = 16
?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z PROC		; CUSBAsio::getErrorMessage, COMDAT

; 359  : {

	mov	rax, rdx

; 360  :     info_print_("getErrorMessage\n");
; 361  :     // >>comment-001<<
; 362  :     size_t size = _tcslen(m_errorMessage) + 1;
; 363  :     size = min(size, ERROR_MESSAGE_LENGTH);
; 364  : 
; 365  : #ifdef _UNICODE
; 366  :     // TCHAR is wchar_t  convert wide char to multibyte
; 367  :     WideCharToMultiByte(CP_ACP, 0, m_errorMessage, -1, errorMessage, ERROR_MESSAGE_LENGTH, NULL, NULL);
; 368  : #else
; 369  :     // TCHAR is char  direct copy
; 370  :     strcpy_s(errorMessage, ERROR_MESSAGE_LENGTH, m_errorMessage);

	lea	r8, QWORD PTR [rcx+2828]
	mov	rcx, rax
	mov	edx, 128				; 00000080H
	jmp	strcpy_s
?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z ENDP		; CUSBAsio::getErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?init@CUSBAsio@@UEAAJPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?init@CUSBAsio@@UEAAJPEAX@Z PROC			; CUSBAsio::init, COMDAT

; 377  :     info_print_("init\n");
; 378  :     // Due to a change in the error handling policy, it has been changed to return an error if an error occurs in CUSBAsio::CUSBAsio ().
; 379  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	SHORT $LN3@init
	cmp	DWORD PTR [rcx+2804], 0
	je	SHORT $LN3@init
	xor	eax, eax
	cmp	DWORD PTR [rcx+2808], eax
	setne	al

; 383  :     }
; 384  :     return ASIOTrue;
; 385  : }

	ret	0
$LN3@init:

; 380  :     {
; 381  :         // Error in CUSBAsio::CUSBAsio ()
; 382  :         return ASIOFalse;

	xor	eax, eax

; 383  :     }
; 384  :     return ASIOTrue;
; 385  : }

	ret	0
?init@CUSBAsio@@UEAAJPEAX@Z ENDP			; CUSBAsio::init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?start@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
this$ = 64
?start@CUSBAsio@@UEAAJXZ PROC				; CUSBAsio::start, COMDAT

; 388  : {

$LN19:
	push	rbx
	sub	rsp, 48					; 00000030H

; 389  :     info_print_("start\n");
; 390  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	mov	rbx, rcx
	je	$LN3@start
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN3@start
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN3@start

; 393  :     }
; 394  : 
; 395  :     if (!m_isActive)

	cmp	BYTE PTR [rcx+2824], 0
	je	$LN3@start

; 396  :     {
; 397  :         return ASE_NotPresent;
; 398  :     }
; 399  : 
; 400  :     if (m_callbacks)

	cmp	QWORD PTR [rcx+48], 0
	je	$LN3@start

; 401  :     {
; 402  :         m_samplePosition = 0;
; 403  :         m_theSystemTime.lo = m_theSystemTime.hi = 0;
; 404  :         m_toggle = 0;
; 405  : 
; 406  :         m_initialSystemTime = 0;
; 407  :         m_calculatedSystemTime = 0;
; 408  :         m_initialKernelTime = 0;
; 409  : 
; 410  :         m_isStarted = true;

	mov	BYTE PTR [rcx+2825], 1
	mov	QWORD PTR [rsp+64], rdi
	xor	edi, edi
	mov	QWORD PTR [rcx+32], rdi
	mov	QWORD PTR [rcx+204], rdi
	mov	DWORD PTR [rcx+2820], edi
	mov	QWORD PTR [rcx+2264], rdi
	mov	QWORD PTR [rcx+2272], rdi

; 1971 :     ResetEvent(m_stopEvent);

	mov	rcx, QWORD PTR [rcx+3672]
	call	QWORD PTR __imp_ResetEvent

; 1972 :     auto beginThreadResult = _beginthreadex(nullptr, 0, WorkerThread, this, 0, nullptr);

	mov	r9, rbx
	mov	QWORD PTR [rsp+40], rdi
	lea	r8, OFFSET FLAT:?WorkerThread@CUSBAsio@@CAIPEAX@Z ; CUSBAsio::WorkerThread
	mov	DWORD PTR [rsp+32], edi
	xor	edx, edx
	xor	ecx, ecx
	call	_beginthreadex

; 1973 :     m_workerThread = (HANDLE)beginThreadResult;

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+3680], rax

; 1974 :     if ((beginThreadResult > 0) && (m_threadPriority == -2))

	test	rax, rax
	je	SHORT $LN8@start
	cmp	DWORD PTR [rbx+3688], -2
	jne	SHORT $LN8@start

; 1975 :     {
; 1976 :         SetThreadPriority(m_workerThread, THREAD_PRIORITY_TIME_CRITICAL);

	mov	edx, 15
	mov	rcx, rax
	call	QWORD PTR __imp_SetThreadPriority
$LN8@start:

; 411  : 
; 412  :         ThreadStart(); // activate 'hardware'
; 413  : 
; 414  :         return ASE_OK;

	xor	eax, eax

; 415  :     }
; 416  :     return ASE_NotPresent;
; 417  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN3@start:

; 391  :     {
; 392  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 415  :     }
; 416  :     return ASE_NotPresent;
; 417  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?start@CUSBAsio@@UEAAJXZ ENDP				; CUSBAsio::start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?stop@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
this$ = 48
?stop@CUSBAsio@@UEAAJXZ PROC				; CUSBAsio::stop, COMDAT

; 420  : {

$LN22:
	push	rbx
	sub	rsp, 32					; 00000020H

; 421  :     info_print_("stop\n");
; 422  : 
; 423  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	mov	rbx, rcx
	je	$LN3@stop
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN3@stop
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN3@stop

; 426  :     }
; 427  : 
; 428  :     if (!m_isStarted)

	cmp	BYTE PTR [rcx+2825], 0
	je	SHORT $LN20@stop

; 429  :     {
; 430  :         return ASE_OK;
; 431  :     }
; 432  :     m_isStarted = false;

	mov	BYTE PTR [rcx+2825], 0

; 1984 :     SetEvent(m_stopEvent);

	mov	rcx, QWORD PTR [rcx+3672]
	call	QWORD PTR __imp_SetEvent

; 1985 :     if (m_workerThread != nullptr)

	mov	rcx, QWORD PTR [rbx+3680]
	test	rcx, rcx
	je	SHORT $LN10@stop

; 1986 :     {
; 1987 :         DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 1988 :         status = WaitForSingleObject(m_workerThread, timeout);

	mov	edx, 6000				; 00001770H
	call	QWORD PTR __imp_WaitForSingleObject

; 1989 :         if (status == WAIT_OBJECT_0)

	test	eax, eax
	jne	SHORT $LN8@stop

; 1990 :         {
; 1991 :             CloseHandle(m_workerThread);

	mov	rcx, QWORD PTR [rbx+3680]
	call	QWORD PTR __imp_CloseHandle

; 1992 :         }

	jmp	SHORT $LN10@stop
$LN8@stop:

; 1993 :         else if (status == WAIT_TIMEOUT)

	cmp	eax, 258				; 00000102H
	jne	SHORT $LN10@stop

; 1994 :         {
; 1995 :             error_print_("wait timouut. force terminating worker thread.");
; 1996 :             // Understanding that there is an issue, preventing proper cleanup, call TerminateThread.
; 1997 :             // TerminateThread(m_workerThread, 0);
; 1998 : 
; 1999 :             // Implemented without using TerminateThread.
; 2000 :             // If the thread does not exit within the timeout, it will be forcibly terminated by the OS when the application exits.
; 2001 : 
; 2002 :             CloseHandle(m_workerThread);

	mov	rcx, QWORD PTR [rbx+3680]
	call	QWORD PTR __imp_CloseHandle

; 2003 :             InterlockedDecrement(&g_WorkerThread);

	lock dec DWORD PTR ?g_WorkerThread@@3JA
$LN10@stop:

; 433  :     ThreadStop(); // de-activate 'hardware'
; 434  :     StopAsioStream(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]

; 2010 :     m_workerThread = nullptr;

	mov	QWORD PTR [rbx+3680], 0

; 433  :     ThreadStop(); // de-activate 'hardware'
; 434  :     StopAsioStream(m_usbDeviceHandle);

	call	?StopAsioStream@@YAHPEAX@Z		; StopAsioStream
$LN20@stop:

; 435  : 
; 436  :     return ASE_OK;
; 437  : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@stop:

; 424  :     {
; 425  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 435  : 
; 436  :     return ASE_OK;
; 437  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?stop@CUSBAsio@@UEAAJXZ ENDP				; CUSBAsio::stop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getChannels@CUSBAsio@@UEAAJPEAJ0@Z
_TEXT	SEGMENT
this$ = 64
numInputChannels$ = 72
numOutputChannels$ = 80
?getChannels@CUSBAsio@@UEAAJPEAJ0@Z PROC		; CUSBAsio::getChannels, COMDAT

; 441  : {

$LN51:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 442  :     info_print_("getChannels\n");
; 443  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	je	SHORT $LN3@getChannel
	cmp	DWORD PTR [rcx+2804], 0
	je	SHORT $LN3@getChannel
	cmp	DWORD PTR [rcx+2808], 0
	je	SHORT $LN3@getChannel

; 449  :     }
; 450  :     if (numInputChannels == nullptr || numOutputChannels == nullptr)

	test	rdx, rdx
	je	SHORT $LN5@getChannel
	test	r8, r8
	je	SHORT $LN5@getChannel
	mov	QWORD PTR [rsp+88], rbp

; 453  :     }
; 454  :     {
; 455  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rbp, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbp
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 456  :         *numInputChannels = m_inAvailableChannels;

	mov	eax, DWORD PTR [rbx+3468]
	mov	DWORD PTR [rdi], eax

; 457  :         *numOutputChannels = m_outAvailableChannels;

	mov	eax, DWORD PTR [rbx+3472]
	mov	DWORD PTR [rsi], eax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbp, rbp
	je	SHORT $LN41@getChannel

; 154  :             close_fn(value);

	mov	rcx, rbp
	call	QWORD PTR __imp_LeaveCriticalSection
$LN41@getChannel:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 460  :     return ASE_OK;

	mov	rbp, QWORD PTR [rsp+88]
	xor	eax, eax

; 461  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@getChannel:

; 451  :     {
; 452  :         return ASE_InvalidParameter;

	mov	eax, -998				; fffffffffffffc1aH

; 461  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN3@getChannel:

; 444  :     {
; 445  :         *numInputChannels = 0;

	xor	eax, eax
	mov	DWORD PTR [rdx], eax

; 446  :         *numOutputChannels = 0;

	mov	DWORD PTR [r8], eax

; 447  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 448  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 461  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?getChannels@CUSBAsio@@UEAAJPEAJ0@Z ENDP		; CUSBAsio::getChannels
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z ENDP ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z
_TEXT	SEGMENT
bytesReturned$2 = 64
privateProperty$3 = 72
__$ArrayPad$ = 96
this$ = 144
inputLatency$ = 152
outputLatency$ = 160
?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z PROC		; CUSBAsio::getLatencies, COMDAT

; 465  : {

$LN14:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rdx
	mov	rbx, rcx

; 466  :     info_print_("getLatencies\n");
; 467  : 
; 468  :     *inputLatency = 0;

	xor	edx, edx
	mov	rsi, r8
	mov	DWORD PTR [rdi], edx

; 469  :     *outputLatency = 0;

	mov	DWORD PTR [r8], edx

; 470  : 
; 471  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	mov	rcx, QWORD PTR [rcx+2984]
	cmp	rcx, -1
	je	$LN3@getLatenci
	cmp	DWORD PTR [rbx+2804], edx
	je	SHORT $LN3@getLatenci
	cmp	DWORD PTR [rbx+2808], edx
	je	SHORT $LN3@getLatenci
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 177  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 178  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);
; 180  : 
; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 481  :     if (GetAudioProperty(m_usbDeviceHandle, &m_audioProperty))

	lea	rax, QWORD PTR [rbx+2992]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 175  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$2[rsp], edx

; 178  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);
; 180  : 
; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	lea	r8, QWORD PTR privateProperty$3[rsp]
	mov	DWORD PTR privateProperty$3[rsp+16], edx
	mov	r9d, 24
	lea	rdx, QWORD PTR bytesReturned$2[rsp]
	mov	DWORD PTR privateProperty$3[rsp+20], 1
	mov	QWORD PTR [rsp+48], rdx
	mov	edx, 3080195				; 002f0003H
	mov	DWORD PTR [rsp+40], 408			; 00000198H
	mov	QWORD PTR [rsp+32], rax
	movups	XMMWORD PTR privateProperty$3[rsp], xmm0
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 486  :     *inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	mov	eax, DWORD PTR [rbx+3308]
	add	eax, DWORD PTR [rbx+2800]
	mov	DWORD PTR [rdi], eax

; 487  :     *outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;

	mov	eax, DWORD PTR [rbx+3364]
	add	eax, DWORD PTR [rbx+2800]
	mov	DWORD PTR [rsi], eax

; 488  : 
; 489  :     // >>comment-002<<
; 490  :     return ASE_OK;

	xor	eax, eax
	jmp	SHORT $LN1@getLatenci
$LN3@getLatenci:

; 472  :     {
; 473  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 474  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H
$LN1@getLatenci:

; 491  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z ENDP		; CUSBAsio::getLatencies
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z
_TEXT	SEGMENT
this$ = 8
minSize$ = 16
maxSize$ = 24
preferredSize$ = 32
granularity$ = 40
?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z PROC		; CUSBAsio::getBufferSize, COMDAT

; 496  :     info_print_("getBufferSize\n");
; 497  : 
; 498  :     *minSize = 0;
; 499  :     *maxSize = 0;
; 500  :     *preferredSize = 0;
; 501  :     *granularity = 0;

	mov	r10, QWORD PTR granularity$[rsp]
	xor	r11d, r11d
	mov	DWORD PTR [rdx], r11d
	mov	DWORD PTR [r8], r11d
	mov	DWORD PTR [r9], r11d
	mov	DWORD PTR [r10], r11d

; 502  : 
; 503  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	SHORT $LN3@getBufferS
	cmp	DWORD PTR [rcx+2804], r11d
	je	SHORT $LN3@getBufferS
	cmp	DWORD PTR [rcx+2808], r11d
	je	SHORT $LN3@getBufferS

; 507  :     }
; 508  :     if (minSize == nullptr || maxSize == nullptr || preferredSize == nullptr || granularity == nullptr)
; 509  :     {
; 510  :         return ASE_InvalidParameter;
; 511  :     }
; 512  :     *minSize = *maxSize = *preferredSize = m_blockFrames; // allow this size only

	mov	eax, DWORD PTR [rcx+2800]
	mov	DWORD PTR [r9], eax
	mov	DWORD PTR [r8], eax
	mov	DWORD PTR [rdx], eax

; 513  :     *granularity = 0;
; 514  :     // No error is returned even if the hardware is unusable.
; 515  :     // Some DAWs will crash if 0 is returned, so the initial value of m_blockFrames is 1024.
; 516  :     return ASE_OK;

	xor	eax, eax
	mov	DWORD PTR [r10], r11d

; 517  : }

	ret	0
$LN3@getBufferS:

; 504  :     {
; 505  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 506  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 517  : }

	ret	0
?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z ENDP		; CUSBAsio::getBufferSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?canSampleRate@CUSBAsio@@UEAAJN@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?canSampleRate@CUSBAsio@@UEAAJN@Z PROC			; CUSBAsio::canSampleRate, COMDAT

; 521  : {

$LN86:
	push	rdi
	sub	rsp, 32					; 00000020H

; 522  :     info_print_("canSampleRate\n");
; 523  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	mov	rdi, rcx
	je	$LN6@canSampleR
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN6@canSampleR
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN6@canSampleR

; 527  :     }
; 528  :     info_print_("requested %lf Hz\n", sampleRate);
; 529  :     if (m_fixedSamplingRate != 0)

	mov	eax, DWORD PTR [rcx+3460]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rbx
	cvttsd2si rsi, xmm1
	test	eax, eax
	je	SHORT $LN9@canSampleR

; 530  :     {
; 531  :         if ((ULONG)sampleRate == m_fixedSamplingRate)

	cmp	esi, eax
	je	SHORT $LN47@canSampleR
$LN62@canSampleR:
	mov	rbx, QWORD PTR [rsp+56]

; 532  :         {
; 533  :             return ASE_OK;
; 534  :         }
; 535  :         else
; 536  :         {
; 537  :             return ASE_NoClock;

	mov	eax, -995				; fffffffffffffc1dH
	mov	rsi, QWORD PTR [rsp+64]

; 559  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@canSampleR:

; 538  :         }
; 539  :     }
; 540  : 
; 541  :     {
; 542  :         auto        lockDevice = m_deviceInfoCS.lock();

	lea	rbx, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 545  :         if ((m_requestedSampleFormat == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	cmp	DWORD PTR [rdi+3464], 0
	jne	SHORT $LN67@canSampleR
	test	BYTE PTR [rdi+3284], 33			; 00000021H
	je	SHORT $LN67@canSampleR

; 546  :         {
; 547  :             for (ULONG index = 0; index < c_FrameRateListNumber; ++index)

	xor	ecx, ecx

; 548  :             {
; 549  :                 if ((requiredFrameRate == c_FrameRateList[index]) && ((m_audioProperty.SupportedSampleRate & (1 << index)) != 0))

	lea	rdx, OFFSET FLAT:?c_FrameRateList@@3QBKB
	npad	2
$LL4@canSampleR:
	cmp	esi, DWORD PTR [rdx+rcx*4]
	jne	SHORT $LN2@canSampleR
	mov	eax, DWORD PTR [rdi+3268]
	bt	eax, ecx
	jb	SHORT $LN65@canSampleR
$LN2@canSampleR:

; 546  :         {
; 547  :             for (ULONG index = 0; index < c_FrameRateListNumber; ++index)

	inc	ecx
	cmp	ecx, 13
	jb	SHORT $LL4@canSampleR
$LN67@canSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN62@canSampleR

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 558  :     return ASE_NoClock;

	jmp	SHORT $LN62@canSampleR
$LN65@canSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN47@canSampleR

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN47@canSampleR:
	mov	rbx, QWORD PTR [rsp+56]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 552  :                     return ASE_OK;

	xor	eax, eax
	mov	rsi, QWORD PTR [rsp+64]

; 559  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@canSampleR:

; 524  :     {
; 525  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 526  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 559  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?canSampleRate@CUSBAsio@@UEAAJN@Z ENDP			; CUSBAsio::canSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getSampleRate@CUSBAsio@@UEAAJPEAN@Z
_TEXT	SEGMENT
this$ = 48
sampleRate$ = 56
?getSampleRate@CUSBAsio@@UEAAJPEAN@Z PROC		; CUSBAsio::getSampleRate, COMDAT

; 563  : {

$LN49:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 564  :     verbose_print_("getSampleRate\n");
; 565  : 
; 566  :     if (sampleRate == nullptr)

	test	rdx, rdx
	jne	SHORT $LN2@getSampleR

; 567  :     {
; 568  :         return ASE_InvalidParameter;

	mov	eax, -998				; fffffffffffffc1aH

; 587  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@getSampleR:

; 569  :     }
; 570  : 
; 571  :     *sampleRate = {};

	mov	QWORD PTR [rdx], 0

; 572  : 
; 573  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	SHORT $LN4@getSampleR
	cmp	DWORD PTR [rcx+2804], 0
	je	SHORT $LN4@getSampleR
	cmp	DWORD PTR [rcx+2808], 0
	je	SHORT $LN4@getSampleR
	mov	QWORD PTR [rsp+64], rdi

; 574  :     {
; 575  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 576  :         return ASE_NotPresent;
; 577  :     }
; 578  :     // Do not return 0 because some DAWs will crash due to division by 0.
; 579  :     // (The initial value of m_sampleRate is 44100)
; 580  :     {
; 581  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rdi, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 582  :         *sampleRate = m_sampleRate;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rsi], rax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN40@getSampleR

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN40@getSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 586  :     return ASE_OK;

	mov	rdi, QWORD PTR [rsp+64]
	xor	eax, eax

; 587  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN4@getSampleR:
	mov	rbx, QWORD PTR [rsp+72]
	mov	eax, -1000				; fffffffffffffc18H
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
?getSampleRate@CUSBAsio@@UEAAJPEAN@Z ENDP		; CUSBAsio::getSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?setSampleRate@CUSBAsio@@UEAAJN@Z
_TEXT	SEGMENT
lockClient$21 = 64
lockDevice$22 = 72
sampleRate$ = 80
bytesReturned$23 = 80
bytesReturned$24 = 88
sampleFormat$ = 88
privateProperty$25 = 96
privateProperty$26 = 96
__$ArrayPad$ = 120
this$ = 176
sampleRate$ = 184
?setSampleRate@CUSBAsio@@UEAAJN@Z PROC			; CUSBAsio::setSampleRate, COMDAT

; 591  : {

$LN231:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 144				; 00000090H
	movaps	XMMWORD PTR [rsp+128], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	movaps	xmm6, xmm1
	mov	rbx, rcx

; 592  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN6@setSampleR
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN6@setSampleR
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN6@setSampleR

; 596  :     }
; 597  :     info_print_("setSampleRate\n");
; 598  :     info_print_("current %lf Hz, device current %u Hz, request %lf Hz\n", this->m_sampleRate, m_audioProperty.SampleRate, sampleRate);
; 599  :     if (canSampleRate(sampleRate) != ASE_OK)

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+96]
	test	eax, eax
	je	SHORT $LN7@setSampleR

; 600  :     {
; 601  :         return ASE_NoClock;

	mov	eax, -995				; fffffffffffffc1dH
	jmp	$LN1@setSampleR
$LN7@setSampleR:

; 602  :     }
; 603  :     {
; 604  :         auto lockClient = m_clientInfoCS.lock();

	lea	rdi, QWORD PTR [rbx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$21[rsp], rdi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 605  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rsi, QWORD PTR [rbx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockDevice$22[rsp], rsi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 607  :         if (sampleRate != this->m_sampleRate)

	ucomisd	xmm6, QWORD PTR [rbx+40]
	jp	SHORT $LN228@setSampleR
	je	$LN18@setSampleR
$LN228@setSampleR:

; 608  :         {
; 609  :             BOOL  result = FALSE;
; 610  :             ULONG sampleFormat;
; 611  :             if (m_requestedSampleFormat != kASIOPCMFormat)

	cmp	DWORD PTR [rbx+3464], 0
	jne	$LN14@setSampleR

; 612  :             {
; 613  :                 return ASE_NoClock;
; 614  :             }
; 615  :             if ((m_audioProperty.CurrentSampleFormat != UACSampleFormat::UAC_SAMPLE_FORMAT_PCM) && (m_audioProperty.CurrentSampleFormat == UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT))

	mov	eax, DWORD PTR [rbx+3288]
	xor	ebp, ebp
	test	eax, eax
	je	SHORT $LN11@setSampleR
	cmp	eax, 5
	jne	SHORT $LN11@setSampleR

; 616  :             {
; 617  :                 if (m_audioProperty.SupportedSampleFormats & (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT)))

	mov	eax, DWORD PTR [rbx+3284]
	test	al, 32					; 00000020H
	je	SHORT $LN12@setSampleR

; 618  :                 {
; 619  :                     sampleFormat = toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT);

	mov	eax, 5

; 620  :                 }

	jmp	SHORT $LN11@setSampleR
$LN12@setSampleR:

; 621  :                 else if (m_audioProperty.SupportedSampleFormats & (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)))

	test	al, 1
	je	$LN14@setSampleR

; 622  :                 {
; 623  :                     sampleFormat = toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM);

	mov	eax, ebp
$LN11@setSampleR:

; 624  :                 }
; 625  :                 else
; 626  :                 {
; 627  :                     return ASE_NoClock;
; 628  :                 }
; 629  :             }
; 630  :             else
; 631  :             {
; 632  :                 sampleFormat = toULong(m_audioProperty.CurrentSampleFormat);
; 633  :             }
; 634  : 
; 635  :             result = SetSampleFormat(m_usbDeviceHandle, sampleFormat);

	mov	DWORD PTR sampleFormat$[rsp], eax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 334  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$23[rsp], ebp

; 335  : 
; 336  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$26[rsp], xmm0

; 337  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$26[rsp+20], 2

; 338  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetSampleFormat);

	mov	DWORD PTR privateProperty$26[rsp+16], 6

; 339  : 
; 340  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleFormat, sizeof(ULONG), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rbp
	lea	rax, QWORD PTR bytesReturned$23[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 4
	lea	rax, QWORD PTR sampleFormat$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$26[rsp]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
	mov	r9d, eax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 636  :             ULONG frameRate = (ULONG)sampleRate;

	cvttsd2si r8, xmm6

; 637  : 
; 638  :             for (ULONG i = 0; i < c_FrameRateListNumber; ++i)

	mov	edx, ebp

; 639  :             {
; 640  :                 if (frameRate == c_FrameRateList[i] &&

	lea	r10, OFFSET FLAT:?c_FrameRateList@@3QBKB
	npad	5
$LL4@setSampleR:
	mov	ecx, edx
	cmp	r8d, DWORD PTR [r10+rcx*4]
	jne	SHORT $LN2@setSampleR
	mov	eax, DWORD PTR [rbx+3268]
	bt	eax, edx
	jb	SHORT $LN222@setSampleR
$LN2@setSampleR:

; 637  : 
; 638  :             for (ULONG i = 0; i < c_FrameRateListNumber; ++i)

	inc	edx
	cmp	edx, 13
	jb	SHORT $LL4@setSampleR
	jmp	SHORT $LN224@setSampleR
$LN222@setSampleR:

; 641  :                     ((m_audioProperty.SupportedSampleRate & (1 << i)) != 0))
; 642  :                 {
; 643  :                     info_print_("This device works at requested sample rate.\n");
; 644  :                     result = ChangeSampleRate(m_usbDeviceHandle, frameRate);

	mov	DWORD PTR sampleRate$[rsp], r8d
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 353  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$24[rsp], ebp

; 354  : 
; 355  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$25[rsp], xmm0

; 356  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$25[rsp+20], 2

; 357  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ChangeSampleRate);

	mov	DWORD PTR privateProperty$25[rsp+16], 7

; 358  : 
; 359  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleRate, sizeof(ULONG), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rbp
	lea	rax, QWORD PTR bytesReturned$24[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 4
	lea	rax, QWORD PTR sampleRate$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$25[rsp]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
	mov	r9d, eax
$LN224@setSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 649  :             if (!result)

	test	r9d, r9d
	jne	SHORT $LN17@setSampleR

; 650  :             {
; 651  :                 return ASE_InvalidMode;

	mov	ebx, -997				; fffffffffffffc1bH
	jmp	SHORT $LN24@setSampleR
$LN17@setSampleR:

; 652  :             }
; 653  :             this->m_sampleRate = sampleRate;

	movsd	QWORD PTR [rbx+40], xmm6

; 654  : 
; 655  :             if (!RequestClockInfoChange())

	mov	rcx, rbx
	call	?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ ; CUSBAsio::RequestClockInfoChange
	test	al, al
	jne	SHORT $LN18@setSampleR

; 657  :                 return ASE_NotPresent;

	mov	ebx, -1000				; fffffffffffffc18H
	jmp	SHORT $LN24@setSampleR
$LN18@setSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rsi, rsi
	je	SHORT $LN110@setSampleR

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN110@setSampleR:

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN125@setSampleR

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN125@setSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 661  :     return ASE_OK;

	xor	eax, eax
	jmp	SHORT $LN1@setSampleR
$LN14@setSampleR:
	mov	ebx, -995				; fffffffffffffc1dH
$LN24@setSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rsi, rsi
	je	SHORT $LN38@setSampleR

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN38@setSampleR:

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN53@setSampleR

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN53@setSampleR:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 657  :                 return ASE_NotPresent;

	mov	eax, ebx
	jmp	SHORT $LN1@setSampleR
$LN6@setSampleR:

; 593  :     {
; 594  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 595  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H
$LN1@setSampleR:

; 662  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [rsp+128]
	add	rsp, 144				; 00000090H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?setSampleRate@CUSBAsio@@UEAAJN@Z ENDP			; CUSBAsio::setSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$21 = 64
lockDevice$22 = 72
sampleRate$ = 80
bytesReturned$23 = 80
bytesReturned$24 = 88
sampleFormat$ = 88
privateProperty$25 = 96
privateProperty$26 = 96
__$ArrayPad$ = 120
this$ = 176
sampleRate$ = 184
?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA PROC	; `CUSBAsio::setSampleRate'::`1'::dtor$0
	lea	rcx, QWORD PTR lockClient$21[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA ENDP	; `CUSBAsio::setSampleRate'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$21 = 64
lockDevice$22 = 72
sampleRate$ = 80
bytesReturned$23 = 80
bytesReturned$24 = 88
sampleFormat$ = 88
privateProperty$25 = 96
privateProperty$26 = 96
__$ArrayPad$ = 120
this$ = 176
sampleRate$ = 184
?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA PROC	; `CUSBAsio::setSampleRate'::`1'::dtor$1
	lea	rcx, QWORD PTR lockDevice$22[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA ENDP	; `CUSBAsio::setSampleRate'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z
_TEXT	SEGMENT
this$ = 96
clocks$ = 104
numSources$ = 112
?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z PROC ; CUSBAsio::getClockSources, COMDAT

; 666  : {

$LN84:
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r15, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 667  :     verbose_print_("getClockSources\n");
; 668  : 
; 669  :     if (clocks == nullptr)

	test	rdx, rdx
	je	$LN69@getClockSo

; 670  :     {
; 671  :         return ASE_InvalidParameter;
; 672  :     }
; 673  :     *clocks = {};

	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0
	movups	XMMWORD PTR [rdx+16], xmm0
	movups	XMMWORD PTR [rdx+32], xmm0

; 674  : 
; 675  :     if (numSources == nullptr)

	test	r8, r8
	je	$LN69@getClockSo

; 678  :     }
; 679  :     *numSources = 0;

	mov	DWORD PTR [r8], 0

; 681  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN8@getClockSo
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN8@getClockSo
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN8@getClockSo
	mov	QWORD PTR [rsp+120], rbx

; 685  :     }
; 686  :     if (*numSources < (long)m_audioProperty.ClockSources)
; 687  :     {
; 688  :         info_print_("too small buffers. *NumSources %d, m_audioProperty.ClockSources %d.\n", *numSources, m_audioProperty.ClockSources);
; 689  :         // return ASE_InvalidParameter;
; 690  :     }
; 691  : 
; 692  :     // Device information is obtained only when the instance is initialized.
; 693  :     {
; 694  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rbx, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 681  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	mov	QWORD PTR [rsp+32], r14
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 695  :         if (m_clockInfo == nullptr)

	mov	r14, QWORD PTR [rdi+3488]
	test	r14, r14
	jne	SHORT $LN10@getClockSo
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN47@getClockSo

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN47@getClockSo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 697  :             return ASE_HWMalfunction;

	mov	eax, -999				; fffffffffffffc19H
$LN81@getClockSo:
	mov	rbx, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+32]

; 718  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN10@getClockSo:

; 698  :         }
; 699  :         UAC_GET_CLOCK_INFO_CONTEXT * clockInfo = m_clockInfo;
; 700  : 
; 701  :         long numDeviceClocks = clockInfo->NumClockSource;

	mov	eax, DWORD PTR [r15]
	mov	QWORD PTR [rsp+56], rbp

; 702  :         if (*numSources < (long)clockInfo->NumClockSource)
; 703  :         {
; 704  :             numDeviceClocks = *numSources;
; 705  :         }
; 706  : 
; 707  :         for (long i = 0; i < numDeviceClocks; ++i)

	xor	ebp, ebp
	cmp	eax, DWORD PTR [r14]
	mov	QWORD PTR [rsp+40], r13
	cmovge	eax, DWORD PTR [r14]
	movsxd	r13, eax
	test	eax, eax
	jle	SHORT $LN3@getClockSo
	mov	QWORD PTR [rsp+48], r12
	lea	rdi, QWORD PTR [rsi+8]
	lea	r12, QWORD PTR [r14+16]
	npad	9
$LL4@getClockSo:

; 708  :         {
; 709  :             clocks[i].index = i;
; 710  :             clocks[i].associatedChannel = -1;
; 711  :             clocks[i].associatedGroup = -1;
; 712  :             clocks[i].isCurrentSource = clockInfo->ClockSource[i].IsCurrentSource ? ASIOTrue : ASIOFalse;

	xor	eax, eax
	mov	DWORD PTR [rdi-8], ebp
	mov	QWORD PTR [rdi-4], -1

; 713  :             sprintf_s(clocks[i].name, CLOCK_SOURCE_NAME_LENGTH, "%S", clockInfo->ClockSource[i].Name);

	lea	r8, OFFSET FLAT:??_C@_02KPKOKMHB@?$CFS@
	cmp	DWORD PTR [r12], eax
	mov	edx, 32					; 00000020H
	movsxd	rcx, ebp
	setne	al
	imul	r9, rcx, 84				; 00000054H
	lea	rcx, QWORD PTR [rcx+rcx*2]
	mov	DWORD PTR [rdi+4], eax
	shl	rcx, 4
	add	r9, 24
	add	rcx, 16
	add	r9, r14
	add	rcx, rsi
	call	sprintf_s
	inc	ebp
	lea	r12, QWORD PTR [r12+84]
	lea	rdi, QWORD PTR [rdi+48]
	sub	r13, 1
	jne	SHORT $LL4@getClockSo

; 702  :         if (*numSources < (long)clockInfo->NumClockSource)
; 703  :         {
; 704  :             numDeviceClocks = *numSources;
; 705  :         }
; 706  : 
; 707  :         for (long i = 0; i < numDeviceClocks; ++i)

	mov	r12, QWORD PTR [rsp+48]
$LN3@getClockSo:

; 714  :         }
; 715  :         *numSources = clockInfo->NumClockSource;

	mov	eax, DWORD PTR [r14]
	mov	r13, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+56]
	mov	DWORD PTR [r15], eax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN62@getClockSo

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN62@getClockSo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 717  :     return ASE_OK;

	xor	eax, eax
	jmp	$LN81@getClockSo
$LN8@getClockSo:

; 682  :     {
; 683  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 684  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 718  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
$LN69@getClockSo:

; 676  :     {
; 677  :         return ASE_InvalidParameter;

	mov	eax, -998				; fffffffffffffc1aH

; 718  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	rdi
	pop	rsi
	ret	0
?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z ENDP ; CUSBAsio::getClockSources
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?setClockSource@CUSBAsio@@UEAAJJ@Z
_TEXT	SEGMENT
lockClient$15 = 64
lockDevice$16 = 72
bytesReturned$17 = 80
setClockSourceContext$18 = 84
privateProperty$19 = 88
__$ArrayPad$ = 112
this$ = 176
index$ = 184
?setClockSource@CUSBAsio@@UEAAJJ@Z PROC			; CUSBAsio::setClockSource, COMDAT

; 722  : {

$LN148:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebp, edx
	mov	rsi, rcx

; 723  :     info_print_("setClockSource\n");
; 724  :     BOOL result = FALSE;
; 725  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN3@setClockSo
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN3@setClockSo
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN3@setClockSo

; 729  :     }
; 730  :     {
; 731  :         auto lockClient = m_clientInfoCS.lock();

	lea	rbx, QWORD PTR [rcx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$15[rsp], rbx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 732  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rdi, QWORD PTR [rsi+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockDevice$16[rsp], rdi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 733  :         if (index < (long)m_audioProperty.ClockSources)

	cmp	ebp, DWORD PTR [rsi+3392]
	jge	$LN5@setClockSo
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 294  :     ULONG                        bytesReturned = 0;

	xor	r15d, r15d
	mov	DWORD PTR bytesReturned$17[rsp], r15d

; 295  :     UAC_SET_CLOCK_SOURCE_CONTEXT setClockSourceContext = {index};

	mov	DWORD PTR setClockSourceContext$18[rsp], ebp

; 296  : 
; 297  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$19[rsp], xmm0

; 298  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$19[rsp+20], 2

; 299  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetClockSource);

	mov	DWORD PTR privateProperty$19[rsp+16], 4

; 300  : 
; 301  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setClockSourceContext, sizeof(UAC_SET_CLOCK_SOURCE_CONTEXT), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r15
	lea	rax, QWORD PTR bytesReturned$17[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 4
	lea	rax, QWORD PTR setClockSourceContext$18[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$19[rsp]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rsi+2984]
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 737  :             if (SetClockSource(m_usbDeviceHandle, index))

	test	eax, eax
	je	SHORT $LN5@setClockSo

; 738  :             {
; 739  :                 if (m_clockInfo != nullptr)

	mov	rcx, QWORD PTR [rsi+3488]
	test	rcx, rcx
	je	SHORT $LN6@setClockSo

; 740  :                 {
; 741  :                     delete[] ((UCHAR *)m_clockInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]

; 742  :                     m_clockInfo = nullptr;

	mov	QWORD PTR [rsi+3488], r15
$LN6@setClockSo:

; 743  :                 }
; 744  :                 GetClockInfo(m_usbDeviceHandle, &m_clockInfo);

	lea	rdx, QWORD PTR [rsi+3488]
	mov	rcx, QWORD PTR [rsi+2984]
	call	?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z ; GetClockInfo

; 745  :                 result = RequestClockInfoChange();

	mov	rcx, rsi
	call	?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ ; CUSBAsio::RequestClockInfoChange
	npad	1

; 750  :                 return ASE_OK;

	mov	esi, -1000				; fffffffffffffc18H
	test	al, al
	cmovne	esi, r15d
	test	rdi, rdi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN99@setClockSo

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN99@setClockSo:

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN114@setClockSo

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN114@setClockSo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 750  :                 return ASE_OK;

	mov	eax, esi
	jmp	SHORT $LN1@setClockSo
$LN5@setClockSo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN129@setClockSo

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN129@setClockSo:

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN144@setClockSo

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN144@setClockSo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 754  :     return ASE_InvalidMode;

	mov	eax, -997				; fffffffffffffc1bH
	jmp	SHORT $LN1@setClockSo
$LN3@setClockSo:

; 726  :     {
; 727  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 728  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H
$LN1@setClockSo:

; 755  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 128				; 00000080H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?setClockSource@CUSBAsio@@UEAAJJ@Z ENDP			; CUSBAsio::setClockSource
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$15 = 64
lockDevice$16 = 72
bytesReturned$17 = 80
setClockSourceContext$18 = 84
privateProperty$19 = 88
__$ArrayPad$ = 112
this$ = 176
index$ = 184
?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA PROC	; `CUSBAsio::setClockSource'::`1'::dtor$0
	lea	rcx, QWORD PTR lockClient$15[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA ENDP	; `CUSBAsio::setClockSource'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$15 = 64
lockDevice$16 = 72
bytesReturned$17 = 80
setClockSourceContext$18 = 84
privateProperty$19 = 88
__$ArrayPad$ = 112
this$ = 176
index$ = 184
?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA PROC	; `CUSBAsio::setClockSource'::`1'::dtor$1
	lea	rcx, QWORD PTR lockDevice$16[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA ENDP	; `CUSBAsio::setClockSource'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z
_TEXT	SEGMENT
this$ = 8
samplePosition$ = 16
timeStamp$ = 24
?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z PROC ; CUSBAsio::getSamplePosition, COMDAT

; 760  :     // info_print_("getSamplePosition");
; 761  : 
; 762  :     *samplePosition = {};

	xor	r9d, r9d
	mov	QWORD PTR [rdx], r9

; 763  :     *timeStamp = {};

	mov	QWORD PTR [r8], r9

; 764  : 
; 765  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	SHORT $LN3@getSampleP
	cmp	DWORD PTR [rcx+2804], r9d
	je	SHORT $LN3@getSampleP
	cmp	DWORD PTR [rcx+2808], r9d
	je	SHORT $LN3@getSampleP

; 769  :     }
; 770  :     if (samplePosition == nullptr || timeStamp == nullptr)
; 771  :     {
; 772  :         return ASE_InvalidParameter;
; 773  :     }
; 774  :     timeStamp->lo = m_theSystemTime.lo;

	mov	eax, DWORD PTR [rcx+208]

; 775  :     timeStamp->hi = m_theSystemTime.hi;
; 776  :     if (m_samplePosition >= c_TwoRaisedTo32)

	movsd	xmm1, QWORD PTR __real@41f0000000000000
	mov	DWORD PTR [r8+4], eax
	mov	eax, DWORD PTR [rcx+204]
	mov	DWORD PTR [r8], eax
	movsd	xmm0, QWORD PTR [rcx+32]
	comisd	xmm0, xmm1
	jb	SHORT $LN6@getSampleP

; 777  :     {
; 778  :         samplePosition->hi = (unsigned long)(m_samplePosition * c_TwoRaisedTo32Reciprocal);

	mulsd	xmm0, QWORD PTR __real@3df0000000000000
	cvttsd2si rax, xmm0
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdx], eax

; 779  :         samplePosition->lo = (unsigned long)(m_samplePosition - (samplePosition->hi * c_TwoRaisedTo32));

	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR [rcx+32]
	subsd	xmm1, xmm0

; 785  :     }
; 786  :     // info_print_("getSamplePosition SamplePosition %u, TimeStamp %u\n", samplePosition->lo, timeStamp->lo);
; 787  :     return ASE_OK;

	cvttsd2si rax, xmm1
	mov	DWORD PTR [rdx+4], eax
	xor	eax, eax

; 788  : }

	ret	0
$LN6@getSampleP:

; 780  :     }
; 781  :     else
; 782  :     {
; 783  :         samplePosition->hi = 0;

	mov	DWORD PTR [rdx], r9d

; 784  :         samplePosition->lo = (unsigned long)m_samplePosition;

	movsd	xmm1, QWORD PTR [rcx+32]

; 785  :     }
; 786  :     // info_print_("getSamplePosition SamplePosition %u, TimeStamp %u\n", samplePosition->lo, timeStamp->lo);
; 787  :     return ASE_OK;

	cvttsd2si rax, xmm1
	mov	DWORD PTR [rdx+4], eax
	xor	eax, eax

; 788  : }

	ret	0
$LN3@getSampleP:

; 766  :     {
; 767  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 768  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H

; 788  : }

	ret	0
?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z ENDP ; CUSBAsio::getSamplePosition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z
_TEXT	SEGMENT
this$ = 48
info$ = 56
?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z PROC ; CUSBAsio::getChannelInfo, COMDAT

; 792  : {

$LN123:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rdi, rcx

; 793  :     verbose_print_("getChannelInfo\n");
; 794  : 
; 795  :     if (info == nullptr)

	test	rdx, rdx
	je	$LN64@getChannel

; 796  :     {
; 797  :         return ASE_InvalidParameter;
; 798  :     }
; 799  : 
; 800  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN15@getChannel
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN15@getChannel
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN15@getChannel

; 801  :     {
; 802  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 803  :         return ASE_NotPresent;
; 804  :     }
; 805  :     {
; 806  :         auto lockDevice = m_deviceInfoCS.lock();

	lea	rbx, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 807  :         if (info->channel < 0 || (info->isInput ? (ULONG)info->channel >= m_inAvailableChannels : (ULONG)info->channel >= m_outAvailableChannels))

	mov	r9d, DWORD PTR [rsi]
	test	r9d, r9d
	js	$LN17@getChannel
	mov	r10d, DWORD PTR [rsi+4]
	xor	edx, edx
	mov	eax, edx
	test	r10d, r10d
	je	SHORT $LN28@getChannel
	cmp	r9d, DWORD PTR [rdi+3468]
	jmp	SHORT $LN119@getChannel
$LN28@getChannel:
	cmp	r9d, DWORD PTR [rdi+3472]
$LN119@getChannel:
	setae	al
	test	eax, eax
	jne	$LN17@getChannel

; 810  :         }
; 811  :         switch (m_requestedSampleFormat)

	cmp	DWORD PTR [rdi+3464], 1
	je	SHORT $LN18@getChannel

; 815  :             break;
; 816  :         default:
; 817  :             info->type = toInt(m_audioProperty.SampleType);

	mov	eax, DWORD PTR [rdi+3280]
	jmp	SHORT $LN2@getChannel
$LN18@getChannel:

; 812  :         {
; 813  :         case kASIODSDFormat:
; 814  :             info->type = ASIOSTDSDInt8MSB1;

	mov	eax, 33					; 00000021H
$LN2@getChannel:

; 818  :             break;
; 819  :         }
; 820  :         info->channelGroup = 0;

	mov	DWORD PTR [rsi+16], eax

; 821  :         info->isActive = ASIOFalse;
; 822  :         ULONG i;
; 823  :         if (info->isInput)

	mov	ecx, edx
	mov	QWORD PTR [rsi+8], 0
	test	r10d, r10d
	je	SHORT $LN20@getChannel

; 824  :         {
; 825  :             for (i = 0; i < m_activeInputs; i++)

	mov	r8d, DWORD PTR [rdi+2812]
	test	r8d, r8d
	je	SHORT $LN8@getChannel
	npad	2
$LL6@getChannel:

; 826  :             {
; 827  :                 if (m_inMap[i] == info->channel)

	mov	eax, ecx
	cmp	DWORD PTR [rdi+rax*4+2288], r9d
	je	SHORT $LN85@getChannel

; 824  :         {
; 825  :             for (i = 0; i < m_activeInputs; i++)

	inc	ecx
	cmp	ecx, r8d
	jb	SHORT $LL6@getChannel

; 828  :                 {
; 829  :                     info->isActive = ASIOTrue;
; 830  :                     break;
; 831  :                 }
; 832  :             }
; 833  :         }

	jmp	SHORT $LN8@getChannel
$LN20@getChannel:

; 834  :         else
; 835  :         {
; 836  :             for (i = 0; i < m_activeOutputs; i++)

	mov	r8d, DWORD PTR [rdi+2816]
	test	r8d, r8d
	je	SHORT $LN8@getChannel
$LL9@getChannel:

; 837  :             {
; 838  :                 if (m_outMap[i] == info->channel)

	mov	eax, ecx
	cmp	DWORD PTR [rdi+rax*4+2544], r9d
	je	SHORT $LN85@getChannel

; 834  :         else
; 835  :         {
; 836  :             for (i = 0; i < m_activeOutputs; i++)

	inc	ecx
	cmp	ecx, r8d
	jb	SHORT $LL9@getChannel

; 839  :                 {
; 840  :                     info->isActive = ASIOTrue;
; 841  :                     break;
; 842  :                 }
; 843  :             }
; 844  :         }
; 845  :         ULONG ch = 0;
; 846  :         for (; ch < m_channelInfo->NumChannels; ++ch)

	jmp	SHORT $LN8@getChannel
$LN85@getChannel:
	mov	DWORD PTR [rsi+8], 1
$LN8@getChannel:
	mov	r11, QWORD PTR [rdi+3480]
	mov	r8d, DWORD PTR [r11]
	test	r8d, r8d
	je	SHORT $LN100@getChannel
	npad	4
$LL12@getChannel:

; 847  :         {
; 848  :             if (m_channelInfo->Channel[ch].Index == info->channel && m_channelInfo->Channel[ch].IsInput == info->isInput)

	lea	rcx, QWORD PTR [rdx+rdx*4]
	add	rcx, rcx
	cmp	DWORD PTR [r11+rcx*8+4], r9d
	jne	SHORT $LN10@getChannel
	cmp	DWORD PTR [r11+rcx*8+8], r10d
	je	SHORT $LN100@getChannel
$LN10@getChannel:

; 839  :                 {
; 840  :                     info->isActive = ASIOTrue;
; 841  :                     break;
; 842  :                 }
; 843  :             }
; 844  :         }
; 845  :         ULONG ch = 0;
; 846  :         for (; ch < m_channelInfo->NumChannels; ++ch)

	inc	edx
	cmp	edx, r8d
	jb	SHORT $LL12@getChannel
$LN100@getChannel:

; 849  :             {
; 850  :                 break;
; 851  :             }
; 852  :         }
; 853  :         if (ch == m_channelInfo->NumChannels)

	lea	rcx, QWORD PTR [rsi+20]
	cmp	edx, r8d
	jne	SHORT $LN25@getChannel

; 854  :         {
; 855  :             sprintf_s(info->name, DRIVER_NAME_LENGTH, "channel %u", info->channel);

	lea	r8, OFFSET FLAT:??_C@_0L@CIJEIFL@channel?5?$CFu@
	mov	edx, 31
	call	sprintf_s

; 856  :         }

	jmp	SHORT $LN26@getChannel
$LN25@getChannel:

; 857  :         else
; 858  :         {
; 859  :             sprintf_s(info->name, DRIVER_NAME_LENGTH, "%S", m_channelInfo->Channel[ch].Name);

	lea	r9, QWORD PTR [rdx+rdx*4]
	add	r11, 20
	shl	r9, 4
	lea	r8, OFFSET FLAT:??_C@_02KPKOKMHB@?$CFS@
	add	r9, r11
	mov	edx, 31
	call	sprintf_s
$LN26@getChannel:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN79@getChannel

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN79@getChannel:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 864  :     return ASE_OK;

	xor	eax, eax

; 865  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN17@getChannel:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN64@getChannel

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN64@getChannel:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 809  :             return ASE_InvalidParameter;

	mov	eax, -998				; fffffffffffffc1aH

; 865  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@getChannel:
	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, -1000				; fffffffffffffc18H
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z ENDP ; CUSBAsio::getChannelInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z
_TEXT	SEGMENT
recSize$1$ = 64
bufferInfos$GSCopy$1$ = 72
callbacks$GSCopy$1$ = 80
createBuffersScope$ = 88
lockClient$57 = 120
lockDevice$58 = 128
lockRecBuffer$59 = 136
callDisposeBuffers$ = 144
error$ = 148
bytesReturned$60 = 152
bufferSize$1$ = 152
playSize$1$ = 152
messageString$61 = 160
__$ArrayPad$ = 288
this$ = 368
bufferInfos$ = 376
numChannels$ = 384
bufferSize$ = 392
callbacks$ = 400
?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z PROC ; CUSBAsio::createBuffers, COMDAT

; 869  : {

$LN801:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-48]
	sub	rsp, 304				; 00000130H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	DWORD PTR bufferSize$1$[rbp-256], r9d
	mov	r12d, r8d
	mov	r13, rdx
	mov	QWORD PTR bufferInfos$GSCopy$1$[rsp], rdx
	mov	rbx, rcx
	mov	rax, QWORD PTR callbacks$[rbp-256]
	mov	QWORD PTR callbacks$GSCopy$1$[rsp], rax

; 870  :     info_print_("createBuffers\n");
; 871  :     ASIOBufferInfo * info = bufferInfos;
; 872  :     long             i;
; 873  :     BOOL             result = FALSE;
; 874  : 
; 875  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN14@createBuff
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN14@createBuff
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN14@createBuff

; 880  :     }
; 881  :     if (bufferInfos == nullptr || callbacks == nullptr)

	test	rdx, rdx
	je	$LN16@createBuff
	test	rax, rax
	je	$LN16@createBuff

; 884  :     }
; 885  : 
; 886  :     if (m_requestedSampleFormat == kASIOPCMFormat && (ULONG)m_sampleRate != m_audioProperty.SampleRate)

	cmp	DWORD PTR [rcx+3464], 0
	jne	SHORT $LN17@createBuff
	cvttsd2si rax, QWORD PTR [rcx+40]
	cmp	eax, DWORD PTR [rcx+3260]
	je	SHORT $LN17@createBuff

; 887  :     {
; 888  :         info_print_("createBuffers : invalid format, format req %u, cur %u, fs req %lf, cur %u.\n", m_requestedSampleFormat, m_audioProperty.CurrentSampleFormat, m_sampleRate, m_audioProperty.SampleRate);
; 889  :         return ASE_InvalidMode;

	mov	eax, -997				; fffffffffffffc1bH
	jmp	$LN1@createBuff
$LN17@createBuff:

; 890  :     }
; 891  : 
; 892  :     ASIOError error = ASE_OK;

	xor	edi, edi
	mov	DWORD PTR error$[rbp-256], edi

; 893  :     bool      callDisposeBuffers = false;

	mov	BYTE PTR callDisposeBuffers$[rbp-256], dil
	xorps	xmm0, xmm0
	movups	XMMWORD PTR createBuffersScope$[rsp], xmm0
	movups	XMMWORD PTR createBuffersScope$[rsp+16], xmm0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	lea	rax, QWORD PTR error$[rbp-256]
	mov	QWORD PTR createBuffersScope$[rsp], rax
	lea	rax, QWORD PTR callDisposeBuffers$[rbp-256]
	mov	QWORD PTR createBuffersScope$[rsp+8], rax
	mov	QWORD PTR createBuffersScope$[rsp+16], rbx

; 544  :         {
; 545  :             static_assert(wistd::is_same<decltype(lambda()), void>::value, "scope_exit lambdas must not have a return value");
; 546  :             static_assert(
; 547  :                 !wistd::is_lvalue_reference<TLambda>::value && !wistd::is_rvalue_reference<TLambda>::value,
; 548  :                 "scope_exit should only be directly used with a lambda");
; 549  :         }
; 550  : 
; 551  :         lambda_call(lambda_call&& other) WI_NOEXCEPT : m_lambda(wistd::move(other.m_lambda)), m_call(other.m_call)
; 552  :         {
; 553  :             other.m_call = false;
; 554  :         }
; 555  : 
; 556  :         ~lambda_call() WI_NOEXCEPT
; 557  :         {
; 558  :             reset();
; 559  :         }
; 560  : 
; 561  :         // Ensures the scope_exit lambda will not be called
; 562  :         void release() WI_NOEXCEPT
; 563  :         {
; 564  :             m_call = false;
; 565  :         }
; 566  : 
; 567  :         // Executes the scope_exit lambda immediately if not yet run; ensures it will not run again
; 568  :         void reset() WI_NOEXCEPT
; 569  :         {
; 570  :             if (m_call)
; 571  :             {
; 572  :                 m_call = false;
; 573  :                 m_lambda();
; 574  :             }
; 575  :         }
; 576  : 
; 577  :         // Returns true if the scope_exit lambda is still going to be executed
; 578  :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 579  :         {
; 580  :             return m_call;
; 581  :         }
; 582  : 
; 583  :     protected:
; 584  :         TLambda m_lambda;
; 585  :         bool m_call = true;

	mov	BYTE PTR createBuffersScope$[rsp+24], 1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 902  :         auto lockClient = m_clientInfoCS.lock();

	lea	r15, QWORD PTR [rcx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, r15
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$57[rsp], r15
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 904  :         if (m_isActive)

	cmp	BYTE PTR [rbx+2824], dil
	je	SHORT $LN18@createBuff

; 905  :         {
; 906  :             info_print_("createBuffers : already initialized.\n");
; 907  :             error = ASE_OK;

	mov	DWORD PTR error$[rbp-256], edi
	jmp	$LN108@createBuff
$LN18@createBuff:

; 908  :             return error;
; 909  :         }
; 910  : 
; 911  :         m_isActive = true;

	mov	BYTE PTR [rbx+2824], 1

; 912  : 
; 913  :         {
; 914  :             auto lockDevice = m_deviceInfoCS.lock();

	lea	rsi, QWORD PTR [rbx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockDevice$58[rbp-256], rsi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 917  :             result = StopAsioStream(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	?StopAsioStream@@YAHPEAX@Z		; StopAsioStream

; 918  : 
; 919  :             result = UnsetAsioBuffer(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	?UnsetAsioBuffer@@YAHPEAX@Z		; UnsetAsioBuffer

; 920  : 
; 921  :             m_activeInputs = 0;

	mov	QWORD PTR [rbx+2812], rdi

; 922  :             m_activeOutputs = 0;
; 923  :             ULONGLONG recChannelsMap = {0};

	mov	rsi, rdi

; 924  :             ULONGLONG playChannelsMap = {0};

	mov	r14, rdi

; 925  : 
; 926  :             for (i = 0; i < numChannels; ++i, ++info)

	mov	r8d, edi
	test	r12d, r12d
	jle	$LN3@createBuff

; 908  :             return error;
; 909  :         }
; 910  : 
; 911  :         m_isActive = true;

	lea	rdx, QWORD PTR [r13+4]
	npad	5
$LL4@createBuff:

; 927  :             {
; 928  :                 if (info->isInput)

	mov	ecx, DWORD PTR [rdx]
	cmp	DWORD PTR [rdx-4], 0
	je	SHORT $LN19@createBuff

; 929  :                 {
; 930  :                     if (info->channelNum < 0)

	test	ecx, ecx
	js	$LN775@createBuff

; 931  :                     {
; 932  :                         info_print_("createBuffers : invalid parameter.\n");
; 933  :                         error = ASE_InvalidParameter;
; 934  :                         return error;
; 935  :                     }
; 936  :                     if ((ULONG)info->channelNum >= m_inAvailableChannels)

	cmp	ecx, DWORD PTR [rbx+3468]
	jae	$LN774@createBuff

; 937  :                     {
; 938  :                         info_print_("createBuffers : over channel.\n");
; 939  :                         error = ASE_InvalidMode;
; 940  :                         return error;
; 941  :                     }
; 942  :                     m_inMap[m_activeInputs] = info->channelNum;

	mov	eax, DWORD PTR [rbx+2812]
	mov	DWORD PTR [rbx+rax*4+2288], ecx

; 943  :                     ++m_activeInputs;

	inc	DWORD PTR [rbx+2812]
	mov	ecx, DWORD PTR [rbx+2812]

; 944  :                     recChannelsMap |= 1ULL << info->channelNum;

	movsxd	rax, DWORD PTR [rdx]
	bts	rsi, rax

; 945  :                     if (m_activeInputs > m_inAvailableChannels)

	cmp	ecx, DWORD PTR [rbx+3468]

; 946  :                     {
; 947  :                         info_print_("createBuffers : over channel.\n");
; 948  :                         error = ASE_InvalidMode;
; 949  :                         return error;
; 950  :                     }
; 951  :                 }

	jmp	SHORT $LN798@createBuff
$LN19@createBuff:

; 952  :                 else
; 953  :                 {
; 954  :                     if (info->channelNum < 0)

	test	ecx, ecx
	js	$LN775@createBuff

; 958  :                         return error;
; 959  :                     }
; 960  :                     if ((ULONG)info->channelNum >= m_outAvailableChannels)

	cmp	ecx, DWORD PTR [rbx+3472]
	jae	$LN774@createBuff

; 961  :                     {
; 962  :                         info_print_("createBuffers : over channel.\n");
; 963  :                         error = ASE_InvalidMode;
; 964  :                         return error;
; 965  :                     }
; 966  :                     m_outMap[m_activeOutputs] = info->channelNum;

	mov	eax, DWORD PTR [rbx+2816]
	mov	DWORD PTR [rbx+rax*4+2544], ecx

; 967  :                     ++m_activeOutputs;

	inc	DWORD PTR [rbx+2816]
	mov	ecx, DWORD PTR [rbx+2816]

; 968  :                     playChannelsMap |= 1ULL << info->channelNum;

	movsxd	rax, DWORD PTR [rdx]
	bts	r14, rax

; 969  :                     if (m_activeOutputs > m_outAvailableChannels)

	cmp	ecx, DWORD PTR [rbx+3472]
$LN798@createBuff:

; 925  : 
; 926  :             for (i = 0; i < numChannels; ++i, ++info)

	ja	SHORT $LN774@createBuff
	inc	r8d
	add	rdx, 24
	cmp	r8d, r12d
	jl	$LL4@createBuff
$LN3@createBuff:

; 970  :                     {
; 971  :                         info_print_("createBuffers : over channel.\n");
; 972  :                         error = ASE_InvalidMode;
; 973  :                         return error;
; 974  :                     }
; 975  :                 }
; 976  :             }
; 977  : 
; 978  :             if (bufferSize != m_blockFrames)

	mov	r15d, DWORD PTR [rbx+2800]
	mov	eax, DWORD PTR bufferSize$1$[rbp-256]
	cmp	eax, r15d
	je	SHORT $LN27@createBuff

; 979  :             {
; 980  :                 info_print_("createBuffers : requested buffer size %u differs from preferred %u.\n", bufferSize, m_blockFrames);
; 981  :                 m_blockFrames = bufferSize;

	mov	DWORD PTR [rbx+2800], eax

; 982  :                 m_isRequireAsioReset = true;

	mov	BYTE PTR [rbx+2968], 1

; 983  :                 SetEvent(m_asioResetEvent);

	mov	rcx, QWORD PTR [rbx+3696]
	call	QWORD PTR __imp_SetEvent
	mov	r15d, DWORD PTR [rbx+2800]
$LN27@createBuff:

; 984  :             }
; 985  : 
; 986  :             ULONG bytesPerSample = 0;
; 987  :             switch (m_audioProperty.SampleType)

	mov	eax, DWORD PTR [rbx+3280]
	add	eax, -16				; fffffff0H
	cmp	eax, 11
	ja	SHORT $LN35@createBuff
	lea	rdx, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR $LN795@createBuff[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN774@createBuff:

; 955  :                     {
; 956  :                         info_print_("createBuffers : invalid parameter.\n");
; 957  :                         error = ASE_InvalidParameter;

	mov	eax, -997				; fffffffffffffc1bH
	mov	DWORD PTR error$[rbp-256], eax
	mov	edi, eax
	jmp	$LN123@createBuff
$LN775@createBuff:
	mov	eax, -998				; fffffffffffffc1aH
	mov	DWORD PTR error$[rbp-256], eax
	mov	edi, eax
	jmp	$LN123@createBuff
$LN29@createBuff:

; 988  :             {
; 989  :             case UACSampleType::UACSTInt16LSB:
; 990  :                 bytesPerSample = 2;
; 991  :                 break;
; 992  :             case UACSampleType::UACSTInt24LSB:
; 993  :                 bytesPerSample = 3;

	mov	eax, 3

; 994  :                 break;

	jmp	SHORT $LN5@createBuff
$LN30@createBuff:

; 995  :             case UACSampleType::UACSTInt32LSB16:
; 996  :             case UACSampleType::UACSTInt32LSB20:
; 997  :             case UACSampleType::UACSTInt32LSB24:
; 998  :             case UACSampleType::UACSTInt32LSB:
; 999  :             case UACSampleType::UACSTFloat32LSB:
; 1000 :                 bytesPerSample = 4;

	mov	eax, 4

; 1001 :                 break;

	jmp	SHORT $LN5@createBuff
$LN35@createBuff:

; 1002 :             default:
; 1003 :                 bytesPerSample = 2;
; 1004 :                 break;
; 1005 :             }
; 1006 :             ULONG bufferSizeBytes = m_blockFrames;
; 1007 :             bufferSizeBytes *= bytesPerSample;

	mov	eax, 2
$LN5@createBuff:
	imul	r15d, eax

; 1008 : 
; 1009 :             ULONG playSize = sizeof(UAC_ASIO_PLAY_BUFFER_HEADER) + m_outAvailableChannels * bufferSizeBytes * 2;

	mov	eax, r15d
	imul	eax, DWORD PTR [rbx+3472]
	lea	ecx, DWORD PTR [rax*2+80]
	mov	DWORD PTR playSize$1$[rbp-256], ecx

; 1010 :             ULONG recSize = sizeof(UAC_ASIO_REC_BUFFER_HEADER) + m_inAvailableChannels * bufferSizeBytes * 2;

	mov	eax, r15d
	imul	eax, DWORD PTR [rbx+3468]
	lea	eax, DWORD PTR [rax*2+88]
	mov	DWORD PTR recSize$1$[rsp], eax

; 1011 : 
; 1012 :             m_driverPlayBufferWithKsProperty = new UCHAR[sizeof(KSPROPERTY) + playSize];

	add	rcx, 24
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR [rbx+3616], rax

; 1013 :             m_driverPlayBuffer = (m_driverPlayBufferWithKsProperty != nullptr) ? &(m_driverPlayBufferWithKsProperty[sizeof(KSPROPERTY)]) : nullptr;

	add	rax, 24
	mov	QWORD PTR [rbx+3624], rax

; 1014 :             {
; 1015 :                 auto lockRecBuffer = m_recBufferCS.lock();

	lea	r13, QWORD PTR [rbx+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, r13
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockRecBuffer$59[rbp-256], r13
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1016 :                 callDisposeBuffers = true;

	mov	BYTE PTR callDisposeBuffers$[rbp-256], 1

; 1017 :                 m_driverRecBuffer = new UCHAR[recSize];

	mov	ecx, DWORD PTR recSize$1$[rsp]
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR [rbx+3632], rax

; 1018 :                 if (m_driverPlayBuffer == nullptr || m_driverRecBuffer == nullptr)

	mov	rcx, QWORD PTR [rbx+3624]
	test	rcx, rcx
	je	$LN37@createBuff

; 1022 :                     return error;
; 1023 :                 }
; 1024 : 
; 1025 :                 info_print_("play buffer at %p, %u bytes, rec buffer at %p, %u bytes, period %d samples.\n", m_driverPlayBuffer, playSize, m_driverRecBuffer, recSize, m_blockFrames);
; 1026 : 
; 1027 :                 ZeroMemory((void *)m_driverPlayBuffer, playSize);

	mov	r8d, DWORD PTR playSize$1$[rbp-256]
	xor	edx, edx
	call	memset

; 1028 :                 ZeroMemory((void *)m_driverRecBuffer, recSize);

	mov	r8d, DWORD PTR recSize$1$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR [rbx+3632]
	call	memset

; 1029 : 
; 1030 :                 if (m_audioProperty.CurrentSampleFormat != UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)

	cmp	DWORD PTR [rbx+3288], 0
	je	SHORT $LN38@createBuff

; 1031 :                 {
; 1032 :                     FillMemory((void *)(m_driverPlayBuffer + sizeof(UAC_ASIO_PLAY_BUFFER_HEADER)), m_outAvailableChannels * bufferSizeBytes * 2, DSD_ZERO_BYTE);

	mov	eax, r15d
	imul	eax, DWORD PTR [rbx+3472]
	lea	r8d, DWORD PTR [rax+rax]
	mov	rcx, QWORD PTR [rbx+3624]
	add	rcx, 80					; 00000050H
	mov	edx, 150				; 00000096H
	call	memset
$LN38@createBuff:

; 1033 :                 }
; 1034 : 
; 1035 :                 m_playReadyPosition = 0LL;

	mov	QWORD PTR [rbx+3640], rdi

; 1036 : 
; 1037 :                 m_activeInputs = 0;

	mov	QWORD PTR [rbx+2812], rdi

; 1038 :                 m_activeOutputs = 0;
; 1039 :                 info = bufferInfos;
; 1040 :                 for (i = 0; i < numChannels; i++, info++)

	test	r12d, r12d
	jle	$LN8@createBuff
	mov	r10d, r15d

; 1033 :                 }
; 1034 : 
; 1035 :                 m_playReadyPosition = 0LL;

	mov	r8, QWORD PTR bufferInfos$GSCopy$1$[rsp]
	add	r8, 4
	mov	r9, r12
	npad	14
$LL9@createBuff:

; 1041 :                 {
; 1042 :                     if (info->isInput)

	mov	eax, DWORD PTR [r8]
	imul	eax, r15d
	lea	ecx, DWORD PTR [rax+rax]
	cmp	DWORD PTR [r8-4], 0
	je	SHORT $LN39@createBuff

; 1043 :                     {
; 1044 :                         m_inputBuffers[m_activeInputs] = m_driverRecBuffer + sizeof(UAC_ASIO_REC_BUFFER_HEADER) + bufferSizeBytes * 2 * info->channelNum;

	mov	rdx, QWORD PTR [rbx+3632]
	add	rdx, 88					; 00000058H
	add	rdx, rcx
	mov	eax, DWORD PTR [rbx+2812]
	mov	QWORD PTR [rbx+rax*8+216], rdx

; 1045 :                         info->buffers[0] = (void *)(m_inputBuffers[m_activeInputs]);

	mov	eax, DWORD PTR [rbx+2812]
	mov	rcx, QWORD PTR [rbx+rax*8+216]
	mov	QWORD PTR [r8+4], rcx

; 1046 :                         info->buffers[1] = (void *)(m_inputBuffers[m_activeInputs] + bufferSizeBytes);

	mov	eax, DWORD PTR [rbx+2812]
	mov	rax, QWORD PTR [rbx+rax*8+216]
	add	rax, r10
	mov	QWORD PTR [r8+12], rax

; 1047 :                         m_inMap[m_activeInputs] = info->channelNum;

	mov	ecx, DWORD PTR [rbx+2812]
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx+rcx*4+2288], eax

; 1048 :                         ++m_activeInputs;

	inc	DWORD PTR [rbx+2812]

; 1049 :                     }

	jmp	SHORT $LN7@createBuff
$LN39@createBuff:

; 1050 :                     else // output
; 1051 :                     {
; 1052 :                         m_outputBuffers[m_activeOutputs] = m_driverPlayBuffer + sizeof(UAC_ASIO_PLAY_BUFFER_HEADER) + bufferSizeBytes * 2 * info->channelNum;

	mov	rdx, QWORD PTR [rbx+3624]
	add	rdx, 80					; 00000050H
	add	rdx, rcx
	mov	eax, DWORD PTR [rbx+2816]
	mov	QWORD PTR [rbx+rax*8+1240], rdx

; 1053 :                         info->buffers[0] = (void *)(m_outputBuffers[m_activeOutputs]);

	mov	eax, DWORD PTR [rbx+2816]
	mov	rcx, QWORD PTR [rbx+rax*8+1240]
	mov	QWORD PTR [r8+4], rcx

; 1054 :                         info->buffers[1] = (void *)(m_outputBuffers[m_activeOutputs] + bufferSizeBytes);

	mov	eax, DWORD PTR [rbx+2816]
	mov	rax, QWORD PTR [rbx+rax*8+1240]
	add	rax, r10
	mov	QWORD PTR [r8+12], rax

; 1055 :                         m_outMap[m_activeOutputs] = info->channelNum;

	mov	ecx, DWORD PTR [rbx+2816]
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx+rcx*4+2544], eax

; 1056 :                         ++m_activeOutputs;

	inc	DWORD PTR [rbx+2816]
$LN7@createBuff:

; 1038 :                 m_activeOutputs = 0;
; 1039 :                 info = bufferInfos;
; 1040 :                 for (i = 0; i < numChannels; i++, info++)

	add	r8, 24
	sub	r9, 1
	jne	$LL9@createBuff
$LN8@createBuff:

; 1057 :                     }
; 1058 :                 }
; 1059 : 
; 1060 :                 m_notificationEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3648], rax

; 1061 :                 if (m_notificationEvent == nullptr)

	test	rax, rax
	je	$LN37@createBuff

; 1062 :                 {
; 1063 :                     info_print_("createBuffers : insufficient resources.\n");
; 1064 :                     error = ASE_NoMemory;
; 1065 :                     return error;
; 1066 :                 }
; 1067 : 
; 1068 :                 m_outputReadyEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3656], rax

; 1069 :                 if (m_outputReadyEvent == nullptr)

	test	rax, rax
	je	$LN37@createBuff

; 1070 :                 {
; 1071 :                     info_print_("createBuffers : insufficient resources.\n");
; 1072 :                     error = ASE_NoMemory;
; 1073 :                     return error;
; 1074 :                 }
; 1075 : 
; 1076 :                 m_deviceReadyEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR [rbx+3664], rax

; 1077 :                 if (m_deviceReadyEvent == nullptr)

	test	rax, rax
	je	$LN37@createBuff

; 1078 :                 {
; 1079 :                     info_print_("createBuffers : insufficient resources.\n");
; 1080 :                     error = ASE_NoMemory;
; 1081 :                     return error;
; 1082 :                 }
; 1083 : 
; 1084 :                 UAC_ASIO_PLAY_BUFFER_HEADER *         playHdr = (UAC_ASIO_PLAY_BUFFER_HEADER *)m_driverPlayBuffer;

	mov	rdx, QWORD PTR [rbx+3624]

; 1085 :                 volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;

	mov	rcx, QWORD PTR [rbx+3632]

; 1086 : 
; 1087 :                 playHdr->AsioDriverVersion = UAC_ASIO_DRIVER_VERSION;

	mov	DWORD PTR [rdx+4], 65536		; 00010000H

; 1088 :                 playHdr->HeaderLength = sizeof(UAC_ASIO_PLAY_BUFFER_HEADER);

	mov	DWORD PTR [rdx], 80			; 00000050H

; 1089 :                 playHdr->PeriodSamples = m_blockFrames;

	mov	eax, DWORD PTR [rbx+2800]
	mov	DWORD PTR [rdx+8], eax

; 1090 :                 playHdr->PlayChannels = m_outAvailableChannels; // m_activeOutputs;

	mov	eax, DWORD PTR [rbx+3472]
	mov	DWORD PTR [rdx+16], eax

; 1091 :                 playHdr->RecChannels = m_inAvailableChannels;   // m_activeInputs;

	mov	eax, DWORD PTR [rbx+3468]
	mov	DWORD PTR [rdx+12], eax

; 1092 :                 playHdr->PlayChannelsMap = playChannelsMap;

	mov	QWORD PTR [rdx+56], r14

; 1093 :                 playHdr->RecChannelsMap = recChannelsMap;

	mov	QWORD PTR [rdx+48], rsi

; 1094 :                 recHdr->HeaderLength = sizeof(UAC_ASIO_REC_BUFFER_HEADER);

	mov	DWORD PTR [rcx], 88			; 00000058H

; 1095 : #ifdef _WIN64
; 1096 :                 playHdr->NotificationEvent.p64 = m_notificationEvent;

	mov	rax, QWORD PTR [rbx+3648]
	mov	QWORD PTR [rdx+24], rax

; 1097 :                 playHdr->OutputReadyEvent.p64 = m_outputReadyEvent;

	mov	rax, QWORD PTR [rbx+3656]
	mov	QWORD PTR [rdx+32], rax

; 1098 :                 playHdr->DeviceReadyEvent.p64 = m_deviceReadyEvent;

	mov	rax, QWORD PTR [rbx+3664]
	mov	QWORD PTR [rdx+40], rax

; 1099 : #else // _WIN64
; 1100 :                 playHdr->NotificationEvent = m_notificationEvent;
; 1101 :                 playHdr->OutputReadyEvent = m_outputReadyEvent;
; 1102 :                 playHdr->DeviceReadyEvent = m_deviceReadyEvent;
; 1103 : #endif
; 1104 :                 playHdr->Training = 0;

	mov	DWORD PTR [rdx+20], edi

; 1105 :                 result = SetAsioBuffer(m_usbDeviceHandle, m_driverPlayBufferWithKsProperty, sizeof(KSPROPERTY) + playSize, (UCHAR *)m_driverRecBuffer, recSize);

	mov	rax, QWORD PTR [rbx+3632]
	mov	r9d, DWORD PTR playSize$1$[rbp-256]
	add	r9d, 24
	mov	r8, QWORD PTR [rbx+3616]
	mov	rcx, QWORD PTR [rbx+2984]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 429  :     ULONG       bytesReturned = 0;

	mov	DWORD PTR bytesReturned$60[rbp-256], edi

; 430  : 
; 431  :     if (driverPlayBufferWithKsPropertySize > sizeof(KSPROPERTY))

	cmp	r9d, 24
	jbe	$LN791@createBuff

; 432  :     {
; 433  :         privateProperty->Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR [r8], xmm0

; 434  :         privateProperty->Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR [r8+20], 2

; 435  :         privateProperty->Id = toInt(KsPropertyUACLowLatencyAudio::SetAsioBuffer);

	mov	DWORD PTR [r8+16], 11

; 436  : 
; 437  :         result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, privateProperty, driverPlayBufferWithKsPropertySize, driverRecBuffer, driverRecBufferSize, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdi
	lea	rdx, QWORD PTR bytesReturned$60[rbp-256]
	mov	QWORD PTR [rsp+48], rdx
	mov	edx, DWORD PTR recSize$1$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	QWORD PTR [rsp+32], rax
	mov	edx, 3080195				; 002f0003H
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1107 :                 if (!result)

	test	eax, eax
	je	$LN791@createBuff

; 1124 :                 }
; 1125 : 
; 1126 :                 this->m_callbacks = callbacks;

	mov	rax, QWORD PTR callbacks$GSCopy$1$[rsp]
	mov	QWORD PTR [rbx+48], rax

; 1127 :                 if (callbacks->asioMessage(kAsioSupportsTimeInfo, 0, 0, 0))

	mov	rax, QWORD PTR [rax+16]
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 7
	call	rax
	test	eax, eax
	je	SHORT $LN47@createBuff

; 1128 :                 {
; 1129 :                     info_print_("time info mode.\n");
; 1130 :                     m_isTimeInfoMode = true;

	mov	BYTE PTR [rbx+2826], 1

; 1131 :                     m_asioTime.timeInfo.speed = 1.;

	mov	rax, 4607182418800017408		; 3ff0000000000000H
	mov	QWORD PTR [rbx+72], rax

; 1132 :                     m_asioTime.timeInfo.systemTime.hi = m_asioTime.timeInfo.systemTime.lo = 0;

	mov	QWORD PTR [rbx+80], rdi

; 1133 :                     m_asioTime.timeInfo.samplePosition.hi = m_asioTime.timeInfo.samplePosition.lo = 0;

	mov	QWORD PTR [rbx+88], rdi

; 1134 :                     m_asioTime.timeInfo.sampleRate = m_sampleRate;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+96], rax

; 1135 :                     m_asioTime.timeInfo.flags = kSystemTimeValid | kSamplePositionValid | kSampleRateValid;

	mov	DWORD PTR [rbx+104], 7

; 1136 :                     m_asioTime.timeCode.flags = 0;

	mov	DWORD PTR [rbx+136], edi

; 1137 :                 }

	jmp	SHORT $LN12@createBuff
$LN47@createBuff:

; 1138 :                 else
; 1139 :                 {
; 1140 :                     info_print_("NOT time info mode.\n");
; 1141 :                     m_isTimeInfoMode = false;

	mov	BYTE PTR [rbx+2826], 0
$LN12@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	r13, r13

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN224@createBuff

; 154  :             close_fn(value);

	mov	rcx, r13
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN224@createBuff:

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	lea	rcx, QWORD PTR [rbx+3496]
	test	rcx, rcx

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN209@createBuff

; 154  :             close_fn(value);

	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN209@createBuff:

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	lea	rcx, QWORD PTR [rbx+3536]
	test	rcx, rcx

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN194@createBuff

; 154  :             close_fn(value);

	call	QWORD PTR __imp_LeaveCriticalSection
$LN194@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1151 :     error = ASE_OK;

	mov	DWORD PTR error$[rbp-256], edi

; 1152 :     return error;

	jmp	$LN93@createBuff
$LN791@createBuff:

; 1108 :                 {
; 1109 :                     DWORD lastError = GetLastError();

	call	QWORD PTR __imp_GetLastError

; 1110 :                     if (lastError == ERROR_REVISION_MISMATCH)

	cmp	eax, 1306				; 0000051aH
	jne	SHORT $LN45@createBuff
	xorps	xmm0, xmm0

; 1111 :                     {
; 1112 :                         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	movups	XMMWORD PTR messageString$61[rbp-256], xmm0
	movups	XMMWORD PTR messageString$61[rbp-240], xmm0
	movups	XMMWORD PTR messageString$61[rbp-224], xmm0
	movups	XMMWORD PTR messageString$61[rbp-208], xmm0
	movups	XMMWORD PTR messageString$61[rbp-192], xmm0
	movups	XMMWORD PTR messageString$61[rbp-176], xmm0
	movups	XMMWORD PTR messageString$61[rbp-160], xmm0
	movups	XMMWORD PTR messageString$61[rbp-144], xmm0

; 1113 :                         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_VERSION_MISMATCH, messageString, sizeof(messageString) / sizeof(messageString[0]));

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rcx, rax
	mov	r9d, 128				; 00000080H
	lea	r8, QWORD PTR messageString$61[rbp-256]
	mov	edx, 104				; 00000068H
	call	QWORD PTR __imp_LoadStringA

; 1114 :                         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	lea	rcx, QWORD PTR [rbx+2828]
	lea	r8, QWORD PTR messageString$61[rbp-256]
	mov	edx, 128				; 00000080H
	call	strcpy_s
$LN45@createBuff:

; 1115 :                         info_print_("createBuffers : driver version mismatch.\n");
; 1116 :                     }
; 1117 :                     else
; 1118 :                     {
; 1119 :                         info_print_("createBuffers : physical driver reports error.\n");
; 1120 :                     }
; 1121 :                     error = ASE_NotPresent;

	mov	DWORD PTR error$[rbp-256], -1000	; fffffffffffffc18H

; 1123 :                     return error;

	mov	edi, -1000				; fffffffffffffc18H
	jmp	SHORT $LN66@createBuff
$LN37@createBuff:

; 1019 :                 {
; 1020 :                     info_print_("createBuffers : insufficient resources.\n");
; 1021 :                     error = ASE_NoMemory;

	mov	DWORD PTR error$[rbp-256], -994		; fffffffffffffc1eH
	mov	edi, -994				; fffffffffffffc1eH
$LN66@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	r13, r13

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN796@createBuff

; 154  :             close_fn(value);

	mov	rcx, r13
	call	QWORD PTR __imp_LeaveCriticalSection
$LN796@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1123 :                     return error;

	lea	r15, QWORD PTR [rbx+3536]
$LN123@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	lea	rcx, QWORD PTR [rbx+3496]
	test	rcx, rcx

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN108@createBuff

; 154  :             close_fn(value);

	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN108@createBuff:

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	r15, r15

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN93@createBuff

; 154  :             close_fn(value);

	mov	rcx, r15
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN93@createBuff:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	cmp	DWORD PTR error$[rbp-256], 0
	je	SHORT $LN78@createBuff
	cmp	BYTE PTR callDisposeBuffers$[rbp-256], 0
	je	SHORT $LN78@createBuff

; 896  :         {
; 897  :             disposeBuffers();

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rdx+160]
	npad	1
$LN78@createBuff:

; 1152 :     return error;

	mov	eax, edi
	jmp	SHORT $LN1@createBuff
$LN16@createBuff:

; 882  :     {
; 883  :         return ASE_InvalidParameter;

	mov	eax, -998				; fffffffffffffc1aH
	jmp	SHORT $LN1@createBuff
$LN14@createBuff:

; 876  :     {
; 877  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 878  :         info_print_("createBuffers : device not ready.\n");
; 879  :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H
$LN1@createBuff:

; 1153 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+384]
	add	rsp, 304				; 00000130H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
	npad	1
$LN795@createBuff:
	DD	$LN35@createBuff
	DD	$LN29@createBuff
	DD	$LN30@createBuff
	DD	$LN30@createBuff
	DD	$LN35@createBuff
	DD	$LN35@createBuff
	DD	$LN35@createBuff
	DD	$LN35@createBuff
	DD	$LN30@createBuff
	DD	$LN35@createBuff
	DD	$LN30@createBuff
	DD	$LN30@createBuff
?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z ENDP ; CUSBAsio::createBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
recSize$1$ = 64
bufferInfos$GSCopy$1$ = 72
callbacks$GSCopy$1$ = 80
createBuffersScope$ = 88
lockClient$57 = 120
lockDevice$58 = 128
lockRecBuffer$59 = 136
callDisposeBuffers$ = 144
error$ = 148
bytesReturned$60 = 152
bufferSize$1$ = 152
playSize$1$ = 152
messageString$61 = 160
__$ArrayPad$ = 288
this$ = 368
bufferInfos$ = 376
numChannels$ = 384
bufferSize$ = 392
callbacks$ = 400
?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA PROC ; `CUSBAsio::createBuffers'::`1'::dtor$0
	lea	rcx, QWORD PTR createBuffersScope$[rdx]
	jmp	??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::~lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >
?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA ENDP ; `CUSBAsio::createBuffers'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
recSize$1$ = 64
bufferInfos$GSCopy$1$ = 72
callbacks$GSCopy$1$ = 80
createBuffersScope$ = 88
lockClient$57 = 120
lockDevice$58 = 128
lockRecBuffer$59 = 136
callDisposeBuffers$ = 144
error$ = 148
bytesReturned$60 = 152
bufferSize$1$ = 152
playSize$1$ = 152
messageString$61 = 160
__$ArrayPad$ = 288
this$ = 368
bufferInfos$ = 376
numChannels$ = 384
bufferSize$ = 392
callbacks$ = 400
?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA PROC ; `CUSBAsio::createBuffers'::`1'::dtor$1
	lea	rcx, QWORD PTR lockClient$57[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA ENDP ; `CUSBAsio::createBuffers'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
recSize$1$ = 64
bufferInfos$GSCopy$1$ = 72
callbacks$GSCopy$1$ = 80
createBuffersScope$ = 88
lockClient$57 = 120
lockDevice$58 = 128
lockRecBuffer$59 = 136
callDisposeBuffers$ = 144
error$ = 148
bytesReturned$60 = 152
bufferSize$1$ = 152
playSize$1$ = 152
messageString$61 = 160
__$ArrayPad$ = 288
this$ = 368
bufferInfos$ = 376
numChannels$ = 384
bufferSize$ = 392
callbacks$ = 400
?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA PROC ; `CUSBAsio::createBuffers'::`1'::dtor$2
	lea	rcx, QWORD PTR lockDevice$58[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA ENDP ; `CUSBAsio::createBuffers'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
recSize$1$ = 64
bufferInfos$GSCopy$1$ = 72
callbacks$GSCopy$1$ = 80
createBuffersScope$ = 88
lockClient$57 = 120
lockDevice$58 = 128
lockRecBuffer$59 = 136
callDisposeBuffers$ = 144
error$ = 148
bytesReturned$60 = 152
bufferSize$1$ = 152
playSize$1$ = 152
messageString$61 = 160
__$ArrayPad$ = 288
this$ = 368
bufferInfos$ = 376
numChannels$ = 384
bufferSize$ = 392
callbacks$ = 400
?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA PROC ; `CUSBAsio::createBuffers'::`1'::dtor$3
	lea	rcx, QWORD PTR lockRecBuffer$59[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA ENDP ; `CUSBAsio::createBuffers'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ??R<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEBA@XZ
_TEXT	SEGMENT
this$ = 8
??R<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEBA@XZ PROC ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::operator(), COMDAT

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN2@operator
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN2@operator

; 896  :         {
; 897  :             disposeBuffers();

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+160]
$LN2@operator:

; 898  :         }
; 899  :     });

	ret	0
??R<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEBA@XZ ENDP ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ??0<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEAA@AEAJAEA_NPEAV2@@Z
_TEXT	SEGMENT
this$ = 8
__error$ = 16
__callDisposeBuffers$ = 24
_This$ = 32
??0<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEAA@AEAJAEA_NPEAV2@@Z PROC ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)
; 896  :         {
; 897  :             disposeBuffers();
; 898  :         }
; 899  :     });

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEAA@AEAJAEA_NPEAV2@@Z ENDP ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??$scope_exit@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wil@@YA?A_P$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lambda$ = 16
??$scope_exit@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wil@@YA?A_P$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z PROC ; wil::scope_exit<`CUSBAsio::createBuffers'::`2'::<lambda_1> >, COMDAT

; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	movups	xmm0, XMMWORD PTR [rdx]

; 666  :     return details::lambda_call<TLambda>(wistd::forward<TLambda>(lambda));

	mov	rax, rcx

; 585  :         bool m_call = true;

	mov	BYTE PTR [rcx+24], 1
	movsd	xmm1, QWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx], xmm0
	movsd	QWORD PTR [rcx+16], xmm1

; 667  : }

	ret	0
??$scope_exit@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wil@@YA?A_P$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z ENDP ; wil::scope_exit<`CUSBAsio::createBuffers'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAX_K@Z PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	ret	0
?__autoclassinit2@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAX_K@Z ENDP ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?disposeBuffers@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
lockClient$14 = 32
lockDevice$15 = 40
this$ = 80
?disposeBuffers@CUSBAsio@@UEAAJXZ PROC			; CUSBAsio::disposeBuffers, COMDAT

; 1156 : {

$LN139:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 1157 :     info_print_("disposeBuffers\n");
; 1158 :     BOOL result;
; 1159 : 
; 1160 :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	cmp	QWORD PTR [rcx+2984], -1
	je	$LN3@disposeBuf
	cmp	DWORD PTR [rcx+2804], 0
	je	$LN3@disposeBuf
	cmp	DWORD PTR [rcx+2808], 0
	je	$LN3@disposeBuf

; 1165 :     }
; 1166 : 
; 1167 :     {
; 1168 :         auto lockClient = m_clientInfoCS.lock();

	lea	rbx, QWORD PTR [rcx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$14[rsp], rbx
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1170 :         if (!m_isActive)

	cmp	BYTE PTR [rsi+2824], 0
	jne	SHORT $LN4@disposeBuf
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN48@disposeBuf

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN48@disposeBuf:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1172 :             return ASE_InvalidMode;

	mov	eax, -997				; fffffffffffffc1bH
	jmp	$LN1@disposeBuf
$LN4@disposeBuf:

; 1173 :         }
; 1174 :         m_isActive = false;

	mov	BYTE PTR [rsi+2824], 0

; 1175 : 
; 1176 :         {
; 1177 :             auto lockDevice = m_deviceInfoCS.lock();

	lea	rbp, QWORD PTR [rsi+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbp
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockDevice$15[rsp], rbp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1179 :             m_callbacks = nullptr;

	xor	r14d, r14d
	mov	QWORD PTR [rsi+48], r14

; 1180 :             stop();

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	call	QWORD PTR [rax+64]

; 1181 :             result = UnsetAsioBuffer(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rsi+2984]
	call	?UnsetAsioBuffer@@YAHPEAX@Z		; UnsetAsioBuffer

; 1182 :             m_activeInputs = 0;

	mov	QWORD PTR [rsi+2812], r14

; 1183 :             m_activeOutputs = 0;
; 1184 :             if (m_driverPlayBufferWithKsProperty != nullptr)

	mov	rcx, QWORD PTR [rsi+3616]
	test	rcx, rcx
	je	SHORT $LN5@disposeBuf

; 1185 :             {
; 1186 :                 delete[] m_driverPlayBufferWithKsProperty;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 1187 :                 m_driverPlayBufferWithKsProperty = nullptr;

	mov	QWORD PTR [rsi+3616], r14

; 1188 :                 m_driverPlayBuffer = nullptr;

	mov	QWORD PTR [rsi+3624], r14
$LN5@disposeBuf:

; 1189 :             }
; 1190 :             {
; 1191 :                 auto lockRecBuffer = m_recBufferCS.lock();

	lea	rdi, QWORD PTR [rsi+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1192 :                 if (m_driverRecBuffer != nullptr)

	mov	rcx, QWORD PTR [rsi+3632]
	test	rcx, rcx
	je	SHORT $LN6@disposeBuf

; 1193 :                 {
; 1194 :                     delete[] m_driverRecBuffer;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 1195 :                     m_driverRecBuffer = nullptr;

	mov	QWORD PTR [rsi+3632], r14
$LN6@disposeBuf:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN105@disposeBuf

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN105@disposeBuf:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1198 :             if (m_deviceReadyEvent != nullptr)

	mov	rcx, QWORD PTR [rsi+3664]
	test	rcx, rcx
	je	SHORT $LN7@disposeBuf

; 1199 :             {
; 1200 :                 result = CloseHandle(m_deviceReadyEvent);

	call	QWORD PTR __imp_CloseHandle

; 1201 :                 m_deviceReadyEvent = nullptr;

	mov	QWORD PTR [rsi+3664], r14
$LN7@disposeBuf:

; 1202 :             }
; 1203 :             if (m_outputReadyEvent != nullptr)

	mov	rcx, QWORD PTR [rsi+3656]
	test	rcx, rcx
	je	SHORT $LN8@disposeBuf

; 1204 :             {
; 1205 :                 result = CloseHandle(m_outputReadyEvent);

	call	QWORD PTR __imp_CloseHandle

; 1206 :                 m_outputReadyEvent = nullptr;

	mov	QWORD PTR [rsi+3656], r14
$LN8@disposeBuf:

; 1207 :             }
; 1208 :             if (m_notificationEvent != nullptr)

	mov	rcx, QWORD PTR [rsi+3648]
	test	rcx, rcx
	je	SHORT $LN9@disposeBuf

; 1209 :             {
; 1210 :                 result = CloseHandle(m_notificationEvent);

	call	QWORD PTR __imp_CloseHandle

; 1211 :                 m_notificationEvent = nullptr;

	mov	QWORD PTR [rsi+3648], r14
$LN9@disposeBuf:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbp, rbp
	je	SHORT $LN120@disposeBuf

; 154  :             close_fn(value);

	mov	rcx, rbp
	call	QWORD PTR __imp_LeaveCriticalSection
	npad	1
$LN120@disposeBuf:

; 222  :             if (policy::is_valid(m_ptr))

	test	rbx, rbx
	je	SHORT $LN135@disposeBuf

; 154  :             close_fn(value);

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN135@disposeBuf:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1215 :     return ASE_OK;

	xor	eax, eax
	jmp	SHORT $LN1@disposeBuf
$LN3@disposeBuf:

; 1161 :     {
; 1162 :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 1163 :         info_print_("disposeBuffers : device not ready.\n");
; 1164 :         return ASE_NotPresent;

	mov	eax, -1000				; fffffffffffffc18H
$LN1@disposeBuf:

; 1216 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?disposeBuffers@CUSBAsio@@UEAAJXZ ENDP			; CUSBAsio::disposeBuffers
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$14 = 32
lockDevice$15 = 40
this$ = 80
?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA PROC	; `CUSBAsio::disposeBuffers'::`1'::dtor$0
	lea	rcx, QWORD PTR lockClient$14[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA ENDP	; `CUSBAsio::disposeBuffers'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$14 = 32
lockDevice$15 = 40
this$ = 80
?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA PROC	; `CUSBAsio::disposeBuffers'::`1'::dtor$1
	lea	rcx, QWORD PTR lockDevice$15[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA ENDP	; `CUSBAsio::disposeBuffers'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?controlPanel@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
processInfo$2 = 80
drive$3 = 104
startupInfo$4 = 112
path$5 = 224
dir$6 = 496
__$ArrayPad$ = 752
this$ = 784
?controlPanel@CUSBAsio@@UEAAJXZ PROC			; CUSBAsio::controlPanel, COMDAT

; 1219 : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-512]
	sub	rsp, 768				; 00000300H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1641 :     TCHAR path[MAX_PATH] = {0};

	xor	edx, edx
	lea	rcx, QWORD PTR path$5[rbp-256]
	mov	r8d, 260				; 00000104H
	call	memset

; 1642 :     TCHAR drive[_MAX_DRIVE] = {0};

	xor	eax, eax

; 1643 :     TCHAR dir[_MAX_DIR] = {0};

	lea	rcx, QWORD PTR dir$6[rbp-256]
	xor	edx, edx
	mov	WORD PTR drive$3[rsp], ax
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR drive$3[rsp+2], al
	call	memset

; 1644 : 
; 1645 :     GetModuleFileNameEx(GetCurrentProcess(), GetModuleHandle(ASIODRV_NAME), path, MAX_PATH);

	lea	rcx, OFFSET FLAT:??_C@_0M@BFGLKKGE@USBAsio?4dll@
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rbx, rax
	call	QWORD PTR __imp_GetCurrentProcess
	mov	r9d, 260				; 00000104H
	lea	r8, QWORD PTR path$5[rbp-256]
	mov	rcx, rax
	mov	rdx, rbx
	call	QWORD PTR __imp_K32GetModuleFileNameExA

; 1646 :     _tsplitpath_s(path, drive, _MAX_DRIVE, dir, _MAX_DIR, nullptr, 0, nullptr, 0);

	xor	ebx, ebx
	lea	r9, QWORD PTR dir$6[rbp-256]
	mov	QWORD PTR [rsp+64], rbx
	lea	rdx, QWORD PTR drive$3[rsp]
	mov	QWORD PTR [rsp+56], rbx
	lea	rcx, QWORD PTR path$5[rbp-256]
	mov	QWORD PTR [rsp+48], rbx
	mov	r8d, 3
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], 256			; 00000100H
	call	_splitpath_s

; 1647 :     _stprintf_s(path, MAX_PATH, TEXT("%s%s%s"), drive, dir, CONTROLPANELPROGRAMNAME);

	lea	rax, OFFSET FLAT:??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@
	mov	edx, 260				; 00000104H
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR drive$3[rsp]
	lea	rax, QWORD PTR dir$6[rbp-256]
	lea	r8, OFFSET FLAT:??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR path$5[rbp-256]
	call	sprintf_s
	xorps	xmm0, xmm0

; 1648 : 
; 1649 :     STARTUPINFO startupInfo;
; 1650 :     ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
; 1651 :     startupInfo.cb = sizeof(STARTUPINFO);

	mov	DWORD PTR startupInfo$4[rsp], 104	; 00000068H
	xor	eax, eax

; 1652 : 
; 1653 :     PROCESS_INFORMATION processInfo{};
; 1654 : 
; 1655 :     CreateProcess(

	lea	rcx, QWORD PTR path$5[rbp-256]
	mov	DWORD PTR startupInfo$4[rbp-156], eax
	xor	r9d, r9d
	mov	QWORD PTR processInfo$2[rsp+16], rax
	xor	r8d, r8d
	lea	rax, QWORD PTR processInfo$2[rsp]
	xor	edx, edx
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR startupInfo$4[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+48], rbx
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	DWORD PTR [rsp+32], ebx
	movups	XMMWORD PTR startupInfo$4[rsp+4], xmm0
	movups	XMMWORD PTR startupInfo$4[rbp-236], xmm0
	movups	XMMWORD PTR startupInfo$4[rbp-220], xmm0
	movups	XMMWORD PTR startupInfo$4[rbp-204], xmm0
	movups	XMMWORD PTR startupInfo$4[rbp-188], xmm0
	movups	XMMWORD PTR startupInfo$4[rbp-172], xmm0
	movups	XMMWORD PTR processInfo$2[rsp], xmm0
	call	QWORD PTR __imp_CreateProcessA

; 1656 :         path,
; 1657 :         nullptr,
; 1658 :         nullptr,
; 1659 :         nullptr,
; 1660 :         FALSE,
; 1661 :         NORMAL_PRIORITY_CLASS,
; 1662 :         nullptr,
; 1663 :         nullptr,
; 1664 :         &startupInfo,
; 1665 :         &processInfo
; 1666 :     );
; 1667 : 
; 1668 :     CloseHandle(processInfo.hThread);

	mov	rcx, QWORD PTR processInfo$2[rsp+8]
	call	QWORD PTR __imp_CloseHandle

; 1669 :     CloseHandle(processInfo.hProcess);

	mov	rcx, QWORD PTR processInfo$2[rsp]
	call	QWORD PTR __imp_CloseHandle

; 1220 :     info_print_("controlPanel\n");
; 1221 : 
; 1222 :     BOOL result = ExecuteControlPanel();
; 1223 :     if (!result)
; 1224 :     {
; 1225 :         // If the Cancel button is pressed.
; 1226 :         return ASE_OK;
; 1227 :     }
; 1228 : 
; 1229 :     return ASE_OK;

	xor	eax, eax

; 1230 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+784]
	add	rsp, 768				; 00000300H
	pop	rbp
	ret	0
?controlPanel@CUSBAsio@@UEAAJXZ ENDP			; CUSBAsio::controlPanel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?future@CUSBAsio@@UEAAJJPEAX@Z
_TEXT	SEGMENT
this$ = 48
selector$ = 56
option$ = 64
?future@CUSBAsio@@UEAAJJPEAX@Z PROC			; CUSBAsio::future, COMDAT

; 1234 : {

$LN131:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rcx

; 1235 :     switch (selector)

	cmp	edx, 588323169				; 23111961H
	jg	$LN39@future
	je	SHORT $LN21@future
	dec	edx
	cmp	edx, 16
	ja	$LN2@future
	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN111@future[rdx+rax]
	mov	ecx, DWORD PTR $LN112@future[rdx+rax*4]
	add	rcx, rdx
	jmp	rcx
$LN21@future:

; 1236 :     {
; 1237 :     case kAsioEnableTimeCodeRead:
; 1238 :         return ASE_NotPresent;
; 1239 :     case kAsioDisableTimeCodeRead:
; 1240 :         return ASE_NotPresent;
; 1241 :     case kAsioSetInputMonitor:
; 1242 :         return ASE_NotPresent;
; 1243 :     case kAsioTransport:
; 1244 :         return ASE_NotPresent;
; 1245 :     case kAsioSetInputGain:
; 1246 :         return ASE_NotPresent;
; 1247 :     case kAsioGetInputMeter:
; 1248 :         return ASE_NotPresent;
; 1249 :     case kAsioSetOutputGain:
; 1250 :         return ASE_NotPresent;
; 1251 :     case kAsioGetOutputMeter:
; 1252 :         return ASE_NotPresent;
; 1253 :     case kAsioCanInputMonitor:
; 1254 :         return ASE_NotPresent;
; 1255 :     case kAsioCanTimeInfo:
; 1256 :         return ASE_SUCCESS;
; 1257 :     case kAsioCanTimeCode:
; 1258 :         return ASE_NotPresent;
; 1259 :     case kAsioCanTransport:
; 1260 :         return ASE_NotPresent;
; 1261 :     case kAsioCanInputGain:
; 1262 :         return ASE_NotPresent;
; 1263 :     case kAsioCanInputMeter:
; 1264 :         return ASE_NotPresent;
; 1265 :     case kAsioCanOutputGain:
; 1266 :         return ASE_NotPresent;
; 1267 :     case kAsioCanOutputMeter:
; 1268 :         return ASE_NotPresent;
; 1269 :     case kAsioOptionalOne:
; 1270 :         return ASE_NotPresent;
; 1271 :     case kAsioSetIoFormat: {
; 1272 :         if (option == nullptr)

	test	rdi, rdi
	je	$LN27@future
	mov	QWORD PTR [rsp+56], rsi

; 1273 :         {
; 1274 :             return ASE_NotPresent;
; 1275 :         }
; 1276 :         ASIOIoFormat * requestedFormat = (ASIOIoFormat *)option;
; 1277 :         info_print_("kAsioSetIoFormat request. Device supported 0x%x, current %u, requested %u.\n", m_audioProperty.SupportedSampleFormats, m_audioProperty.CurrentSampleFormat, requestedFormat->FormatType);
; 1278 :         auto lockClient = m_clientInfoCS.lock();

	lea	rsi, QWORD PTR [rcx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1280 :         if ((requestedFormat->FormatType == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	cmp	DWORD PTR [rdi], 0
	jne	SHORT $LN23@future
	test	BYTE PTR [rbx+3284], 33			; 00000021H
	je	SHORT $LN23@future

; 1281 :         {
; 1282 :             m_requestedSampleFormat = requestedFormat->FormatType;

	mov	DWORD PTR [rbx+3464], 0
	mov	ebx, 1061701536				; 3f4847a0H
	jmp	SHORT $LN40@future
$LN23@future:

; 1287 :             return ASE_NotPresent;

	mov	ebx, -1000				; fffffffffffffc18H
$LN40@future:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rsi, rsi
	je	SHORT $LN90@future

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN90@future:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1287 :             return ASE_NotPresent;

	mov	rsi, QWORD PTR [rsp+56]
	mov	eax, ebx

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN39@future:

; 1235 :     switch (selector)

	cmp	edx, 588323203				; 23111983H
	je	$LN105@future
	cmp	edx, 588324868				; 23112004H
	je	SHORT $LN28@future
	cmp	edx, 604250130				; 24042012H
	je	SHORT $LN32@future
	cmp	edx, 621027346				; 25042012H
	jne	SHORT $LN2@future

; 1333 :             return ASE_NotPresent;
; 1334 :         }
; 1335 :     }
; 1336 :     case kAsioGetInternalBufferSamples: {
; 1337 :         if (option == nullptr)

	test	rdi, rdi
	jne	SHORT $LN37@future
$LN2@future:

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	eax, -998				; fffffffffffffc1aH
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN37@future:

; 1338 :         {
; 1339 :             return ASE_InvalidParameter;
; 1340 :         }
; 1341 :         ASIOInternalBufferInfo * internalBufferInfo = (ASIOInternalBufferInfo *)option;
; 1342 :         internalBufferInfo->inputSamples = m_audioProperty.InputDriverBuffer;

	mov	eax, DWORD PTR [rcx+3336]
	mov	DWORD PTR [r8], eax

; 1343 :         internalBufferInfo->outputSamples = m_audioProperty.OutputDriverBuffer;

	mov	eax, DWORD PTR [rcx+3384]
	mov	DWORD PTR [r8+4], eax

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;

	mov	eax, 1061701536				; 3f4847a0H

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN32@future:

; 1317 :         }
; 1318 :         else
; 1319 :         {
; 1320 :             return ASE_NotPresent;
; 1321 :         }
; 1322 :     }
; 1323 :     case kAsioCanReportOverload: {
; 1324 :         if (m_isDropoutDetectionSetting)

	cmp	BYTE PTR [rcx+2969], 0
	je	SHORT $LN34@future

; 1325 :         {
; 1326 :             m_isSupportDropoutDetection = true;

	mov	BYTE PTR [rcx+2970], 1

; 1327 :             info_print_("kAsioCanReportOverload request.\n");
; 1328 :             return ASE_SUCCESS;

	mov	eax, 1061701536				; 3f4847a0H

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN34@future:

; 1329 :         }
; 1330 :         else
; 1331 :         {
; 1332 :             m_isSupportDropoutDetection = false;

	mov	BYTE PTR [rcx+2970], 0
$LN27@future:

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	eax, -1000				; fffffffffffffc18H
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@future:

; 1300 :             return ASE_SUCCESS;
; 1301 :         }
; 1302 :         else
; 1303 :         {
; 1304 :             return ASE_NotPresent;
; 1305 :         }
; 1306 :     }
; 1307 :     case kAsioCanDoIoFormat: {
; 1308 :         if (option == nullptr)

	test	rdi, rdi
	je	SHORT $LN27@future

; 1309 :         {
; 1310 :             return ASE_NotPresent;
; 1311 :         }
; 1312 :         ASIOIoFormat * requestedFormat = (ASIOIoFormat *)option;
; 1313 :         info_print_("kAsioCanDoIoFormat. Device supported %u, current 0x%x, requested %u.\n", m_audioProperty.SupportedSampleFormats, m_audioProperty.CurrentSampleFormat, requestedFormat->FormatType);
; 1314 :         if ((requestedFormat->FormatType == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	cmp	DWORD PTR [r8], 0
	jne	SHORT $LN27@future
	test	BYTE PTR [rcx+3284], 33			; 00000021H
	je	SHORT $LN27@future
$LN110@future:

; 1315 :         {
; 1316 :             return ASE_SUCCESS;

	mov	eax, 1061701536				; 3f4847a0H

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN105@future:

; 1288 :         }
; 1289 :     }
; 1290 :     case kAsioGetIoFormat: {
; 1291 :         if (option == nullptr)

	test	rdi, rdi
	je	SHORT $LN27@future

; 1292 :         {
; 1293 :             return ASE_NotPresent;
; 1294 :         }
; 1295 :         ASIOIoFormat * requestedFormat = (ASIOIoFormat *)option;
; 1296 :         info_print_("kAsioGetIoFormat request. Device supported 0x%x, current %u.\n", m_audioProperty.SupportedSampleFormats, m_audioProperty.CurrentSampleFormat);
; 1297 :         if ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0)

	test	BYTE PTR [rcx+3284], 33			; 00000021H
	je	SHORT $LN27@future

; 1298 :         {
; 1299 :             requestedFormat->FormatType = m_requestedSampleFormat;

	mov	eax, DWORD PTR [rcx+3464]

; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	DWORD PTR [r8], eax
	mov	eax, 1061701536				; 3f4847a0H
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
	npad	1
$LN112@future:
	DD	$LN27@future
	DD	$LN110@future
$LN111@future:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
?future@CUSBAsio@@UEAAJJPEAX@Z ENDP			; CUSBAsio::future
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?BufferSwitch@CUSBAsio@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?BufferSwitch@CUSBAsio@@QEAAXXZ PROC			; CUSBAsio::BufferSwitch, COMDAT

; 1355 : {

$LN14:
	push	rdi
	sub	rsp, 32					; 00000020H

; 1356 :     if (m_isStarted && m_callbacks)

	cmp	BYTE PTR [rcx+2825], 0
	mov	rdi, rcx
	je	$LN2@BufferSwit
	cmp	QWORD PTR [rcx+48], 0
	je	$LN2@BufferSwit

; 101  :     double nanoSeconds = (double)((unsigned long)timeGetTime()) * 1000000.;

	call	QWORD PTR __imp_timeGetTime
	mov	eax, eax
	xorps	xmm1, xmm1
	cvtsi2sd xmm1, rax
	mulsd	xmm1, QWORD PTR __real@412e848000000000

; 102  :     timeStamp->hi = (unsigned long)(nanoSeconds / c_TwoRaisedTo32);

	movaps	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3df0000000000000
	cvttsd2si rax, xmm0
	xorps	xmm0, xmm0
	mov	DWORD PTR [rdi+204], eax

; 103  :     timeStamp->lo = (unsigned long)(nanoSeconds - (timeStamp->hi * c_TwoRaisedTo32));

	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@41f0000000000000
	subsd	xmm1, xmm0
	cvttsd2si rax, xmm1
	mov	DWORD PTR [rdi+208], eax

; 1357 :     {
; 1358 :         getNanoSeconds(&m_theSystemTime); // latch system time
; 1359 :         m_samplePosition += m_blockFrames;
; 1360 :         if (m_isTimeInfoMode)

	cmp	BYTE PTR [rdi+2826], 0
	movd	xmm0, DWORD PTR [rdi+2800]
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR [rdi+32]
	movsd	QWORD PTR [rdi+32], xmm0
	je	SHORT $LN3@BufferSwit

; 1374 :     getSamplePosition(&m_asioTime.timeInfo.samplePosition, &m_asioTime.timeInfo.systemTime);

	mov	rax, QWORD PTR [rdi]
	lea	r8, QWORD PTR [rdi+80]
	lea	rdx, QWORD PTR [rdi+88]

; 1357 :     {
; 1358 :         getNanoSeconds(&m_theSystemTime); // latch system time
; 1359 :         m_samplePosition += m_blockFrames;
; 1360 :         if (m_isTimeInfoMode)

	mov	QWORD PTR [rsp+48], rbx

; 1374 :     getSamplePosition(&m_asioTime.timeInfo.samplePosition, &m_asioTime.timeInfo.systemTime);

	mov	rcx, rdi
	call	QWORD PTR [rax+136]

; 1375 :     m_callbacks->bufferSwitchTimeInfo(&m_asioTime, m_toggle, ASIOTrue);

	mov	rax, QWORD PTR [rdi+48]
	lea	rcx, QWORD PTR [rdi+56]
	mov	edx, DWORD PTR [rdi+2820]
	mov	r8d, 1
	mov	r9, QWORD PTR [rax+24]
	call	r9

; 1376 :     m_asioTime.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);

	and	DWORD PTR [rdi+104], -49		; ffffffcfH
	mov	rbx, QWORD PTR [rsp+48]

; 1361 :         {
; 1362 :             BufferSwitchX();
; 1363 :         }

	jmp	SHORT $LN4@BufferSwit
$LN3@BufferSwit:

; 1364 :         else
; 1365 :         {
; 1366 :             m_callbacks->bufferSwitch(m_toggle, ASIOTrue);

	mov	rax, QWORD PTR [rdi+48]
	mov	edx, 1
	mov	ecx, DWORD PTR [rdi+2820]
	mov	r8, QWORD PTR [rax]
	call	r8
$LN4@BufferSwit:

; 1367 :         }
; 1368 :         m_toggle = m_toggle ? 0 : 1;

	xor	eax, eax
	cmp	DWORD PTR [rdi+2820], eax
	sete	al
	mov	DWORD PTR [rdi+2820], eax
$LN2@BufferSwit:

; 1369 :     }
; 1370 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?BufferSwitch@CUSBAsio@@QEAAXXZ ENDP			; CUSBAsio::BufferSwitch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?BufferSwitchX@CUSBAsio@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?BufferSwitchX@CUSBAsio@@AEAAXXZ PROC			; CUSBAsio::BufferSwitchX, COMDAT

; 1373 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1374 :     getSamplePosition(&m_asioTime.timeInfo.samplePosition, &m_asioTime.timeInfo.systemTime);

	mov	rax, QWORD PTR [rcx]
	lea	r8, QWORD PTR [rcx+80]
	lea	rdx, QWORD PTR [rcx+88]
	mov	rdi, rcx
	call	QWORD PTR [rax+136]

; 1375 :     m_callbacks->bufferSwitchTimeInfo(&m_asioTime, m_toggle, ASIOTrue);

	mov	rax, QWORD PTR [rdi+48]
	lea	rcx, QWORD PTR [rdi+56]
	mov	edx, DWORD PTR [rdi+2820]
	mov	r8d, 1
	mov	r9, QWORD PTR [rax+24]
	call	r9

; 1376 :     m_asioTime.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);

	and	DWORD PTR [rdi+104], -49		; ffffffcfH

; 1377 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?BufferSwitchX@CUSBAsio@@AEAAXXZ ENDP			; CUSBAsio::BufferSwitchX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?GetSupportedSampleFormats@CUSBAsio@@CAKXZ
_TEXT	SEGMENT
?GetSupportedSampleFormats@CUSBAsio@@CAKXZ PROC		; CUSBAsio::GetSupportedSampleFormats, COMDAT

; 1381 :     return ((1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)) | (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT)));

	mov	eax, 33					; 00000021H

; 1382 : }

	ret	0
?GetSupportedSampleFormats@CUSBAsio@@CAKXZ ENDP		; CUSBAsio::GetSupportedSampleFormats
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?outputReady@CUSBAsio@@UEAAJXZ
_TEXT	SEGMENT
this$ = 48
?outputReady@CUSBAsio@@UEAAJXZ PROC			; CUSBAsio::outputReady, COMDAT

; 1385 : {

$LN50:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1386 :     if (!m_isActive)

	cmp	BYTE PTR [rcx+2824], 0
	mov	rbx, rcx
	je	SHORT $LN43@outputRead
	mov	QWORD PTR [rsp+56], rdi

; 1387 :     {
; 1388 :         return ASE_OK;
; 1389 :     }
; 1390 :     auto                                  lockRecBuffer = m_recBufferCS.lock();

	lea	rdi, QWORD PTR [rcx+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1391 :     volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;

	mov	rdx, QWORD PTR [rbx+3632]

; 1392 :     if (recHdr != nullptr)

	test	rdx, rdx
	je	SHORT $LN3@outputRead

; 1393 :     {
; 1394 :         InterlockedOr((LONG *)&recHdr->OutputReady, toInt(UserThreadStatuses::OutputReady));

	lock or	DWORD PTR [rdx+64], 1

; 1395 :         recHdr->PlayReadyPosition = m_playReadyPosition;

	mov	rax, QWORD PTR [rbx+3640]
	mov	QWORD PTR [rdx+48], rax
$LN3@outputRead:

; 1396 :     }
; 1397 :     SetEvent(m_outputReadyEvent);

	mov	rcx, QWORD PTR [rbx+3656]
	call	QWORD PTR __imp_SetEvent

; 1398 :     SetEvent(m_outputReadyBlockEvent);

	mov	rcx, QWORD PTR [rbx+3720]
	call	QWORD PTR __imp_SetEvent

; 1399 :     InterlockedOr(&m_outputReadyBlock, 1);

	lock or	DWORD PTR [rbx+2976], 1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN42@outputRead

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN42@outputRead:
	mov	rdi, QWORD PTR [rsp+56]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1400 :     return ASE_OK;

	xor	eax, eax

; 1401 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN43@outputRead:

; 1400 :     return ASE_OK;

	xor	eax, eax

; 1401 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?outputReady@CUSBAsio@@UEAAJXZ ENDP			; CUSBAsio::outputReady
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?MeasureLatency@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?MeasureLatency@CUSBAsio@@AEAA_NXZ PROC			; CUSBAsio::MeasureLatency, COMDAT

; 1467 :     if (m_activeInputs != 0 || m_activeOutputs != 0)

	cmp	DWORD PTR [rcx+2812], 0
	jne	SHORT $LN3@MeasureLat
	cmp	DWORD PTR [rcx+2816], 0
	jne	SHORT $LN3@MeasureLat

; 1470 :     }
; 1471 : 
; 1472 : #if defined(INFO_PRINT_)
; 1473 :     ULONG classicFramesPerIrp = (m_audioProperty.PacketsPerSec == 1000 ? m_driverFlags.ClassicFramesPerIrp : m_driverFlags.ClassicFramesPerIrp2);
; 1474 : #endif
; 1475 : 
; 1476 :     m_inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	mov	edx, DWORD PTR [rcx+2800]
	mov	r8d, DWORD PTR [rcx+3308]

; 1477 : 
; 1478 :     m_outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;

	mov	r9d, DWORD PTR [rcx+3364]
	add	r8d, edx
	add	r9d, edx
	mov	DWORD PTR [rcx+2804], r8d
	mov	DWORD PTR [rcx+2808], r9d

; 1479 : 
; 1480 :     info_print_(" SampleRate = %d, m_blockFrames = %d, ClassicFramesPerIrp = %d, OutFrameDelay = %d, InputLatencyOffset = %d, OutputLatencyOffset = %d\n", m_audioProperty.SampleRate, m_blockFrames, classicFramesPerIrp, m_driverFlags.OutputFrameDelay, m_audioProperty.InputLatencyOffset, m_audioProperty.OutputLatencyOffset);
; 1481 :     info_print_("calculated latency is in:%d, out:%d samples.\n", m_inputLatency, m_outputLatency);
; 1482 : 
; 1483 :     if (m_inputLatency == 0 || m_outputLatency == 0)

	test	r8d, r8d
	je	SHORT $LN6@MeasureLat
	test	r9d, r9d
	jne	SHORT $LN3@MeasureLat
$LN6@MeasureLat:

; 1484 :     {
; 1485 :         return false;

	xor	al, al

; 1486 :     }
; 1487 :     else
; 1488 :     {
; 1489 :         return true;
; 1490 :     }
; 1491 : }

	ret	0
$LN3@MeasureLat:

; 1468 :     {
; 1469 :         return true;

	mov	al, 1

; 1486 :     }
; 1487 :     else
; 1488 :     {
; 1489 :         return true;
; 1490 :     }
; 1491 : }

	ret	0
?MeasureLatency@CUSBAsio@@AEAA_NXZ ENDP			; CUSBAsio::MeasureLatency
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?ApplySettings@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
hKey$ = 64
size$ = 72
temp$ = 76
bytesReturned$2 = 80
privateProperty$3 = 88
setFlagsContext$4 = 112
__$ArrayPad$ = 176
this$ = 208
?ApplySettings@CUSBAsio@@AEAA_NXZ PROC			; CUSBAsio::ApplySettings, COMDAT

; 1494 : {

$LN39:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	lea	rbp, QWORD PTR [rsp-87]
	sub	rsp, 192				; 000000c0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax

; 1495 :     LONG  result;
; 1496 :     HKEY  hKey;
; 1497 :     ULONG temp;
; 1498 :     DWORD size;
; 1499 : 
; 1500 :     // default values
; 1501 :     m_fixedSamplingRate = 0;

	xor	edi, edi

; 1502 :     m_blockFrames = UAC_DEFAULT_ASIO_BUFFER_SIZE;

	mov	DWORD PTR [rcx+2800], 512		; 00000200H
	mov	DWORD PTR [rcx+3460], edi

; 1503 :     m_driverFlags.FirstPacketLatency = UAC_DEFAULT_FIRST_PACKET_LATENCY;
; 1504 :     m_driverFlags.ClassicFramesPerIrp = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1505 :     m_driverFlags.MaxIrpNumber = UAC_DEFAULT_MAX_IRP_NUMBER;
; 1506 :     m_driverFlags.PreSendFrames = UAC_DEFAULT_PRE_SEND_FRAMES;
; 1507 :     m_driverFlags.OutputFrameDelay = UAC_DEFAULT_OUTPUT_FRAME_DELAY;
; 1508 :     m_driverFlags.DelayedOutputBufferSwitch = UAC_DEFAULT_DELAYED_OUTPUT_BUFFER_SWITCH;
; 1509 :     m_driverFlags.InputBufferOperationOffset = UAC_DEFAULT_IN_BUFFER_OPERATION_OFFSET;
; 1510 :     m_driverFlags.InputHubOffset = UAC_DEFAULT_IN_HUB_OFFSET;
; 1511 :     m_driverFlags.OutputBufferOperationOffset = UAC_DEFAULT_OUT_BUFFER_OPERATION_OFFSET;
; 1512 :     m_driverFlags.OutputHubOffset = UAC_DEFAULT_OUT_HUB_OFFSET;
; 1513 :     m_driverFlags.BufferThreadPriority = UAC_DEFAULT_BUFFER_THREAD_PRIORITY;
; 1514 :     m_driverFlags.ClassicFramesPerIrp2 = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1515 :     m_driverFlags.SuggestedBufferPeriod = UAC_DEFAULT_ASIO_BUFFER_SIZE;
; 1516 :     m_threadPriority = 2;
; 1517 :     m_isDropoutDetectionSetting = UAC_DEFAULT_DROPOUT_DETECTION;
; 1518 : 
; 1519 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	lea	rax, QWORD PTR hKey$[rbp-105]
	mov	QWORD PTR [rcx+3416], rdi
	lea	rdx, OFFSET FLAT:??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@
	mov	DWORD PTR [rcx+3432], edi
	mov	rbx, rcx
	mov	DWORD PTR [rcx+3440], edi
	mov	r9d, 131097				; 00020019H
	mov	DWORD PTR [rcx+3400], 20
	xor	r8d, r8d
	mov	DWORD PTR [rcx+3404], 4
	mov	QWORD PTR [rcx+3408], 4
	mov	DWORD PTR [rcx+3428], -1879048192	; 90000000H
	mov	DWORD PTR [rcx+3436], -1879048188	; 90000004H
	mov	DWORD PTR [rcx+3444], 30
	mov	DWORD PTR [rcx+3448], 4
	mov	DWORD PTR [rcx+3452], 512		; 00000200H
	mov	DWORD PTR [rcx+3688], 2
	mov	BYTE PTR [rcx+2969], 1
	mov	rcx, -2147483647			; ffffffff80000001H
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_RegOpenKeyExA

; 1520 : 
; 1521 :     if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	$LN2@ApplySetti

; 1522 :     {
; 1523 :         size = sizeof(ULONG);
; 1524 :         result = RegQueryValueEx(hKey, c_FixedSamplingRateValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BC@CNPFEPCO@FixedSamplingRate@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1525 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN3@ApplySetti

; 1526 :         {
; 1527 :             m_fixedSamplingRate = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3460], eax
$LN3@ApplySetti:

; 1528 :         }
; 1529 : 
; 1530 :         size = sizeof(ULONG);
; 1531 :         result = RegQueryValueEx(hKey, c_PeriodFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0N@FDBGAPPM@PeriodFrames@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1532 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN4@ApplySetti

; 1533 :         {
; 1534 :             m_blockFrames = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+2800], eax
$LN4@ApplySetti:

; 1535 :         }
; 1536 : 
; 1537 :         size = sizeof(ULONG);
; 1538 :         result = RegQueryValueEx(hKey, c_FirstPacketLatencyValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BD@JPDMMNEG@FirstPacketLatency@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1539 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN5@ApplySetti

; 1540 :         {
; 1541 :             m_driverFlags.FirstPacketLatency = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3400], eax
$LN5@ApplySetti:

; 1542 :         }
; 1543 :         size = sizeof(ULONG);
; 1544 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrpValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1545 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN6@ApplySetti

; 1546 :         {
; 1547 :             m_driverFlags.ClassicFramesPerIrp = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3404], eax
$LN6@ApplySetti:

; 1548 :         }
; 1549 :         size = sizeof(ULONG);
; 1550 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrp2ValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1551 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN7@ApplySetti

; 1552 :         {
; 1553 :             m_driverFlags.ClassicFramesPerIrp2 = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3448], eax
$LN7@ApplySetti:

; 1554 :         }
; 1555 : 
; 1556 :         size = sizeof(ULONG);
; 1557 :         result = RegQueryValueEx(hKey, c_MaxIrpNumberValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0N@BNFIBEN@MaxIrpNumber@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1558 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN8@ApplySetti

; 1559 :         {
; 1560 :             m_driverFlags.MaxIrpNumber = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3408], eax
$LN8@ApplySetti:

; 1561 :         }
; 1562 : 
; 1563 :         size = sizeof(ULONG);
; 1564 :         result = RegQueryValueEx(hKey, c_PreSendFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0O@DDKFKBEA@PreSendFrames@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1565 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN9@ApplySetti

; 1566 :         {
; 1567 :             m_driverFlags.PreSendFrames = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3412], eax
$LN9@ApplySetti:

; 1568 :         }
; 1569 : 
; 1570 :         size = sizeof(ULONG);
; 1571 :         result = RegQueryValueEx(hKey, c_OutputFrameDelayValueName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BB@PIAJBBGI@OutputFrameDelay@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1572 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN10@ApplySetti

; 1573 :         {
; 1574 :             m_driverFlags.OutputFrameDelay = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3416], eax
$LN10@ApplySetti:

; 1575 :         }
; 1576 : 
; 1577 :         size = sizeof(ULONG);
; 1578 :         result = RegQueryValueEx(hKey, c_DelayedOutputBufferSwitchName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1579 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN11@ApplySetti

; 1580 :         {
; 1581 :             m_driverFlags.DelayedOutputBufferSwitch = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3420], eax
$LN11@ApplySetti:

; 1582 :         }
; 1583 : 
; 1584 :         size = sizeof(ULONG);
; 1585 :         result = RegQueryValueEx(hKey, c_InputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BI@IIKKMOIC@InBufferOperationOffset@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1586 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN12@ApplySetti

; 1587 :         {
; 1588 :             m_driverFlags.InputBufferOperationOffset = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3428], eax
$LN12@ApplySetti:

; 1589 :         }
; 1590 : 
; 1591 :         size = sizeof(ULONG);
; 1592 :         result = RegQueryValueEx(hKey, c_InputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0M@IIIMLOLG@InHubOffset@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1593 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN13@ApplySetti

; 1594 :         {
; 1595 :             m_driverFlags.InputHubOffset = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3432], eax
$LN13@ApplySetti:

; 1596 :         }
; 1597 : 
; 1598 :         size = sizeof(ULONG);
; 1599 :         result = RegQueryValueEx(hKey, c_OutputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1600 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN14@ApplySetti

; 1601 :         {
; 1602 :             m_driverFlags.OutputBufferOperationOffset = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3436], eax
$LN14@ApplySetti:

; 1603 :         }
; 1604 : 
; 1605 :         size = sizeof(ULONG);
; 1606 :         result = RegQueryValueEx(hKey, c_OutputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0N@DLKKJNAP@OutHubOffset@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1607 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN15@ApplySetti

; 1608 :         {
; 1609 :             m_driverFlags.OutputHubOffset = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3440], eax
$LN15@ApplySetti:

; 1610 :         }
; 1611 : 
; 1612 :         size = sizeof(ULONG);
; 1613 :         result = RegQueryValueEx(hKey, c_BufferThreadPriorityName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BF@BAAHAIB@BufferThreadPriority@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1614 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN16@ApplySetti

; 1615 :         {
; 1616 :             m_driverFlags.BufferThreadPriority = temp;

	mov	eax, DWORD PTR temp$[rbp-105]
	mov	DWORD PTR [rbx+3444], eax
$LN16@ApplySetti:

; 1617 :         }
; 1618 : 
; 1619 :         size = sizeof(ULONG);
; 1620 :         result = RegQueryValueEx(hKey, c_DropoutDetectionName, 0, nullptr, (PBYTE)&temp, &size);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	lea	rax, QWORD PTR size$[rbp-105]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BB@GLAIOBJJ@DropoutDetection@
	lea	rax, QWORD PTR temp$[rbp-105]
	mov	DWORD PTR size$[rbp-105], 4
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1621 :         if (result == ERROR_SUCCESS)

	test	eax, eax
	jne	SHORT $LN17@ApplySetti

; 1622 :         {
; 1623 :             m_isDropoutDetectionSetting = temp != 0;

	cmp	DWORD PTR temp$[rbp-105], edi
	setne	al
	mov	BYTE PTR [rbx+2969], al
$LN17@ApplySetti:

; 1624 :         }
; 1625 : 
; 1626 :         m_driverFlags.SuggestedBufferPeriod = m_blockFrames;

	mov	eax, DWORD PTR [rbx+2800]

; 1627 : 
; 1628 :         RegCloseKey(hKey);

	mov	rcx, QWORD PTR hKey$[rbp-105]
	mov	DWORD PTR [rbx+3452], eax
	call	QWORD PTR __imp_RegCloseKey
$LN2@ApplySetti:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 315  :     UAC_SET_FLAGS_CONTEXT setFlagsContext = flags;

	movups	xmm0, XMMWORD PTR [rbx+3400]
	mov	eax, DWORD PTR [rbx+3456]

; 316  : 
; 317  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;
; 318  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 319  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetFlags);
; 320  : 
; 321  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setFlagsContext, sizeof(UAC_SET_FLAGS_CONTEXT), &bytesReturned, nullptr);

	mov	r9d, 24
	movups	xmm1, XMMWORD PTR [rbx+3416]
	mov	rcx, QWORD PTR [rbx+2984]
	lea	r8, QWORD PTR privateProperty$3[rbp-105]
	movups	XMMWORD PTR setFlagsContext$4[rbp-105], xmm0
	mov	DWORD PTR setFlagsContext$4[rbp-49], eax
	lea	rax, QWORD PTR bytesReturned$2[rbp-105]
	movups	xmm0, XMMWORD PTR [rbx+3432]
	mov	QWORD PTR [rsp+56], rdi
	mov	edx, 3080195				; 002f0003H
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR setFlagsContext$4[rbp-105]
	movups	XMMWORD PTR setFlagsContext$4[rbp-73], xmm0
	mov	DWORD PTR [rsp+40], 60			; 0000003cH
	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	mov	DWORD PTR bytesReturned$2[rbp-105], edi
	movups	XMMWORD PTR setFlagsContext$4[rbp-89], xmm1
	mov	DWORD PTR privateProperty$3[rbp-85], 2
	movsd	xmm1, QWORD PTR [rbx+3448]
	movups	XMMWORD PTR privateProperty$3[rbp-105], xmm0
	mov	DWORD PTR privateProperty$3[rbp-89], 5
	movsd	QWORD PTR setFlagsContext$4[rbp-57], xmm1
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1631 :     if (!SetFlags(m_usbDeviceHandle, m_driverFlags))

	test	eax, eax
	setne	al

; 1632 :     {
; 1633 :         info_print_("set flags failed.\n");
; 1634 :         return false;
; 1635 :     }
; 1636 :     return true;
; 1637 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rbp
	ret	0
?ApplySettings@CUSBAsio@@AEAA_NXZ ENDP			; CUSBAsio::ApplySettings
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
processInfo$ = 80
drive$ = 104
startupInfo$ = 112
path$ = 224
dir$ = 496
__$ArrayPad$ = 752
this$dead$ = 784
?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ PROC		; CUSBAsio::ExecuteControlPanel, COMDAT

; 1640 : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	lea	rbp, QWORD PTR [rsp-512]
	sub	rsp, 768				; 00000300H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 1641 :     TCHAR path[MAX_PATH] = {0};

	xor	edx, edx
	lea	rcx, QWORD PTR path$[rbp-256]
	mov	r8d, 260				; 00000104H
	call	memset

; 1642 :     TCHAR drive[_MAX_DRIVE] = {0};

	xor	eax, eax

; 1643 :     TCHAR dir[_MAX_DIR] = {0};

	lea	rcx, QWORD PTR dir$[rbp-256]
	xor	edx, edx
	mov	WORD PTR drive$[rsp], ax
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR drive$[rsp+2], al
	call	memset

; 1644 : 
; 1645 :     GetModuleFileNameEx(GetCurrentProcess(), GetModuleHandle(ASIODRV_NAME), path, MAX_PATH);

	lea	rcx, OFFSET FLAT:??_C@_0M@BFGLKKGE@USBAsio?4dll@
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rbx, rax
	call	QWORD PTR __imp_GetCurrentProcess
	mov	r9d, 260				; 00000104H
	lea	r8, QWORD PTR path$[rbp-256]
	mov	rcx, rax
	mov	rdx, rbx
	call	QWORD PTR __imp_K32GetModuleFileNameExA

; 1646 :     _tsplitpath_s(path, drive, _MAX_DRIVE, dir, _MAX_DIR, nullptr, 0, nullptr, 0);

	xor	ebx, ebx
	lea	r9, QWORD PTR dir$[rbp-256]
	mov	QWORD PTR [rsp+64], rbx
	lea	rdx, QWORD PTR drive$[rsp]
	mov	QWORD PTR [rsp+56], rbx
	lea	rcx, QWORD PTR path$[rbp-256]
	mov	QWORD PTR [rsp+48], rbx
	mov	r8d, 3
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], 256			; 00000100H
	call	_splitpath_s

; 1647 :     _stprintf_s(path, MAX_PATH, TEXT("%s%s%s"), drive, dir, CONTROLPANELPROGRAMNAME);

	lea	rax, OFFSET FLAT:??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@
	mov	edx, 260				; 00000104H
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR drive$[rsp]
	lea	rax, QWORD PTR dir$[rbp-256]
	lea	r8, OFFSET FLAT:??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
	mov	QWORD PTR [rsp+32], rax
	lea	rcx, QWORD PTR path$[rbp-256]
	call	sprintf_s
	xorps	xmm0, xmm0

; 1648 : 
; 1649 :     STARTUPINFO startupInfo;
; 1650 :     ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
; 1651 :     startupInfo.cb = sizeof(STARTUPINFO);

	mov	DWORD PTR startupInfo$[rsp], 104	; 00000068H
	xor	eax, eax

; 1652 : 
; 1653 :     PROCESS_INFORMATION processInfo{};
; 1654 : 
; 1655 :     CreateProcess(

	lea	rcx, QWORD PTR path$[rbp-256]
	mov	DWORD PTR startupInfo$[rbp-156], eax
	xor	r9d, r9d
	mov	QWORD PTR processInfo$[rsp+16], rax
	xor	r8d, r8d
	lea	rax, QWORD PTR processInfo$[rsp]
	xor	edx, edx
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR startupInfo$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rbx
	mov	QWORD PTR [rsp+48], rbx
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	DWORD PTR [rsp+32], ebx
	movups	XMMWORD PTR startupInfo$[rsp+4], xmm0
	movups	XMMWORD PTR startupInfo$[rbp-236], xmm0
	movups	XMMWORD PTR startupInfo$[rbp-220], xmm0
	movups	XMMWORD PTR startupInfo$[rbp-204], xmm0
	movups	XMMWORD PTR startupInfo$[rbp-188], xmm0
	movups	XMMWORD PTR startupInfo$[rbp-172], xmm0
	movups	XMMWORD PTR processInfo$[rsp], xmm0
	call	QWORD PTR __imp_CreateProcessA

; 1656 :         path,
; 1657 :         nullptr,
; 1658 :         nullptr,
; 1659 :         nullptr,
; 1660 :         FALSE,
; 1661 :         NORMAL_PRIORITY_CLASS,
; 1662 :         nullptr,
; 1663 :         nullptr,
; 1664 :         &startupInfo,
; 1665 :         &processInfo
; 1666 :     );
; 1667 : 
; 1668 :     CloseHandle(processInfo.hThread);

	mov	rcx, QWORD PTR processInfo$[rsp+8]
	call	QWORD PTR __imp_CloseHandle

; 1669 :     CloseHandle(processInfo.hProcess);

	mov	rcx, QWORD PTR processInfo$[rsp]
	call	QWORD PTR __imp_CloseHandle

; 1670 :     return true;

	mov	al, 1

; 1671 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+784]
	add	rsp, 768				; 00000300H
	pop	rbp
	ret	0
?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ ENDP		; CUSBAsio::ExecuteControlPanel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?GetDesiredPath@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
size$ = 48
hKey$ = 56
__$ArrayPad$ = 64
this$ = 96
?GetDesiredPath@CUSBAsio@@AEAA_NXZ PROC			; CUSBAsio::GetDesiredPath, COMDAT

; 1674 : {

$LN15:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx

; 1675 :     LONG  result;
; 1676 :     DWORD size;
; 1677 :     HKEY  hKey;
; 1678 : 
; 1679 :     if (m_desiredPath != nullptr)

	mov	rcx, QWORD PTR [rcx+2280]
	test	rcx, rcx
	je	SHORT $LN2@GetDesired

; 1680 :     {
; 1681 :         delete[] m_desiredPath;

	call	??_V@YAXPEAX@Z				; operator delete[]

; 1682 :         m_desiredPath = nullptr;

	mov	QWORD PTR [rbx+2280], 0
$LN2@GetDesired:

; 1683 :     }
; 1684 : 
; 1685 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	lea	rax, QWORD PTR hKey$[rsp]
	mov	r9d, 131097				; 00020019H
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, OFFSET FLAT:??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@
	mov	rcx, -2147483647			; ffffffff80000001H
	call	QWORD PTR __imp_RegOpenKeyExA

; 1686 :     if (result != ERROR_SUCCESS)

	test	eax, eax
	jne	$LN13@GetDesired

; 1687 :     {
; 1688 :         return false;
; 1689 :     }
; 1690 : 
; 1691 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, nullptr, &size);

	mov	rcx, QWORD PTR hKey$[rsp]
	lea	rax, QWORD PTR size$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0L@ONBBLLLB@AsioDevice@
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	xor	r8d, r8d
	call	QWORD PTR __imp_RegQueryValueExA

; 1692 :     if (result != ERROR_SUCCESS || size == 0)

	test	eax, eax
	jne	$LN5@GetDesired
	mov	eax, DWORD PTR size$[rsp]
	test	eax, eax
	je	SHORT $LN5@GetDesired

; 1695 :         return false;
; 1696 :     }
; 1697 : 
; 1698 :     m_desiredPath = new TCHAR[size / sizeof(TCHAR)];

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 1699 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, (LPBYTE)m_desiredPath, &size);

	lea	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rbx+2280], rax
	mov	QWORD PTR [rsp+40], rcx
	lea	rdx, OFFSET FLAT:??_C@_0L@ONBBLLLB@AsioDevice@
	mov	rcx, QWORD PTR hKey$[rsp]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_RegQueryValueExA

; 1700 :     if (result != ERROR_SUCCESS)

	mov	rcx, QWORD PTR hKey$[rsp]
	test	eax, eax
	je	SHORT $LN6@GetDesired

; 1701 :     {
; 1702 :         RegCloseKey(hKey);

	call	QWORD PTR __imp_RegCloseKey

; 1703 :         delete[] m_desiredPath;

	mov	rcx, QWORD PTR [rbx+2280]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 1704 :         m_desiredPath = nullptr;

	mov	QWORD PTR [rbx+2280], 0

; 1705 :         return false;

	jmp	SHORT $LN13@GetDesired
$LN6@GetDesired:

; 1706 :     }
; 1707 : 
; 1708 :     RegCloseKey(hKey);

	call	QWORD PTR __imp_RegCloseKey

; 1709 : 
; 1710 :     info_print_(_T("ASIO device path : %s\n"), m_desiredPath);
; 1711 : 
; 1712 :     return true;

	mov	al, 1

; 1713 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN5@GetDesired:

; 1693 :     {
; 1694 :         RegCloseKey(hKey);

	mov	rcx, QWORD PTR hKey$[rsp]
	call	QWORD PTR __imp_RegCloseKey
$LN13@GetDesired:

; 1713 : }

	xor	al, al
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?GetDesiredPath@CUSBAsio@@AEAA_NXZ ENDP			; CUSBAsio::GetDesiredPath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
lockDevice$ = 64
bytesReturned$19 = 72
bytesReturned$20 = 72
bytesReturned$21 = 72
bytesReturned$22 = 72
privateProperty$23 = 80
privateProperty$24 = 80
privateProperty$25 = 80
privateProperty$26 = 80
messageString$27 = 112
messageString$28 = 112
__$ArrayPad$ = 240
this$ = 304
?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ PROC		; CUSBAsio::ObtainDeviceParameter, COMDAT

; 1716 : {

$LN174:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 256				; 00000100H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-201], rax
	mov	rbx, rcx

; 1717 :     int  bufferCoefficient = 1;

	mov	edi, 1

; 1718 :     bool isLatencyMeasured = true;
; 1719 :     BOOL result = TRUE;
; 1720 : 
; 1721 :     auto lockDevice = m_deviceInfoCS.lock();

	lea	r15, QWORD PTR [rcx+3496]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, r15
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockDevice$[rsp], r15
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1724 :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	xor	r13d, r13d
	mov	r14d, r13d
	lea	r12, QWORD PTR [rbx+2992]
$LN170@ObtainDevi:

; 1725 :     {
; 1726 :         if (m_channelInfo != nullptr)

	mov	edx, 16
	mov	rcx, QWORD PTR [rbx+3480]
	test	rcx, rcx
	je	SHORT $LN5@ObtainDevi

; 1727 :         {
; 1728 :             delete[] ((UCHAR *)m_channelInfo);

	call	??_V@YAXPEAX@Z				; operator delete[]

; 1729 :             m_channelInfo = nullptr;

	mov	QWORD PTR [rbx+3480], r13
	mov	edx, 16
$LN5@ObtainDevi:

; 1730 :         }
; 1731 :         m_inputLatency = 0;

	mov	QWORD PTR [rbx+2804], r13

; 1732 :         m_outputLatency = 0;
; 1733 : 
; 1734 :         if (m_audioProperty.SampleRate > 50000 && m_audioProperty.SampleRate < 99999)

	mov	ecx, DWORD PTR [rbx+3260]
	cmp	ecx, 50000				; 0000c350H
	jbe	SHORT $LN6@ObtainDevi
	cmp	ecx, 99999				; 0001869fH
	jae	SHORT $LN6@ObtainDevi

; 1735 :         {
; 1736 :             bufferCoefficient = 2;

	mov	edi, 2

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN9@ObtainDevi
$LN6@ObtainDevi:

; 1737 :         }
; 1738 :         if (m_audioProperty.SampleRate > 100000 && m_audioProperty.SampleRate < 199999)

	lea	eax, DWORD PTR [rcx-100001]
	cmp	eax, 99997				; 0001869dH
	ja	SHORT $LN7@ObtainDevi

; 1739 :         {
; 1740 :             bufferCoefficient = 4;

	mov	edi, 4

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN9@ObtainDevi
$LN7@ObtainDevi:

; 1741 :         }
; 1742 :         if (m_audioProperty.SampleRate > 200000 && m_audioProperty.SampleRate < 399999)

	lea	eax, DWORD PTR [rcx-200001]
	cmp	eax, 199997				; 00030d3dH
	ja	SHORT $LN8@ObtainDevi

; 1743 :         {
; 1744 :             bufferCoefficient = 8;

	mov	edi, 8

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN9@ObtainDevi
$LN8@ObtainDevi:

; 1745 :         }
; 1746 :         if (m_audioProperty.SampleRate > 400000)

	cmp	ecx, 400000				; 00061a80H
	cmova	edi, edx
$LN9@ObtainDevi:

; 1747 :         {
; 1748 :             bufferCoefficient = 16;
; 1749 :         }
; 1750 :         m_blockFrames /= bufferCoefficient;

	mov	eax, DWORD PTR [rbx+2800]
	cdq
	idiv	edi
	mov	DWORD PTR [rbx+2800], eax
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 175  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$19[rsp], r13d

; 176  : 
; 177  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$23[rbp-201], xmm0

; 178  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;

	mov	DWORD PTR privateProperty$23[rbp-181], 1

; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);

	mov	DWORD PTR privateProperty$23[rbp-185], r13d

; 180  : 
; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r13
	lea	rax, QWORD PTR bytesReturned$19[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 408			; 00000198H
	mov	QWORD PTR [rsp+32], r12
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$23[rbp-201]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1753 :         if (!result || !m_audioProperty.IsAccessible)

	test	eax, eax
	je	$LN152@ObtainDevi
	cmp	BYTE PTR [rbx+3396], r13b
	je	$LN152@ObtainDevi

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	cmp	DWORD PTR [rbx+3292], 1
	jae	SHORT $LN162@ObtainDevi
	cmp	DWORD PTR [rbx+3340], 1
	jb	$LN152@ObtainDevi
$LN162@ObtainDevi:

; 1765 :         {
; 1766 :             TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 1767 :             LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));
; 1768 :             _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);
; 1769 :             ReleaseAsioOwnership(m_usbDeviceHandle);
; 1770 :             CloseHandle(m_usbDeviceHandle);
; 1771 :             m_usbDeviceHandle = INVALID_HANDLE_VALUE;
; 1772 :             return false;
; 1773 :         }
; 1774 :         UCHAR * channelInfoBuffer = nullptr;
; 1775 :         result = GetChannelInfo(m_usbDeviceHandle, (PUAC_GET_CHANNEL_INFO_CONTEXT *)&channelInfoBuffer);

	mov	rsi, QWORD PTR [rbx+2984]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 194  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$22[rsp], r13d

; 195  : 
; 196  :     if (channelInfo == nullptr)
; 197  :     {
; 198  :         return result;
; 199  :     }
; 200  : 
; 201  :     *channelInfo = {};

	mov	rdi, r13

; 202  : 
; 203  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$26[rbp-201], xmm0

; 204  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;

	mov	DWORD PTR privateProperty$26[rbp-181], 1

; 205  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetChannelInfo);

	mov	DWORD PTR privateProperty$26[rbp-185], 1

; 206  : 
; 207  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r13
	lea	rax, QWORD PTR bytesReturned$22[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], r13d
	mov	QWORD PTR [rsp+32], r13
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$26[rbp-201]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, rsi
	call	QWORD PTR __imp_DeviceIoControl

; 208  : 
; 209  :     if (!result)

	test	eax, eax
	jne	SHORT $LN78@ObtainDevi

; 210  :     {
; 211  :         DWORD error = GetLastError();

	call	QWORD PTR __imp_GetLastError

; 212  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CHANNEL_INFO_CONTEXT)))

	cmp	eax, 234				; 000000eaH
	jne	$LN152@ObtainDevi
	mov	eax, DWORD PTR bytesReturned$22[rsp]
	cmp	eax, 84					; 00000054H
	jb	$LN152@ObtainDevi

; 213  :         {
; 214  :             *channelInfo = (PUAC_GET_CHANNEL_INFO_CONTEXT)(new BYTE[bytesReturned]);

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	rdi, rax

; 215  :             if (channelInfo != nullptr)
; 216  :             {
; 217  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *channelInfo, bytesReturned, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r13
	lea	rax, QWORD PTR bytesReturned$22[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	edx, DWORD PTR bytesReturned$22[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	QWORD PTR [rsp+32], rdi
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$26[rbp-201]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, rsi
	call	QWORD PTR __imp_DeviceIoControl

; 218  :                 if (!result)

	test	eax, eax
	je	$LN164@ObtainDevi
$LN78@ObtainDevi:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1778 :             m_channelInfo = (PUAC_GET_CHANNEL_INFO_CONTEXT)channelInfoBuffer;

	mov	QWORD PTR [rbx+3480], rdi

; 1779 :         }
; 1780 :         else
; 1781 :         {
; 1782 :             TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 1783 :             LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));
; 1784 :             _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);
; 1785 :             ReleaseAsioOwnership(m_usbDeviceHandle);
; 1786 :             CloseHandle(m_usbDeviceHandle);
; 1787 :             m_usbDeviceHandle = INVALID_HANDLE_VALUE;
; 1788 :             return false;
; 1789 :         }
; 1790 : 
; 1791 :         bufferCoefficient = 1;
; 1792 :         if (m_audioProperty.SampleRate > 50000 && m_audioProperty.SampleRate < 99999)

	mov	ecx, DWORD PTR [rbx+3260]
	cmp	ecx, 50000				; 0000c350H
	jbe	SHORT $LN15@ObtainDevi
	cmp	ecx, 99999				; 0001869fH
	jae	SHORT $LN15@ObtainDevi

; 1793 :         {
; 1794 :             bufferCoefficient = 2;

	mov	edi, 2

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN18@ObtainDevi
$LN15@ObtainDevi:

; 1795 :         }
; 1796 :         if (m_audioProperty.SampleRate > 100000 && m_audioProperty.SampleRate < 199999)

	lea	eax, DWORD PTR [rcx-100001]
	cmp	eax, 99997				; 0001869dH
	ja	SHORT $LN16@ObtainDevi

; 1797 :         {
; 1798 :             bufferCoefficient = 4;

	mov	edi, 4

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN18@ObtainDevi
$LN16@ObtainDevi:

; 1799 :         }
; 1800 :         if (m_audioProperty.SampleRate > 200000 && m_audioProperty.SampleRate < 399999)

	mov	eax, ecx
	cmp	ecx, 200000				; 00030d40H
	jbe	SHORT $LN17@ObtainDevi
	cmp	ecx, 399999				; 00061a7fH
	jae	SHORT $LN17@ObtainDevi

; 1801 :         {
; 1802 :             bufferCoefficient = 8;

	mov	edi, 8

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	jmp	SHORT $LN18@ObtainDevi
$LN17@ObtainDevi:

; 1803 :         }
; 1804 :         if (m_audioProperty.SampleRate > 400000)

	mov	edi, 1
	cmp	ecx, 400000				; 00061a80H
	jbe	SHORT $LN18@ObtainDevi

; 1805 :         {
; 1806 :             bufferCoefficient = 16;

	mov	edi, 16
	mov	ecx, eax
$LN18@ObtainDevi:

; 1807 :         }
; 1808 :         m_blockFrames *= bufferCoefficient;

	mov	edx, edi
	imul	edx, DWORD PTR [rbx+2800]
	mov	DWORD PTR [rbx+2800], edx

; 1809 : 
; 1810 :         m_inAvailableChannels = m_audioProperty.InputAsioChannels;

	mov	r9d, DWORD PTR [rbx+3292]
	mov	DWORD PTR [rbx+3468], r9d

; 1811 :         m_outAvailableChannels = m_audioProperty.OutputAsioChannels;

	mov	r10d, DWORD PTR [rbx+3340]
	mov	DWORD PTR [rbx+3472], r10d

; 1812 :         m_sampleRate = (double)m_audioProperty.SampleRate;

	mov	eax, ecx
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	movsd	QWORD PTR [rbx+40], xmm0

; 1467 :     if (m_activeInputs != 0 || m_activeOutputs != 0)

	cmp	DWORD PTR [rbx+2812], r13d
	jne	$LN21@ObtainDevi
	cmp	DWORD PTR [rbx+2816], r13d
	jne	$LN21@ObtainDevi

; 1468 :     {
; 1469 :         return true;
; 1470 :     }
; 1471 : 
; 1472 : #if defined(INFO_PRINT_)
; 1473 :     ULONG classicFramesPerIrp = (m_audioProperty.PacketsPerSec == 1000 ? m_driverFlags.ClassicFramesPerIrp : m_driverFlags.ClassicFramesPerIrp2);
; 1474 : #endif
; 1475 : 
; 1476 :     m_inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	mov	ecx, DWORD PTR [rbx+3308]
	add	ecx, edx
	mov	DWORD PTR [rbx+2804], ecx

; 1477 : 
; 1478 :     m_outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;

	mov	r8d, DWORD PTR [rbx+3364]
	add	r8d, edx
	mov	DWORD PTR [rbx+2808], r8d

; 1479 : 
; 1480 :     info_print_(" SampleRate = %d, m_blockFrames = %d, ClassicFramesPerIrp = %d, OutFrameDelay = %d, InputLatencyOffset = %d, OutputLatencyOffset = %d\n", m_audioProperty.SampleRate, m_blockFrames, classicFramesPerIrp, m_driverFlags.OutputFrameDelay, m_audioProperty.InputLatencyOffset, m_audioProperty.OutputLatencyOffset);
; 1481 :     info_print_("calculated latency is in:%d, out:%d samples.\n", m_inputLatency, m_outputLatency);
; 1482 : 
; 1483 :     if (m_inputLatency == 0 || m_outputLatency == 0)

	test	ecx, ecx
	je	SHORT $LN163@ObtainDevi
	test	r8d, r8d
	jne	$LN21@ObtainDevi
$LN163@ObtainDevi:

; 1813 : 
; 1814 :         isLatencyMeasured = MeasureLatency();
; 1815 :         if (isLatencyMeasured)
; 1816 :         {
; 1817 :             break;
; 1818 :         }
; 1819 :         if (retry < maxRetry - 1)

	cmp	r14d, 5
	jae	SHORT $LN2@ObtainDevi

; 1820 :         {
; 1821 :             Sleep(500);

	mov	ecx, 500				; 000001f4H
	call	QWORD PTR __imp_Sleep
$LN2@ObtainDevi:

; 1724 :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	inc	r14d
	cmp	r14d, 6
	jb	$LN170@ObtainDevi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 468  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$21[rsp], r13d

; 469  : 
; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	movups	XMMWORD PTR privateProperty$25[rbp-201], xmm0

; 471  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$25[rbp-181], 2

; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov	DWORD PTR privateProperty$25[rbp-185], 13

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r13
	lea	rax, QWORD PTR bytesReturned$21[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], r13d
	mov	QWORD PTR [rsp+32], r13
	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$25[rbp-201]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1828 :         CloseHandle(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_CloseHandle

; 1829 :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov	QWORD PTR [rbx+2984], -1
	xorps	xmm0, xmm0

; 1830 :         // >>comment-004<<
; 1831 :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	movups	XMMWORD PTR messageString$28[rbp-201], xmm0
	movups	XMMWORD PTR messageString$28[rbp-185], xmm0
	movups	XMMWORD PTR messageString$28[rbp-169], xmm0
	movups	XMMWORD PTR messageString$28[rbp-153], xmm0
	movups	XMMWORD PTR messageString$28[rbp-137], xmm0
	movups	XMMWORD PTR messageString$28[rbp-121], xmm0
	movups	XMMWORD PTR messageString$28[rbp-105], xmm0
	movups	XMMWORD PTR messageString$28[rbp-89], xmm0

; 1832 :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_LATENCY, messageString, sizeof(messageString) / sizeof(messageString[0]));

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleA
	mov	rcx, rax
	mov	r9d, 128				; 00000080H
	lea	r8, QWORD PTR messageString$28[rbp-201]
	mov	edx, 101				; 00000065H
	call	QWORD PTR __imp_LoadStringA

; 1833 :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	lea	rcx, QWORD PTR [rbx+2828]
	lea	r8, QWORD PTR messageString$28[rbp-201]
	mov	edx, 128				; 00000080H
	call	strcpy_s
	jmp	$LN28@ObtainDevi
$LN164@ObtainDevi:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 220  :                     delete[] (BYTE *)(*channelInfo);

	mov	rcx, rdi
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN152@ObtainDevi:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1756 :             TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	xorps	xmm0, xmm0
	movups	XMMWORD PTR messageString$27[rbp-201], xmm0
	movups	XMMWORD PTR messageString$27[rbp-185], xmm0
	movups	XMMWORD PTR messageString$27[rbp-169], xmm0
	movups	XMMWORD PTR messageString$27[rbp-153], xmm0
	movups	XMMWORD PTR messageString$27[rbp-137], xmm0
	movups	XMMWORD PTR messageString$27[rbp-121], xmm0
	movups	XMMWORD PTR messageString$27[rbp-105], xmm0
	movups	XMMWORD PTR messageString$27[rbp-89], xmm0

; 1757 :             LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	xor	ecx, ecx
	call	QWORD PTR __imp_GetModuleHandleA
	mov	r9d, 128				; 00000080H
	lea	r8, QWORD PTR messageString$27[rbp-201]
	mov	edx, 102				; 00000066H
	mov	rcx, rax
	call	QWORD PTR __imp_LoadStringA

; 1758 :             _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	lea	r8, QWORD PTR messageString$27[rbp-201]
	mov	edx, 128				; 00000080H
	lea	rcx, QWORD PTR [rbx+2828]
	call	strcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r13
	lea	rax, QWORD PTR bytesReturned$20[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], r13d

; 469  : 
; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+32], r13

; 468  :     ULONG      bytesReturned = 0;

	mov	DWORD PTR bytesReturned$20[rsp], r13d

; 469  : 
; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	XMMWORD PTR privateProperty$24[rbp-201], xmm0

; 471  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$24[rbp-181], 2

; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov	DWORD PTR privateProperty$24[rbp-185], 13

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	r9d, 24
	lea	r8, QWORD PTR privateProperty$24[rbp-201]
	mov	edx, 3080195				; 002f0003H
	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1760 :             CloseHandle(m_usbDeviceHandle);

	mov	rcx, QWORD PTR [rbx+2984]
	call	QWORD PTR __imp_CloseHandle

; 1761 :             m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov	QWORD PTR [rbx+2984], -1
$LN28@ObtainDevi:
	xor	bl, bl
$LN29@ObtainDevi:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	r15, r15

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN169@ObtainDevi

; 154  :             close_fn(value);

	mov	rcx, r15
	call	QWORD PTR __imp_LeaveCriticalSection
$LN169@ObtainDevi:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1845 : }

	movzx	eax, bl
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-201]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+256]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN21@ObtainDevi:

; 1834 :         return false;
; 1835 :     }
; 1836 :     if (m_inAvailableChannels > NUMOFINPUTS)

	cmp	r9d, 64					; 00000040H
	jbe	SHORT $LN22@ObtainDevi

; 1837 :     {
; 1838 :         m_inAvailableChannels = NUMOFINPUTS;

	mov	DWORD PTR [rbx+3468], 64		; 00000040H
$LN22@ObtainDevi:

; 1839 :     }
; 1840 :     if (m_outAvailableChannels > NUMOFOUTPUTS)

	cmp	r10d, 64				; 00000040H
	jbe	SHORT $LN23@ObtainDevi

; 1841 :     {
; 1842 :         m_outAvailableChannels = NUMOFOUTPUTS;

	mov	DWORD PTR [rbx+3472], 64		; 00000040H
$LN23@ObtainDevi:

; 1843 :     }
; 1844 :     return true;

	mov	bl, 1
	jmp	SHORT $LN29@ObtainDevi
	int	3
?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ ENDP		; CUSBAsio::ObtainDeviceParameter
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockDevice$ = 64
bytesReturned$19 = 72
bytesReturned$20 = 72
bytesReturned$21 = 72
bytesReturned$22 = 72
privateProperty$23 = 80
privateProperty$24 = 80
privateProperty$25 = 80
privateProperty$26 = 80
messageString$27 = 112
messageString$28 = 112
__$ArrayPad$ = 240
this$ = 304
?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA PROC ; `CUSBAsio::ObtainDeviceParameter'::`1'::dtor$0
	lea	rcx, QWORD PTR lockDevice$[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA ENDP ; `CUSBAsio::ObtainDeviceParameter'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ
_TEXT	SEGMENT
lockClient$ = 32
this$ = 64
?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ PROC		; CUSBAsio::RequestClockInfoChange, COMDAT

; 1848 : {

$LN105:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 1849 :     info_print_("RequestClockInfoChange\n");
; 1850 : 
; 1851 :     auto lockClient = m_clientInfoCS.lock();

	lea	rsi, QWORD PTR [rcx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$[rsp], rsi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1852 :     if (m_isActive)

	cmp	BYTE PTR [rbx+2824], 0
	je	$LN2@RequestClo

; 1853 :     {
; 1854 :         auto lockRecBuffer = m_recBufferCS.lock();

	lea	rbp, QWORD PTR [rbx+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rbp
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1856 :         volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;

	mov	rdi, QWORD PTR [rbx+3632]

; 1857 :         if (recHdr != nullptr && (recHdr->DeviceStatus & toInt(DeviceStatuses::SampleRateChanged)) != 0 && recHdr->CurrentSampleRate != 0)

	test	rdi, rdi
	je	SHORT $LN5@RequestClo
	mov	eax, DWORD PTR [rdi+4]
	test	al, 2
	je	SHORT $LN4@RequestClo
	mov	eax, DWORD PTR [rdi+8]
	test	eax, eax
	je	SHORT $LN4@RequestClo

; 1858 :         {
; 1859 :             m_requireSampleRateChange = true;

	mov	BYTE PTR [rbx+2956], 1

; 1860 :             m_nextSampleRate = (ASIOSampleRate)(recHdr->CurrentSampleRate);

	mov	eax, DWORD PTR [rdi+8]
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	movsd	QWORD PTR [rbx+2960], xmm0

; 1861 :             SetEvent(m_asioResetEvent);

	mov	rcx, QWORD PTR [rbx+3696]
	call	QWORD PTR __imp_SetEvent

; 1862 :             recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::SampleRateChanged));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR [rdi+4], eax
$LN4@RequestClo:

; 1863 :         }
; 1864 :         if (recHdr != nullptr && (recHdr->DeviceStatus & toInt(DeviceStatuses::ResetRequired)) != 0)

	mov	eax, DWORD PTR [rdi+4]
	test	al, 1
	je	SHORT $LN5@RequestClo

; 1865 :         {
; 1866 :             m_isRequireAsioReset = true;

	mov	BYTE PTR [rbx+2968], 1

; 1867 :             SetEvent(m_asioResetEvent);

	mov	rcx, QWORD PTR [rbx+3696]
	call	QWORD PTR __imp_SetEvent

; 1868 :             recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ResetRequired));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR [rdi+4], eax
$LN5@RequestClo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rbp, rbp
	je	SHORT $LN6@RequestClo

; 154  :             close_fn(value);

	mov	rcx, rbp
	call	QWORD PTR __imp_LeaveCriticalSection
$LN6@RequestClo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1881 :     return true;

	mov	bl, 1
$LN10@RequestClo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rsi, rsi
	je	SHORT $LN102@RequestClo

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN102@RequestClo:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1882 : }

	movzx	eax, bl
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@RequestClo:

; 1869 :         }
; 1870 :     }
; 1871 :     else
; 1872 :     {
; 1873 :         // If the fs/clock source is changed before the buffer is acquired, the device information is acquired again and the latency is calculated again.
; 1874 :         bool result = ObtainDeviceParameter();

	mov	rcx, rbx
	call	?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ ; CUSBAsio::ObtainDeviceParameter

; 1875 :         info_print_("ObtainDeviceParameter() completed, result %u, current rate %u, format %u\n", result, m_audioProperty.SampleRate, m_audioProperty.CurrentSampleFormat);
; 1876 :         if (!result)

	test	al, al
	jne	SHORT $LN6@RequestClo
	xor	bl, bl
	jmp	SHORT $LN10@RequestClo
	int	3
?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ ENDP		; CUSBAsio::RequestClockInfoChange
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$ = 32
this$ = 64
?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA PROC ; `CUSBAsio::RequestClockInfoChange'::`1'::dtor$0
	lea	rcx, QWORD PTR lockClient$[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA ENDP ; `CUSBAsio::RequestClockInfoChange'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?AsioResetThread@CUSBAsio@@CAIPEAX@Z
_TEXT	SEGMENT
lockClient$7 = 32
lockClient$8 = 32
handlesForWait$ = 40
__$ArrayPad$ = 56
param$ = 96
?AsioResetThread@CUSBAsio@@CAIPEAX@Z PROC		; CUSBAsio::AsioResetThread, COMDAT

; 1886 : {

$LN107:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rsp+64], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx
	xorps	xmm6, xmm6

; 1887 :     CUSBAsio *     self = (CUSBAsio *)param;
; 1888 :     bool           done = false;
; 1889 :     DWORD          status = 0;
; 1890 :     ASIOSampleRate oldSampleRate = 0;
; 1891 :     ULONG          resetQueue = 0;

	xor	esi, esi

; 1892 :     ULONG          resetExecuted = 0;
; 1893 : 
; 1894 :     InterlockedIncrement(&g_AsioResetThread);

	lock inc DWORD PTR ?g_AsioResetThread@@3JA

; 1895 : 
; 1896 :     info_print_("entering ASIO reset thread instance %d.\n", InterlockedCompareExchange(&g_AsioResetThread, 0, 0));
; 1897 : 
; 1898 :     HANDLE handlesForWait[] = {self->m_terminateAsioResetEvent, self->m_asioResetEvent};

	mov	rax, QWORD PTR [rcx+3704]
	mov	QWORD PTR handlesForWait$[rsp], rax
	mov	rax, QWORD PTR [rcx+3696]
	mov	QWORD PTR handlesForWait$[rsp+8], rax
	npad	6
$LL4@AsioResetT:

; 1899 : 
; 1900 :     do
; 1901 :     {
; 1902 :         if (resetQueue > 0)

	test	esi, esi
	je	SHORT $LN57@AsioResetT

; 1903 :         {
; 1904 :             auto lockClient = self->m_clientInfoCS.lock();

	lea	rdi, QWORD PTR [rbx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$7[rsp], rdi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1905 :             if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	mov	rax, QWORD PTR [rbx+48]
	test	rax, rax
	je	SHORT $LN8@AsioResetT
	mov	r10, QWORD PTR [rax+16]
	test	r10, r10
	je	SHORT $LN8@AsioResetT

; 1906 :             {
; 1907 :                 info_print_("AsioResetThread: ASIO reset callback try %u, thread ID %u.\n", resetExecuted, GetCurrentThreadId());
; 1908 :                 self->m_callbacks->asioMessage(kAsioResetRequest, 0, nullptr, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 3
	call	r10

; 1909 :                 --resetQueue;

	dec	esi
$LN8@AsioResetT:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN57@AsioResetT

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN57@AsioResetT:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1913 :         status = WaitForMultipleObjects(sizeof(handlesForWait) / sizeof(handlesForWait[0]), handlesForWait, FALSE, ASIO_RESET_TIMEOUT);

	mov	r9d, 1000				; 000003e8H
	xor	r8d, r8d
	lea	rdx, QWORD PTR handlesForWait$[rsp]
	mov	ecx, 2
	call	QWORD PTR __imp_WaitForMultipleObjects

; 1914 :         switch (status)

	test	eax, eax
	je	SHORT $LN104@AsioResetT
	sub	eax, 1
	je	SHORT $LN10@AsioResetT
	cmp	eax, 257				; 00000101H
	je	SHORT $LL4@AsioResetT
$LN104@AsioResetT:

; 1962 : 
; 1963 :     info_print_("exiting ASIO reset thread %d.\n", InterlockedCompareExchange(&g_AsioResetThread, 0, 0));
; 1964 :     InterlockedDecrement(&g_AsioResetThread);
; 1965 : 
; 1966 :     return 0;
; 1967 : }

	lock dec DWORD PTR ?g_AsioResetThread@@3JA
	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN10@AsioResetT:

; 1915 :         {
; 1916 :         case WAIT_OBJECT_0:
; 1917 :             done = true;
; 1918 :             break;
; 1919 :         case WAIT_OBJECT_0 + 1:
; 1920 :             if (self->m_requireSampleRateChange)

	cmp	BYTE PTR [rbx+2956], 0
	je	SHORT $LN93@AsioResetT

; 1921 :             {
; 1922 :                 self->m_requireSampleRateChange = false;

	mov	BYTE PTR [rbx+2956], 0

; 1923 :                 auto lockClient = self->m_clientInfoCS.lock();

	lea	rdi, QWORD PTR [rbx+3536]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rdi
	call	QWORD PTR __imp_EnterCriticalSection

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR lockClient$8[rsp], rdi
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1924 :                 if (self->m_callbacks != nullptr && self->m_callbacks->sampleRateDidChange != nullptr && oldSampleRate != self->m_nextSampleRate)

	mov	rax, QWORD PTR [rbx+48]
	test	rax, rax
	je	SHORT $LN12@AsioResetT
	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN12@AsioResetT
	movsd	xmm0, QWORD PTR [rbx+2960]
	ucomisd	xmm6, xmm0
	jp	SHORT $LN101@AsioResetT
	je	SHORT $LN12@AsioResetT
$LN101@AsioResetT:

; 1925 :                 {
; 1926 :                     info_print_("AsioResetThread: sample rate change callback, new %lf.\n", self->m_nextSampleRate);
; 1927 :                     self->m_callbacks->sampleRateDidChange(self->m_nextSampleRate);

	call	rcx

; 1928 :                     oldSampleRate = self->m_nextSampleRate;

	movsd	xmm6, QWORD PTR [rbx+2960]
$LN12@AsioResetT:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	test	rdi, rdi
	je	SHORT $LN93@AsioResetT

; 154  :             close_fn(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN93@AsioResetT:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1931 :             if (self->m_isSupportDropoutDetection && self->m_isRequireReportDropout)

	cmp	BYTE PTR [rbx+2970], 0
	je	SHORT $LN14@AsioResetT
	cmp	BYTE PTR [rbx+2971], 0
	je	SHORT $LN14@AsioResetT

; 1932 :             {
; 1933 :                 self->m_isRequireReportDropout = false;

	mov	BYTE PTR [rbx+2971], 0

; 1934 :                 if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	mov	rax, QWORD PTR [rbx+48]
	test	rax, rax
	je	SHORT $LN14@AsioResetT
	mov	r10, QWORD PTR [rax+16]
	test	r10, r10
	je	SHORT $LN14@AsioResetT

; 1935 :                 {
; 1936 :                     info_print_("AsioResetThread: dropout detect callback.\n");
; 1937 :                     self->m_callbacks->asioMessage(kAsioOverload, 0, nullptr, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 15
	call	r10
$LN14@AsioResetT:

; 1938 :                 }
; 1939 :             }
; 1940 :             if (self->m_isRequireLatencyChange)

	cmp	BYTE PTR [rbx+2972], 0
	je	SHORT $LN16@AsioResetT

; 1941 :             {
; 1942 :                 self->m_isRequireLatencyChange = false;

	mov	BYTE PTR [rbx+2972], 0

; 1943 :                 if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	mov	rax, QWORD PTR [rbx+48]
	test	rax, rax
	je	SHORT $LN16@AsioResetT
	mov	r10, QWORD PTR [rax+16]
	test	r10, r10
	je	SHORT $LN16@AsioResetT

; 1944 :                 {
; 1945 :                     info_print_("AsioResetThread: latency change callback.\n");
; 1946 :                     self->m_callbacks->asioMessage(kAsioLatenciesChanged, 0, nullptr, nullptr);

	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, 6
	call	r10
$LN16@AsioResetT:

; 1947 :                 }
; 1948 :             }
; 1949 :             if (self->m_isRequireAsioReset)

	cmp	BYTE PTR [rbx+2968], 0
	je	$LL4@AsioResetT

; 1950 :             {
; 1951 :                 self->m_isRequireAsioReset = false;

	mov	BYTE PTR [rbx+2968], 0

; 1952 :                 ++resetQueue;

	inc	esi

; 1953 :             }
; 1954 :             break;
; 1955 :         case WAIT_TIMEOUT:
; 1956 :             break;
; 1957 :         default:
; 1958 :             done = true;
; 1959 :             break;
; 1960 :         }
; 1961 :     } while (!done);

	jmp	$LL4@AsioResetT
?AsioResetThread@CUSBAsio@@CAIPEAX@Z ENDP		; CUSBAsio::AsioResetThread
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$7 = 32
lockClient$8 = 32
handlesForWait$ = 40
__$ArrayPad$ = 56
param$ = 96
?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA PROC ; `CUSBAsio::AsioResetThread'::`1'::dtor$0
	lea	rcx, QWORD PTR lockClient$7[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA ENDP ; `CUSBAsio::AsioResetThread'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
lockClient$7 = 32
lockClient$8 = 32
handlesForWait$ = 40
__$ArrayPad$ = 56
param$ = 96
?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA PROC ; `CUSBAsio::AsioResetThread'::`1'::dtor$1
	lea	rcx, QWORD PTR lockClient$8[rdx]
	jmp	??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ
?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA ENDP ; `CUSBAsio::AsioResetThread'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?ThreadStart@CUSBAsio@@AEAAXXZ
_TEXT	SEGMENT
this$ = 64
?ThreadStart@CUSBAsio@@AEAAXXZ PROC			; CUSBAsio::ThreadStart, COMDAT

; 1970 : {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx

; 1971 :     ResetEvent(m_stopEvent);

	mov	rcx, QWORD PTR [rcx+3672]
	call	QWORD PTR __imp_ResetEvent

; 1972 :     auto beginThreadResult = _beginthreadex(nullptr, 0, WorkerThread, this, 0, nullptr);

	xor	eax, eax
	lea	r8, OFFSET FLAT:?WorkerThread@CUSBAsio@@CAIPEAX@Z ; CUSBAsio::WorkerThread
	mov	QWORD PTR [rsp+40], rax
	mov	r9, rbx
	xor	edx, edx
	mov	DWORD PTR [rsp+32], eax
	xor	ecx, ecx
	call	_beginthreadex

; 1973 :     m_workerThread = (HANDLE)beginThreadResult;

	mov	QWORD PTR [rbx+3680], rax

; 1974 :     if ((beginThreadResult > 0) && (m_threadPriority == -2))

	test	rax, rax
	je	SHORT $LN2@ThreadStar
	cmp	DWORD PTR [rbx+3688], -2
	jne	SHORT $LN2@ThreadStar

; 1975 :     {
; 1976 :         SetThreadPriority(m_workerThread, THREAD_PRIORITY_TIME_CRITICAL);

	mov	edx, 15
	mov	rcx, rax

; 1977 :         info_print_("call SetThreadPriority %d.\n", THREAD_PRIORITY_TIME_CRITICAL);
; 1978 :     }
; 1979 : }

	add	rsp, 48					; 00000030H
	pop	rbx

; 1975 :     {
; 1976 :         SetThreadPriority(m_workerThread, THREAD_PRIORITY_TIME_CRITICAL);

	rex_jmp	QWORD PTR __imp_SetThreadPriority
$LN2@ThreadStar:

; 1977 :         info_print_("call SetThreadPriority %d.\n", THREAD_PRIORITY_TIME_CRITICAL);
; 1978 :     }
; 1979 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?ThreadStart@CUSBAsio@@AEAAXXZ ENDP			; CUSBAsio::ThreadStart
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?ThreadStop@CUSBAsio@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?ThreadStop@CUSBAsio@@AEAAXXZ PROC			; CUSBAsio::ThreadStop, COMDAT

; 1982 : {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1983 :     DWORD status;
; 1984 :     SetEvent(m_stopEvent);

	mov	rcx, QWORD PTR [rcx+3672]
	call	QWORD PTR __imp_SetEvent

; 1985 :     if (m_workerThread != nullptr)

	mov	rcx, QWORD PTR [rbx+3680]
	test	rcx, rcx
	je	SHORT $LN9@ThreadStop

; 1986 :     {
; 1987 :         DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 1988 :         status = WaitForSingleObject(m_workerThread, timeout);

	mov	edx, 6000				; 00001770H
	call	QWORD PTR __imp_WaitForSingleObject

; 1989 :         if (status == WAIT_OBJECT_0)

	test	eax, eax
	jne	SHORT $LN3@ThreadStop

; 1990 :         {
; 1991 :             CloseHandle(m_workerThread);

	mov	rcx, QWORD PTR [rbx+3680]
	call	QWORD PTR __imp_CloseHandle

; 2004 :         }
; 2005 :         else
; 2006 :         {
; 2007 :             error_print_("wait timeout.\n");
; 2008 :         }
; 2009 :     }
; 2010 :     m_workerThread = nullptr;
; 2011 : }

	mov	QWORD PTR [rbx+3680], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@ThreadStop:

; 1992 :         }
; 1993 :         else if (status == WAIT_TIMEOUT)

	cmp	eax, 258				; 00000102H
	jne	SHORT $LN9@ThreadStop

; 1994 :         {
; 1995 :             error_print_("wait timouut. force terminating worker thread.");
; 1996 :             // Understanding that there is an issue, preventing proper cleanup, call TerminateThread.
; 1997 :             // TerminateThread(m_workerThread, 0);
; 1998 : 
; 1999 :             // Implemented without using TerminateThread.
; 2000 :             // If the thread does not exit within the timeout, it will be forcibly terminated by the OS when the application exits.
; 2001 : 
; 2002 :             CloseHandle(m_workerThread);

	mov	rcx, QWORD PTR [rbx+3680]
	call	QWORD PTR __imp_CloseHandle

; 2003 :             InterlockedDecrement(&g_WorkerThread);

	lock dec DWORD PTR ?g_WorkerThread@@3JA
$LN9@ThreadStop:

; 2004 :         }
; 2005 :         else
; 2006 :         {
; 2007 :             error_print_("wait timeout.\n");
; 2008 :         }
; 2009 :     }
; 2010 :     m_workerThread = nullptr;
; 2011 : }

	mov	QWORD PTR [rbx+3680], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ThreadStop@CUSBAsio@@AEAAXXZ ENDP			; CUSBAsio::ThreadStop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
;	COMDAT ?WorkerThread@CUSBAsio@@CAIPEAX@Z
_TEXT	SEGMENT
done$1$ = 64
$T9 = 72
prevHdr$ = 80
bytesReturned$10 = 168
timeout$1$ = 168
performanceFreq$ = 176
taskIndex$ = 184
currentPC$11 = 192
privateProperty$12 = 200
handlesForWait$ = 224
__$ArrayPad$ = 240
param$ = 400
?WorkerThread@CUSBAsio@@CAIPEAX@Z PROC			; CUSBAsio::WorkerThread, COMDAT

; 2015 : {

$LN229:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-96]
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 2016 :     CUSBAsio *                            self = (CUSBAsio *)param;
; 2017 :     volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)self->m_driverRecBuffer;

	mov	rdi, QWORD PTR [rcx+3632]
	mov	rbx, rcx

; 2018 :     ULONG                                 wakeup = 0;
; 2019 :     DWORD                                 status = 0;
; 2020 :     bool                                  done = false;

	xor	r14b, r14b

; 2021 : 
; 2022 : #ifdef ASIO_THREAD_STATISTICS
; 2023 :     static const ULONG statsSize = 120000;
; 2024 :     ULONG              statsPos = 0;

	xor	r13d, r13d

; 2025 : 
; 2026 :     typedef struct ASIO_STATISTICS_
; 2027 :     {
; 2028 :         double dueTime;
; 2029 :     } ASIO_STATISTICS, *PASIO_STATISTICS;
; 2030 : 
; 2031 :     PASIO_STATISTICS stats = new ASIO_STATISTICS[statsSize];

	mov	ecx, 960000				; 000ea600H
	mov	BYTE PTR done$1$[rsp], r14b
	mov	r12d, r13d
	call	??_U@YAPEAX_K@Z				; operator new[]

; 2032 : 
; 2033 :     LARGE_INTEGER performanceFreq = {0};
; 2034 :     QueryPerformanceFrequency(&performanceFreq);

	lea	rcx, QWORD PTR performanceFreq$[rbp-256]
	mov	QWORD PTR $T9[rsp], rax
	mov	rsi, rax
	mov	QWORD PTR performanceFreq$[rbp-256], r13
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 2035 : 
; 2036 :     ULONGLONG lastAsioCallbackPC = {0};
; 2037 : 
; 2038 : #if defined(INFO_PRINT_)
; 2039 :     double idealPeriod = (double)(self->m_blockFrames * 1000000) / self->m_sampleRate;
; 2040 : #endif
; 2041 : #endif
; 2042 : 
; 2043 :     UAC_ASIO_REC_BUFFER_HEADER curHdr = {0};
; 2044 :     UAC_ASIO_REC_BUFFER_HEADER prevHdr = {0};
; 2045 :     prevHdr.RecBufferPosition = 0 - self->m_blockFrames;

	mov	ecx, DWORD PTR [rbx+2800]
	mov	r15d, r13d
	neg	ecx
	movsxd	rcx, ecx
	mov	QWORD PTR prevHdr$[rsp+40], rcx

; 2046 : 
; 2047 :     InterlockedIncrement(&g_WorkerThread);

	lock inc DWORD PTR ?g_WorkerThread@@3JA

; 2048 : 
; 2049 :     info_print_("entering worker thread instance %d.\n", InterlockedCompareExchange(&g_WorkerThread, 0, 0));
; 2050 : 
; 2051 :     HANDLE handlesForWait[] = {self->m_stopEvent, self->m_notificationEvent};
; 2052 : 
; 2053 :     DWORD taskIndex = 0;
; 2054 :     if (self->m_threadPriority != -2)

	cmp	DWORD PTR [rbx+3688], -2
	mov	rax, QWORD PTR [rbx+3672]
	mov	QWORD PTR handlesForWait$[rbp-256], rax
	mov	rax, QWORD PTR [rbx+3648]
	mov	QWORD PTR handlesForWait$[rbp-248], rax
	mov	DWORD PTR taskIndex$[rbp-256], r13d
	je	SHORT $LN15@WorkerThre

; 2055 :     {
; 2056 :         HANDLE hTask = AvSetMmThreadCharacteristics(TEXT("Pro Audio"), &taskIndex);

	lea	rdx, QWORD PTR taskIndex$[rbp-256]
	lea	rcx, OFFSET FLAT:??_C@_09FJFDCAPM@Pro?5Audio@
	call	QWORD PTR __imp_AvSetMmThreadCharacteristicsA

; 2057 :         AvSetMmThreadPriority(hTask, (AVRT_PRIORITY)self->m_threadPriority);

	mov	edx, DWORD PTR [rbx+3688]
	mov	rcx, rax
	call	QWORD PTR __imp_AvSetMmThreadPriority
$LN15@WorkerThre:

; 2058 :         info_print_("call AvSetMmThreadPriority %d.\n", self->m_threadPriority);
; 2059 :     }
; 2060 : 
; 2061 :     self->BufferSwitch();

	mov	rcx, rbx
	call	?BufferSwitch@CUSBAsio@@QEAAXXZ		; CUSBAsio::BufferSwitch

; 2062 : 
; 2063 :     Sleep(self->m_blockFrames / 1000 / self->m_audioProperty.SampleRate);

	mov	eax, 274877907				; 10624dd3H
	imul	DWORD PTR [rbx+2800]
	mov	eax, edx
	xor	edx, edx
	sar	eax, 6
	mov	ecx, eax
	shr	ecx, 31
	add	eax, ecx
	div	DWORD PTR [rbx+3260]
	mov	ecx, eax
	call	QWORD PTR __imp_Sleep

; 2064 : 
; 2065 :     self->BufferSwitch();

	mov	rcx, rbx
	call	?BufferSwitch@CUSBAsio@@QEAAXXZ		; CUSBAsio::BufferSwitch
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 391  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 392  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 393  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::StartAsioStream);
; 394  : 
; 395  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	rcx, QWORD PTR [rbx+2984]
	lea	rax, QWORD PTR bytesReturned$10[rbp-256]
	mov	QWORD PTR [rsp+56], r13
	lea	r8, QWORD PTR privateProperty$12[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	r9d, 24
	mov	DWORD PTR [rsp+40], r13d
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$12[rbp-256], xmm0
	mov	QWORD PTR [rsp+32], r13
	mov	DWORD PTR bytesReturned$10[rbp-256], r13d
	mov	DWORD PTR privateProperty$12[rbp-236], 2
	mov	DWORD PTR privateProperty$12[rbp-240], 9
	call	QWORD PTR __imp_DeviceIoControl
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2071 :     recHdr->CallbackRemain = 0;

	movaps	XMMWORD PTR [rsp+336], xmm6
	mov	eax, 3000				; 00000bb8H
	movaps	XMMWORD PTR [rsp+320], xmm7
	movaps	XMMWORD PTR [rsp+304], xmm8
	movaps	XMMWORD PTR [rsp+288], xmm9
	movaps	XMMWORD PTR [rsp+272], xmm10
	mov	DWORD PTR timeout$1$[rbp-256], eax
	movaps	XMMWORD PTR [rsp+256], xmm11
	mov	DWORD PTR [rdi+72], r13d
	npad	1
$LL4@WorkerThre:

; 2072 : 
; 2073 :     do
; 2074 :     {
; 2075 :         bool setAsioResetEvent = false;
; 2076 :         status = WaitForMultipleObjects(sizeof(handlesForWait) / sizeof(handlesForWait[0]), handlesForWait, FALSE, timeout);

	mov	r9d, eax
	lea	rdx, QWORD PTR handlesForWait$[rbp-256]
	xor	r8d, r8d
	mov	ecx, 2
	xor	r13b, r13b
	call	QWORD PTR __imp_WaitForMultipleObjects

; 2077 :         switch (status)

	test	eax, eax
	je	$LC157@WorkerThre
	cmp	eax, 1
	je	SHORT $LN17@WorkerThre

; 2209 :                 ++wakeup;
; 2210 :             }
; 2211 :             break;
; 2212 :         default:
; 2213 :             // If no notification is received from the kernel driver after waiting for a certain period of time,
; 2214 :             // it is assumed that an error has occurred, the thread is terminated, and the application is prompted to reset.
; 2215 :             if (timeout == NOTIFICATION_TIMEOUT)

	cmp	DWORD PTR timeout$1$[rbp-256], 3000	; 00000bb8H
	jne	SHORT $LN38@WorkerThre

; 2216 :             {
; 2217 :                 error_print_("wait timeout. requesting reset.\n");
; 2218 :                 error_print_("cur  hdr PC%7u PB%7u RC%7u RB%7u\n", recHdr->PlayCurrentPosition, recHdr->PlayBufferPosition, recHdr->RecCurrentPosition, recHdr->RecBufferPosition);
; 2219 :                 self->m_isRequireAsioReset = true;
; 2220 :                 setAsioResetEvent = true;
; 2221 :                 timeout = self->m_blockFrames / 1000 / self->m_audioProperty.SampleRate;

	mov	eax, 274877907				; 10624dd3H
	mov	BYTE PTR [rbx+2968], 1
	imul	DWORD PTR [rbx+2800]
	mov	r13b, 1
	mov	eax, edx
	xor	edx, edx
	sar	eax, 6
	mov	ecx, eax
	shr	ecx, 31
	add	eax, ecx
	div	DWORD PTR [rbx+3260]
	mov	DWORD PTR timeout$1$[rbp-256], eax
$LN38@WorkerThre:

; 2222 :             }
; 2223 :             self->BufferSwitch();

	mov	rcx, rbx
	call	?BufferSwitch@CUSBAsio@@QEAAXXZ		; CUSBAsio::BufferSwitch
	jmp	$LN5@WorkerThre
$LN17@WorkerThre:

; 2078 :         {
; 2079 :         case WAIT_OBJECT_0:
; 2080 :             done = true;
; 2081 :             break;
; 2082 :         case WAIT_OBJECT_0 + 1:
; 2083 :             memcpy(&curHdr, (void *)recHdr, sizeof(curHdr)); // Explicit copy

	movups	xmm6, XMMWORD PTR [rdi]
	movups	xmm7, XMMWORD PTR [rdi+32]

; 2084 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::ClockSourceChanged)) != 0)

	movq	rcx, xmm6
	mov	r8, rcx
	shr	r8, 32					; 00000020H
	test	r8b, 4
	je	SHORT $LN186@WorkerThre

; 2085 :             {
; 2086 :                 info_print_("clock source change detected, new %u.\n", curHdr.CurrentClockSource);
; 2087 :                 self->m_asioTime.timeInfo.flags |= kClockSourceChanged;

	or	DWORD PTR [rbx+104], 32			; 00000020H

; 2088 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ClockSourceChanged));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -5					; fffffffbH
	mov	DWORD PTR [rdi+4], eax
$LN186@WorkerThre:

; 2089 :             }
; 2090 :             if (((curHdr.DeviceStatus & toInt(DeviceStatuses::SampleRateChanged)) != 0 && curHdr.CurrentSampleRate != 0) ||

	movdqa	xmm0, xmm6
	psrldq	xmm0, 8
	movd	edx, xmm0
	test	r8b, 2
	je	SHORT $LN21@WorkerThre
	test	edx, edx
	jne	SHORT $LN187@WorkerThre
$LN21@WorkerThre:
	cvttsd2si rax, QWORD PTR [rbx+40]
	cmp	edx, eax
	je	SHORT $LN19@WorkerThre
$LN187@WorkerThre:

; 2091 :                 (curHdr.CurrentSampleRate != (ULONG)self->m_sampleRate))
; 2092 :             {
; 2093 :                 info_print_("sample rate change detected, old %u, new %u.\n", self->m_audioProperty.SampleRate, curHdr.CurrentSampleRate);
; 2094 :                 self->m_asioTime.timeInfo.flags |= kSampleRateChanged;

	or	DWORD PTR [rbx+104], 16
	xorps	xmm0, xmm0

; 2095 :                 self->m_requireSampleRateChange = true;
; 2096 :                 self->m_nextSampleRate = (ASIOSampleRate)curHdr.CurrentSampleRate;

	mov	eax, edx

; 2097 :                 setAsioResetEvent = true;

	mov	r13b, 1
	mov	BYTE PTR [rbx+2956], 1
	cvtsi2sd xmm0, rax
	movsd	QWORD PTR [rbx+2960], xmm0

; 2098 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::SampleRateChanged));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR [rdi+4], eax
$LN19@WorkerThre:

; 2099 :             }
; 2100 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::OverloadDetected)) != 0)

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	test	al, 8
	je	SHORT $LN22@WorkerThre

; 2101 :             {
; 2102 :                 info_print_("overload detected.\n");
; 2103 :                 self->m_isRequireReportDropout = true;

	mov	BYTE PTR [rbx+2971], 1

; 2104 :                 setAsioResetEvent = true;

	mov	r13b, 1

; 2105 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::OverloadDetected));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -9					; fffffff7H
	mov	DWORD PTR [rdi+4], eax
$LN22@WorkerThre:

; 2106 :             }
; 2107 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::LatencyChanged)) != 0)

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	test	al, 16
	je	SHORT $LN23@WorkerThre

; 2108 :             {
; 2109 :                 info_print_("latency change detected.\n");
; 2110 :                 self->m_isRequireLatencyChange = true;

	mov	BYTE PTR [rbx+2972], 1

; 2111 :                 setAsioResetEvent = true;

	mov	r13b, 1

; 2112 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::LatencyChanged));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -17				; ffffffefH
	mov	DWORD PTR [rdi+4], eax
$LN23@WorkerThre:

; 2113 :             }
; 2114 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::ResetRequired)) != 0 ||

	shr	rcx, 32					; 00000020H
	test	cl, 1
	jne	SHORT $LN25@WorkerThre
	cvttsd2si rax, QWORD PTR [rbx+40]
	cmp	edx, eax
	je	SHORT $LN24@WorkerThre
$LN25@WorkerThre:

; 2115 :                 (curHdr.CurrentSampleRate != (ULONG)self->m_sampleRate))
; 2116 :             {
; 2117 :                 info_print_("reset request detected.\n");
; 2118 :                 self->m_isRequireAsioReset = true;

	mov	BYTE PTR [rbx+2968], 1

; 2119 :                 setAsioResetEvent = true;

	mov	r13b, 1

; 2120 :                 // To prevent "Ableton Live" from hanging, callbacks will be processed even after a reset request.
; 2121 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ResetRequired));

	mov	eax, DWORD PTR [rdi+4]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR [rdi+4], eax
$LN24@WorkerThre:

; 2122 :             }
; 2123 :             if (self->m_outputReadyBlock)

	cmp	DWORD PTR [rbx+2976], 0
	je	SHORT $LN188@WorkerThre

; 2124 :             {
; 2125 :                 if (WaitForSingleObject(&self->m_outputReadyBlockEvent, NOTIFICATION_TIMEOUT) == WAIT_TIMEOUT)

	lea	rcx, QWORD PTR [rbx+3720]
	mov	edx, 3000				; 00000bb8H
	call	QWORD PTR __imp_WaitForSingleObject
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN188@WorkerThre

; 2126 :                 {
; 2127 :                     done = true;

	mov	r14b, 1
	mov	BYTE PTR done$1$[rsp], r14b

; 2128 :                     break;

	jmp	$LN5@WorkerThre
$LN188@WorkerThre:

; 2129 :                 }
; 2130 :             }
; 2131 :             {
; 2132 :                 LONG positionDiff = (LONG)(curHdr.RecBufferPosition - prevHdr.RecBufferPosition);

	movdqa	xmm0, xmm7
	psrldq	xmm0, 8
	movd	eax, xmm0
	sub	eax, DWORD PTR prevHdr$[rsp+40]

; 2133 :                 LONG iteration = positionDiff / self->m_blockFrames;

	cdq
	idiv	DWORD PTR [rbx+2800]
	mov	r14d, eax

; 2134 :                 if (iteration > 3)

	cmp	eax, 3
	jle	SHORT $LL7@WorkerThre

; 2135 :                 {
; 2136 :                     SetEvent(self->m_asioResetEvent);

	mov	rcx, QWORD PTR [rbx+3696]
	call	QWORD PTR __imp_SetEvent

; 2137 :                     iteration %= 2;

	and	r14d, -2147483647			; ffffffff80000001H
	jge	SHORT $LL7@WorkerThre
	dec	r14d
	or	r14d, -2
	inc	r14d
	npad	8
$LL7@WorkerThre:

; 2138 :                 }
; 2139 :                 while (iteration > 0)

	test	r14d, r14d
	jle	$LN199@WorkerThre

; 2140 :                 {
; 2141 :                     self->m_playReadyPosition = recHdr->RecBufferPosition;

	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rbx+3640], rax

; 2142 :                     recHdr->PlayReadyPosition = self->m_playReadyPosition;

	mov	QWORD PTR [rdi+48], rax

; 2143 : #ifdef ASIO_THREAD_STATISTICS
; 2144 :                     if (performanceFreq.QuadPart != 0)

	cmp	QWORD PTR performanceFreq$[rbp-256], 0
	je	SHORT $LN29@WorkerThre

; 2145 :                     {
; 2146 :                         LARGE_INTEGER currentPC = {0};
; 2147 :                         QueryPerformanceCounter(&currentPC);

	lea	rcx, QWORD PTR currentPC$11[rbp-256]
	mov	QWORD PTR currentPC$11[rbp-256], 0
	call	QWORD PTR __imp_QueryPerformanceCounter

; 2150 : 
; 2151 :                         if (lastAsioCallbackPC != 0 && statsPos < statsSize)

	mov	rax, QWORD PTR currentPC$11[rbp-256]
	test	r15, r15
	je	SHORT $LN30@WorkerThre
	cmp	r12d, 120000				; 0001d4c0H
	jae	SHORT $LN30@WorkerThre

; 2148 : 
; 2149 :                         double measuredPeriod = (double)((currentPC.QuadPart - lastAsioCallbackPC) * 1000000) / (double)(performanceFreq.QuadPart);

	mov	rcx, rax
	xorps	xmm1, xmm1
	sub	rcx, r15
	imul	rdx, rcx, 1000000			; 000f4240H
	test	rdx, rdx
	js	SHORT $LN192@WorkerThre
	cvtsi2sd xmm1, rdx
	jmp	SHORT $LN193@WorkerThre
$LN192@WorkerThre:
	mov	rcx, rdx
	and	edx, 1
	shr	rcx, 1
	or	rcx, rdx
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
$LN193@WorkerThre:

; 2152 :                         {
; 2153 :                             stats[statsPos].dueTime = measuredPeriod;

	xorps	xmm0, xmm0
	mov	ecx, r12d
	cvtsi2sd xmm0, QWORD PTR performanceFreq$[rbp-256]

; 2154 :                             ++statsPos;

	inc	r12d
	divsd	xmm1, xmm0
	movsd	QWORD PTR [rsi+rcx*8], xmm1
$LN30@WorkerThre:

; 2155 :                         }
; 2156 : 
; 2157 :                         lastAsioCallbackPC = currentPC.QuadPart;

	mov	r15, rax
$LN29@WorkerThre:

; 2158 :                     }
; 2159 : #endif
; 2160 :                     ULONG outputReady = 0;
; 2161 :                     LONG  readyBuffers = 0;
; 2162 :                     {
; 2163 :                         auto lockRecBuffer = self->m_recBufferCS.lock();

	lea	rsi, QWORD PTR [rbx+3576]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2164 :                         outputReady = InterlockedExchange((LONG *)&recHdr->OutputReady, toInt(UserThreadStatuses::BufferStart));

	mov	eax, 2
	xchg	DWORD PTR [rdi+64], eax

; 2165 :                         readyBuffers = InterlockedIncrement(&recHdr->ReadyBuffers);

	lock inc DWORD PTR [rdi+68]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	rsi, rsi

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN97@WorkerThre

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN97@WorkerThre:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2167 :                     if (self->m_initialSystemTime == 0)

	cmp	DWORD PTR [rbx+2264], 0
	jne	SHORT $LN31@WorkerThre

; 2168 :                     {
; 2169 :                         self->m_initialSystemTime = timeGetTime();

	call	QWORD PTR __imp_timeGetTime
	mov	DWORD PTR [rbx+2264], eax

; 2170 :                         self->m_initialKernelTime = recHdr->NotifySystemTime;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rbx+2272], rax

; 2171 :                     }

	jmp	SHORT $LN32@WorkerThre
$LN31@WorkerThre:

; 2172 :                     else
; 2173 :                     {
; 2174 :                         self->m_calculatedSystemTime = self->m_initialSystemTime +

	mov	rcx, QWORD PTR [rdi+56]
	mov	rax, QWORD PTR [rbx+2272]
	sub	rcx, rax
	mov	rax, 442721857769029239			; 0624dd2f1a9fbe77H
	mul	rcx
	sub	rcx, rdx
	shr	rcx, 1
	add	rcx, rdx
	shr	rcx, 9
	add	ecx, DWORD PTR [rbx+2264]
	mov	DWORD PTR [rbx+2268], ecx
$LN32@WorkerThre:

; 2175 :                                                        (DWORD)((recHdr->NotifySystemTime - self->m_initialKernelTime) / 1000);
; 2176 :                     }
; 2177 :                     InterlockedIncrement(&recHdr->AsioProcessStart);

	lock inc DWORD PTR [rdi+76]

; 2178 :                     self->BufferSwitch();

	mov	rcx, rbx
	call	?BufferSwitch@CUSBAsio@@QEAAXXZ		; CUSBAsio::BufferSwitch

; 2179 :                     InterlockedIncrement(&recHdr->AsioProcessComplete);

	lock inc DWORD PTR [rdi+80]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov	rcx, rsi
	call	QWORD PTR __imp_EnterCriticalSection
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2182 :                         outputReady = InterlockedExchange(&recHdr->OutputReady, toInt(UserThreadStatuses::BufferStart) | toInt(UserThreadStatuses::BufferEnd) | toInt(UserThreadStatuses::OutputReady));

	mov	eax, 7
	xchg	DWORD PTR [rdi+64], eax

; 2183 :                         if (self->m_outputReadyBlock && (!(outputReady & toInt(UserThreadStatuses::OutputReady))) && (outputReady & toInt(UserThreadStatuses::BufferStart)))

	cmp	DWORD PTR [rbx+2976], 0
	je	SHORT $LN33@WorkerThre
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN33@WorkerThre

; 2184 :                         {
; 2185 :                             InterlockedOr(&recHdr->OutputReady, toInt(UserThreadStatuses::OutputReadyDelay));

	lock or	DWORD PTR [rdi+64], 8

; 2186 :                             SetEvent(self->m_outputReadyEvent);

	mov	rcx, QWORD PTR [rbx+3656]
	call	QWORD PTR __imp_SetEvent
$LN33@WorkerThre:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	rsi, rsi

; 222  :             if (policy::is_valid(m_ptr))

	je	SHORT $LN61@WorkerThre

; 154  :             close_fn(value);

	mov	rcx, rsi
	call	QWORD PTR __imp_LeaveCriticalSection
$LN61@WorkerThre:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2189 :                     --iteration;

	sub	r14d, 1

; 2190 :                     if (iteration == 0)

	je	SHORT $LN198@WorkerThre

; 2191 :                     {
; 2192 :                         break;
; 2193 :                     }
; 2194 :                     error_print_("out of sync, ASIO callback iteration %u, sleep %u(ms).\n", iteration, self->m_blockFrames * 500 / (LONG)(self->m_sampleRate));
; 2195 :                     error_print_("prev hdr PC%7u PB%7u RC%7u RB%7u\n", prevHdr.PlayCurrentPosition, prevHdr.PlayBufferPosition, prevHdr.RecCurrentPosition, prevHdr.RecBufferPosition);
; 2196 :                     error_print_("cur  hdr PC%7u PB%7u RC%7u RB%7u REB%7u\n", curHdr.PlayCurrentPosition, curHdr.PlayBufferPosition, curHdr.RecCurrentPosition, curHdr.RecBufferPosition, readyBuffers);
; 2197 :                     status = WaitForSingleObject(self->m_stopEvent, 0);

	mov	rcx, QWORD PTR [rbx+3672]
	xor	edx, edx
	call	QWORD PTR __imp_WaitForSingleObject

; 2198 :                     if (status == WAIT_TIMEOUT)

	mov	rsi, QWORD PTR $T9[rsp]
	cmp	eax, 258				; 00000102H
	je	$LL7@WorkerThre

; 2199 :                     {
; 2200 :                         continue;
; 2201 :                     }
; 2202 :                     else
; 2203 :                     {
; 2204 :                         done = true;

	mov	r14b, 1
	mov	BYTE PTR done$1$[rsp], r14b
	jmp	SHORT $LN126@WorkerThre
$LN198@WorkerThre:

; 2190 :                     if (iteration == 0)

	mov	rsi, QWORD PTR $T9[rsp]
$LN199@WorkerThre:

; 2205 :                         break;
; 2206 :                     }
; 2207 :                 }
; 2208 :                 prevHdr = curHdr;

	movzx	r14d, BYTE PTR done$1$[rsp]
$LN126@WorkerThre:
	movups	XMMWORD PTR prevHdr$[rsp+32], xmm7
$LN5@WorkerThre:

; 2224 :             break;
; 2225 :         }
; 2226 :         if (setAsioResetEvent)

	test	r13b, r13b
	je	SHORT $LN2@WorkerThre

; 2227 :         {
; 2228 :             SetEvent(self->m_asioResetEvent);

	mov	rcx, QWORD PTR [rbx+3696]
	call	QWORD PTR __imp_SetEvent
$LN2@WorkerThre:

; 2229 :         }
; 2230 :     } while (!done);

	mov	eax, DWORD PTR timeout$1$[rbp-256]
	test	r14b, r14b
	je	$LL4@WorkerThre
$LC157@WorkerThre:

; 2231 :     info_print_("exiting worker thread...\n");
; 2232 : #ifdef ASIO_THREAD_STATISTICS
; 2233 :     if (statsPos != 0)
; 2234 :     {
; 2235 :         double dueTimeTotal = 0;
; 2236 :         for (ULONG i = 0; i < statsPos; ++i)
; 2237 :         {
; 2238 :             dueTimeTotal += stats[i].dueTime;
; 2239 :         }
; 2240 :         double dueTimeAvg = dueTimeTotal / (double)statsPos;
; 2241 :         double dueTimeVar = 0;
; 2242 :         double dueTimeMax = 0;
; 2243 :         double dueTimeMin = 60000000;
; 2244 :         for (ULONG i = 0; i < statsPos; ++i)
; 2245 :         {
; 2246 :             dueTimeVar += pow(stats[i].dueTime - dueTimeAvg, 2);
; 2247 :             if (dueTimeMax < stats[i].dueTime)
; 2248 :             {
; 2249 :                 dueTimeMax = stats[i].dueTime;
; 2250 :             }
; 2251 :             if (dueTimeMin > stats[i].dueTime)
; 2252 :             {
; 2253 :                 dueTimeMin = stats[i].dueTime;
; 2254 :             }
; 2255 :         }
; 2256 :         dueTimeVar /= (double)(statsPos);
; 2257 : #if defined(INFO_PRINT_)
; 2258 :         double dueTimeStddev = sqrt(dueTimeVar);
; 2259 : #endif
; 2260 :         info_print_("- ASIO Callback %5u(times), DueTime Calc %5d(us), Avg %5d(us), Stddev %5d(us), Max %5d(us), Min %5d(us)\n", statsPos, (LONG)idealPeriod, (LONG)dueTimeAvg, (LONG)dueTimeStddev, (LONG)dueTimeMax, (LONG)dueTimeMin);
; 2261 :     }
; 2262 :     delete[] stats;

	mov	rcx, rsi
	call	??_V@YAXPEAX@Z				; operator delete[]

; 2263 : #endif
; 2264 :     InterlockedDecrement(&g_WorkerThread);

	lock dec DWORD PTR ?g_WorkerThread@@3JA

; 2265 :     return 0;

	movaps	xmm11, XMMWORD PTR [rsp+256]
	xor	eax, eax
	movaps	xmm10, XMMWORD PTR [rsp+272]
	movaps	xmm9, XMMWORD PTR [rsp+288]
	movaps	xmm8, XMMWORD PTR [rsp+304]
	movaps	xmm7, XMMWORD PTR [rsp+320]
	movaps	xmm6, XMMWORD PTR [rsp+336]

; 2266 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+352]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?WorkerThread@CUSBAsio@@CAIPEAX@Z ENDP			; CUSBAsio::WorkerThread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
;	COMDAT ??$assign_to_opt_param@I@wil@@YAXPEAII@Z
_TEXT	SEGMENT
outParam$ = 8
val$dead$ = 16
??$assign_to_opt_param@I@wil@@YAXPEAII@Z PROC		; wil::assign_to_opt_param<unsigned int>, COMDAT

; 645  :     if (outParam != nullptr)

	test	rcx, rcx
	je	SHORT $LN2@assign_to_

; 646  :     {
; 647  :         *outParam = val;

	mov	DWORD PTR [rcx], 0
$LN2@assign_to_:

; 648  :     }
; 649  : }

	ret	0
??$assign_to_opt_param@I@wil@@YAXPEAII@Z ENDP		; wil::assign_to_opt_param<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z
_TEXT	SEGMENT
module$ = 8
procName$dead$ = 16
??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z PROC ; wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>, COMDAT

; 1700 :         return reinterpret_cast<FuncPtr>(reinterpret_cast<void (*)()>(::GetProcAddress(module, procName)));

	lea	rdx, OFFSET FLAT:??_C@_0BH@EEDPADAA@RaiseFailFastException@
	rex_jmp	QWORD PTR __imp_GetProcAddress
??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z ENDP ; wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z
_TEXT	SEGMENT
pStart$ = 48
pEnd$ = 56
pszString$ = 64
ppszBufferString$ = 72
??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z PROC ; wil::details::WriteResultString<wchar_t const *>, COMDAT

; 3036 :     {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	r9, r8
	mov	rdi, rcx

; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rcx, rdx
	je	SHORT $LN3@WriteResul
	test	r8, r8
	je	SHORT $LN3@WriteResul
	cmp	WORD PTR [r8], 0
	je	SHORT $LN3@WriteResul

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov	rax, -1
$LL27@WriteResul:
	cmp	WORD PTR [r8+rax*2+2], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL27@WriteResul
	lea	rsi, QWORD PTR [rax*2+2]

; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub	rdx, rdi

; 3049 :         if (bufferSize < stringSize)

	cmp	rdx, rsi
	jb	SHORT $LN3@WriteResul
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	rsi, rsi
	je	SHORT $LN22@WriteResul

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rdi, rdi
	jne	SHORT $LN18@WriteResul
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN22@WriteResul
$LN18@WriteResul:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, rsi
	mov	rdx, r9
	call	memcpy
$LN22@WriteResul:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	rbx, rbx
	je	SHORT $LN25@WriteResul

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [rbx], rdi
$LN25@WriteResul:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	lea	rax, QWORD PTR [rsi+rdi]

; 3061 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@WriteResul:

; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;

	test	rbx, rbx
	je	SHORT $LN7@WriteResul
	mov	QWORD PTR [rbx], 0
$LN7@WriteResul:

; 3061 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z ENDP ; wil::details::WriteResultString<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
;	COMDAT ??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z
_TEXT	SEGMENT
pStart$ = 48
pEnd$ = 56
pszString$ = 64
ppszBufferString$ = 72
??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z PROC ; wil::details::WriteResultString<char const *>, COMDAT

; 3036 :     {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r9
	mov	r9, r8
	mov	rdi, rcx

; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp	rcx, rdx
	je	SHORT $LN3@WriteResul
	test	r8, r8
	je	SHORT $LN3@WriteResul
	cmp	BYTE PTR [r8], 0
	je	SHORT $LN3@WriteResul

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov	rax, -1
	npad	1
$LL27@WriteResul:
	cmp	BYTE PTR [r8+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL27@WriteResul
	lea	rsi, QWORD PTR [rax+1]

; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub	rdx, rdi

; 3049 :         if (bufferSize < stringSize)

	cmp	rdx, rsi
	jb	SHORT $LN3@WriteResul
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

; 46   :         if (_SourceSize == 0)

	test	rsi, rsi
	je	SHORT $LN22@WriteResul

; 47   :         {
; 48   :             return 0;
; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	test	rdi, rdi
	jne	SHORT $LN18@WriteResul
	call	_errno
	mov	DWORD PTR [rax], 22
	call	_invalid_parameter_noinfo
	jmp	SHORT $LN22@WriteResul
$LN18@WriteResul:

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)
; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);
; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);
; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;
; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov	r8, rsi
	mov	rdx, r9
	call	memcpy
$LN22@WriteResul:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	test	rbx, rbx
	je	SHORT $LN25@WriteResul

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [rbx], rdi
$LN25@WriteResul:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	lea	rax, QWORD PTR [rsi+rdi]

; 3061 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@WriteResul:

; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;

	test	rbx, rbx
	je	SHORT $LN7@WriteResul
	mov	QWORD PTR [rbx], 0
$LN7@WriteResul:

; 3061 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z ENDP ; wil::details::WriteResultString<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
this$ = 8
first$ = 16
??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>, COMDAT

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 351  :         storage_t(wistd::forward<arg1>(first), wistd::forward<args_t>(args)...)
; 352  :     {
; 353  :         static_assert(
; 354  :             wistd::is_same<typename policy::pointer_access, details::pointer_access_none>::value ||
; 355  :                 wistd::is_same<typename policy::pointer_access, details::pointer_access_all>::value ||
; 356  :                 wistd::is_same<typename policy::pointer_access, details::pointer_access_noaddress>::value,
; 357  :             "pointer_access policy must be a known pointer_access* integral type");
; 358  :     }

	mov	rax, rcx
	ret	0
??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h
;	COMDAT ??$forward@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z
_TEXT	SEGMENT
__t$ = 8
??$forward@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z PROC ; wistd::forward<`CUSBAsio::createBuffers'::`2'::<lambda_1> >, COMDAT

; 2507 :     return static_cast<_Tp&&>(__t);

	mov	rax, rcx

; 2508 : }

	ret	0
??$forward@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z ENDP ; wistd::forward<`CUSBAsio::createBuffers'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::~lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >, COMDAT

; 557  :         {

	sub	rsp, 40					; 00000028H

; 570  :             if (m_call)

	cmp	BYTE PTR [rcx+24], 0
	je	SHORT $LN15@lambda_cal

; 571  :             {
; 572  :                 m_call = false;

	mov	BYTE PTR [rcx+24], 0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN15@lambda_cal
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN15@lambda_cal

; 896  :         {
; 897  :             disposeBuffers();

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+160]
	npad	1
$LN15@lambda_cal:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 559  :         }

	add	rsp, 40					; 00000028H
	ret	0
??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ ENDP ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::~lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??0?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z
_TEXT	SEGMENT
this$ = 8
lambda$ = 16
??0?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >, COMDAT

; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	movups	xmm0, XMMWORD PTR [rdx]

; 545  :             static_assert(wistd::is_same<decltype(lambda()), void>::value, "scope_exit lambdas must not have a return value");
; 546  :             static_assert(
; 547  :                 !wistd::is_lvalue_reference<TLambda>::value && !wistd::is_rvalue_reference<TLambda>::value,
; 548  :                 "scope_exit should only be directly used with a lambda");
; 549  :         }

	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movsd	xmm1, QWORD PTR [rdx+16]
	movsd	QWORD PTR [rcx+16], xmm1

; 550  : 
; 551  :         lambda_call(lambda_call&& other) WI_NOEXCEPT : m_lambda(wistd::move(other.m_lambda)), m_call(other.m_call)
; 552  :         {
; 553  :             other.m_call = false;
; 554  :         }
; 555  : 
; 556  :         ~lambda_call() WI_NOEXCEPT
; 557  :         {
; 558  :             reset();
; 559  :         }
; 560  : 
; 561  :         // Ensures the scope_exit lambda will not be called
; 562  :         void release() WI_NOEXCEPT
; 563  :         {
; 564  :             m_call = false;
; 565  :         }
; 566  : 
; 567  :         // Executes the scope_exit lambda immediately if not yet run; ensures it will not run again
; 568  :         void reset() WI_NOEXCEPT
; 569  :         {
; 570  :             if (m_call)
; 571  :             {
; 572  :                 m_call = false;
; 573  :                 m_lambda();
; 574  :             }
; 575  :         }
; 576  : 
; 577  :         // Returns true if the scope_exit lambda is still going to be executed
; 578  :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 579  :         {
; 580  :             return m_call;
; 581  :         }
; 582  : 
; 583  :     protected:
; 584  :         TLambda m_lambda;
; 585  :         bool m_call = true;

	mov	BYTE PTR [rcx+24], 1
	ret	0
??0?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z ENDP ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ PROC ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >, COMDAT

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	mov	rcx, QWORD PTR [rcx]

; 222  :             if (policy::is_valid(m_ptr))

	test	rcx, rcx
	je	SHORT $LN9@unique_sto

; 154  :             close_fn(value);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
$LN9@unique_sto:

; 223  :             {
; 224  :                 policy::close(m_ptr);
; 225  :             }
; 226  :         }

	ret	0
??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ ENDP ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
;	COMDAT ??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z
_TEXT	SEGMENT
outParam$ = 8
??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z PROC ; wil::assign_null_to_opt_param<wchar_t const *>, COMDAT

; 656  :     if (outParam != nullptr)

	test	rcx, rcx
	je	SHORT $LN2@assign_nul

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [rcx], 0
$LN2@assign_nul:

; 659  :     }
; 660  : }

	ret	0
??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z ENDP ; wil::assign_null_to_opt_param<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
;	COMDAT ??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z
_TEXT	SEGMENT
outParam$ = 8
val$ = 16
??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z PROC ; wil::assign_to_opt_param<wchar_t const *>, COMDAT

; 645  :     if (outParam != nullptr)

	test	rcx, rcx
	je	SHORT $LN2@assign_to_

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [rcx], rdx
$LN2@assign_to_:

; 648  :     }
; 649  : }

	ret	0
??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z ENDP ; wil::assign_to_opt_param<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
;	COMDAT ??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z
_TEXT	SEGMENT
outParam$ = 8
??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z PROC	; wil::assign_null_to_opt_param<char const *>, COMDAT

; 656  :     if (outParam != nullptr)

	test	rcx, rcx
	je	SHORT $LN2@assign_nul

; 657  :     {
; 658  :         *outParam = nullptr;

	mov	QWORD PTR [rcx], 0
$LN2@assign_nul:

; 659  :     }
; 660  : }

	ret	0
??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z ENDP	; wil::assign_null_to_opt_param<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
;	COMDAT ??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z
_TEXT	SEGMENT
outParam$ = 8
val$ = 16
??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z PROC	; wil::assign_to_opt_param<char const *>, COMDAT

; 645  :     if (outParam != nullptr)

	test	rcx, rcx
	je	SHORT $LN2@assign_to_

; 646  :     {
; 647  :         *outParam = val;

	mov	QWORD PTR [rcx], rdx
$LN2@assign_to_:

; 648  :     }
; 649  : }

	ret	0
??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z ENDP	; wil::assign_to_opt_param<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h
;	COMDAT ??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z
_TEXT	SEGMENT
__t$ = 8
??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z PROC ; wistd::forward<_RTL_CRITICAL_SECTION * &>, COMDAT

; 2507 :     return static_cast<_Tp&&>(__t);

	mov	rax, rcx

; 2508 : }

	ret	0
??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z ENDP ; wistd::forward<_RTL_CRITICAL_SECTION * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h
;	COMDAT ??$move@AEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z
_TEXT	SEGMENT
__t$ = 8
??$move@AEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z PROC ; wistd::move<`CUSBAsio::createBuffers'::`2'::<lambda_1> &>, COMDAT

; 2500 :     typedef typename remove_reference<_Tp>::type _Up;
; 2501 :     return static_cast<_Up&&>(__t);

	mov	rax, rcx

; 2502 : }

	ret	0
??$move@AEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z ENDP ; wistd::move<`CUSBAsio::createBuffers'::`2'::<lambda_1> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::reset, COMDAT

; 569  :         {

	sub	rsp, 40					; 00000028H

; 570  :             if (m_call)

	cmp	BYTE PTR [rcx+24], 0
	je	SHORT $LN6@reset

; 571  :             {
; 572  :                 m_call = false;

	mov	BYTE PTR [rcx+24], 0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN6@reset
	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN6@reset

; 896  :         {
; 897  :             disposeBuffers();

	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+160]
	npad	1
$LN6@reset:
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 575  :         }

	add	rsp, 40					; 00000028H
	ret	0
?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ ENDP ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
value$ = 8
?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z PROC ; wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close, COMDAT

; 154  :             close_fn(value);

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
this$ = 8
ptr$ = 16
??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z PROC ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >, COMDAT

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	mov	QWORD PTR [rcx], rdx

; 213  :         }

	mov	rax, rcx
	ret	0
??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
;	COMDAT ?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
value$ = 8
?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z PROC ; wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid, COMDAT

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	test	rcx, rcx
	setne	al

; 189  :         }

	ret	0
?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECUSBAsio@@W7EAAPEAXI@Z
_TEXT	SEGMENT
??_ECUSBAsio@@W7EAAPEAXI@Z PROC				; [thunk]:CUSBAsio::`vector deleting destructor', COMDAT
	sub	rcx, 8
	jmp	??_ECUSBAsio@@UEAAPEAXI@Z
??_ECUSBAsio@@W7EAAPEAXI@Z ENDP				; [thunk]:CUSBAsio::`vector deleting destructor'
_TEXT	ENDS
END
