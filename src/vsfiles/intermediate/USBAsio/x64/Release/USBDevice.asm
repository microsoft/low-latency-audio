; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35216.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_SetupDiGetDeviceRegistryPropertyA:PROC
EXTRN	_stricmp:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_StrStrIA:PROC
EXTRN	__imp_SetupDiGetDeviceInterfaceDetailA:PROC
EXTRN	__imp_DeviceIoControl:PROC
EXTRN	__imp_SetupDiGetClassDevsA:PROC
EXTRN	__imp_SetupDiEnumDeviceInterfaces:PROC
EXTRN	__imp_SetupDiDestroyDeviceInfoList:PROC
PUBLIC	?toInt@@YAHW4KsPropertyUACLowLatencyAudio@@@Z	; toInt
PUBLIC	?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z	; OpenUsbDevice
PUBLIC	?ChangeSampleRate@@YAHPEAXK@Z			; ChangeSampleRate
PUBLIC	?SetAsioBuffer@@YAHPEAXPEAEK1K@Z		; SetAsioBuffer
PUBLIC	?GetAsioOwnership@@YAHPEAX@Z			; GetAsioOwnership
PUBLIC	?StopAsioStream@@YAHPEAX@Z			; StopAsioStream
PUBLIC	?SetClockSource@@YAHPEAXK@Z			; SetClockSource
PUBLIC	?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z ; GetClockInfo
PUBLIC	?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z ; SetFlags
PUBLIC	?StartAsioStream@@YAHPEAX@Z			; StartAsioStream
PUBLIC	?UnsetAsioBuffer@@YAHPEAX@Z			; UnsetAsioBuffer
PUBLIC	?ReleaseAsioOwnership@@YAHPEAX@Z		; ReleaseAsioOwnership
PUBLIC	?SetSampleFormat@@YAHPEAXK@Z			; SetSampleFormat
PUBLIC	?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z ; GetChannelInfo
PUBLIC	?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z ; GetAudioProperty
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+78
	DD	imagerel $unwind$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+78
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+720
	DD	imagerel $chain$3$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+720
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+747
	DD	imagerel $chain$4$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+747
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+780
	DD	imagerel $chain$5$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z DD imagerel $LN9
	DD	imagerel $LN9+44
	DD	imagerel $unwind$?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ChangeSampleRate@@YAHPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$?ChangeSampleRate@@YAHPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetAsioBuffer@@YAHPEAXPEAEK1K@Z DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$?SetAsioBuffer@@YAHPEAXPEAEK1K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetAsioOwnership@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?GetAsioOwnership@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StopAsioStream@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?StopAsioStream@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetClockSource@@YAHPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$?SetClockSource@@YAHPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD imagerel $LN16
	DD	imagerel $LN16+102
	DD	imagerel $unwind$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD imagerel $LN16+102
	DD	imagerel $LN16+256
	DD	imagerel $chain$0$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD imagerel $LN16+256
	DD	imagerel $LN16+277
	DD	imagerel $chain$1$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+182
	DD	imagerel $unwind$?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartAsioStream@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?StartAsioStream@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UnsetAsioBuffer@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?UnsetAsioBuffer@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReleaseAsioOwnership@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?ReleaseAsioOwnership@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetSampleFormat@@YAHPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$?SetSampleFormat@@YAHPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD imagerel $LN15
	DD	imagerel $LN15+102
	DD	imagerel $unwind$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD imagerel $LN15+102
	DD	imagerel $LN15+252
	DD	imagerel $chain$0$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD imagerel $LN15+252
	DD	imagerel $LN15+273
	DD	imagerel $chain$1$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+102
	DD	imagerel $unwind$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD 020821H
	DD	0147408H
	DD	imagerel $LN15
	DD	imagerel $LN15+102
	DD	imagerel $unwind$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z DD 041719H
	DD	06004d208H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetSampleFormat@@YAHPEAXK@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReleaseAsioOwnership@@YAHPEAX@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UnsetAsioBuffer@@YAHPEAX@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartAsioStream@@YAHPEAX@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z DD 021c19H
	DD	017010aH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+102
	DD	imagerel $unwind$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD 020821H
	DD	0147408H
	DD	imagerel $LN16
	DD	imagerel $LN16+102
	DD	imagerel $unwind$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z DD 041719H
	DD	06004d208H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetClockSource@@YAHPEAXK@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StopAsioStream@@YAHPEAX@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetAsioOwnership@@YAHPEAX@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetAsioBuffer@@YAHPEAXPEAEK1K@Z DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ChangeSampleRate@@YAHPEAXK@Z DD 011319H
	DD	0e204H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD 080021H
	DD	05ae400H
	DD	05bc400H
	DD	0617400H
	DD	0606400H
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+78
	DD	imagerel $unwind$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD 021H
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+78
	DD	imagerel $unwind$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD 083221H
	DD	05ae432H
	DD	05bc424H
	DD	0617415H
	DD	0606408H
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
	DD	imagerel ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z+78
	DD	imagerel $unwind$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z DD 052519H
	DD	05c0114H
	DD	03003f005H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
audioProperty$ = 136
?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z PROC ; GetAudioProperty, COMDAT

; 172  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 173  :     BOOL       result = FALSE;
; 174  :     KSPROPERTY privateProperty{};
; 175  :     ULONG      bytesReturned = 0;
; 176  : 
; 177  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	eax, eax

; 178  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;

	mov	DWORD PTR privateProperty$[rsp+20], 1

; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);
; 180  : 
; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR bytesReturned$[rsp], eax
	mov	r9d, 24
	mov	DWORD PTR privateProperty$[rsp+16], eax
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	DWORD PTR [rsp+40], 408			; 00000198H
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	call	QWORD PTR __imp_DeviceIoControl

; 182  : 
; 183  :     return result;
; 184  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z ENDP ; GetAudioProperty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 144
channelInfo$ = 152
?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z PROC ; GetChannelInfo, COMDAT

; 191  : {

$LN15:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 192  :     BOOL       result = FALSE;
; 193  :     KSPROPERTY privateProperty{};
; 194  :     ULONG      bytesReturned = 0;

	xor	ebp, ebp
	mov	rbx, rdx
	mov	DWORD PTR bytesReturned$[rsp], ebp
	mov	rsi, rcx

; 195  : 
; 196  :     if (channelInfo == nullptr)

	test	rdx, rdx
	jne	SHORT $LN2@GetChannel

; 197  :     {
; 198  :         return result;

	xor	eax, eax
	jmp	$LN1@GetChannel
$LN2@GetChannel:

; 199  :     }
; 200  : 
; 201  :     *channelInfo = {};
; 202  : 
; 203  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 204  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 205  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetChannelInfo);
; 206  : 
; 207  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rbp
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	QWORD PTR [rdx], rbp
	mov	r9d, 24
	mov	DWORD PTR [rsp+40], ebp
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+160], rdi
	mov	DWORD PTR privateProperty$[rsp+20], 1
	mov	DWORD PTR privateProperty$[rsp+16], 1
	call	QWORD PTR __imp_DeviceIoControl
	mov	edi, eax

; 208  : 
; 209  :     if (!result)

	test	eax, eax
	jne	SHORT $LN7@GetChannel

; 210  :     {
; 211  :         DWORD error = GetLastError();

	call	QWORD PTR __imp_GetLastError

; 212  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CHANNEL_INFO_CONTEXT)))

	cmp	eax, 234				; 000000eaH
	jne	SHORT $LN7@GetChannel
	mov	eax, DWORD PTR bytesReturned$[rsp]
	cmp	eax, 84					; 00000054H
	jb	SHORT $LN7@GetChannel

; 213  :         {
; 214  :             *channelInfo = (PUAC_GET_CHANNEL_INFO_CONTEXT)(new BYTE[bytesReturned]);

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 215  :             if (channelInfo != nullptr)
; 216  :             {
; 217  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *channelInfo, bytesReturned, &bytesReturned, nullptr);

	mov	r8d, DWORD PTR bytesReturned$[rsp]
	lea	rcx, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+56], rbp
	mov	r9d, 24
	mov	QWORD PTR [rsp+48], rcx
	mov	edx, 3080195				; 002f0003H
	mov	DWORD PTR [rsp+40], r8d
	mov	rcx, rsi
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_DeviceIoControl
	mov	edi, eax

; 218  :                 if (!result)

	test	eax, eax
	jne	SHORT $LN7@GetChannel

; 219  :                 {
; 220  :                     delete[] (BYTE *)(*channelInfo);

	mov	rcx, QWORD PTR [rbx]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 221  :                     *channelInfo = nullptr;

	mov	QWORD PTR [rbx], rbp
$LN7@GetChannel:

; 222  :                 }
; 223  :             }
; 224  :             else
; 225  :             {
; 226  :                 result = FALSE;
; 227  :             }
; 228  :         }
; 229  :     }
; 230  : 
; 231  :     return result;

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+160]
$LN1@GetChannel:

; 232  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?GetChannelInfo@@YAHPEAXPEAPEAUUAC_GET_CHANNEL_INFO_CONTEXT_@@@Z ENDP ; GetChannelInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?SetSampleFormat@@YAHPEAXK@Z
_TEXT	SEGMENT
bytesReturned$ = 64
sampleFormat$GSCopy$ = 72
privateProperty$ = 80
__$ArrayPad$ = 104
deviceHandle$ = 128
sampleFormat$ = 136
?SetSampleFormat@@YAHPEAXK@Z PROC			; SetSampleFormat, COMDAT

; 331  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 332  :     BOOL       result = FALSE;
; 333  :     KSPROPERTY privateProperty{};
; 334  :     ULONG      bytesReturned = 0;
; 335  : 
; 336  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	eax, eax
	mov	DWORD PTR sampleFormat$GSCopy$[rsp], edx

; 337  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 338  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetSampleFormat);
; 339  : 
; 340  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleFormat, sizeof(ULONG), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR bytesReturned$[rsp], eax
	mov	r9d, 24
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	DWORD PTR privateProperty$[rsp+20], 2
	mov	QWORD PTR [rsp+48], rax
	mov	edx, 3080195				; 002f0003H
	lea	rax, QWORD PTR sampleFormat$GSCopy$[rsp]
	mov	DWORD PTR [rsp+40], 4
	mov	QWORD PTR [rsp+32], rax
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 6
	call	QWORD PTR __imp_DeviceIoControl

; 341  : 
; 342  :     return result;
; 343  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?SetSampleFormat@@YAHPEAXK@Z ENDP			; SetSampleFormat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?ReleaseAsioOwnership@@YAHPEAX@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
?ReleaseAsioOwnership@@YAHPEAX@Z PROC			; ReleaseAsioOwnership, COMDAT

; 465  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 466  :     BOOL       result = FALSE;
; 467  :     KSPROPERTY privateProperty{};
; 468  :     ULONG      bytesReturned = 0;
; 469  : 
; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	edx, edx

; 471  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$[rsp+20], 2

; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);
; 473  : 
; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rdx
	mov	DWORD PTR bytesReturned$[rsp], edx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 13
	call	QWORD PTR __imp_DeviceIoControl

; 475  : 
; 476  :     return result;
; 477  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?ReleaseAsioOwnership@@YAHPEAX@Z ENDP			; ReleaseAsioOwnership
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?UnsetAsioBuffer@@YAHPEAX@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
?UnsetAsioBuffer@@YAHPEAX@Z PROC			; UnsetAsioBuffer, COMDAT

; 447  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 448  :     BOOL       result = FALSE;
; 449  :     KSPROPERTY privateProperty{};
; 450  :     ULONG      bytesReturned = 0;
; 451  : 
; 452  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	edx, edx

; 453  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$[rsp+20], 2

; 454  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::UnsetAsioBuffer);
; 455  : 
; 456  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rdx
	mov	DWORD PTR bytesReturned$[rsp], edx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 12
	call	QWORD PTR __imp_DeviceIoControl

; 457  : 
; 458  :     return result;
; 459  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?UnsetAsioBuffer@@YAHPEAX@Z ENDP			; UnsetAsioBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?StartAsioStream@@YAHPEAX@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
?StartAsioStream@@YAHPEAX@Z PROC			; StartAsioStream, COMDAT

; 386  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 387  :     BOOL       result = FALSE;
; 388  :     KSPROPERTY privateProperty{};
; 389  :     ULONG      bytesReturned = 0;
; 390  : 
; 391  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	edx, edx

; 392  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$[rsp+20], 2

; 393  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::StartAsioStream);
; 394  : 
; 395  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rdx
	mov	DWORD PTR bytesReturned$[rsp], edx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 9
	call	QWORD PTR __imp_DeviceIoControl

; 396  : 
; 397  :     return result;
; 398  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?StartAsioStream@@YAHPEAX@Z ENDP			; StartAsioStream
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z
_TEXT	SEGMENT
privateProperty$ = 72
setFlagsContext$ = 96
__$ArrayPad$ = 160
deviceHandle$ = 192
flags$ = 200
?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z PROC	; SetFlags, COMDAT

; 311  : {

$LN4:
	mov	r11, rsp
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 312  :     BOOL                  result = FALSE;
; 313  :     KSPROPERTY            privateProperty{};
; 314  :     ULONG                 bytesReturned = 0;
; 315  :     UAC_SET_FLAGS_CONTEXT setFlagsContext = flags;

	movups	xmm0, XMMWORD PTR [rdx]
	mov	eax, DWORD PTR [rdx+56]
	xor	r8d, r8d
	movups	xmm1, XMMWORD PTR [rdx+16]

; 316  : 
; 317  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;
; 318  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 319  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetFlags);
; 320  : 
; 321  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setFlagsContext, sizeof(UAC_SET_FLAGS_CONTEXT), &bytesReturned, nullptr);

	mov	QWORD PTR [r11-128], r8
	mov	r9d, 24
	movups	XMMWORD PTR setFlagsContext$[rsp], xmm0
	mov	DWORD PTR [r11-120], r8d
	lea	r8, QWORD PTR [r11-112]
	movups	xmm0, XMMWORD PTR [rdx+32]
	mov	DWORD PTR privateProperty$[rsp+20], 2
	movups	XMMWORD PTR setFlagsContext$[rsp+16], xmm1
	mov	DWORD PTR [r11-32], eax
	lea	rax, QWORD PTR [r11-120]
	movsd	xmm1, QWORD PTR [rdx+48]
	mov	edx, 3080195				; 002f0003H
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR [r11-88]
	movups	XMMWORD PTR [r11-56], xmm0
	mov	DWORD PTR [rsp+40], 60			; 0000003cH
	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	mov	DWORD PTR privateProperty$[rsp+16], 5
	movsd	QWORD PTR [r11-40], xmm1
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_DeviceIoControl

; 322  : 
; 323  :     return result;
; 324  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	ret	0
?SetFlags@@YAHPEAXAEBUUAC_SET_FLAGS_CONTEXT_@@@Z ENDP	; SetFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 144
clockInfo$ = 152
?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z PROC ; GetClockInfo, COMDAT

; 239  : {

$LN16:
	push	rbx
	push	rbp
	push	rsi
	sub	rsp, 112				; 00000070H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 240  :     BOOL       result = FALSE;
; 241  :     KSPROPERTY privateProperty{};
; 242  :     ULONG      bytesReturned = 0;

	xor	ebp, ebp
	mov	rbx, rdx
	mov	DWORD PTR bytesReturned$[rsp], ebp
	mov	rsi, rcx

; 243  : 
; 244  :     if (clockInfo == nullptr)

	test	rdx, rdx
	jne	SHORT $LN2@GetClockIn

; 245  :     {
; 246  :         return result;

	xor	eax, eax
	jmp	$LN1@GetClockIn
$LN2@GetClockIn:

; 247  :     }
; 248  : 
; 249  :     *clockInfo = {};
; 250  : 
; 251  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 252  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 253  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetClockInfo);
; 254  : 
; 255  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rbp
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	QWORD PTR [rdx], rbp
	mov	r9d, 24
	mov	DWORD PTR [rsp+40], ebp
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+160], rdi
	mov	DWORD PTR privateProperty$[rsp+20], 1
	mov	DWORD PTR privateProperty$[rsp+16], 2
	call	QWORD PTR __imp_DeviceIoControl
	mov	edi, eax

; 256  : 
; 257  :     if (!result)

	test	eax, eax
	jne	SHORT $LN5@GetClockIn

; 258  :     {
; 259  :         DWORD error = GetLastError();

	call	QWORD PTR __imp_GetLastError

; 260  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CLOCK_INFO_CONTEXT)))

	cmp	eax, 234				; 000000eaH
	jne	SHORT $LN4@GetClockIn
	mov	eax, DWORD PTR bytesReturned$[rsp]
	cmp	eax, 88					; 00000058H
	jb	SHORT $LN4@GetClockIn

; 261  :         {
; 262  :             *clockInfo = (PUAC_GET_CLOCK_INFO_CONTEXT)(new BYTE[bytesReturned]);

	mov	ecx, eax
	call	??_U@YAPEAX_K@Z				; operator new[]

; 263  :             if (clockInfo != nullptr)
; 264  :             {
; 265  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *clockInfo, bytesReturned, &bytesReturned, nullptr);

	mov	r8d, DWORD PTR bytesReturned$[rsp]
	lea	rcx, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+56], rbp
	mov	r9d, 24
	mov	QWORD PTR [rsp+48], rcx
	mov	edx, 3080195				; 002f0003H
	mov	DWORD PTR [rsp+40], r8d
	mov	rcx, rsi
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_DeviceIoControl
	mov	edi, eax

; 266  :                 if (!result)

	test	eax, eax
	jne	SHORT $LN5@GetClockIn

; 267  :                 {
; 268  :                     delete[] (BYTE *)(*clockInfo);

	mov	rcx, QWORD PTR [rbx]
	call	??_V@YAXPEAX@Z				; operator delete[]

; 269  :                     *clockInfo = nullptr;

	mov	QWORD PTR [rbx], rbp

; 270  :                 }
; 271  :             }
; 272  :             else
; 273  :             {
; 274  :                 result = FALSE;
; 275  :             }
; 276  :         }

	jmp	SHORT $LN5@GetClockIn
$LN4@GetClockIn:

; 277  :         else
; 278  :         {
; 279  :             result = FALSE;

	mov	edi, ebp
$LN5@GetClockIn:

; 280  :         }
; 281  :     }
; 282  : 
; 283  :     return result;

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+160]
$LN1@GetClockIn:

; 284  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 112				; 00000070H
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z ENDP ; GetClockInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?SetClockSource@@YAHPEAXK@Z
_TEXT	SEGMENT
bytesReturned$ = 64
setClockSourceContext$ = 68
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
index$ = 136
?SetClockSource@@YAHPEAXK@Z PROC			; SetClockSource, COMDAT

; 291  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 292  :     BOOL                         result = FALSE;
; 293  :     KSPROPERTY                   privateProperty{};
; 294  :     ULONG                        bytesReturned = 0;
; 295  :     UAC_SET_CLOCK_SOURCE_CONTEXT setClockSourceContext = {index};
; 296  : 
; 297  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	eax, eax
	mov	DWORD PTR setClockSourceContext$[rsp], edx

; 298  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 299  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetClockSource);
; 300  : 
; 301  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setClockSourceContext, sizeof(UAC_SET_CLOCK_SOURCE_CONTEXT), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR bytesReturned$[rsp], eax
	mov	r9d, 24
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	DWORD PTR privateProperty$[rsp+20], 2
	mov	QWORD PTR [rsp+48], rax
	mov	edx, 3080195				; 002f0003H
	lea	rax, QWORD PTR setClockSourceContext$[rsp]
	mov	DWORD PTR [rsp+40], 4
	mov	QWORD PTR [rsp+32], rax
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 4
	call	QWORD PTR __imp_DeviceIoControl

; 302  : 
; 303  :     return result;
; 304  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?SetClockSource@@YAHPEAXK@Z ENDP			; SetClockSource
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?StopAsioStream@@YAHPEAX@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
?StopAsioStream@@YAHPEAX@Z PROC				; StopAsioStream, COMDAT

; 404  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 405  :     BOOL       result = FALSE;
; 406  :     KSPROPERTY privateProperty{};
; 407  :     ULONG      bytesReturned = 0;
; 408  : 
; 409  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	edx, edx

; 410  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$[rsp+20], 2

; 411  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::StopAsioStream);
; 412  : 
; 413  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rdx
	mov	DWORD PTR bytesReturned$[rsp], edx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 10
	call	QWORD PTR __imp_DeviceIoControl

; 414  : 
; 415  :     return result;
; 416  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?StopAsioStream@@YAHPEAX@Z ENDP				; StopAsioStream
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?GetAsioOwnership@@YAHPEAX@Z
_TEXT	SEGMENT
bytesReturned$ = 64
privateProperty$ = 72
__$ArrayPad$ = 96
deviceHandle$ = 128
?GetAsioOwnership@@YAHPEAX@Z PROC			; GetAsioOwnership, COMDAT

; 368  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 369  :     BOOL       result = FALSE;
; 370  :     KSPROPERTY privateProperty{};
; 371  :     ULONG      bytesReturned = 0;
; 372  : 
; 373  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	edx, edx

; 374  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;

	mov	DWORD PTR privateProperty$[rsp+20], 2

; 375  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAsioOwnership);
; 376  : 
; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rdx
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR [rsp+40], edx
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rdx
	mov	DWORD PTR bytesReturned$[rsp], edx
	mov	edx, 3080195				; 002f0003H
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 8
	call	QWORD PTR __imp_DeviceIoControl

; 378  : 
; 379  :     return result;
; 380  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?GetAsioOwnership@@YAHPEAX@Z ENDP			; GetAsioOwnership
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?SetAsioBuffer@@YAHPEAXPEAEK1K@Z
_TEXT	SEGMENT
bytesReturned$ = 64
__$ArrayPad$ = 72
deviceHandle$ = 96
driverPlayBufferWithKsProperty$ = 104
driverPlayBufferWithKsPropertySize$ = 112
driverRecBuffer$ = 120
driverRecBufferSize$ = 128
?SetAsioBuffer@@YAHPEAXPEAEK1K@Z PROC			; SetAsioBuffer, COMDAT

; 426  : {

$LN6:
	sub	rsp, 88					; 00000058H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 427  :     BOOL        result = FALSE;

	xor	eax, eax

; 428  :     PKSPROPERTY privateProperty = (PKSPROPERTY)driverPlayBufferWithKsProperty;
; 429  :     ULONG       bytesReturned = 0;

	mov	DWORD PTR bytesReturned$[rsp], eax

; 430  : 
; 431  :     if (driverPlayBufferWithKsPropertySize > sizeof(KSPROPERTY))

	cmp	r8d, 24
	jbe	SHORT $LN4@SetAsioBuf

; 432  :     {
; 433  :         privateProperty->Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 434  :         privateProperty->Flags = KSPROPERTY_TYPE_SET;
; 435  :         privateProperty->Id = toInt(KsPropertyUACLowLatencyAudio::SetAsioBuffer);
; 436  : 
; 437  :         result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, privateProperty, driverPlayBufferWithKsPropertySize, driverRecBuffer, driverRecBufferSize, &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR driverRecBufferSize$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	QWORD PTR [rsp+32], r9
	mov	r9d, r8d
	mov	r8, rdx
	mov	DWORD PTR [rdx+20], 2
	movups	XMMWORD PTR [rdx], xmm0
	mov	DWORD PTR [rdx+16], 11
	mov	edx, 3080195				; 002f0003H
	call	QWORD PTR __imp_DeviceIoControl
$LN4@SetAsioBuf:

; 438  :     }
; 439  : 
; 440  :     return result;
; 441  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 88					; 00000058H
	ret	0
?SetAsioBuffer@@YAHPEAXPEAEK1K@Z ENDP			; SetAsioBuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?ChangeSampleRate@@YAHPEAXK@Z
_TEXT	SEGMENT
bytesReturned$ = 64
sampleRate$GSCopy$ = 72
privateProperty$ = 80
__$ArrayPad$ = 104
deviceHandle$ = 128
sampleRate$ = 136
?ChangeSampleRate@@YAHPEAXK@Z PROC			; ChangeSampleRate, COMDAT

; 350  : {

$LN4:
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 351  :     BOOL       result = FALSE;
; 352  :     KSPROPERTY privateProperty{};
; 353  :     ULONG      bytesReturned = 0;
; 354  : 
; 355  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio
	xor	eax, eax
	mov	DWORD PTR sampleRate$GSCopy$[rsp], edx

; 356  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 357  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ChangeSampleRate);
; 358  : 
; 359  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleRate, sizeof(ULONG), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], rax
	lea	r8, QWORD PTR privateProperty$[rsp]
	mov	DWORD PTR bytesReturned$[rsp], eax
	mov	r9d, 24
	lea	rax, QWORD PTR bytesReturned$[rsp]
	mov	DWORD PTR privateProperty$[rsp+20], 2
	mov	QWORD PTR [rsp+48], rax
	mov	edx, 3080195				; 002f0003H
	lea	rax, QWORD PTR sampleRate$GSCopy$[rsp]
	mov	DWORD PTR [rsp+40], 4
	mov	QWORD PTR [rsp+32], rax
	movups	XMMWORD PTR privateProperty$[rsp], xmm0
	mov	DWORD PTR privateProperty$[rsp+16], 7
	call	QWORD PTR __imp_DeviceIoControl

; 360  : 
; 361  :     return result;
; 362  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?ChangeSampleRate@@YAHPEAXK@Z ENDP			; ChangeSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z
_TEXT	SEGMENT
classGuid$dead$ = 48
serviceName$dead$ = 56
referenceString$dead$ = 64
desiredPath$ = 72
?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z PROC		; OpenUsbDevice, COMDAT

; 156  : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r9

; 157  :     HANDLE targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, desiredPath);

	call	?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z ; OpenUsbDeviceCore

; 158  : 
; 159  :     if ((targetHandle == INVALID_HANDLE_VALUE) && (desiredPath != nullptr))

	cmp	rax, -1
	jne	SHORT $LN4@OpenUsbDev
	test	rbx, rbx
	je	SHORT $LN4@OpenUsbDev

; 160  :     {
; 161  :         // force open
; 162  :         targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, nullptr);

	xor	r9d, r9d

; 163  :     }
; 164  :     return targetHandle;
; 165  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 160  :     {
; 161  :         // force open
; 162  :         targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, nullptr);

	jmp	?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z ; OpenUsbDeviceCore
$LN4@OpenUsbDev:

; 163  :     }
; 164  :     return targetHandle;
; 165  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?OpenUsbDevice@@YAPEAXQEAU_GUID@@PEBD11@Z ENDP		; OpenUsbDevice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h
;	COMDAT ?toInt@@YAHW4KsPropertyUACLowLatencyAudio@@@Z
_TEXT	SEGMENT
Property$ = 8
?toInt@@YAHW4KsPropertyUACLowLatencyAudio@@@Z PROC	; toInt, COMDAT

; 126  :     return static_cast<int>(Property);

	mov	eax, ecx

; 127  : }

	ret	0
?toInt@@YAHW4KsPropertyUACLowLatencyAudio@@@Z ENDP	; toInt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
;	COMDAT ?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z
_TEXT	SEGMENT
deviceInterfaceDetailDataSize$5 = 64
bytesReturned$6 = 68
deviceInterfaceData$7 = 72
privateProperty$8 = 104
deviceInfoData$9 = 128
audioProp$10 = 160
serviceName$11 = 576
__$ArrayPad$ = 704
classGuid$dead$ = 768
__formal$dead$ = 776
referenceString$dead$ = 784
desiredPath$ = 792
?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z PROC	; OpenUsbDeviceCore, COMDAT

; 41   : {

	push	rbp
	push	rbx
	push	r15
	lea	rbp, QWORD PTR [rsp-480]
	sub	rsp, 736				; 000002e0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r15, r9

; 42   :     BOOL result = FALSE;
; 43   : 
; 44   :     HDEVINFO deviceInfo = SetupDiGetClassDevs(classGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

	lea	rcx, OFFSET FLAT:_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196
	mov	r9d, 18
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_SetupDiGetClassDevsA
	mov	rbx, rax

; 45   : 
; 46   :     if (deviceInfo == INVALID_HANDLE_VALUE)

	cmp	rax, -1
	jne	SHORT $LN5@OpenUsbDev

; 47   :     {
; 48   :         return INVALID_HANDLE_VALUE;

	jmp	$LN1@OpenUsbDev
$LN5@OpenUsbDev:
	mov	QWORD PTR [rsp+768], rsi

; 55   : 
; 56   :         result = SetupDiEnumDeviceInterfaces(deviceInfo, nullptr, classGuid, index, &deviceInterfaceData);

	lea	rax, QWORD PTR deviceInterfaceData$7[rsp]
	mov	QWORD PTR [rsp+776], rdi
	lea	r8, OFFSET FLAT:_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196
	mov	QWORD PTR [rsp+728], r12
	xor	r9d, r9d
	xor	r12d, r12d
	mov	QWORD PTR [rsp+720], r14
	xor	edx, edx
	mov	DWORD PTR deviceInterfaceData$7[rsp], 32 ; 00000020H
	mov	rcx, rbx
	mov	QWORD PTR [rsp+32], rax
	mov	r14d, r12d
	call	QWORD PTR __imp_SetupDiEnumDeviceInterfaces

; 57   : 
; 58   :         if (!result)

	test	eax, eax
	je	$LN28@OpenUsbDev
	npad	13
$LL4@OpenUsbDev:

; 61   :             {
; 62   :                 goto OpenUsbDeviceCore_Error;
; 63   :             }
; 64   :             else
; 65   :             {
; 66   :                 break;
; 67   :             }
; 68   :         }
; 69   : 
; 70   :         BOOL            success = TRUE;
; 71   :         DWORD           deviceInterfaceDetailDataSize = 0;
; 72   :         TCHAR           serviceName[128];
; 73   :         SP_DEVINFO_DATA deviceInfoData;
; 74   :         deviceInfoData.cbSize = sizeof(deviceInfoData);
; 75   : 
; 76   :         success = SetupDiGetDeviceInterfaceDetail(deviceInfo, &deviceInterfaceData, nullptr, 0, &deviceInterfaceDetailDataSize, &deviceInfoData);

	lea	rax, QWORD PTR deviceInfoData$9[rbp-256]
	mov	DWORD PTR deviceInterfaceDetailDataSize$5[rsp], r12d
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, QWORD PTR deviceInterfaceData$7[rsp]
	lea	rax, QWORD PTR deviceInterfaceDetailDataSize$5[rsp]
	mov	DWORD PTR deviceInfoData$9[rbp-256], 32	; 00000020H
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	xor	r8d, r8d
	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiGetDeviceInterfaceDetailA

; 77   :         // Check for error.
; 78   :         if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (!deviceInterfaceDetailDataSize))

	call	QWORD PTR __imp_GetLastError
	cmp	eax, 122				; 0000007aH
	jne	$LN29@OpenUsbDev
	cmp	DWORD PTR deviceInterfaceDetailDataSize$5[rsp], r12d
	je	$LN29@OpenUsbDev

; 81   :             break;
; 82   :         }
; 83   : 
; 84   :         if (SetupDiGetDeviceRegistryProperty(deviceInfo, &deviceInfoData, SPDRP_SERVICE, nullptr, (PBYTE)serviceName, sizeof(serviceName), nullptr))

	mov	QWORD PTR [rsp+48], r12
	lea	rax, QWORD PTR serviceName$11[rbp-256]
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	lea	rdx, QWORD PTR deviceInfoData$9[rbp-256]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rax
	mov	r8d, 4
	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiGetDeviceRegistryPropertyA
	test	eax, eax
	je	$LN2@OpenUsbDev

; 85   :         {
; 86   :             if (_tcsicmp(serviceName, serviceName) == 0)

	lea	rdx, QWORD PTR serviceName$11[rbp-256]
	lea	rcx, QWORD PTR serviceName$11[rbp-256]
	call	_stricmp
	test	eax, eax
	jne	$LN2@OpenUsbDev

; 87   :             {
; 88   :                 // Allocate the buffer for the device interface detail data.
; 89   :                 PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData = nullptr;
; 90   : 
; 91   :                 deviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) new BYTE[deviceInterfaceDetailDataSize];

	mov	ecx, DWORD PTR deviceInterfaceDetailDataSize$5[rsp]
	call	??_U@YAPEAX_K@Z				; operator new[]

; 92   : 
; 93   :                 if (!deviceInterfaceDetailData)
; 94   :                 {
; 95   :                     break;
; 96   :                 }
; 97   :                 (deviceInterfaceDetailData)->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
; 98   : 
; 99   :                 if (SetupDiGetDeviceInterfaceDetail(deviceInfo, &deviceInterfaceData, deviceInterfaceDetailData, deviceInterfaceDetailDataSize, nullptr, nullptr))

	mov	QWORD PTR [rsp+40], r12
	lea	rdx, QWORD PTR deviceInterfaceData$7[rsp]
	mov	r8, rax
	mov	QWORD PTR [rsp+32], r12
	mov	rcx, rbx
	mov	rsi, rax
	mov	DWORD PTR [rax], 8
	mov	r9d, DWORD PTR deviceInterfaceDetailDataSize$5[rsp]
	call	QWORD PTR __imp_SetupDiGetDeviceInterfaceDetailA
	test	eax, eax
	je	$LN21@OpenUsbDev

; 100  :                 {
; 101  :                     info_print_("compare %s, %s\n", deviceInterfaceDetailData->DevicePath, referenceString);
; 102  :                     if (StrStrI(deviceInterfaceDetailData->DevicePath, referenceString) != nullptr)

	lea	rdx, OFFSET FLAT:??_C@_0O@LGMBKNOO@RenderDevice0@
	lea	rcx, QWORD PTR [rsi+4]
	call	QWORD PTR __imp_StrStrIA
	test	rax, rax
	je	$LN21@OpenUsbDev

; 103  :                     {
; 104  :                         if ((desiredPath == nullptr) || ((desiredPath != nullptr && _tcsicmp(deviceInterfaceDetailData->DevicePath, desiredPath) == 0)))

	test	r15, r15
	je	SHORT $LN18@OpenUsbDev
	mov	rdx, r15
	lea	rcx, QWORD PTR [rsi+4]
	call	_stricmp
	test	eax, eax
	jne	$LN21@OpenUsbDev
$LN18@OpenUsbDev:

; 105  :                         {
; 106  :                             HANDLE targetHandle = CreateFile(deviceInterfaceDetailData->DevicePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);

	mov	QWORD PTR [rsp+48], r12
	lea	rcx, QWORD PTR [rsi+4]
	mov	DWORD PTR [rsp+40], r12d
	xor	r9d, r9d
	mov	edx, -2147483648			; 80000000H
	mov	DWORD PTR [rsp+32], 3
	mov	r8d, 3
	call	QWORD PTR __imp_CreateFileA
	mov	rdi, rax

; 107  : 
; 108  :                             if (targetHandle != INVALID_HANDLE_VALUE)

	cmp	rax, -1
	je	SHORT $LN21@OpenUsbDev

; 177  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	movups	xmm0, XMMWORD PTR KSPROPSETID_LowLatencyAudio

; 178  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);
; 180  : 
; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	mov	QWORD PTR [rsp+56], r12
	lea	rax, QWORD PTR bytesReturned$6[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	r8, QWORD PTR privateProperty$8[rsp]
	lea	rax, QWORD PTR audioProp$10[rbp-256]
	mov	DWORD PTR [rsp+40], 408			; 00000198H
	mov	r9d, 24
	mov	QWORD PTR [rsp+32], rax
	mov	edx, 3080195				; 002f0003H
	mov	DWORD PTR bytesReturned$6[rsp], r12d
	mov	rcx, rdi
	mov	DWORD PTR privateProperty$8[rsp+20], 1
	movups	XMMWORD PTR privateProperty$8[rsp], xmm0
	mov	DWORD PTR privateProperty$8[rsp+16], r12d
	call	QWORD PTR __imp_DeviceIoControl

; 109  :                             {
; 110  :                                 UAC_AUDIO_PROPERTY audioProp;
; 111  :                                 result = GetAudioProperty(targetHandle, &audioProp);
; 112  :                                 if (result && (audioProp.OutputAsioChannels != 0))

	test	eax, eax
	je	SHORT $LN20@OpenUsbDev
	cmp	DWORD PTR audioProp$10[rbp+92], r12d
	jne	$LN31@OpenUsbDev
$LN20@OpenUsbDev:

; 120  :                                 }
; 121  :                                 else
; 122  :                                 {
; 123  :                                     CloseHandle(targetHandle);

	mov	rcx, rdi
	call	QWORD PTR __imp_CloseHandle
$LN21@OpenUsbDev:

; 124  :                                     targetHandle = INVALID_HANDLE_VALUE;
; 125  :                                 }
; 126  :                             }
; 127  :                         }
; 128  :                     }
; 129  :                 }
; 130  :                 if (deviceInterfaceDetailData != nullptr)
; 131  :                 {
; 132  :                     delete[] (BYTE *)deviceInterfaceDetailData;

	mov	rcx, rsi
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN2@OpenUsbDev:

; 49   :     }
; 50   : 
; 51   :     for (DWORD index = 0;; index++)
; 52   :     {
; 53   :         SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
; 54   :         deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

	lea	rax, QWORD PTR deviceInterfaceData$7[rsp]
	mov	DWORD PTR deviceInterfaceData$7[rsp], 32 ; 00000020H
	inc	r14d

; 55   : 
; 56   :         result = SetupDiEnumDeviceInterfaces(deviceInfo, nullptr, classGuid, index, &deviceInterfaceData);

	mov	QWORD PTR [rsp+32], rax
	mov	r9d, r14d
	lea	r8, OFFSET FLAT:_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196
	xor	edx, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiEnumDeviceInterfaces

; 57   : 
; 58   :         if (!result)

	test	eax, eax
	jne	$LL4@OpenUsbDev
$LN28@OpenUsbDev:

; 59   :         {
; 60   :             if (ERROR_NO_MORE_ITEMS != GetLastError())

	call	QWORD PTR __imp_GetLastError
$OpenUsbDeviceCore_Error$53:

; 133  :                     deviceInterfaceDetailData = nullptr;
; 134  :                 }
; 135  :             }
; 136  :         }
; 137  :     }
; 138  : 
; 139  : OpenUsbDeviceCore_Error:
; 140  :     if (deviceInfo != INVALID_HANDLE_VALUE)
; 141  :     {
; 142  :         SetupDiDestroyDeviceInfoList(deviceInfo);

	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiDestroyDeviceInfoList

; 143  :         deviceInfo = INVALID_HANDLE_VALUE;
; 144  :     }
; 145  : 
; 146  :     return INVALID_HANDLE_VALUE;

	mov	rax, -1
$LN51@OpenUsbDev:
	mov	r12, QWORD PTR [rsp+728]
	mov	rdi, QWORD PTR [rsp+776]
	mov	rsi, QWORD PTR [rsp+768]
	mov	r14, QWORD PTR [rsp+720]
$LN1@OpenUsbDev:

; 147  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 736				; 000002e0H
	pop	r15
	pop	rbx
	pop	rbp
	ret	0
$LN31@OpenUsbDev:

; 113  :                                 {
; 114  :                                     info_print_("successfully opened %s\n", deviceInterfaceDetailData->DevicePath);
; 115  :                                     delete[] (BYTE *)deviceInterfaceDetailData;

	mov	rcx, rsi
	call	??_V@YAXPEAX@Z				; operator delete[]

; 116  :                                     deviceInterfaceDetailData = nullptr;
; 117  :                                     SetupDiDestroyDeviceInfoList(deviceInfo);

	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiDestroyDeviceInfoList

; 118  :                                     deviceInfo = INVALID_HANDLE_VALUE;
; 119  :                                     return targetHandle;

	mov	rax, rdi
	jmp	SHORT $LN51@OpenUsbDev
$LN29@OpenUsbDev:

; 79   :         {
; 80   :             SetupDiDestroyDeviceInfoList(deviceInfo);

	mov	rcx, rbx
	call	QWORD PTR __imp_SetupDiDestroyDeviceInfoList
	jmp	SHORT $OpenUsbDeviceCore_Error$53
?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z ENDP	; OpenUsbDeviceCore
_TEXT	ENDS
END
