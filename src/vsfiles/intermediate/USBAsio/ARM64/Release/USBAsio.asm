; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35216.0 

	TTL	g:\github\microsoft\low-latency-audio\src\vsfiles\intermediate\usbasio\arm64\release\usbasio.obj
	;ARM64

	AREA	|.drectve|, DRECTVE

	EXPORT	|?g_Templates@@3PAVCFactoryTemplate@@A| [ DATA ] ; g_Templates
	EXPORT	|?g_NumOfTemplates@@3HA| [ DATA ]	; g_NumOfTemplates
	EXPORT	|??_C@_00CNPNBAHC@@| [ DATA ]		; `string'
	EXPORT	|??_C@_0BC@EOODALEL@Unknown?5exception@| [ DATA ] ; `string'
	EXPORT	|??_C@_09FBNMMHMJ@Exception@| [ DATA ]	; `string'
	EXPORT	|??_C@_08PHCNGLJD@ReturnNt@| [ DATA ]	; `string'
	EXPORT	|??_C@_08KFPKLAKH@ReturnHr@| [ DATA ]	; `string'
	EXPORT	|??_C@_05LKGDKHFF@LogNt@| [ DATA ]	; `string'
	EXPORT	|??_C@_05OILEHMGB@LogHr@| [ DATA ]	; `string'
	EXPORT	|??_C@_08IAOKKAJK@FailFast@| [ DATA ]	; `string'
	EXPORT	|??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@| [ DATA ] ; `string'
	EXPORT	|??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@| [ DATA ] ; `string'
	EXPORT	|??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@| [ DATA ] ; `string'
	EXPORT	|??_C@_13LBAGMAIH@?$AA?6@| [ DATA ]	; `string'
	EXPORT	|??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BH@EEDPADAA@RaiseFailFastException@| [ DATA ] ; `string'
	EXPORT	|??_C@_0O@KIMGFJMA@WIL?5Exception@| [ DATA ] ; `string'
	EXPORT	|??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BC@CNPFEPCO@FixedSamplingRate@| [ DATA ] ; `string'
	EXPORT	|??_C@_0N@FDBGAPPM@PeriodFrames@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@| [ DATA ] ; `string'
	EXPORT	|??_C@_0N@BNFIBEN@MaxIrpNumber@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BD@JPDMMNEG@FirstPacketLatency@| [ DATA ] ; `string'
	EXPORT	|??_C@_0O@DDKFKBEA@PreSendFrames@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BB@PIAJBBGI@OutputFrameDelay@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@| [ DATA ] ; `string'
	EXPORT	|??_C@_0L@ONBBLLLB@AsioDevice@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@| [ DATA ] ; `string'
	EXPORT	|??_C@_0N@DLKKJNAP@OutHubOffset@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@| [ DATA ] ; `string'
	EXPORT	|??_C@_0M@IIIMLOLG@InHubOffset@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BF@BAAHAIB@BufferThreadPriority@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BB@GLAIOBJJ@DropoutDetection@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BH@ECDADGG@OutBulkOperationOffset@| [ DATA ] ; `string'
	EXPORT	|??_C@_0O@CHCBIFB@USBAudio2?9ACX@| [ DATA ] ; `string'
	EXPORT	|??_C@_0O@LGMBKNOO@RenderDevice0@| [ DATA ] ; `string'
	EXPORT	|??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@| [ DATA ] ; `string'
	EXPORT	|??_C@_09OOLPICH@Apartment@| [ DATA ]	; `string'
	EXPORT	|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@| [ DATA ] ; `string'
	EXPORT	|??_C@_0M@BFGLKKGE@USBAsio?4dll@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@| [ DATA ] ; `string'
	EXPORT	|??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@| [ DATA ] ; `string'
	EXPORT	|??_C@_08KPIIIDA@CUSBAsio@| [ DATA ]	; `string'
	EXPORT	|??_C@_02KPKOKMHB@?$CFS@| [ DATA ]	; `string'
	EXPORT	|??_C@_0L@CIJEIFL@channel?5?$CFu@| [ DATA ] ; `string'
	EXPORT	|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@| [ DATA ] ; `string'
	EXPORT	|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@| [ DATA ] ; `string'
	EXPORT	|??_C@_09FJFDCAPM@Pro?5Audio@| [ DATA ]	; `string'
	EXPORT	|_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196| [ DATA ]
	EXPORT	|??_R4IASIO@@6B@| [ DATA ]		; IASIO::`RTTI Complete Object Locator'
	EXPORT	|??_R4exception@std@@6B@| [ DATA ]	; std::exception::`RTTI Complete Object Locator'
	EXPORT	|??_R3IASIO@@8| [ DATA ]		; IASIO::`RTTI Class Hierarchy Descriptor'
	EXPORT	|??_R3CUSBAsio@@8| [ DATA ]		; CUSBAsio::`RTTI Class Hierarchy Descriptor'
	EXPORT	|??_R0?AVbad_alloc@std@@@8| [ DATA ]	; std::bad_alloc `RTTI Type Descriptor'
	EXPORT	|g_pfnResultLoggingCallback| [ DATA ]
	EXPORT	|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA| [ DATA ] ; wil::g_pfnResultFromCaughtException
	EXPORT	|?g_resultMessageCallbackSet@details@wil@@3_NA| [ DATA ] ; wil::details::g_resultMessageCallbackSet
	EXPORT	|?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA| [ DATA ] ; wil::details::g_pfnFormatNtStatusMsg
	EXPORT	|g_pfnResultFromCaughtException_CppWinRt| [ DATA ]
	EXPORT	|g_pfnResultFromCaughtException_WinRt| [ DATA ]
	EXPORT	|??_R17?0A@EA@INonDelegatingUnknown@@8| [ DATA ] ; INonDelegatingUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	EXPORT	|??_R3ResultException@wil@@8| [ DATA ]	; wil::ResultException::`RTTI Class Hierarchy Descriptor'
	EXPORT	|??_R1A@?0A@EA@IASIO@@8| [ DATA ]	; IASIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
	EXPORT	|??_R2CUSBAsio@@8| [ DATA ]		; CUSBAsio::`RTTI Base Class Array'
	EXPORT	|??_7CUSBAsio@@6BCUnknown@@@| [ DATA ]	; CUSBAsio::`vftable'
	EXPORT	|?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC| [ DATA ] ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid
	EXPORT	|?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC| [ DATA ] ; `wil::details::RecordFailFast'::`2'::s_hrErrorLast
	EXPORT	|??_7IASIO@@6B@| [ DATA ]		; IASIO::`vftable'
	EXPORT	|??_R1A@?0A@EA@exception@std@@8| [ DATA ] ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	EXPORT	|??_7CUSBAsio@@6BIASIO@@@| [ DATA ]	; CUSBAsio::`vftable'
	EXPORT	|??_R1BA@?0A@EA@CBaseObject@@8| [ DATA ] ; CBaseObject::`RTTI Base Class Descriptor at (16,-1,0,64)'
	EXPORT	|??_R1A@?0A@EA@ResultException@wil@@8| [ DATA ] ; wil::ResultException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	EXPORT	|??_R0?AVResultException@wil@@@8| [ DATA ] ; wil::ResultException `RTTI Type Descriptor'
	EXPORT	|??_R2IASIO@@8| [ DATA ]		; IASIO::`RTTI Base Class Array'
	EXPORT	|??_R2ResultException@wil@@8| [ DATA ]	; wil::ResultException::`RTTI Base Class Array'
	EXPORT	|?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA| [ DATA ] ; `wil::details::GetCurrentModuleName'::`2'::s_szModule
	EXPORT	|??_R2exception@std@@8| [ DATA ]	; std::exception::`RTTI Base Class Array'
	EXPORT	|??_R4CUSBAsio@@6BCUnknown@@@| [ DATA ]	; CUSBAsio::`RTTI Complete Object Locator'
	EXPORT	|KSPROPSETID_LowLatencyAudio| [ DATA ]
	EXPORT	|_CTA2?AVResultException@wil@@| [ DATA ]
	EXPORT	|??_R17?0A@EA@CUnknown@@8| [ DATA ]	; CUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	EXPORT	|??_7exception@std@@6B@| [ DATA ]	; std::exception::`vftable'
	EXPORT	|??_R3exception@std@@8| [ DATA ]	; std::exception::`RTTI Class Hierarchy Descriptor'
	EXPORT	|??_R0?AVCUSBAsio@@@8| [ DATA ]		; CUSBAsio `RTTI Type Descriptor'
	EXPORT	|?IID_ASIO_DRIVER@@3U_GUID@@A| [ DATA ]	; IID_ASIO_DRIVER
	EXPORT	|??_R4ResultException@wil@@6B@| [ DATA ] ; wil::ResultException::`RTTI Complete Object Locator'
	EXPORT	|??_R0?AUIASIO@@@8| [ DATA ]		; IASIO `RTTI Type Descriptor'
	EXPORT	|??_R1A@?0A@EA@CUSBAsio@@8| [ DATA ]	; CUSBAsio::`RTTI Base Class Descriptor at (0,-1,0,64)'
	EXPORT	|??_R4CUSBAsio@@6BIASIO@@@| [ DATA ]	; CUSBAsio::`RTTI Complete Object Locator'
	EXPORT	|??_7ResultException@wil@@6B@| [ DATA ]	; wil::ResultException::`vftable'
	EXPORT	|_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24| [ DATA ]
	EXPORT	|_CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208| [ DATA ]
	EXPORT	|??_R0?AVexception@std@@@8| [ DATA ]	; std::exception `RTTI Type Descriptor'
	EXPORT	|_TI2?AVResultException@wil@@| [ DATA ]
	IMPORT	|_splitpath_s|
	IMPORT	|__imp_QueryPerformanceCounter|
	IMPORT	|__imp_CreateEventA|
	IMPORT	|__imp_DebugBreak|
	IMPORT	|__imp_CreateProcessA|
	IMPORT	|__imp_LoadStringA|
	IMPORT	|__imp_GetModuleHandleW|
	IMPORT	|__imp_GetProcessHeap|
	IMPORT	|__imp_DeleteCriticalSection|
	IMPORT	|__imp_AvSetMmThreadCharacteristicsA|
	IMPORT	|__imp_GetProcAddress|
	IMPORT	|__imp_AvSetMmThreadPriority|
	IMPORT	|??_U@YAPEAX_K@Z|			; operator new[]
	IMPORT	|__imp_HeapAlloc|
	IMPORT	|__imp_ResetEvent|
	IMPORT	|__imp_CloseHandle|
	IMPORT	|_errno|
	IMPORT	|__stdio_common_vswprintf|
	IMPORT	|__imp_QueryPerformanceFrequency|
	IMPORT	|__imp_SetEvent|
	IMPORT	|__imp_K32GetModuleFileNameExA|
	IMPORT	|__imp_FormatMessageW|
	IMPORT	|_purecall|
	IMPORT	|__imp_Sleep|
	IMPORT	|_invalid_parameter_noinfo|
	IMPORT	|__imp_MessageBoxA|
	IMPORT	|__std_exception_copy|
	IMPORT	|__imp_GetCurrentThreadId|
	IMPORT	|__imp_WaitForSingleObject|
	IMPORT	|__imp_InitializeCriticalSectionEx|
	IMPORT	|_beginthreadex|
	IMPORT	|__imp_LeaveCriticalSection|
	IMPORT	|__imp_SetThreadPriority|
	IMPORT	|__imp_WaitForMultipleObjects|
	IMPORT	|__imp_GetModuleHandleExW|
	IMPORT	|__imp_GetCurrentProcess|
	IMPORT	|__imp_EnterCriticalSection|
	IMPORT	|__imp_HeapFree|
	IMPORT	|__imp_timeGetTime|
	IMPORT	|??_V@YAXPEAX@Z|			; operator delete[]
	IMPORT	|__std_exception_destroy|

	AREA	|.bss|, NOINIT
|g_pfnResultLoggingCallback| % 0x8

	AREA	|.bss|, NOINIT
|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA| % 0x8	; wil::g_pfnResultFromCaughtException

	AREA	|.bss|, NOINIT
|?g_resultMessageCallbackSet@details@wil@@3_NA| % 0x1	; wil::details::g_resultMessageCallbackSet

	AREA	|.bss|, NOINIT
|?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA| % 0x8 ; wil::details::g_pfnFormatNtStatusMsg

	AREA	|.bss|, NOINIT
|g_pfnResultFromCaughtException_CppWinRt| % 0x8

	AREA	|.bss|, NOINIT
|g_pfnResultFromCaughtException_WinRt| % 0x8

	AREA	|.bss|, NOINIT
|?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC| % 0x1 ; `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid

	AREA	|.bss|, NOINIT
|?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC| % 0x4 ; `wil::details::RecordFailFast'::`2'::s_hrErrorLast

	AREA	|.bss|, NOINIT
|?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA| % 0x40 ; `wil::details::GetCurrentModuleName'::`2'::s_szModule

	AREA	|.xdata$x|, DATA, READONLY
|_TI2?AVResultException@wil@@| DCD 0x0
	DCD	|??1ResultException@wil@@UEAA@XZ|
	DCD	0x0
	DCD	|_CTA2?AVResultException@wil@@|

	AREA	|.data$r|, DATA
|??_R0?AVexception@std@@@8| DCQ |??_7type_info@@6B@|, 0	; std::exception `RTTI Type Descriptor'
	DCQ	0x0000000000000000
	DCB	".?AVexception@std@@", 0x0

	AREA	|.xdata$x|, DATA, READONLY
|_CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208| DCD 0x0
	DCD	|??_R0?AVResultException@wil@@@8|
	DCD	0x0
	DCD	0xffffffff
	%	4
	DCD	0xd0
	DCD	|??0ResultException@wil@@QEAA@AEBV01@@Z|

	AREA	|.xdata$x|, DATA, READONLY
|_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24| DCD 0x0
	DCD	|??_R0?AVexception@std@@@8|
	DCD	0x0
	DCD	0xffffffff
	%	4
	DCD	0x18
	DCD	|??0exception@std@@QEAA@AEBV01@@Z|

	AREA	|.rdata|, DATA, READONLY
|??_7ResultException@wil@@6B@| DCQ |??_R4ResultException@wil@@6B@|, 0 ; wil::ResultException::`vftable'
	DCQ	|??_EResultException@wil@@UEAAPEAXI@Z|, 0
	DCQ	|?what@ResultException@wil@@UEBAPEBDXZ|, 0

	AREA	|.rdata$r|, DATA, READONLY
|??_R4CUSBAsio@@6BIASIO@@@| DCD 0x1			; CUSBAsio::`RTTI Complete Object Locator'
	DCD	0x0
	DCD	0x0
	DCD	|??_R0?AVCUSBAsio@@@8|
	DCD	|??_R3CUSBAsio@@8|
	DCD	|??_R4CUSBAsio@@6BIASIO@@@|

	AREA	|.rdata$r|, DATA, READONLY
|??_R1A@?0A@EA@CUSBAsio@@8| DCD |??_R0?AVCUSBAsio@@@8|	; CUSBAsio::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DCD	0x5
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3CUSBAsio@@8|

	AREA	|.data$rs|, DATA
|??_R0?AUIASIO@@@8| DCQ |??_7type_info@@6B@|, 0		; IASIO `RTTI Type Descriptor'
	DCQ	0x0000000000000000
	DCB	".?AUIASIO@@", 0x0

	AREA	|.rdata$r|, DATA, READONLY
|??_R4ResultException@wil@@6B@| DCD 0x1			; wil::ResultException::`RTTI Complete Object Locator'
	DCD	0x0
	DCD	0x0
	DCD	|??_R0?AVResultException@wil@@@8|
	DCD	|??_R3ResultException@wil@@8|
	DCD	|??_R4ResultException@wil@@6B@|

	AREA	|.data$rs|, DATA
|??_R0?AVCUSBAsio@@@8| DCQ |??_7type_info@@6B@|, 0	; CUSBAsio `RTTI Type Descriptor'
	DCQ	0x0000000000000000
	DCB	".?AVCUSBAsio@@", 0x0

	AREA	|.rdata$r|, DATA, READONLY
|??_R3exception@std@@8| DCD 0x0				; std::exception::`RTTI Class Hierarchy Descriptor'
	DCD	0x0
	DCD	0x1
	DCD	|??_R2exception@std@@8|

	AREA	|.rdata|, DATA, READONLY
|??_7exception@std@@6B@| DCQ |??_R4exception@std@@6B@|, 0 ; std::exception::`vftable'
	DCQ	|??_Eexception@std@@UEAAPEAXI@Z|, 0
	DCQ	|?what@exception@std@@UEBAPEBDXZ|, 0

	AREA	|.rdata$r|, DATA, READONLY
|??_R17?0A@EA@CUnknown@@8| DCD |??_R0?AVCUnknown@@@8|	; CUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DCD	0x2
	DCD	0x8
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3CUnknown@@8|

	AREA	|.xdata$x|, DATA, READONLY
|_CTA2?AVResultException@wil@@| DCD 0x2
	DCD	|_CT??_R0?AVResultException@wil@@@8??0ResultException@wil@@QEAA@AEBV01@@Z208|
	DCD	|_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24|

	AREA	|.rdata|, DATA, READONLY
|KSPROPSETID_LowLatencyAudio| DCD 0x16af08f
	DCW	0xf499
	DCW	0x4637
	DCB	0xb7
	DCB	0xa5
	DCB	0xaf
	DCB	0xc0
	DCB	0x1c
	DCB	0x86
	DCB	0x27
	DCB	0x6f

	AREA	|.rdata$r|, DATA, READONLY
|??_R4CUSBAsio@@6BCUnknown@@@| DCD 0x1			; CUSBAsio::`RTTI Complete Object Locator'
	DCD	0x8
	DCD	0x0
	DCD	|??_R0?AVCUSBAsio@@@8|
	DCD	|??_R3CUSBAsio@@8|
	DCD	|??_R4CUSBAsio@@6BCUnknown@@@|

	AREA	|.rdata$r|, DATA, READONLY
|??_R2exception@std@@8| DCD |??_R1A@?0A@EA@exception@std@@8| ; std::exception::`RTTI Base Class Array'
	%	3

	AREA	|.rdata$r|, DATA, READONLY
|??_R2ResultException@wil@@8| DCD |??_R1A@?0A@EA@ResultException@wil@@8| ; wil::ResultException::`RTTI Base Class Array'
	DCD	|??_R1A@?0A@EA@exception@std@@8|
	%	3

	AREA	|.rdata$r|, DATA, READONLY
|??_R2IASIO@@8| DCD |??_R1A@?0A@EA@IASIO@@8|		; IASIO::`RTTI Base Class Array'
	DCD	|??_R1A@?0A@EA@IUnknown@@8|
	%	3

	AREA	|.data$r|, DATA
|??_R0?AVResultException@wil@@@8| DCQ |??_7type_info@@6B@|, 0 ; wil::ResultException `RTTI Type Descriptor'
	DCQ	0x0000000000000000
	DCB	".?AVResultException@wil@@", 0x0

	AREA	|.rdata$r|, DATA, READONLY
|??_R1A@?0A@EA@ResultException@wil@@8| DCD |??_R0?AVResultException@wil@@@8| ; wil::ResultException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DCD	0x1
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3ResultException@wil@@8|

	AREA	|.rdata$r|, DATA, READONLY
|??_R1BA@?0A@EA@CBaseObject@@8| DCD |??_R0?AVCBaseObject@@@8| ; CBaseObject::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DCD	0x0
	DCD	0x10
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3CBaseObject@@8|

	AREA	|.rdata|, DATA, READONLY
|??_7CUSBAsio@@6BIASIO@@@| DCQ |??_R4CUSBAsio@@6BIASIO@@@|, 0 ; CUSBAsio::`vftable'
	DCQ	|?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z|, 0
	DCQ	|?AddRef@CUSBAsio@@UEAAKXZ|, 0
	DCQ	|?Release@CUSBAsio@@UEAAKXZ|, 0
	DCQ	|?init@CUSBAsio@@UEAAJPEAX@Z|, 0
	DCQ	|?getDriverName@CUSBAsio@@UEAAXPEAD@Z|, 0
	DCQ	|?getDriverVersion@CUSBAsio@@UEAAJXZ|, 0
	DCQ	|?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z|, 0
	DCQ	|?start@CUSBAsio@@UEAAJXZ|, 0
	DCQ	|?stop@CUSBAsio@@UEAAJXZ|, 0
	DCQ	|?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|, 0
	DCQ	|?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|, 0
	DCQ	|?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z|, 0
	DCQ	|?canSampleRate@CUSBAsio@@UEAAJN@Z|, 0
	DCQ	|?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|, 0
	DCQ	|?setSampleRate@CUSBAsio@@UEAAJN@Z|, 0
	DCQ	|?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|, 0
	DCQ	|?setClockSource@CUSBAsio@@UEAAJJ@Z|, 0
	DCQ	|?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z|, 0
	DCQ	|?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|, 0
	DCQ	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, 0
	DCQ	|?disposeBuffers@CUSBAsio@@UEAAJXZ|, 0
	DCQ	|?controlPanel@CUSBAsio@@UEAAJXZ|, 0
	DCQ	|?future@CUSBAsio@@UEAAJJPEAX@Z|, 0
	DCQ	|?outputReady@CUSBAsio@@UEAAJXZ|, 0

	AREA	|.rdata$r|, DATA, READONLY
|??_R1A@?0A@EA@exception@std@@8| DCD |??_R0?AVexception@std@@@8| ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DCD	0x0
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3exception@std@@8|

	AREA	|.rdata|, DATA, READONLY
|??_7IASIO@@6B@| DCQ |??_R4IASIO@@6B@|, 0		; IASIO::`vftable'
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0
	DCQ	|_purecall|, 0

	AREA	|.rdata|, DATA, READONLY
|??_7CUSBAsio@@6BCUnknown@@@| DCQ |??_R4CUSBAsio@@6BCUnknown@@@|, 0 ; CUSBAsio::`vftable'
	DCQ	|?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z|, 0
	DCQ	|?NonDelegatingAddRef@CUnknown@@UEAAKXZ|, 0
	DCQ	|?NonDelegatingRelease@CUnknown@@UEAAKXZ|, 0
	DCQ	|??_ECUSBAsio@@W7EAAPEAXI@Z|, 0

	AREA	|.rdata$r|, DATA, READONLY
|??_R2CUSBAsio@@8| DCD |??_R1A@?0A@EA@CUSBAsio@@8|	; CUSBAsio::`RTTI Base Class Array'
	DCD	|??_R1A@?0A@EA@IASIO@@8|
	DCD	|??_R1A@?0A@EA@IUnknown@@8|
	DCD	|??_R17?0A@EA@CUnknown@@8|
	DCD	|??_R17?0A@EA@INonDelegatingUnknown@@8|
	DCD	|??_R1BA@?0A@EA@CBaseObject@@8|
	%	3

	AREA	|.interprocess|, DATA
|?g_WorkerThread@@3JA| DCD 0x0				; g_WorkerThread
|?g_AsioResetThread@@3JA| DCD 0x0			; g_AsioResetThread
|?g_Instance@@3JA| DCD 0x0				; g_Instance

	AREA	|.rdata$r|, DATA, READONLY
|??_R1A@?0A@EA@IASIO@@8| DCD |??_R0?AUIASIO@@@8|	; IASIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DCD	0x1
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3IASIO@@8|

	AREA	|.rdata$r|, DATA, READONLY
|??_R3ResultException@wil@@8| DCD 0x0			; wil::ResultException::`RTTI Class Hierarchy Descriptor'
	DCD	0x0
	DCD	0x2
	DCD	|??_R2ResultException@wil@@8|

	AREA	|.rdata$r|, DATA, READONLY
|??_R17?0A@EA@INonDelegatingUnknown@@8| DCD |??_R0?AUINonDelegatingUnknown@@@8| ; INonDelegatingUnknown::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DCD	0x0
	DCD	0x8
	DCD	0xffffffff
	DCD	0x0
	DCD	0x40
	DCD	|??_R3INonDelegatingUnknown@@8|

	AREA	|.data$r|, DATA
|??_R0?AVbad_alloc@std@@@8| DCQ |??_7type_info@@6B@|, 0	; std::bad_alloc `RTTI Type Descriptor'
	DCQ	0x0000000000000000
	DCB	".?AVbad_alloc@std@@", 0x0

	AREA	|.rdata$r|, DATA, READONLY
|??_R3CUSBAsio@@8| DCD 0x0				; CUSBAsio::`RTTI Class Hierarchy Descriptor'
	DCD	0x1
	DCD	0x6
	DCD	|??_R2CUSBAsio@@8|

	AREA	|.rdata$r|, DATA, READONLY
|??_R3IASIO@@8| DCD 0x0					; IASIO::`RTTI Class Hierarchy Descriptor'
	DCD	0x0
	DCD	0x2
	DCD	|??_R2IASIO@@8|

	AREA	|.rdata$r|, DATA, READONLY
|??_R4exception@std@@6B@| DCD 0x1			; std::exception::`RTTI Complete Object Locator'
	DCD	0x0
	DCD	0x0
	DCD	|??_R0?AVexception@std@@@8|
	DCD	|??_R3exception@std@@8|
	DCD	|??_R4exception@std@@6B@|

	AREA	|.rdata$r|, DATA, READONLY
|??_R4IASIO@@6B@| DCD 0x1				; IASIO::`RTTI Complete Object Locator'
	DCD	0x0
	DCD	0x0
	DCD	|??_R0?AUIASIO@@@8|
	DCD	|??_R3IASIO@@8|
	DCD	|??_R4IASIO@@6B@|

	AREA	|.rdata|, DATA, READONLY
|_GUID_6994ad04_93ef_11d0_a3cc_00a0c9223196| DCD 0x6994ad04
	DCW	0x93ef
	DCW	0x11d0
	DCB	0xa3
	DCB	0xcc
	DCB	0x0
	DCB	0xa0
	DCB	0xc9
	DCB	0x22
	DCB	0x31
	DCB	0x96

	AREA	|.rdata|, DATA, READONLY
|??_C@_09FJFDCAPM@Pro?5Audio@| DCB "Pro Audio", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@| DCB "%s%s%s", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@| DCB "USBAsioControlPanel.e"
	DCB	"xe", 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0L@CIJEIFL@channel?5?$CFu@| DCB "channel %u", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_02KPKOKMHB@?$CFS@| DCB "%S", 0x0			; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_08KPIIIDA@CUSBAsio@| DCB "CUSBAsio", 0x0		; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@| DCB "U"
	DCB	"nregister Server failed ! (%d)", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@| DCB "R"
	DCB	"egister Server failed ! (%d)", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0M@BFGLKKGE@USBAsio?4dll@| DCB "USBAsio.dll", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@| DCB "USB ASIO (ARM64X)", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_09OOLPICH@Apartment@| DCB "Apartment", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@| DCB "Y"
	DCB	0x0, "S", 0x0, "U", 0x0, "S", 0x0, "B", 0x0, "_", 0x0, "A"
	DCB	0x0, "S", 0x0, "I", 0x0, "O", 0x0, 0x0, 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0O@LGMBKNOO@RenderDevice0@| DCB "RenderDevice0", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0O@CHCBIFB@USBAudio2?9ACX@| DCB "USBAudio2-ACX", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BH@ECDADGG@OutBulkOperationOffset@| DCB "OutBulkOperationOffset", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BB@GLAIOBJJ@DropoutDetection@| DCB "DropoutDetection", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BF@BAAHAIB@BufferThreadPriority@| DCB "BufferThreadPriority", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0M@IIIMLOLG@InHubOffset@| DCB "InHubOffset", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@| DCB "InBufferOperationOffse"
	DCB	"t", 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0N@DLKKJNAP@OutHubOffset@| DCB "OutHubOffset", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@| DCB "OutBufferOperationOff"
	DCB	"set", 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0L@ONBBLLLB@AsioDevice@| DCB "AsioDevice", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@| DCB "DelayedOutputBufferS"
	DCB	"witch", 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BB@PIAJBBGI@OutputFrameDelay@| DCB "OutputFrameDelay", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0O@DDKFKBEA@PreSendFrames@| DCB "PreSendFrames", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BD@JPDMMNEG@FirstPacketLatency@| DCB "FirstPacketLatency", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0N@BNFIBEN@MaxIrpNumber@| DCB "MaxIrpNumber", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@| DCB "ClassicFramesPerIrp2", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@| DCB "ClassicFramesPerIrp", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0N@FDBGAPPM@PeriodFrames@| DCB "PeriodFrames", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BC@CNPFEPCO@FixedSamplingRate@| DCB "FixedSamplingRate", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@| DCB "Software\\"
	DCB	"Microsoft\\Windows USB ASIO", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@| DCB "s"
	DCB	0x0, "t", 0x0, "d", 0x0, ":", 0x0, ":", 0x0, "e", 0x0, "x"
	DCB	0x0, "c", 0x0, "e", 0x0, "p", 0x0, "t", 0x0, "i", 0x0, "o"
	DCB	0x0, "n", 0x0, ":", 0x0, " ", 0x0, "%", 0x0, "h", 0x0, "s"
	DCB	0x0, 0x0, 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0O@KIMGFJMA@WIL?5Exception@| DCB "WIL Exception", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BH@EEDPADAA@RaiseFailFastException@| DCB "RaiseFailFastException", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@| DCB "k"
	DCB	0x0, "e", 0x0, "r", 0x0, "n", 0x0, "e", 0x0, "l", 0x0, "b"
	DCB	0x0, "a", 0x0, "s", 0x0, "e", 0x0, ".", 0x0, "d", 0x0, "l"
	DCB	0x0, "l", 0x0, 0x0, 0x0			; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_13LBAGMAIH@?$AA?6@| DCB 0xa, 0x0, 0x0, 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@| DCB "[", 0x0
	DCB	"%", 0x0, "h", 0x0, "s", 0x0, "]", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@| DCB "["
	DCB	0x0, "%", 0x0, "h", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "h"
	DCB	0x0, "s", 0x0, ")", 0x0, "]", 0x0, 0xa, 0x0, 0x0, 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@| DCB "C"
	DCB	0x0, "a", 0x0, "l", 0x0, "l", 0x0, "C", 0x0, "o", 0x0, "n"
	DCB	0x0, "t", 0x0, "e", 0x0, "x", 0x0, "t", 0x0, ":", 0x0, "["
	DCB	0x0, "%", 0x0, "h", 0x0, "s", 0x0, "]", 0x0, " ", 0x0, 0x0
	DCB	0x0					; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@| DCB "M"
	DCB	0x0, "s", 0x0, "g", 0x0, ":", 0x0, "[", 0x0, "%", 0x0, "w"
	DCB	0x0, "s", 0x0, "]", 0x0, " ", 0x0, 0x0, 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@| DCB " ", 0x0, " ", 0x0, " ", 0x0
	DCB	" ", 0x0, 0x0, 0x0			; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@| DCB "%"
	DCB	0x0, "h", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "d", 0x0, ")"
	DCB	0x0, " ", 0x0, "t", 0x0, "i", 0x0, "d", 0x0, "(", 0x0, "%"
	DCB	0x0, "x", 0x0, ")", 0x0, " ", 0x0, "%", 0x0, "0", 0x0, "8"
	DCB	0x0, "X", 0x0, " ", 0x0, "%", 0x0, "w", 0x0, "s", 0x0, 0x0
	DCB	0x0					; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@| DCB "("
	DCB	0x0, "c", 0x0, "a", 0x0, "l", 0x0, "l", 0x0, "e", 0x0, "r"
	DCB	0x0, ":", 0x0, " ", 0x0, "%", 0x0, "p", 0x0, ")", 0x0, " "
	DCB	0x0, 0x0, 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@| DCB "%"
	DCB	0x0, "h", 0x0, "s", 0x0, "!", 0x0, "%", 0x0, "p", 0x0, ":"
	DCB	0x0, " ", 0x0, 0x0, 0x0			; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@| DCB "%"
	DCB	0x0, "h", 0x0, "s", 0x0, "(", 0x0, "%", 0x0, "u", 0x0, ")"
	DCB	0x0, "\\", 0x0, "%", 0x0, "h", 0x0, "s", 0x0, "!", 0x0, "%"
	DCB	0x0, "p", 0x0, ":", 0x0, " ", 0x0, 0x0, 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_08IAOKKAJK@FailFast@| DCB "FailFast", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_05OILEHMGB@LogHr@| DCB "LogHr", 0x0		; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_05LKGDKHFF@LogNt@| DCB "LogNt", 0x0		; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_08KFPKLAKH@ReturnHr@| DCB "ReturnHr", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_08PHCNGLJD@ReturnNt@| DCB "ReturnNt", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_09FBNMMHMJ@Exception@| DCB "Exception", 0x0	; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_0BC@EOODALEL@Unknown?5exception@| DCB "Unknown exception", 0x0 ; `string'

	AREA	|.rdata|, DATA, READONLY
|??_C@_00CNPNBAHC@@| DCB 0x0				; `string'

	AREA	|.rdata|, DATA, READONLY
|?g_NumOfTemplates@@3HA| DCD 0x1			; g_NumOfTemplates
	%	4
|?c_PeriodFramesValueName@@3PEBDEB| DCQ |??_C@_0N@FDBGAPPM@PeriodFrames@|, 0 ; c_PeriodFramesValueName
|?c_RegistryKeyName@@3PEBDEB| DCQ |??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|, 0 ; c_RegistryKeyName
|?c_DropoutDetectionName@@3PEBDEB| DCQ |??_C@_0BB@GLAIOBJJ@DropoutDetection@|, 0 ; c_DropoutDetectionName
|?c_FirstPacketLatencyValueName@@3PEBDEB| DCQ |??_C@_0BD@JPDMMNEG@FirstPacketLatency@|, 0 ; c_FirstPacketLatencyValueName
|?c_OutputHubOffsetName@@3PEBDEB| DCQ |??_C@_0N@DLKKJNAP@OutHubOffset@|, 0 ; c_OutputHubOffsetName
|?c_FrameRateList@@3QBKB| DCD 0x2b11			; c_FrameRateList
	DCD	0x5622
	DCD	0x7d00
	DCD	0xac44
	DCD	0xbb80
	DCD	0x15888
	DCD	0x17700
	DCD	0x2b110
	DCD	0x2ee00
	DCD	0x56220
	DCD	0x5dc00
	DCD	0xac440
	DCD	0xbb800
	%	4
|?c_BufferThreadPriorityName@@3PEBDEB| DCQ |??_C@_0BF@BAAHAIB@BufferThreadPriority@|, 0 ; c_BufferThreadPriorityName
|?c_OutputFrameDelayValueName@@3PEBDEB| DCQ |??_C@_0BB@PIAJBBGI@OutputFrameDelay@|, 0 ; c_OutputFrameDelayValueName
|?c_ClassicFramesPerIrp2ValueName@@3PEBDEB| DCQ |??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@|, 0 ; c_ClassicFramesPerIrp2ValueName
|?c_ReferenceName@@3PEBDEB| DCQ |??_C@_0O@LGMBKNOO@RenderDevice0@|, 0 ; c_ReferenceName
|?c_DelayedOutputBufferSwitchName@@3PEBDEB| DCQ |??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@|, 0 ; c_DelayedOutputBufferSwitchName
|?c_AsioDeviceValueName@@3PEBDEB| DCQ |??_C@_0L@ONBBLLLB@AsioDevice@|, 0 ; c_AsioDeviceValueName
|?c_ClassicFramesPerIrpValueName@@3PEBDEB| DCQ |??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@|, 0 ; c_ClassicFramesPerIrpValueName
|?c_ServiceName@@3PEBDEB| DCQ |??_C@_0O@CHCBIFB@USBAudio2?9ACX@|, 0 ; c_ServiceName
|?c_PreSendFramesValueName@@3PEBDEB| DCQ |??_C@_0O@DDKFKBEA@PreSendFrames@|, 0 ; c_PreSendFramesValueName
|?c_MaxIrpNumberValueName@@3PEBDEB| DCQ |??_C@_0N@BNFIBEN@MaxIrpNumber@|, 0 ; c_MaxIrpNumberValueName
|?c_FixedSamplingRateValueName@@3PEBDEB| DCQ |??_C@_0BC@CNPFEPCO@FixedSamplingRate@|, 0 ; c_FixedSamplingRateValueName
|?c_InputBufferOperationOffsetName@@3PEBDEB| DCQ |??_C@_0BI@IIKKMOIC@InBufferOperationOffset@|, 0 ; c_InputBufferOperationOffsetName
|?c_OutputBufferOperationOffsetName@@3PEBDEB| DCQ |??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@|, 0 ; c_OutputBufferOperationOffsetName
|?c_InputHubOffsetName@@3PEBDEB| DCQ |??_C@_0M@IIIMLOLG@InHubOffset@|, 0 ; c_InputHubOffsetName

	AREA	|.data|, DATA
|?g_Templates@@3PAVCFactoryTemplate@@A| DCQ |??_C@_1BG@NOBPGPPM@?$AAY?$AAS?$AAU?$AAS?$AAB?$AA_?$AAA?$AAS?$AAI?$AAO@|, 0 ; g_Templates
	DCQ	|?IID_ASIO_DRIVER@@3U_GUID@@A|, 0
	DCQ	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, 0
	%	8
|?IID_ASIO_DRIVER@@3U_GUID@@A| DCD 0x327468a4		; IID_ASIO_DRIVER
	DCW	0x1351
	DCW	0x4930
	DCB	0xbb
	DCB	0x6b
	DCB	0xf
	DCB	0xeb
	DCB	0x69
	DCB	0xbf
	DCB	0x5d
	DCB	0x70
	EXPORT	|??_ECUSBAsio@@W7EAAPEAXI@Z|		; [thunk]:CUSBAsio::`vector deleting destructor'
	EXPORT	|?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z| ; wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid
	EXPORT	|??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z| ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
	EXPORT	|?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z| ; wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close
	EXPORT	|??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z| ; wistd::forward<_RTL_CRITICAL_SECTION * &>
	EXPORT	|??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z| ; wil::assign_to_opt_param<char const *>
	EXPORT	|??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z| ; wil::assign_null_to_opt_param<char const *>
	EXPORT	|??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z| ; wil::assign_to_opt_param<wchar_t const *>
	EXPORT	|??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z| ; wil::assign_null_to_opt_param<wchar_t const *>
	EXPORT	|??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ| ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >
	EXPORT	|??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z| ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>
	EXPORT	|??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z| ; wil::details::WriteResultString<char const *>
	EXPORT	|??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z| ; wil::details::WriteResultString<wchar_t const *>
	EXPORT	|??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z| ; wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>
	EXPORT	|??$assign_to_opt_param@I@wil@@YAXPEAII@Z| ; wil::assign_to_opt_param<unsigned int>
	EXPORT	|?WorkerThread@CUSBAsio@@CAIPEAX@Z|	; CUSBAsio::WorkerThread
	EXPORT	|?ThreadStop@CUSBAsio@@AEAAXXZ|		; CUSBAsio::ThreadStop
	EXPORT	|?ThreadStart@CUSBAsio@@AEAAXXZ|	; CUSBAsio::ThreadStart
	EXPORT	|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|	; CUSBAsio::AsioResetThread
	EXPORT	|?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| ; CUSBAsio::RequestClockInfoChange
	EXPORT	|?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| ; CUSBAsio::ObtainDeviceParameter
	EXPORT	|?GetDesiredPath@CUSBAsio@@AEAA_NXZ|	; CUSBAsio::GetDesiredPath
	EXPORT	|?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ| ; CUSBAsio::ExecuteControlPanel
	EXPORT	|?ApplySettings@CUSBAsio@@AEAA_NXZ|	; CUSBAsio::ApplySettings
	EXPORT	|?MeasureLatency@CUSBAsio@@AEAA_NXZ|	; CUSBAsio::MeasureLatency
	EXPORT	|?outputReady@CUSBAsio@@UEAAJXZ|	; CUSBAsio::outputReady
	EXPORT	|?GetSupportedSampleFormats@CUSBAsio@@CAKXZ| ; CUSBAsio::GetSupportedSampleFormats
	EXPORT	|?BufferSwitchX@CUSBAsio@@AEAAXXZ|	; CUSBAsio::BufferSwitchX
	EXPORT	|?BufferSwitch@CUSBAsio@@QEAAXXZ|	; CUSBAsio::BufferSwitch
	EXPORT	|?future@CUSBAsio@@UEAAJJPEAX@Z|	; CUSBAsio::future
	EXPORT	|?controlPanel@CUSBAsio@@UEAAJXZ|	; CUSBAsio::controlPanel
	EXPORT	|?disposeBuffers@CUSBAsio@@UEAAJXZ|	; CUSBAsio::disposeBuffers
	EXPORT	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| ; CUSBAsio::createBuffers
	EXPORT	|?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| ; CUSBAsio::getChannelInfo
	EXPORT	|?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z| ; CUSBAsio::getSamplePosition
	EXPORT	|?setClockSource@CUSBAsio@@UEAAJJ@Z|	; CUSBAsio::setClockSource
	EXPORT	|?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| ; CUSBAsio::getClockSources
	EXPORT	|?setSampleRate@CUSBAsio@@UEAAJN@Z|	; CUSBAsio::setSampleRate
	EXPORT	|?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|	; CUSBAsio::getSampleRate
	EXPORT	|?canSampleRate@CUSBAsio@@UEAAJN@Z|	; CUSBAsio::canSampleRate
	EXPORT	|?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z| ; CUSBAsio::getBufferSize
	EXPORT	|?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|	; CUSBAsio::getLatencies
	EXPORT	|?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z| ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2
	EXPORT	|?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|	; CUSBAsio::getChannels
	EXPORT	|?stop@CUSBAsio@@UEAAJXZ|		; CUSBAsio::stop
	EXPORT	|?start@CUSBAsio@@UEAAJXZ|		; CUSBAsio::start
	EXPORT	|?init@CUSBAsio@@UEAAJPEAX@Z|		; CUSBAsio::init
	EXPORT	|?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z| ; CUSBAsio::getErrorMessage
	EXPORT	|?getDriverVersion@CUSBAsio@@UEAAJXZ|	; CUSBAsio::getDriverVersion
	EXPORT	|?getDriverName@CUSBAsio@@UEAAXPEAD@Z|	; CUSBAsio::getDriverName
	EXPORT	|??1CUSBAsio@@UEAA@XZ|			; CUSBAsio::~CUSBAsio
	EXPORT	|??0IASIO@@QEAA@XZ|			; IASIO::IASIO
	EXPORT	|??_GCUSBAsio@@UEAAPEAXI@Z|		; CUSBAsio::`scalar deleting destructor'
	EXPORT	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| ; CUSBAsio::CUSBAsio
	EXPORT	|?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| ; CUSBAsio::NonDelegatingQueryInterface
	EXPORT	|?__autoclassinit2@CUSBAsio@@QEAAX_K@Z|	; CUSBAsio::__autoclassinit2
	EXPORT	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| ; CUSBAsio::CreateInstance
	EXPORT	|?Release@CUSBAsio@@UEAAKXZ|		; CUSBAsio::Release
	EXPORT	|?AddRef@CUSBAsio@@UEAAKXZ|		; CUSBAsio::AddRef
	EXPORT	|?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| ; CUSBAsio::QueryInterface
	EXPORT	|?toInt@@YAHW4UACSampleType@@@Z|	; toInt
	EXPORT	|?toInt@@YAHW4UserThreadStatuses@@@Z|	; toInt
	EXPORT	|?toInt@@YAHW4DeviceStatuses@@@Z|	; toInt
	EXPORT	|?toULong@@YAKW4UACSampleFormat@@@Z|	; toULong
	EXPORT	|?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ| ; CUnknown::GetOwner
	EXPORT	|?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ| ; wil::critical_section::lock
	EXPORT	|??1critical_section@wil@@QEAA@XZ|	; wil::critical_section::~critical_section
	EXPORT	|??0critical_section@wil@@QEAA@K@Z|	; wil::critical_section::critical_section
	EXPORT	|??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ| ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >
	EXPORT	|?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z| ; wil::EnterCriticalSection
	EXPORT	|?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| ; wil::details::RunFunctorWithExceptionFilter
	EXPORT	|?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| ; wil::details::ResultFromCaughtExceptionInternal
	EXPORT	|??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| ; wil::StoredFailureInfo::StoredFailureInfo
	EXPORT	|??0ResultException@wil@@QEAA@AEBV01@@Z| ; wil::ResultException::ResultException
	EXPORT	|?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z| ; wil::details::ThrowResultExceptionInternal
	EXPORT	|?Rethrow@details@wil@@YAXXZ|		; wil::details::Rethrow
	EXPORT	|?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| ; wil::details::RecognizeCaughtExceptionFromCallback
	EXPORT	|?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z| ; wil::details::MaybeGetExceptionString
	EXPORT	|?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z| ; wil::details::MaybeGetExceptionString
	EXPORT	|??1StoredFailureInfo@wil@@QEAA@XZ|	; wil::StoredFailureInfo::~StoredFailureInfo
	EXPORT	|??1ResultException@wil@@UEAA@XZ|	; wil::ResultException::~ResultException
	EXPORT	|??_GResultException@wil@@UEAAPEAXI@Z|	; wil::ResultException::`scalar deleting destructor'
	EXPORT	|?what@ResultException@wil@@UEBAPEBDXZ|	; wil::ResultException::what
	EXPORT	|?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ| ; wil::ResultException::GetFailureInfo
	EXPORT	|??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z| ; wil::ResultException::ResultException
	EXPORT	|?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z| ; wil::StoredFailureInfo::SetFailureInfo
	EXPORT	|?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ| ; wil::StoredFailureInfo::GetFailureInfo
	EXPORT	|??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z| ; wil::StoredFailureInfo::StoredFailureInfo
	EXPORT	|?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ| ; wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse
	EXPORT	|?ResultStringSize@details@wil@@YA_KPEB_W@Z| ; wil::details::ResultStringSize
	EXPORT	|?ResultStringSize@details@wil@@YA_KPEBD@Z| ; wil::details::ResultStringSize
	EXPORT	|?HrToNtStatus@details@wil@@YAJJ@Z|	; wil::details::HrToNtStatus
	EXPORT	|?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z| ; wil::details::WilDynamicLoadRaiseFailFastException
	EXPORT	|?DebugBreak@details@wil@@YAXXZ|	; wil::details::DebugBreak
	EXPORT	|?GetCurrentModuleName@details@wil@@YAPEBDXZ| ; wil::details::GetCurrentModuleName
	EXPORT	|?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z| ; wil::details::K32GetModuleInformation
	EXPORT	|?RecordFailFast@details@wil@@YAHJ@Z|	; wil::details::RecordFailFast
	EXPORT	|?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z| ; wil::details::shared_buffer::assign
	EXPORT	|?unique@shared_buffer@details@wil@@QEBA_NXZ| ; wil::details::shared_buffer::unique
	EXPORT	|??Bshared_buffer@details@wil@@QEBA_NXZ| ; wil::details::shared_buffer::operator bool
	EXPORT	|?size@shared_buffer@details@wil@@QEBA_KXZ| ; wil::details::shared_buffer::size
	EXPORT	|?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z| ; wil::details::shared_buffer::get
	EXPORT	|?create@shared_buffer@details@wil@@QEAA_N_K@Z| ; wil::details::shared_buffer::create
	EXPORT	|?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z| ; wil::details::shared_buffer::create
	EXPORT	|?reset@shared_buffer@details@wil@@QEAAXXZ| ; wil::details::shared_buffer::reset
	EXPORT	|??1shared_buffer@details@wil@@QEAA@XZ|	; wil::details::shared_buffer::~shared_buffer
	EXPORT	|??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| ; wil::details::shared_buffer::shared_buffer
	EXPORT	|??0shared_buffer@details@wil@@QEAA@XZ|	; wil::details::shared_buffer::shared_buffer
	EXPORT	|?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z| ; wil::details::ResultStatus::FromFailureInfo
	EXPORT	|?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z| ; wil::details::ResultStatus::FromResult
	EXPORT	|?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| ; wil::GetFailureLogString
	EXPORT	|?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ| ; wil::details::LogStringPrintf
	EXPORT	|??_Gexception@std@@UEAAPEAXI@Z|	; std::exception::`scalar deleting destructor'
	EXPORT	|?what@exception@std@@UEBAPEBDXZ|	; std::exception::what
	EXPORT	|??1exception@std@@UEAA@XZ|		; std::exception::~exception
	EXPORT	|??0exception@std@@QEAA@AEBV01@@Z|	; std::exception::exception
	EXPORT	|??0exception@std@@QEAA@XZ|		; std::exception::exception
	EXPORT	|?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ|	; StringCchPrintfW
	EXPORT	|?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z| ; StringCchVPrintfW
	EXPORT	|?StringCchCopyA@@YAJPEAD_KPEBD@Z|	; StringCchCopyA
	EXPORT	|_vsnwprintf|
	EXPORT	|_vsnwprintf_l|
	EXPORT	|?RegisterAsioDriver@@YAJXZ|		; RegisterAsioDriver
	EXPORT	|?UnregisterAsioDriver@@YAJXZ|		; UnregisterAsioDriver
	EXPORT	|g_header_init_WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse| [ DATA ]
	EXPORT	|g_header_init_InitializeResultExceptions| [ DATA ]
	IMPORT	|??_Eexception@std@@UEAAPEAXI@Z|, WEAK |??_Gexception@std@@UEAAPEAXI@Z| ; std::exception::`vector deleting destructor', std::exception::`scalar deleting destructor'
	IMPORT	|??_ECUSBAsio@@UEAAPEAXI@Z|, WEAK |??_GCUSBAsio@@UEAAPEAXI@Z| ; CUSBAsio::`vector deleting destructor', CUSBAsio::`scalar deleting destructor'
	IMPORT	|??_EResultException@wil@@UEAAPEAXI@Z|, WEAK |??_GResultException@wil@@UEAAPEAXI@Z| ; wil::ResultException::`vector deleting destructor', wil::ResultException::`scalar deleting destructor'

	AREA	|.pdata|, PDATA
|$pdata$?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z| DCD |$LN8|
	DCD	0xe0001d
	;Flags[SingleProEpi] functionLength[28] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ| DCD |?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|
	DCD	|$unwind$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|

	AREA	|.pdata|, PDATA
|$pdata$??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ| DCD |$LN18|
	DCD	0xe00025
	;Flags[SingleProEpi] functionLength[36] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| DCD |??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|
	DCD	|$unwind$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|

	AREA	|.pdata|, PDATA
|$pdata$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z| DCD |$LN27|
	DCD	|$unwind$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z|

	AREA	|.pdata|, PDATA
|$pdata$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z| DCD |$LN27|
	DCD	|$unwind$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z|

	AREA	|.pdata|, PDATA
|$pdata$??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z| DCD |$LN8|
	DCD	0xe00025
	;Flags[SingleProEpi] functionLength[36] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$?WorkerThread@CUSBAsio@@CAIPEAX@Z| DCD |$LN198|
	DCD	|$unwind$?WorkerThread@CUSBAsio@@CAIPEAX@Z|

	AREA	|.pdata|, PDATA
|$pdata$?ThreadStop@CUSBAsio@@AEAAXXZ| DCD |$LN14|
	DCD	|$unwind$?ThreadStop@CUSBAsio@@AEAAXXZ|

	AREA	|.pdata|, PDATA
|$pdata$?ThreadStart@CUSBAsio@@AEAAXXZ| DCD |$LN10|
	DCD	0x1610071
	;Flags[SingleProEpi] functionLength[112] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z| DCD |$LN108|
	DCD	|$unwind$?AsioResetThread@CUSBAsio@@CAIPEAX@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| DCD |?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|
	DCD	|$unwind$?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| DCD |?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|
	DCD	|$unwind$?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| DCD |$LN106|
	DCD	|$unwind$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA| DCD |?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA|
	DCD	|$unwind$?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| DCD |$LN184|
	DCD	|$unwind$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA| DCD |?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA|
	DCD	|$unwind$?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?GetDesiredPath@CUSBAsio@@AEAA_NXZ| DCD |$LN12|
	DCD	|$unwind$?GetDesiredPath@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ| DCD |$LN6|
	DCD	|$unwind$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD |$LN28|
	DCD	|$unwind$?ApplySettings@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD |$LN28|+180
	DCD	|$unwind$0$?ApplySettings@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$1$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD |$LN28|+1064
	DCD	|$unwind$1$?ApplySettings@CUSBAsio@@AEAA_NXZ|

	AREA	|.pdata|, PDATA
|$pdata$?outputReady@CUSBAsio@@UEAAJXZ| DCD |$LN49|
	DCD	|$unwind$?outputReady@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$?outputReady@CUSBAsio@@UEAAJXZ| DCD |$LN49|+20
	DCD	|$unwind$0$?outputReady@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$1$?outputReady@CUSBAsio@@UEAAJXZ| DCD |$LN49|+152
	DCD	|$unwind$1$?outputReady@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$?BufferSwitchX@CUSBAsio@@AEAAXXZ| DCD |$LN6|
	DCD	0x1610055
	;Flags[SingleProEpi] functionLength[84] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$0$?BufferSwitch@CUSBAsio@@QEAAXXZ| DCD |$LN19|+8
	DCD	|$unwind$0$?BufferSwitch@CUSBAsio@@QEAAXXZ|

	AREA	|.pdata|, PDATA
|$pdata$?future@CUSBAsio@@UEAAJJPEAX@Z| DCD |$LN137|
	DCD	|$unwind$?future@CUSBAsio@@UEAAJJPEAX@Z|

	AREA	|.pdata|, PDATA
|$pdata$?controlPanel@CUSBAsio@@UEAAJXZ| DCD |$LN9|
	DCD	|$unwind$?controlPanel@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$?disposeBuffers@CUSBAsio@@UEAAJXZ| DCD |$LN141|
	DCD	|$unwind$?disposeBuffers@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| DCD |?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|
	DCD	|$unwind$?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| DCD |?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|
	DCD	|$unwind$?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| DCD |$LN824|
	DCD	|$unwind$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD |?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	|$unwind$?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD |?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	|$unwind$?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD |?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	|$unwind$?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD |?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	|$unwind$?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|
	DCD	|$unwind$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+16
	DCD	|$unwind$0$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+396
	DCD	|$unwind$1$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+408
	DCD	|$unwind$2$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+436
	DCD	|$unwind$3$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$4$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+452
	DCD	|$unwind$4$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$5$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD |$LN118|+464
	DCD	|$unwind$5$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|

	AREA	|.pdata|, PDATA
|$pdata$?setClockSource@CUSBAsio@@UEAAJJ@Z| DCD |$LN150|
	DCD	|$unwind$?setClockSource@CUSBAsio@@UEAAJJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| DCD |?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|
	DCD	|$unwind$?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| DCD |?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|
	DCD	|$unwind$?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD |$LN81|
	DCD	|$unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD |$LN81|+16
	DCD	|$unwind$0$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD |$LN81|+184
	DCD	|$unwind$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD |$LN81|+196
	DCD	|$unwind$2$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD |$LN81|+368
	DCD	|$unwind$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$?setSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN235|
	DCD	|$unwind$?setSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| DCD |?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|
	DCD	|$unwind$?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| DCD |?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|
	DCD	|$unwind$?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD |$LN48|
	DCD	|$unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD |$LN48|+32
	DCD	|$unwind$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD |$LN48|+140
	DCD	|$unwind$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD |$LN48|+152
	DCD	|$unwind$2$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD |$LN48|+164
	DCD	|$unwind$3$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|

	AREA	|.pdata|, PDATA
|$pdata$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|
	DCD	|$unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+24
	DCD	|$unwind$0$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+88
	DCD	|$unwind$1$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+100
	DCD	|$unwind$2$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+256
	DCD	|$unwind$3$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$4$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+268
	DCD	|$unwind$4$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$5$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD |$LN82|+276
	DCD	|$unwind$5$?canSampleRate@CUSBAsio@@UEAAJN@Z|

	AREA	|.pdata|, PDATA
|$pdata$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN15|
	DCD	|$unwind$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN15|+32
	DCD	|$unwind$0$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN15|+124
	DCD	|$unwind$1$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN15|+136
	DCD	|$unwind$2$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN15|+144
	DCD	|$unwind$3$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|
	DCD	|$unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+24
	DCD	|$unwind$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+136
	DCD	|$unwind$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$2$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+148
	DCD	|$unwind$2$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$3$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+160
	DCD	|$unwind$3$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$4$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+172
	DCD	|$unwind$4$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$5$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD |$LN51|+188
	DCD	|$unwind$5$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?stop@CUSBAsio@@UEAAJXZ| DCD |$LN21|+12
	DCD	|$unwind$0$?stop@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$2$?stop@CUSBAsio@@UEAAJXZ| DCD |$LN21|+184
	DCD	|$unwind$2$?stop@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$?start@CUSBAsio@@UEAAJXZ| DCD |$LN18|+12
	DCD	|$unwind$0$?start@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$2$?start@CUSBAsio@@UEAAJXZ| DCD |$LN18|+188
	DCD	|$unwind$2$?start@CUSBAsio@@UEAAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$??1CUSBAsio@@UEAA@XZ| DCD |$LN37|
	DCD	|$unwind$??1CUSBAsio@@UEAA@XZ|

	AREA	|.pdata|, PDATA
|$pdata$??_GCUSBAsio@@UEAAPEAXI@Z| DCD |$LN43|
	DCD	|$unwind$??_GCUSBAsio@@UEAAPEAXI@Z|

	AREA	|.pdata|, PDATA
|$pdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| DCD |$LN211|
	DCD	|$unwind$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| DCD |$LN33|
	DCD	|$unwind$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z|

	AREA	|.pdata|, PDATA
|$pdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| DCD |$LN243|
	DCD	|$unwind$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD |?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	|$unwind$?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z| DCD |?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z|
	DCD	0x1610059
	;Flags[SingleProEpi] functionLength[88] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ| DCD |$LN21|
	DCD	0x1620035
	;Flags[SingleProEpi] functionLength[52] RegF[0] RegI[2] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$??1critical_section@wil@@QEAA@XZ| DCD |$LN8|
	DCD	0xe0001d
	;Flags[SingleProEpi] functionLength[28] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$??0critical_section@wil@@QEAA@K@Z| DCD |$LN8|
	DCD	0x1610035
	;Flags[SingleProEpi] functionLength[52] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ| DCD |$LN21|
	DCD	0xe00025
	;Flags[SingleProEpi] functionLength[36] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z| DCD |$LN16|
	DCD	0x1620039
	;Flags[SingleProEpi] functionLength[56] RegF[0] RegI[2] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD |$LN12|
	DCD	|$unwind$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|

	AREA	|.pdata|, PDATA
|$pdata$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA| DCD |?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA|
	DCD	|$unwind$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD |$LN84|
	DCD	|$unwind$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|

	AREA	|.pdata|, PDATA
|$pdata$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD |?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	|$unwind$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD |$LN23|
	DCD	|$unwind$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD |$LN23|+72
	DCD	|$unwind$0$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD |$LN23|+100
	DCD	|$unwind$1$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z|

	AREA	|.pdata|, PDATA
|$pdata$??0ResultException@wil@@QEAA@AEBV01@@Z| DCD |$LN40|
	DCD	0x16200b1
	;Flags[SingleProEpi] functionLength[176] RegF[0] RegI[2] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z| DCD |$LN7|
	DCD	|$unwind$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z|

	AREA	|.pdata|, PDATA
|$pdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD |$LN22|
	DCD	|$unwind$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|

	AREA	|.pdata|, PDATA
|$pdata$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| DCD |?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|
	DCD	|$unwind$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| DCD |?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|
	DCD	|$unwind$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|

	AREA	|.pdata|, PDATA
|$pdata$0$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z| DCD |$LN10|+4
	DCD	|$unwind$0$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$??1StoredFailureInfo@wil@@QEAA@XZ| DCD |$LN19|+8
	DCD	|$unwind$0$??1StoredFailureInfo@wil@@QEAA@XZ|

	AREA	|.pdata|, PDATA
|$pdata$??1ResultException@wil@@UEAA@XZ| DCD |$LN32|
	DCD	0x16200a1
	;Flags[SingleProEpi] functionLength[160] RegF[0] RegI[2] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$??_GResultException@wil@@UEAAPEAXI@Z| DCD |$LN38|
	DCD	0x1e300c1
	;Flags[SingleProEpi] functionLength[192] RegF[0] RegI[3] H[0] frameChainReturn[Chained] frameSize[48]

	AREA	|.pdata|, PDATA
|$pdata$?what@ResultException@wil@@UEBAPEBDXZ| DCD |$LN29|
	DCD	|$unwind$?what@ResultException@wil@@UEBAPEBDXZ|

	AREA	|.pdata|, PDATA
|$pdata$??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z| DCD |$LN22|
	DCD	0x1610045
	;Flags[SingleProEpi] functionLength[68] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z| DCD |$LN362|
	DCD	0x26607cd
	;Flags[SingleProEpi] functionLength[1996] RegF[0] RegI[6] H[0] frameChainReturn[Chained] frameSize[64]

	AREA	|.pdata|, PDATA
|$pdata$??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z| DCD |$LN11|
	DCD	0x1610029
	;Flags[SingleProEpi] functionLength[40] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z| DCD |$LN14|
	DCD	0x1e3006d
	;Flags[SingleProEpi] functionLength[108] RegF[0] RegI[3] H[0] frameChainReturn[Chained] frameSize[48]

	AREA	|.pdata|, PDATA
|$pdata$?DebugBreak@details@wil@@YAXXZ| DCD |$LN8|
	DCD	0xe0001d
	;Flags[SingleProEpi] functionLength[28] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$0$?GetCurrentModuleName@details@wil@@YAPEBDXZ| DCD |$LN59|+24
	DCD	|$unwind$0$?GetCurrentModuleName@details@wil@@YAPEBDXZ|

	AREA	|.pdata|, PDATA
|$pdata$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z| DCD |$LN56|
	DCD	|$unwind$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z|

	AREA	|.pdata|, PDATA
|$pdata$?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z| DCD |$LN15|
	DCD	0x1e4007d
	;Flags[SingleProEpi] functionLength[124] RegF[0] RegI[4] H[0] frameChainReturn[Chained] frameSize[48]

	AREA	|.pdata|, PDATA
|$pdata$?create@shared_buffer@details@wil@@QEAA_N_K@Z| DCD |$LN29|
	DCD	|$unwind$?create@shared_buffer@details@wil@@QEAA_N_K@Z|

	AREA	|.pdata|, PDATA
|$pdata$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z| DCD |$LN26|
	DCD	|$unwind$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$?reset@shared_buffer@details@wil@@QEAAXXZ| DCD |$LN13|+8
	DCD	|$unwind$0$?reset@shared_buffer@details@wil@@QEAAXXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$??1shared_buffer@details@wil@@QEAA@XZ| DCD |$LN16|+8
	DCD	|$unwind$0$??1shared_buffer@details@wil@@QEAA@XZ|

	AREA	|.pdata|, PDATA
|$pdata$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD |$LN20|
	DCD	|$unwind$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z|

	AREA	|.pdata|, PDATA
|$pdata$0$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD |$LN20|+24
	DCD	|$unwind$0$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z|

	AREA	|.pdata|, PDATA
|$pdata$1$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD |$LN20|+52
	DCD	|$unwind$1$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z|

	AREA	|.pdata|, PDATA
|$pdata$?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z| DCD |$LN6|
	DCD	0x800021
	;Flags[SingleProEpi] functionLength[32] RegF[0] RegI[0] H[0] frameChainReturn[UnChained] frameSize[16]

	AREA	|.pdata|, PDATA
|$pdata$?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z| DCD |$LN6|
	DCD	0x1600025
	;Flags[SingleProEpi] functionLength[36] RegF[0] RegI[0] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| DCD |$LN44|
	DCD	|$unwind$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|

	AREA	|.pdata|, PDATA
|$pdata$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ| DCD |$LN36|
	DCD	|$unwind$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

	AREA	|.pdata|, PDATA
|$pdata$??_Gexception@std@@UEAAPEAXI@Z| DCD |$LN15|
	DCD	0x1620049
	;Flags[SingleProEpi] functionLength[72] RegF[0] RegI[2] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$??0exception@std@@QEAA@AEBV01@@Z| DCD |$LN8|
	DCD	0x1610045
	;Flags[SingleProEpi] functionLength[68] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[32]

	AREA	|.pdata|, PDATA
|$pdata$?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z| DCD |?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z|
	DCD	0x2650089
	;Flags[SingleProEpi] functionLength[136] RegF[0] RegI[5] H[0] frameChainReturn[Chained] frameSize[64]

	AREA	|.pdata|, PDATA
|$pdata$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ| DCD |$LN29|
	DCD	|$unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ|

	AREA	|.pdata|, PDATA
|$pdata$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z| DCD |$LN29|
	DCD	|$unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z|

	AREA	|.pdata|, PDATA
|$pdata$_vsnwprintf| DCD |$LN8|
	DCD	0x1e4005d
	;Flags[SingleProEpi] functionLength[92] RegF[0] RegI[4] H[0] frameChainReturn[Chained] frameSize[48]

	AREA	|.pdata|, PDATA
|$pdata$_vsnwprintf_l| DCD |$LN6|
	DCD	0x1e4005d
	;Flags[SingleProEpi] functionLength[92] RegF[0] RegI[4] H[0] frameChainReturn[Chained] frameSize[48]

	AREA	|.pdata|, PDATA
|$pdata$0$memcpy_s| DCD |memcpy_s|+12
	DCD	|$unwind$0$memcpy_s|

	AREA	|.pdata|, PDATA
|$pdata$2$memcpy_s| DCD |memcpy_s|+80
	DCD	|$unwind$2$memcpy_s|

	AREA	|.pdata|, PDATA
|$pdata$4$memcpy_s| DCD |memcpy_s|+124
	DCD	|$unwind$4$memcpy_s|

	AREA	|.pdata|, PDATA
|$pdata$?RegisterAsioDriver@@YAJXZ| DCD |$LN10|
	DCD	|$unwind$?RegisterAsioDriver@@YAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$?RegisterAsioDriver@@YAJXZ| DCD |$LN10|+36
	DCD	|$unwind$0$?RegisterAsioDriver@@YAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$1$?RegisterAsioDriver@@YAJXZ| DCD |$LN10|+128
	DCD	|$unwind$1$?RegisterAsioDriver@@YAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$?UnregisterAsioDriver@@YAJXZ| DCD |$LN10|
	DCD	|$unwind$?UnregisterAsioDriver@@YAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$0$?UnregisterAsioDriver@@YAJXZ| DCD |$LN10|+36
	DCD	|$unwind$0$?UnregisterAsioDriver@@YAJXZ|

	AREA	|.pdata|, PDATA
|$pdata$1$?UnregisterAsioDriver@@YAJXZ| DCD |$LN10|+128
	DCD	|$unwind$1$?UnregisterAsioDriver@@YAJXZ|

	AREA	|.data|, DATA
|g_header_init_InitializeResultExceptions| DCB 0x1

	AREA	|.data|, DATA
|g_header_init_WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse| DCB 0x1

	AREA	|.xdata|, DATA
|$unwind$1$?UnregisterAsioDriver@@YAJXZ| DCD 0x19700004
	DCD	0x83e101e5
	DCD	0x830108e4
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[3], Epilog Start Index[5], E[1], X[1], Function Length[4]=16 bytes
	;end_c
	;alloc_s
	;set_fp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?UnregisterAsioDriver@@YAJXZ| DCD 0x10500017
	DCD	0x16
	DCD	0x1e514d0
	DCD	0xe3e483e1
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[2], Epilog Count[1], E[0], X[1], Function Length[23]=92 bytes
	;Epilog Start Index[0], Epilog Start Offset[22]=88 bytes
	;save_reg
	;end_c
	;alloc_s
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?UnregisterAsioDriver@@YAJXZ| DCD 0x8100009
	DCD	0xe483e101
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[1], Epilog Count[0], E[0], X[1], Function Length[9]=36 bytes
	;alloc_s
	;set_fp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$1$?RegisterAsioDriver@@YAJXZ| DCD 0x19700004
	DCD	0x83e101e5
	DCD	0x830108e4
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[3], Epilog Start Index[5], E[1], X[1], Function Length[4]=16 bytes
	;end_c
	;alloc_s
	;set_fp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?RegisterAsioDriver@@YAJXZ| DCD 0x10500017
	DCD	0x16
	DCD	0x1e514d0
	DCD	0xe3e483e1
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[2], Epilog Count[1], E[0], X[1], Function Length[23]=92 bytes
	;Epilog Start Index[0], Epilog Start Offset[22]=88 bytes
	;save_reg
	;end_c
	;alloc_s
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?RegisterAsioDriver@@YAJXZ| DCD 0x8100009
	DCD	0xe483e101
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[1], Epilog Count[0], E[0], X[1], Function Length[9]=36 bytes
	;alloc_s
	;set_fp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$4$memcpy_s| DCD 0x1040000e
	DCD	0x80000b
	DCD	0xd081e1e5
	DCD	0xe3e42482
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[14]=56 bytes
	;Epilog Start Index[2], Epilog Start Offset[11]=44 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;save_reg
	;save_r19r20_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$memcpy_s| DCD 0x1040000a
	DCD	0x800007
	DCD	0xd081e1e5
	DCD	0xe3e42482
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[10]=40 bytes
	;Epilog Start Index[2], Epilog Start Offset[7]=28 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;save_reg
	;save_r19r20_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$memcpy_s| DCD 0x10400010
	DCD	0x40000d
	DCD	0x82d081e1
	DCD	0xe3e4e524
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[16]=64 bytes
	;Epilog Start Index[1], Epilog Start Offset[13]=52 bytes
	;set_fp
	;save_fplr_x
	;save_reg
	;save_r19r20_x
	;end_c
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z| DCD 0x10800030
	DCD	0x40000f
	DCD	0x400029
	DCD	0x4d181e1
	DCD	0xe42682c8
	;Code Words[2], Epilog Count[2], E[0], X[0], Function Length[48]=192 bytes
	;Epilog Start Index[1], Epilog Start Offset[15]=60 bytes
	;Epilog Start Index[1], Epilog Start Offset[41]=164 bytes
	;set_fp
	;save_fplr_x
	;save_reg
	;save_regp
	;save_r19r20_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ| DCD 0x28800034
	DCD	0x2c00011
	DCD	0x2c0002c
	DCD	0xe3e381e1
	DCD	0xc804d1e3
	DCD	0x81e42a82
	DCD	0x82c804d1
	DCD	0xe3e3e42a
	;Code Words[5], Epilog Count[2], E[0], X[0], Function Length[52]=208 bytes
	;Epilog Start Index[11], Epilog Start Offset[17]=68 bytes
	;Epilog Start Index[11], Epilog Start Offset[44]=176 bytes
	;set_fp
	;save_fplr_x
	;nop
	;nop
	;nop
	;save_reg
	;save_regp
	;save_r19r20_x
	;end
	;save_fplr_x
	;save_reg
	;save_regp
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ| DCD 0x22600036
	DCD	0xe3e383e1
	DCD	0x2a82c8e3
	DCD	0x82c883e4
	DCD	0xe3e3e42a
	;Code Words[4], Epilog Start Index[9], E[1], X[0], Function Length[54]=216 bytes
	;set_fp
	;save_fplr_x
	;nop
	;nop
	;nop
	;save_regp
	;save_r19r20_x
	;end
	;save_fplr_x
	;save_regp
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| DCD |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|+108
	DCD	0xffffffff
	DCD	|?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|+732
	DCD	0x0

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| DCD 0x19930522
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x2
	DCD	|$ip2state$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|
	DCD	0xfffffd90
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| DCD 0x385000bb
	DCD	0x30000af
	DCD	0x88c9e101
	DCD	0x84c806c9
	DCD	0xe48902c8
	DCD	0xc90121c0
	DCD	0xc806c988
	DCD	0x8902c884
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|
	DCD	0xffffffab
	;Code Words[7], Epilog Count[1], E[0], X[1], Function Length[187]=748 bytes
	;Epilog Start Index[12], Epilog Start Offset[175]=700 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD 0x10a00003
	DCD	0x181e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD 0x10400007
	DCD	0x6
	DCD	0xe1e502d0
	DCD	0xe3e40181
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[7]=28 bytes
	;Epilog Start Index[0], Epilog Start Offset[6]=24 bytes
	;save_reg
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| DCD 0x8000006
	DCD	0xe40181e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[6]=24 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$0$??1shared_buffer@details@wil@@QEAA@XZ| DCD 0x10400013
	DCD	0x400011
	DCD	0xe52281e1
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[19]=76 bytes
	;Epilog Start Index[1], Epilog Start Offset[17]=68 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end_c
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?reset@shared_buffer@details@wil@@QEAAXXZ| DCD 0x10400013
	DCD	0x400011
	DCD	0xe52281e1
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[19]=76 bytes
	;Epilog Start Index[1], Epilog Start Offset[17]=68 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end_c
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z| DCD 0x10c0003f
	DCD	0x400016
	DCD	0x400025
	DCD	0x40003b
	DCD	0x82c881e1
	DCD	0xe3e3e424
	;Code Words[2], Epilog Count[3], E[0], X[0], Function Length[63]=252 bytes
	;Epilog Start Index[1], Epilog Start Offset[22]=88 bytes
	;Epilog Start Index[1], Epilog Start Offset[37]=148 bytes
	;Epilog Start Index[1], Epilog Start Offset[59]=236 bytes
	;set_fp
	;save_fplr_x
	;save_regp
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?create@shared_buffer@details@wil@@QEAA_N_K@Z| DCD 0x10c0003f
	DCD	0x400016
	DCD	0x400025
	DCD	0x40003b
	DCD	0x82c881e1
	DCD	0xe3e3e424
	;Code Words[2], Epilog Count[3], E[0], X[0], Function Length[63]=252 bytes
	;Epilog Start Index[1], Epilog Start Offset[22]=88 bytes
	;Epilog Start Index[1], Epilog Start Offset[37]=148 bytes
	;Epilog Start Index[1], Epilog Start Offset[59]=236 bytes
	;set_fp
	;save_fplr_x
	;save_regp
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z| DCD 0x22300055
	DCD	0x84c8e101
	DCD	0xe48502c8
	DCD	0x84c80111
	DCD	0xe48502c8
	DCD	|__GSHandlerCheck|
	DCD	0xffffffc8
	;Code Words[4], Epilog Start Index[8], E[1], X[1], Function Length[85]=340 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$0$?GetCurrentModuleName@details@wil@@YAPEBDXZ| DCD 0x20500042
	DCD	0x200003e
	DCD	0xc8e10111
	DCD	0xe4e58302
	DCD	0x2c80111
	DCD	0xe3e3e383
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[4], Epilog Count[1], E[0], X[1], Function Length[66]=264 bytes
	;Epilog Start Index[8], Epilog Start Offset[62]=248 bytes
	;alloc_s
	;alloc_s
	;set_fp
	;save_regp
	;save_fplr_x
	;end_c
	;end
	;alloc_s
	;alloc_s
	;save_regp
	;save_fplr_x
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?what@ResultException@wil@@UEBAPEBDXZ| DCD 0x21b0003a
	DCD	0x2c8e101
	DCD	0xc1e483
	DCD	0x8302c801
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[4], Epilog Start Index[6], E[1], X[1], Function Length[58]=232 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$??1StoredFailureInfo@wil@@QEAA@XZ| DCD 0x10400013
	DCD	0x400011
	DCD	0xe52281e1
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[19]=76 bytes
	;Epilog Start Index[1], Epilog Start Offset[17]=68 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end_c
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z| DCD 0x10400010
	DCD	0x40000e
	DCD	0xe52281e1
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[16]=64 bytes
	;Epilog Start Index[1], Epilog Start Offset[14]=56 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end_c
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| DCD 0x8500006
	DCD	0x3
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[6]=24 bytes
	;Epilog Start Index[0], Epilog Start Offset[3]=12 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| DCD 0x850000f
	DCD	0xb
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[15]=60 bytes
	;Epilog Start Index[0], Epilog Start Offset[11]=44 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD |?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|+36
	DCD	0xffffffff
	DCD	|?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|+80
	DCD	0x0
	DCD	|?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|+12
	DCD	0x1

	AREA	|.xdata|, DATA
|$handlerMap$0$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD 0x8
	DCD	|??_R0?AVexception@std@@@8|
	DCD	0xffffffe0
	DCD	|?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|
	DCD	0x0
	DCD	0x40
	DCD	0x0
	DCD	0x0
	DCD	|?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA|
	DCD	0x0

	AREA	|.xdata|, DATA
|$tryMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD 0x0
	DCD	0x0
	DCD	0x1
	DCD	0x2
	DCD	|$handlerMap$0$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|

	AREA	|.xdata|, DATA
|$stateUnwindMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD 0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	DCD	0x1
	DCD	|$tryMap$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	DCD	0x3
	DCD	|$ip2state$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	DCD	0xffffffd8
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| DCD 0x10500016
	DCD	0x40000f
	DCD	0x1d487e1
	DCD	0xe3e3e3e4
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|
	;Code Words[2], Epilog Count[1], E[0], X[1], Function Length[22]=88 bytes
	;Epilog Start Index[1], Epilog Start Offset[15]=60 bytes
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z| DCD 0x800000a
	DCD	0xe3e49be1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[10]=40 bytes
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD 0x10a00003
	DCD	0x181e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD 0x10400007
	DCD	0x6
	DCD	0xe1e502d0
	DCD	0xe3e40181
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[7]=28 bytes
	;Epilog Start Index[0], Epilog Start Offset[6]=24 bytes
	;save_reg
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| DCD 0x8000012
	DCD	0xe40181e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[18]=72 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x8500006
	DCD	0x3
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[6]=24 bytes
	;Epilog Start Index[0], Epilog Start Offset[3]=12 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x850000f
	DCD	0xa
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[15]=60 bytes
	;Epilog Start Index[0], Epilog Start Offset[10]=40 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x850000f
	DCD	0xa
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[15]=60 bytes
	;Epilog Start Index[0], Epilog Start Offset[10]=40 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x8500016
	DCD	0x12
	DCD	0xe401d481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[22]=88 bytes
	;Epilog Start Index[0], Epilog Start Offset[18]=72 bytes
	;save_fplr_x
	;save_reg_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x850000f
	DCD	0xc
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[15]=60 bytes
	;Epilog Start Index[0], Epilog Start Offset[12]=48 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x850000f
	DCD	0xa
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[15]=60 bytes
	;Epilog Start Index[0], Epilog Start Offset[10]=40 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| DCD 0x8500015
	DCD	0x11
	DCD	0xe401d481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[21]=84 bytes
	;Epilog Start Index[0], Epilog Start Offset[17]=68 bytes
	;save_fplr_x
	;save_reg_x
	;end

	AREA	|.xdata|, DATA
|$ip2state$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|+80
	DCD	0xffffffff
	DCD	|?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|+136
	DCD	0x0
	DCD	|?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|+212
	DCD	0x2
	DCD	|?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|+228
	DCD	0x0
	DCD	|?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|+12
	DCD	0x1
	DCD	|?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|+28
	DCD	0x0
	DCD	|?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|+12
	DCD	0x3
	DCD	|?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|+32
	DCD	0x0

	AREA	|.xdata|, DATA
|$handlerMap$1$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0x9
	DCD	|??_R0?AVResultException@wil@@@8|
	DCD	0xffffffb8
	DCD	|?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0
	DCD	0x9
	DCD	|??_R0?AVbad_alloc@std@@@8|
	DCD	0xffffffd0
	DCD	|?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0
	DCD	0x8
	DCD	|??_R0?AVexception@std@@@8|
	DCD	0xffffffd8
	DCD	|?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0
	DCD	0x40
	DCD	0x0
	DCD	0x0
	DCD	|?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0

	AREA	|.xdata|, DATA
|$handlerMap$0$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0x9
	DCD	|??_R0?AVResultException@wil@@@8|
	DCD	0xffffffb0
	DCD	|?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0
	DCD	0x9
	DCD	|??_R0?AVbad_alloc@std@@@8|
	DCD	0xffffffc8
	DCD	|?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0
	DCD	0x40
	DCD	0x0
	DCD	0x0
	DCD	|?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA|
	DCD	0x0

	AREA	|.xdata|, DATA
|$tryMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0x0
	DCD	0x0
	DCD	0x1
	DCD	0x3
	DCD	|$handlerMap$0$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	DCD	0x2
	DCD	0x2
	DCD	0x3
	DCD	0x4
	DCD	|$handlerMap$1$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|

	AREA	|.xdata|, DATA
|$stateUnwindMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0x19930522
	DCD	0x4
	DCD	|$stateUnwindMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	DCD	0x2
	DCD	|$tryMap$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	DCD	0x8
	DCD	|$ip2state$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	DCD	0xffffffc0
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| DCD 0x1090003b
	DCD	0x400025
	DCD	0x40002f
	DCD	0x82d08be1
	DCD	0xe3e3e424
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|
	;Code Words[2], Epilog Count[2], E[0], X[1], Function Length[59]=236 bytes
	;Epilog Start Index[1], Epilog Start Offset[37]=148 bytes
	;Epilog Start Index[1], Epilog Start Offset[47]=188 bytes
	;set_fp
	;save_fplr_x
	;save_reg
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA| DCD 0x850000b
	DCD	0x8
	DCD	0xe3e3e481
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[11]=44 bytes
	;Epilog Start Index[0], Epilog Start Offset[8]=32 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD |?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|+40
	DCD	0x0
	DCD	|?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA|+16
	DCD	0x1

	AREA	|.xdata|, DATA
|$handlerMap$0$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD 0x40
	DCD	0x0
	DCD	0x0
	DCD	|?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA|
	DCD	0x0

	AREA	|.xdata|, DATA
|$tryMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD 0x0
	DCD	0x0
	DCD	0x1
	DCD	0x1
	DCD	|$handlerMap$0$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|

	AREA	|.xdata|, DATA
|$stateUnwindMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD 0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|
	DCD	0x1
	DCD	|$tryMap$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|
	DCD	0x2
	DCD	|$ip2state$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|
	DCD	0xfffffff0
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| DCD 0x8500010
	DCD	0x40000d
	DCD	0xe3e485e1
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|
	;Code Words[1], Epilog Count[1], E[0], X[1], Function Length[16]=64 bytes
	;Epilog Start Index[1], Epilog Start Offset[13]=52 bytes
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| DCD |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+56
	DCD	0xffffffff
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+560
	DCD	0x1
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+588
	DCD	0x2
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+616
	DCD	0x3
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+788
	DCD	0x4
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+1084
	DCD	0x0
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+1164
	DCD	0x4
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+1332
	DCD	0x0
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+1472
	DCD	0x4
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+2440
	DCD	0x0
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+2468
	DCD	0x4
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+2540
	DCD	0x0
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+2600
	DCD	0x4
	DCD	|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|+3928
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x1
	DCD	|?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x2
	DCD	|?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x3
	DCD	|?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| DCD 0x19930522
	DCD	0x5
	DCD	|$stateUnwindMap$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|
	DCD	0x0
	DCD	0x0
	DCD	0xe
	DCD	|$ip2state$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|
	DCD	0xfffffc10
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| DCD 0x405003e2
	DCD	0x38003d7
	DCD	0xad2e101
	DCD	0x6c988c9
	DCD	0x2c884c8
	DCD	0x38c0e48b
	DCD	0xc90ad201
	DCD	0xc806c988
	DCD	0x8b02c884
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|
	DCD	0xffffff9a
	;Code Words[8], Epilog Count[1], E[0], X[1], Function Length[994]=3976 bytes
	;Epilog Start Index[14], Epilog Start Offset[983]=3932 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| DCD 0x8c00038
	DCD	0x400017
	DCD	0x40001e
	DCD	0x400034
	DCD	0xe3e481e1
	;Code Words[1], Epilog Count[3], E[0], X[0], Function Length[56]=224 bytes
	;Epilog Start Index[1], Epilog Start Offset[23]=92 bytes
	;Epilog Start Index[1], Epilog Start Offset[30]=120 bytes
	;Epilog Start Index[1], Epilog Start Offset[52]=208 bytes
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| DCD 0x8200006
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[6]=24 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| DCD |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+536
	DCD	0x0
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+564
	DCD	0x1
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+592
	DCD	0x2
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+764
	DCD	0x3
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+1060
	DCD	0x0
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+1132
	DCD	0x3
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+1336
	DCD	0x0
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+1396
	DCD	0x3
	DCD	|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|+2724
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x1
	DCD	|?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|
	DCD	0x2
	DCD	|?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| DCD 0x19930522
	DCD	0x4
	DCD	|$stateUnwindMap$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x9
	DCD	|$ip2state$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|
	DCD	0xfffffc80
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| DCD 0x405002b6
	DCD	0x38002aa
	DCD	0xad2e101
	DCD	0x6c988c9
	DCD	0x2c884c8
	DCD	0x31c0e48b
	DCD	0xc90ad201
	DCD	0xc806c988
	DCD	0x8b02c884
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|
	DCD	0xffffff9a
	;Code Words[8], Epilog Count[1], E[0], X[1], Function Length[694]=2776 bytes
	;Epilog Start Index[14], Epilog Start Offset[682]=2728 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$??_GCUSBAsio@@UEAAPEAXI@Z| DCD |??_GCUSBAsio@@UEAAPEAXI@Z|+64
	DCD	0x0
	DCD	|??_GCUSBAsio@@UEAAPEAXI@Z|+448
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$??_GCUSBAsio@@UEAAPEAXI@Z| DCD 0xffffffff
	DCD	|__std_terminate|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$??_GCUSBAsio@@UEAAPEAXI@Z| DCD 0x19930522
	DCD	0x1
	DCD	|$stateUnwindMap$??_GCUSBAsio@@UEAAPEAXI@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x2
	DCD	|$ip2state$??_GCUSBAsio@@UEAAPEAXI@Z|
	DCD	0xffffff90
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$??_GCUSBAsio@@UEAAPEAXI@Z| DCD 0x2230007b
	DCD	0x84d0e101
	DCD	0xe48502c8
	DCD	0x84d00103
	DCD	0xe48502c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$??_GCUSBAsio@@UEAAPEAXI@Z|
	DCD	0xffffffcb
	;Code Words[4], Epilog Start Index[8], E[1], X[1], Function Length[123]=492 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_reg
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$ip2state$??1CUSBAsio@@UEAA@XZ| DCD |??1CUSBAsio@@UEAA@XZ|+56
	DCD	0xffffffff

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$??1CUSBAsio@@UEAA@XZ| DCD 0x19930522
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	|$ip2state$??1CUSBAsio@@UEAA@XZ|
	DCD	0xffffffa0
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$??1CUSBAsio@@UEAA@XZ| DCD 0x19b00072
	DCD	0x2c8e101
	DCD	0x103e483
	DCD	0xe48302c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$??1CUSBAsio@@UEAA@XZ|
	DCD	0xffffffdb
	;Code Words[3], Epilog Start Index[6], E[1], X[1], Function Length[114]=456 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$2$?start@CUSBAsio@@UEAAJXZ| DCD 0x10400002
	DCD	0x800000
	DCD	0xd481e1e5
	DCD	0xe3e3e401
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[2]=8 bytes
	;Epilog Start Index[2], Epilog Start Offset[0]=0 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?start@CUSBAsio@@UEAAJXZ| DCD 0x1040002b
	DCD	0x400029
	DCD	0x1d481e1
	DCD	0xe3e3e4e5
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[43]=172 bytes
	;Epilog Start Index[1], Epilog Start Offset[41]=164 bytes
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end_c
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?stop@CUSBAsio@@UEAAJXZ| DCD 0x10400002
	DCD	0x800000
	DCD	0xd481e1e5
	DCD	0xe3e3e401
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[2]=8 bytes
	;Epilog Start Index[2], Epilog Start Offset[0]=0 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?stop@CUSBAsio@@UEAAJXZ| DCD 0x1040002a
	DCD	0x400028
	DCD	0x1d481e1
	DCD	0xe3e3e4e5
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[42]=168 bytes
	;Epilog Start Index[1], Epilog Start Offset[40]=160 bytes
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end_c
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$5$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x10a00006
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[6]=24 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$4$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x18400004
	DCD	0x400002
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[4]=16 bytes
	;Epilog Start Index[1], Epilog Start Offset[2]=8 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$3$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x18400003
	DCD	0x400001
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[3]=12 bytes
	;Epilog Start Index[1], Epilog Start Offset[1]=4 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x1840001c
	DCD	0x1a
	DCD	0x2c884c8
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[28]=112 bytes
	;Epilog Start Index[0], Epilog Start Offset[26]=104 bytes
	;save_regp
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x8000006
	DCD	0xe40281e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[6]=24 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$3$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x10a00004
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[4]=16 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x18400002
	DCD	0x400000
	DCD	0xc884d0e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[2]=8 bytes
	;Epilog Start Index[1], Epilog Start Offset[0]=0 bytes
	;end_c
	;save_reg
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x18400017
	DCD	0x15
	DCD	0x2c884d0
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[23]=92 bytes
	;Epilog Start Index[0], Epilog Start Offset[21]=84 bytes
	;save_reg
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| DCD 0x8000008
	DCD	0xe40281e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[8]=32 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$5$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x10a00004
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[4]=16 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$4$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x18400002
	DCD	0x400000
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[2]=8 bytes
	;Epilog Start Index[1], Epilog Start Offset[0]=0 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$3$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x18400027
	DCD	0x400025
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[39]=156 bytes
	;Epilog Start Index[1], Epilog Start Offset[37]=148 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x18400010
	DCD	0xe
	DCD	0x2c884c8
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[16]=64 bytes
	;Epilog Start Index[0], Epilog Start Offset[14]=56 bytes
	;save_regp
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?canSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x8000006
	DCD	0xe40281e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[6]=24 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$3$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD 0x18400003
	DCD	0x400001
	DCD	0xc884d0e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[3]=12 bytes
	;Epilog Start Index[1], Epilog Start Offset[1]=4 bytes
	;end_c
	;save_reg
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD 0x1840001b
	DCD	0x19
	DCD	0x2c884d0
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[27]=108 bytes
	;Epilog Start Index[0], Epilog Start Offset[25]=100 bytes
	;save_reg
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| DCD 0x8600008
	DCD	0xe40281e1
	;Code Words[1], Epilog Start Index[1], E[1], X[0], Function Length[8]=32 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?setSampleRate@CUSBAsio@@UEAAJN@Z| DCD |?setSampleRate@CUSBAsio@@UEAAJN@Z|+92
	DCD	0xffffffff
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+132
	DCD	0x0
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+156
	DCD	0x1
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+360
	DCD	0x0
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+424
	DCD	0x1
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+468
	DCD	0x0
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+492
	DCD	0xffffffff
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+520
	DCD	0x0
	DCD	|?setSampleRate@CUSBAsio@@UEAAJN@Z|+544
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?setSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?setSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?setSampleRate@CUSBAsio@@UEAAJN@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x9
	DCD	|$ip2state$?setSampleRate@CUSBAsio@@UEAAJN@Z|
	DCD	0xffffff60
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?setSampleRate@CUSBAsio@@UEAAJN@Z| DCD 0x33300098
	DCD	0x8dce101
	DCD	0x84c806c9
	DCD	0xe48902c8
	DCD	0x8dc0104
	DCD	0x84c806c9
	DCD	0xe48902c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?setSampleRate@CUSBAsio@@UEAAJN@Z|
	DCD	0xffffffaa
	;Code Words[6], Epilog Start Index[12], E[1], X[1], Function Length[152]=608 bytes
	;alloc_s
	;set_fp
	;save_freg
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_freg
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$3$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD 0x10a00004
	DCD	0x587e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[4]=16 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD 0x2040002b
	DCD	0x400026
	DCD	0xc910cae5
	DCD	0xc80cc98e
	DCD	0xe108c88a
	DCD	0xe3e40587
	;Code Words[4], Epilog Count[1], E[0], X[0], Function Length[43]=172 bytes
	;Epilog Start Index[1], Epilog Start Offset[38]=152 bytes
	;end_c
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD 0x10a00003
	DCD	0x587e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD 0x2040002a
	DCD	0x25
	DCD	0x8ec910ca
	DCD	0x8ac80cc9
	DCD	0xe1e508c8
	DCD	0xe3e40587
	;Code Words[4], Epilog Count[1], E[0], X[0], Function Length[42]=168 bytes
	;Epilog Start Index[0], Epilog Start Offset[37]=148 bytes
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop

	AREA	|.xdata|, DATA
|$unwind$?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| DCD 0x8000004
	DCD	0xe40587e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[4]=16 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?setClockSource@CUSBAsio@@UEAAJJ@Z| DCD |?setClockSource@CUSBAsio@@UEAAJJ@Z|+92
	DCD	0xffffffff
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+116
	DCD	0x0
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+212
	DCD	0x1
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+260
	DCD	0x0
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+296
	DCD	0xffffffff
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+324
	DCD	0x0
	DCD	|?setClockSource@CUSBAsio@@UEAAJJ@Z|+348
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?setClockSource@CUSBAsio@@UEAAJJ@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?setClockSource@CUSBAsio@@UEAAJJ@Z| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?setClockSource@CUSBAsio@@UEAAJJ@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x7
	DCD	|$ip2state$?setClockSource@CUSBAsio@@UEAAJJ@Z|
	DCD	0xffffff70
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?setClockSource@CUSBAsio@@UEAAJJ@Z| DCD 0x2ab00066
	DCD	0x6d1e101
	DCD	0x2c884c8
	DCD	0x104e487
	DCD	0x84c806d1
	DCD	0xe48702c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?setClockSource@CUSBAsio@@UEAAJJ@Z|
	DCD	0xffffffba
	;Code Words[5], Epilog Start Index[10], E[1], X[1], Function Length[102]=408 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$5$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$4$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x18400003
	DCD	0x400001
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[3]=12 bytes
	;Epilog Start Index[1], Epilog Start Offset[1]=4 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$3$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x10a00004
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[4]=16 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$2$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x18400007
	DCD	0x400005
	DCD	0xc884c8e5
	DCD	0x281e102
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[7]=28 bytes
	;Epilog Start Index[1], Epilog Start Offset[5]=20 bytes
	;end_c
	;save_regp
	;save_regp
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x10a00003
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[3]=12 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x1840005f
	DCD	0x5d
	DCD	0x2c884c8
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[95]=380 bytes
	;Epilog Start Index[0], Epilog Start Offset[93]=372 bytes
	;save_regp
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| DCD 0x8000004
	DCD	0xe40281e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[4]=16 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| DCD |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+208
	DCD	0x0
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+264
	DCD	0x1
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+500
	DCD	0x3
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+720
	DCD	0xa
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1184
	DCD	0x0
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1348
	DCD	0xa
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1432
	DCD	0x3
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1456
	DCD	0x1
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1480
	DCD	0x0
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1516
	DCD	0xa
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1636
	DCD	0x3
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1660
	DCD	0x1
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1684
	DCD	0x0
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1708
	DCD	0x10
	DCD	|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|+1740
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	0xffffffff
	DCD	0x0
	DCD	0x1
	DCD	|?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0x3
	DCD	|?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA|
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	0x0
	DCD	0xffffffff
	DCD	|__std_terminate|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| DCD 0x19930522
	DCD	0x11
	DCD	|$stateUnwindMap$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|
	DCD	0x0
	DCD	0x0
	DCD	0xf
	DCD	|$ip2state$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|
	DCD	0xfffffeb8
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| DCD 0x385001cd
	DCD	0x38001b8
	DCD	0xad2e101
	DCD	0x6c988c9
	DCD	0x2c884c8
	DCD	0x110e48b
	DCD	0x88c90ad2
	DCD	0x84c806c9
	DCD	0xe48b02c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|
	DCD	0xffffff9a
	;Code Words[7], Epilog Count[1], E[0], X[1], Function Length[461]=1844 bytes
	;Epilog Start Index[14], Epilog Start Offset[440]=1760 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?disposeBuffers@CUSBAsio@@UEAAJXZ| DCD |?disposeBuffers@CUSBAsio@@UEAAJXZ|+72
	DCD	0xffffffff
	DCD	|?disposeBuffers@CUSBAsio@@UEAAJXZ|+128
	DCD	0x0
	DCD	|?disposeBuffers@CUSBAsio@@UEAAJXZ|+156
	DCD	0x1
	DCD	|?disposeBuffers@CUSBAsio@@UEAAJXZ|+340
	DCD	0x0
	DCD	|?disposeBuffers@CUSBAsio@@UEAAJXZ|+364
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?disposeBuffers@CUSBAsio@@UEAAJXZ| DCD 0xffffffff
	DCD	|?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|
	DCD	0x0
	DCD	|?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?disposeBuffers@CUSBAsio@@UEAAJXZ| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?disposeBuffers@CUSBAsio@@UEAAJXZ|
	DCD	0x0
	DCD	0x0
	DCD	0x5
	DCD	|$ip2state$?disposeBuffers@CUSBAsio@@UEAAJXZ|
	DCD	0xffffffc0
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?disposeBuffers@CUSBAsio@@UEAAJXZ| DCD 0x10d0006a
	DCD	0x40001c
	DCD	0x400061
	DCD	0x400066
	DCD	0x82c885e1
	DCD	0xe3e3e424
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?disposeBuffers@CUSBAsio@@UEAAJXZ|
	;Code Words[2], Epilog Count[3], E[0], X[1], Function Length[106]=424 bytes
	;Epilog Start Index[1], Epilog Start Offset[28]=112 bytes
	;Epilog Start Index[1], Epilog Start Offset[97]=388 bytes
	;Epilog Start Index[1], Epilog Start Offset[102]=408 bytes
	;set_fp
	;save_fplr_x
	;save_regp
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?controlPanel@CUSBAsio@@UEAAJXZ| DCD 0x21b00064
	DCD	0x2d0e101
	DCD	0x2bc0e483
	DCD	0x8302d001
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[4], Epilog Start Index[6], E[1], X[1], Function Length[100]=400 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_reg
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?future@CUSBAsio@@UEAAJJPEAX@Z| DCD 0x11c0007d
	DCD	0x400029
	DCD	0x400043
	DCD	0x400050
	DCD	0x40005a
	DCD	0x400060
	DCD	0x40006a
	DCD	0x400074
	DCD	0x82d081e1
	DCD	0xe3e3e424
	;Code Words[2], Epilog Count[7], E[0], X[0], Function Length[125]=500 bytes
	;Epilog Start Index[1], Epilog Start Offset[41]=164 bytes
	;Epilog Start Index[1], Epilog Start Offset[67]=268 bytes
	;Epilog Start Index[1], Epilog Start Offset[80]=320 bytes
	;Epilog Start Index[1], Epilog Start Offset[90]=360 bytes
	;Epilog Start Index[1], Epilog Start Offset[96]=384 bytes
	;Epilog Start Index[1], Epilog Start Offset[106]=424 bytes
	;Epilog Start Index[1], Epilog Start Offset[116]=464 bytes
	;set_fp
	;save_fplr_x
	;save_reg
	;save_r19r20_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?BufferSwitch@CUSBAsio@@QEAAXXZ| DCD 0x10400037
	DCD	0x400035
	DCD	0x1d481e1
	DCD	0xe3e3e4e5
	;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[55]=220 bytes
	;Epilog Start Index[1], Epilog Start Offset[53]=212 bytes
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end_c
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$1$?outputReady@CUSBAsio@@UEAAJXZ| DCD 0x10a00004
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Start Index[2], E[1], X[0], Function Length[4]=16 bytes
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?outputReady@CUSBAsio@@UEAAJXZ| DCD 0x18400021
	DCD	0x1f
	DCD	0x2c884d0
	DCD	0x281e1e5
	DCD	0xe3e3e3e4
	;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[33]=132 bytes
	;Epilog Start Index[0], Epilog Start Offset[31]=124 bytes
	;save_reg
	;save_regp
	;end_c
	;set_fp
	;save_fplr_x
	;alloc_s
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?outputReady@CUSBAsio@@UEAAJXZ| DCD 0x8000005
	DCD	0xe40281e1
	;Code Words[1], Epilog Count[0], E[0], X[0], Function Length[5]=20 bytes
	;set_fp
	;save_fplr_x
	;alloc_s
	;end

	AREA	|.xdata|, DATA
|$unwind$1$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD 0x32f00025
	DCD	0xd1e101e5
	DCD	0xc884c806
	DCD	0x8e48702
	DCD	0xc806d101
	DCD	0x8702c884
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffb8
	;Code Words[6], Epilog Start Index[11], E[1], X[1], Function Length[37]=148 bytes
	;end_c
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$0$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD 0x205000dd
	DCD	0xdc
	DCD	0x1e559d1
	DCD	0xc806d1e1
	DCD	0x8702c884
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffb8
	;Code Words[4], Epilog Count[1], E[0], X[1], Function Length[221]=884 bytes
	;Epilog Start Index[0], Epilog Start Offset[220]=880 bytes
	;save_reg
	;end_c
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?ApplySettings@CUSBAsio@@AEAA_NXZ| DCD 0x1810002d
	DCD	0x6d1e101
	DCD	0x2c884c8
	DCD	0xe3e3e487
	DCD	|__GSHandlerCheck|
	DCD	0xffffffb8
	;Code Words[3], Epilog Count[0], E[0], X[1], Function Length[45]=180 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ| DCD 0x21b00064
	DCD	0x2d0e101
	DCD	0x2bc0e483
	DCD	0x8302d001
	DCD	0xe3e3e3e4
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[4], Epilog Start Index[6], E[1], X[1], Function Length[100]=400 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_fplr_x
	;end
	;alloc_m
	;alloc_s
	;save_reg
	;save_fplr_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?GetDesiredPath@CUSBAsio@@AEAA_NXZ| DCD 0x18900048
	DCD	0x1800039
	DCD	0x1800043
	DCD	0x2c8e101
	DCD	0x101e483
	DCD	0xe48302c8
	DCD	|__GSHandlerCheck|
	DCD	0xffffffd8
	;Code Words[3], Epilog Count[2], E[0], X[1], Function Length[72]=288 bytes
	;Epilog Start Index[6], Epilog Start Offset[57]=228 bytes
	;Epilog Start Index[6], Epilog Start Offset[67]=268 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| DCD |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|+72
	DCD	0xffffffff
	DCD	|?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|+324
	DCD	0x0
	DCD	|?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|+1120
	DCD	0xffffffff
	DCD	|?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|+1180
	DCD	0x0

	AREA	|.xdata|, DATA
|$stateUnwindMap$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| DCD 0xffffffff
	DCD	|?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| DCD 0x19930522
	DCD	0x1
	DCD	|$stateUnwindMap$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|
	DCD	0x0
	DCD	0x0
	DCD	0x4
	DCD	|$ip2state$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|
	DCD	0xfffffec8
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| DCD 0x38500131
	DCD	0x380011e
	DCD	0xad2e101
	DCD	0x6c988c9
	DCD	0x2c884c8
	DCD	0x10de48b
	DCD	0x88c90ad2
	DCD	0x84c806c9
	DCD	0xe48b02c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|
	DCD	0xffffff9a
	;Code Words[7], Epilog Count[1], E[0], X[1], Function Length[305]=1220 bytes
	;Epilog Start Index[14], Epilog Start Offset[286]=1144 bytes
	;alloc_s
	;set_fp
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_reg
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| DCD |?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|+48
	DCD	0xffffffff
	DCD	|?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|+84
	DCD	0x0
	DCD	|?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|+220
	DCD	0xffffffff
	DCD	|?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|+264
	DCD	0x0

	AREA	|.xdata|, DATA
|$stateUnwindMap$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| DCD 0xffffffff
	DCD	|?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| DCD 0x19930522
	DCD	0x1
	DCD	|$stateUnwindMap$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|
	DCD	0x0
	DCD	0x0
	DCD	0x4
	DCD	|$ip2state$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|
	DCD	0xffffffc0
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| DCD 0x10500048
	DCD	0x40003d
	DCD	0x4d183e1
	DCD	0xe42682c8
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|
	;Code Words[2], Epilog Count[1], E[0], X[1], Function Length[72]=288 bytes
	;Epilog Start Index[1], Epilog Start Offset[61]=244 bytes
	;set_fp
	;save_fplr_x
	;save_reg
	;save_regp
	;save_r19r20_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| DCD 0x8200005
	DCD	0xe3e3e481
	;Code Words[1], Epilog Start Index[0], E[1], X[0], Function Length[5]=20 bytes
	;save_fplr_x
	;end
	;nop
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?AsioResetThread@CUSBAsio@@CAIPEAX@Z| DCD |?AsioResetThread@CUSBAsio@@CAIPEAX@Z|+100
	DCD	0xffffffff
	DCD	|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|+140
	DCD	0x0
	DCD	|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|+164
	DCD	0xffffffff
	DCD	|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|+296
	DCD	0x1
	DCD	|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|+332
	DCD	0xffffffff

	AREA	|.xdata|, DATA
|$stateUnwindMap$?AsioResetThread@CUSBAsio@@CAIPEAX@Z| DCD 0xffffffff
	DCD	|?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|
	DCD	0xffffffff
	DCD	|?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z| DCD 0x19930522
	DCD	0x2
	DCD	|$stateUnwindMap$?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	DCD	0x0
	DCD	0x0
	DCD	0x5
	DCD	|$ip2state$?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	DCD	0xffffff98
	DCD	0x0
	DCD	0x1

	AREA	|.xdata|, DATA
|$unwind$?AsioResetThread@CUSBAsio@@CAIPEAX@Z| DCD 0x30500077
	DCD	0x3000039
	DCD	0x7dce101
	DCD	0x84c806d1
	DCD	0xe48702c8
	DCD	0x7dc0102
	DCD	0x84c806d1
	DCD	0xe48702c8
	DCD	|__GSHandlerCheck_EH|
	DCD	|$cppxdata$?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	DCD	0xffffffba
	;Code Words[6], Epilog Count[1], E[0], X[1], Function Length[119]=476 bytes
	;Epilog Start Index[12], Epilog Start Offset[57]=228 bytes
	;alloc_s
	;set_fp
	;save_freg
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_freg
	;save_reg
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$?ThreadStop@CUSBAsio@@AEAAXXZ| DCD 0x10800024
	DCD	0x400014
	DCD	0x400021
	DCD	0x1d481e1
	DCD	0xe3e3e3e4
	;Code Words[2], Epilog Count[2], E[0], X[0], Function Length[36]=144 bytes
	;Epilog Start Index[1], Epilog Start Offset[20]=80 bytes
	;Epilog Start Index[1], Epilog Start Offset[33]=132 bytes
	;set_fp
	;save_fplr_x
	;save_reg_x
	;end
	;nop
	;nop
	;nop

	AREA	|.xdata|, DATA
|$unwind$?WorkerThread@CUSBAsio@@CAIPEAX@Z| DCD 0x3850014e
	DCD	0x3800142
	DCD	0xacae101
	DCD	0x6c988c9
	DCD	0x2c884c8
	DCD	0x112e48b
	DCD	0x88c90aca
	DCD	0x84c806c9
	DCD	0xe48b02c8
	DCD	|__GSHandlerCheck|
	DCD	0xffffff98
	;Code Words[7], Epilog Count[1], E[0], X[1], Function Length[334]=1336 bytes
	;Epilog Start Index[14], Epilog Start Offset[322]=1288 bytes
	;alloc_s
	;set_fp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end
	;alloc_s
	;alloc_s
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_regp
	;save_fplr_x
	;end

	AREA	|.xdata|, DATA
|$unwind$??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z| DCD 0x8800026
	DCD	0x40001d
	DCD	0x400023
	DCD	0xe42283e1
	;Code Words[1], Epilog Count[2], E[0], X[0], Function Length[38]=152 bytes
	;Epilog Start Index[1], Epilog Start Offset[29]=116 bytes
	;Epilog Start Index[1], Epilog Start Offset[35]=140 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end

	AREA	|.xdata|, DATA
|$unwind$??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z| DCD 0x8800024
	DCD	0x40001b
	DCD	0x400021
	DCD	0xe42283e1
	;Code Words[1], Epilog Count[2], E[0], X[0], Function Length[36]=144 bytes
	;Epilog Start Index[1], Epilog Start Offset[27]=108 bytes
	;Epilog Start Index[1], Epilog Start Offset[33]=132 bytes
	;set_fp
	;save_fplr_x
	;save_r19r20_x
	;end

	AREA	|.xdata|, DATA
|$ip2state$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| DCD |??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|+64
	DCD	0x0

	AREA	|.xdata|, DATA
|$stateUnwindMap$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| DCD 0xffffffff
	DCD	|__std_terminate|

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| DCD 0x19930522
	DCD	0x1
	DCD	|$stateUnwindMap$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	|$ip2state$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|
	DCD	0xfffffff0
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| DCD 0x8700014
	DCD	0xe3e483e1
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|
	;Code Words[1], Epilog Start Index[1], E[1], X[1], Function Length[20]=80 bytes
	;set_fp
	;save_fplr_x
	;end
	;nop

	AREA	|.xdata|, DATA
|$ip2state$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ| DCD |?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|+64
	DCD	0xffffffff

	AREA	|.rdata|, DATA, READONLY
|$cppxdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ| DCD 0x19930522
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x0
	DCD	0x1
	DCD	|$ip2state$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|
	DCD	0xfffffff0
	DCD	0x0
	DCD	0x5

	AREA	|.xdata|, DATA
|$unwind$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ| DCD 0x8700013
	DCD	0xe3e483e1
	DCD	|__CxxFrameHandler3|
	DCD	|$cppxdata$?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|
	;Code Words[1], Epilog Start Index[1], E[1], X[1], Function Length[19]=76 bytes
	;set_fp
	;save_fplr_x
	;end
	;nop
; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?UnregisterAsioDriver@@YAJXZ| PROC			; UnregisterAsioDriver

; 140  : {

|$LN10|
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x80

; 141  :     HRESULT result = UnregisterAsioDriver(IID_ASIO_DRIVER, ASIODRV_NAME, DRIVER_NAME);

	adrp        x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	add         x8,x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	ldp         x0,x1,[x8]
	bl          |?UnregisterAsioDriver@@YAJU_GUID@@PEBD1@Z|

; 142  : 
; 143  :     if (!SUCCEEDED(result))

	tbz         w0,#0x1F,|$LN2@Unregister|
	str         x19,[sp,#0xA0]
	mov         w19,w0

; 144  :     {
; 145  :         TCHAR message[ERROR_MESSAGE_LENGTH] = {0};

	movi        v16.16b,#0
	stp         q16,q16,[sp]
	stp         q16,q16,[sp,#0x20]
	stp         q16,q16,[sp,#0x40]
	stp         q16,q16,[sp,#0x60]

; 146  :         _stprintf_s(message, ERROR_MESSAGE_LENGTH, TEXT("Unregister Server failed ! (%d)"), result);

	mov         w3,w19
	adrp        x8,|??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@|
	add         x2,x8,|??_C@_0CA@OPFFDHMA@Unregister?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@|
	mov         x1,#0x80
	mov         x0,sp
	bl          sprintf_s

; 147  :         MessageBox(nullptr, message, DRIVER_NAME, MB_OK);

	mov         w3,#0
	adrp        x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	add         x2,x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	mov         x1,sp
	mov         x0,#0
	adrp        x8,__imp_MessageBoxA
	ldr         x8,[x8,__imp_MessageBoxA]
	blr         x8
	mov         w0,w19
	ldr         x19,[sp,#0xA0]
|$LN2@Unregister|
	add         sp,sp,#0x80
	bl          __security_pop_cookie
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?UnregisterAsioDriver@@YAJXZ|, UnregisterAsioDriver

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?RegisterAsioDriver@@YAJXZ| PROC			; RegisterAsioDriver

; 126  : {

|$LN10|
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x80

; 127  :     HRESULT result = RegisterAsioDriver(IID_ASIO_DRIVER, ASIODRV_NAME, DRIVER_NAME, DRIVER_NAME, TEXT("Apartment"));

	adrp        x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	add         x8,x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	ldp         x0,x1,[x8]
	bl          |?RegisterAsioDriver@@YAJU_GUID@@PEBD111@Z|

; 128  : 
; 129  :     if (!SUCCEEDED(result))

	tbz         w0,#0x1F,|$LN2@RegisterAs|
	str         x19,[sp,#0xA0]
	mov         w19,w0

; 130  :     {
; 131  :         TCHAR message[ERROR_MESSAGE_LENGTH] = {0};

	movi        v16.16b,#0
	stp         q16,q16,[sp]
	stp         q16,q16,[sp,#0x20]
	stp         q16,q16,[sp,#0x40]
	stp         q16,q16,[sp,#0x60]

; 132  :         _stprintf_s(message, ERROR_MESSAGE_LENGTH, TEXT("Register Server failed ! (%d)"), result);

	mov         w3,w19
	adrp        x8,|??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@|
	add         x2,x8,|??_C@_0BO@KGBEPONM@Register?5Server?5failed?5?$CB?5?$CI?$CFd?$CJ@|
	mov         x1,#0x80
	mov         x0,sp
	bl          sprintf_s

; 133  :         MessageBox(nullptr, message, DRIVER_NAME, MB_OK);

	mov         w3,#0
	adrp        x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	add         x2,x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	mov         x1,sp
	mov         x0,#0
	adrp        x8,__imp_MessageBoxA
	ldr         x8,[x8,__imp_MessageBoxA]
	blr         x8
	mov         w0,w19
	ldr         x19,[sp,#0xA0]
|$LN2@RegisterAs|
	add         sp,sp,#0x80
	bl          __security_pop_cookie
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?RegisterAsioDriver@@YAJXZ|, RegisterAsioDriver

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h

	AREA	|.text$mn|, CODE, ARM64

|memcpy_s| PROC

; 46   :         if (_SourceSize == 0)

	cbnz        x3,|$LN11@memcpy_s|

; 47   :         {
; 48   :             return 0;

	mov         w0,#0
	ret
|$LN11@memcpy_s|
	stp         x19,x20,[sp,#-0x20]!
	str         x21,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 46   :         if (_SourceSize == 0)

	mov         x21,x1
	mov         x19,x2
	mov         x20,x3

; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	cbnz        x0,|$LN3@memcpy_s|
|$LN13@memcpy_s|

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;

	bl          _errno
	mov         w8,#0x16
	str         w8,[x0]
	bl          _invalid_parameter_noinfo
|$LN7@memcpy_s|
	mov         w0,#0x16
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN3@memcpy_s|

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	cmp         x19,#0
	ccmpne      x21,x20,#0
	blo         |$LN5@memcpy_s|

; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

	mov         x2,x20
	mov         x1,x19
	bl          memcpy

; 63   :         return 0;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN5@memcpy_s|

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

	mov         x2,x21
	mov         w1,#0
	bl          memset

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cbz         x19,|$LN13@memcpy_s|

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	cmp         x21,x20
	bhs         |$LN7@memcpy_s|
	bl          _errno
	mov         w8,#0x22
	str         w8,[x0]
	bl          _invalid_parameter_noinfo
	mov         w0,#0x22
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |memcpy_s|

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

	AREA	|.text$mn|, CODE, ARM64

|_vsnwprintf_l| PROC

; 1061 :     {

|$LN6|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x22,x0
	mov         x21,x1
	mov         x20,x2
	mov         x19,x4

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	ldr         x8,[x0]
	mov         x5,x19
	mov         x4,#0
	mov         x3,x20
	mov         x2,x21
	orr         x0,x8,#1
	mov         x1,x22
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w0,w0,wzr
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |_vsnwprintf_l|

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

	AREA	|.text$mn|, CODE, ARM64

|_vsnwprintf| PROC

; 1129 :     {

|$LN8|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x22,x0
	mov         x21,x1
	mov         x20,x2
	mov         x19,x3

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	ldr         x8,[x0]
	mov         x5,x19
	mov         x4,#0
	mov         x3,x20
	mov         x2,x21
	orr         x0,x8,#1
	mov         x1,x22
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w0,w0,wzr
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |_vsnwprintf|

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringCchCopyA@@YAJPEAD_KPEBD@Z| PROC			; StringCchCopyA

; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	sub         x11,x1,#1
	mov         x10,#0x7FFFFFFE
	cmp         x11,x10
	mov         x8,x0
	bhi         |$LN8@StringCchC|

; 543  :     HRESULT hr;
; 544  : 
; 545  :     hr = StringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 546  : 
; 547  :     if (SUCCEEDED(hr))
; 548  :     {
; 549  :         hr = StringCopyWorkerA(pszDest,

	sub         x10,x10,x1
	sub         x11,x2,x8
|$LL11@StringCchC|

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	add         x9,x10,x1
	cbz         x9,|$LN26@StringCchC|
	ldrsb       w9,[x11,x8]
	cbz         w9,|$LN26@StringCchC|

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	strb        w9,[x8]
	add         x8,x8,#1

; 9919 :         cchDest--;

	sub         x1,x1,#1
	cbnz        x1,|$LL11@StringCchC|
|$LN26@StringCchC|

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	sub         x10,x8,#1
	cmp         x1,#0
	cselne      x8,x8,x10
	strb        wzr,[x8]
	ldr         w8,|$LN28@StringCchC|
	cselne      w0,wzr,w8
	ret
|$LN8@StringCchC|

; 550  :                 cchDest,
; 551  :                 NULL,
; 552  :                 pszSrc,
; 553  :                 STRSAFE_MAX_LENGTH);
; 554  :     }
; 555  :     else if (cchDest > 0)

	ldr         w0,|$LN29@StringCchC|
	cbz         x1,|$LN4@StringCchC|

; 556  :     {
; 557  :         *pszDest = '\0';

	strb        wzr,[x8]
	ldr         w0,|$LN29@StringCchC|
|$LN4@StringCchC|
	ret
	nop
|$LN28@StringCchC|
	DCD         0x8007007a
|$LN29@StringCchC|
	DCD         0x80070057

	ENDP  ; |?StringCchCopyA@@YAJPEAD_KPEBD@Z|, StringCchCopyA

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z| PROC	; StringCchVPrintfW

; 4559 : {

|$LN29|
	stp         x19,x20,[sp,#-0x30]!
	stp         x21,x22,[sp,#0x10]
	str         x23,[sp,#0x20]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	sub         x9,x1,#1
	mov         x8,#0x7FFFFFFE
	cmp         x9,x8
	mov         x22,x0
	mov         x21,x2
	mov         x20,x3
	bls         |$LN7@StringCchV|

; 4567 :                 cchDest,
; 4568 :                 NULL,
; 4569 :                 pszFormat,
; 4570 :                 argList);
; 4571 :     }
; 4572 :     else if (cchDest > 0)

	ldr         w0,|$LN27@StringCchV|
	cbz         x1,|$LN4@StringCchV|

; 4573 :     {
; 4574 :         *pszDest = L'\0';

	strh        wzr,[x22]
	ldp         fp,lr,[sp],#0x10
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x30
	ret
|$LN7@StringCchV|

; 10129:     HRESULT hr = S_OK;

	mov         w19,#0

; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	sub         x23,x1,#1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	ldr         x8,[x0]
	mov         x5,x20
	mov         x4,#0
	mov         x3,x21
	mov         x2,x23
	orr         x0,x8,#1
	mov         x1,x22
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w8,w0,wzr
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	tbnz        w8,#0x1F,|$LN13@StringCchV|
	cmp         x23,w8,sxtw #0
	blo         |$LN13@StringCchV|

; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	bne         |$LN15@StringCchV|

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';
; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }

	b           |$LN25@StringCchV|
|$LN13@StringCchV|

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';
; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	ldr         w19,|$LN28@StringCchV|
|$LN25@StringCchV|

; 4560 :     HRESULT hr;
; 4561 : 
; 4562 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);
; 4563 : 
; 4564 :     if (SUCCEEDED(hr))
; 4565 :     {
; 4566 :         hr = StringVPrintfWorkerW(pszDest,

	strh        wzr,[x22,x23 lsl #1]
|$LN15@StringCchV|
	mov         w0,w19
|$LN4@StringCchV|
	ldp         fp,lr,[sp],#0x10
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x30
	ret
|$LN27@StringCchV|
	DCD         0x80070057
|$LN28@StringCchV|
	DCD         0x8007007a

	ENDP  ; |?StringCchVPrintfW@@YAJPEA_W_KPEB_WPEAD@Z|, StringCchVPrintfW

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ| PROC		; StringCchPrintfW

; 5050 : {

|$LN29|
	stp         x19,x20,[sp,#-0x50]!
	stp         x21,x22,[sp,#0x10]
	str         x23,[sp,#0x20]
	stp         x3,x4,[sp,#0x28]
	stp         x5,x6,[sp,#0x38]
	str         x7,[sp,#0x48]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	sub         x9,x1,#1
	mov         x8,#0x7FFFFFFE
	cmp         x9,x8
	mov         x21,x0
	mov         x20,x2
	bls         |$LN7@StringCchP|

; 5062 :                 cchDest,
; 5063 :                 NULL,
; 5064 :                 pszFormat,
; 5065 :                 argList);
; 5066 : 
; 5067 :         va_end(argList);
; 5068 :     }
; 5069 :     else if (cchDest > 0)

	ldr         w0,|$LN27@StringCchP|
	cbz         x1,|$LN4@StringCchP|

; 5070 :     {
; 5071 :         *pszDest = '\0';

	strh        wzr,[x21]
	ldp         fp,lr,[sp],#0x10
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x50
	ret
|$LN7@StringCchP|

; 5051 :     HRESULT hr;
; 5052 : 
; 5053 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);
; 5054 : 
; 5055 :     if (SUCCEEDED(hr))
; 5056 :     {
; 5057 :         va_list argList;
; 5058 : 
; 5059 :         va_start(argList, pszFormat);

	add         x23,sp,#0x38

; 10129:     HRESULT hr = S_OK;

	mov         w19,#0

; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	sub         x22,x1,#1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	ldr         x8,[x0]
	mov         x5,x23
	mov         x3,x20
	mov         x2,x22
	mov         x1,x21
	orr         x0,x8,#1
	mov         x4,#0
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w8,w0,wzr
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	tbnz        w8,#0x1F,|$LN13@StringCchP|
	cmp         x22,w8,sxtw #0
	blo         |$LN13@StringCchP|

; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	bne         |$LN15@StringCchP|

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';
; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }

	b           |$LN25@StringCchP|
|$LN13@StringCchP|

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';
; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	ldr         w19,|$LN28@StringCchP|
|$LN25@StringCchP|

; 5060 : 
; 5061 :         hr = StringVPrintfWorkerW(pszDest,

	strh        wzr,[x21,x22 lsl #1]
|$LN15@StringCchP|
	mov         w0,w19
|$LN4@StringCchP|
	ldp         fp,lr,[sp],#0x10
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x50
	ret
	nop
|$LN27@StringCchP|
	DCD         0x80070057
|$LN28@StringCchP|
	DCD         0x8007007a

	ENDP  ; |?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ|, StringCchPrintfW

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringValidateDestA@@YAJPEBD_K_K@Z| PROC		; StringValidateDestA

; 9667 :     HRESULT hr = S_OK;
; 9668 : 
; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	mov         x8,#0x7FFFFFFE
	sub         x9,x1,#1
	cmp         x9,x8
	ldr         w8,|$LN9@StringVali|
	cselhi      w0,w8,wzr
	ret
|$LN9@StringVali|
	DCD         0x80070057

	ENDP  ; |?StringValidateDestA@@YAJPEBD_K_K@Z|, StringValidateDestA

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringValidateDestW@@YAJPEB_W_K_K@Z| PROC		; StringValidateDestW

; 9721 :     HRESULT hr = S_OK;
; 9722 : 
; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	mov         x8,#0x7FFFFFFE
	sub         x9,x1,#1
	cmp         x9,x8
	ldr         w8,|$LN9@StringVali|
	cselhi      w0,w8,wzr
	ret
|$LN9@StringVali|
	DCD         0x80070057

	ENDP  ; |?StringValidateDestW@@YAJPEB_W_K_K@Z|, StringValidateDestW

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringCopyWorkerA@@YAJPEAD_KPEA_KPEBD1@Z| PROC	; StringCopyWorkerA

; 9913 : 
; 9914 :     // ASSERT(cchDest != 0);
; 9915 : 
; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	cbz         x1,|$LN17@StringCopy|

; 9911 :     HRESULT hr = S_OK;
; 9912 :     size_t cchNewDestLength = 0;

	mov         x8,#0x7FFFFFFE
	sub         x10,x3,x0
|$LL2@StringCopy|

; 9913 : 
; 9914 :     // ASSERT(cchDest != 0);
; 9915 : 
; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	cbz         x8,|$LN17@StringCopy|
	ldrsb       w9,[x10,x0]
	cbz         w9,|$LN17@StringCopy|

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	strb        w9,[x0]
	add         x0,x0,#1

; 9919 :         cchDest--;

	sub         x1,x1,#1
	sub         x8,x8,#1
	cbnz        x1,|$LL2@StringCopy|
|$LN17@StringCopy|

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	cmp         x1,#0
	sub         x9,x0,#1
	ldr         w8,|$LN21@StringCopy|
	cselne      x9,x0,x9
	cselne      w8,wzr,w8
	strb        wzr,[x9]

; 9935 : 
; 9936 :     if (pcchNewDestLength)
; 9937 :     {
; 9938 :         *pcchNewDestLength = cchNewDestLength;
; 9939 :     }
; 9940 : 
; 9941 :     return hr;

	mov         w0,w8
	ret
	nop
|$LN21@StringCopy|
	DCD         0x8007007a

	ENDP  ; |?StringCopyWorkerA@@YAJPEAD_KPEA_KPEBD1@Z|, StringCopyWorkerA

; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

	AREA	|.text$mn|, CODE, ARM64

|?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z| PROC ; StringVPrintfWorkerW

; 10128: {

	stp         x19,x20,[sp,#-0x30]!
	stp         x21,x22,[sp,#0x10]
	str         x23,[sp,#0x20]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x20,x0
	mov         x23,x3
	mov         x22,x4

; 10129:     HRESULT hr = S_OK;

	mov         w19,#0

; 10130:     int iRet;
; 10131:     size_t cchMax;
; 10132:     size_t cchNewDestLength = 0;
; 10133: 
; 10134:     // leave the last space for the null terminator
; 10135:     cchMax = cchDest - 1;

	sub         x21,x1,#1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	ldr         x8,[x0]
	mov         x5,x22
	mov         x4,#0
	mov         x3,x23
	mov         x2,x21
	orr         x0,x8,#1
	mov         x1,x20
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w8,w0,wzr
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	tbnz        w8,#0x1F,|$LN4@StringVPri|
	cmp         x21,w8,sxtw #0
	blo         |$LN4@StringVPri|

; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	bne         |$LN7@StringVPri|

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';
; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }

	b           |$LN15@StringVPri|
|$LN4@StringVPri|

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';
; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	ldr         w19,|$LN17@StringVPri|
|$LN15@StringVPri|

; 10166:     else
; 10167:     {
; 10168:         cchNewDestLength = (size_t)iRet;
; 10169:     }
; 10170: 
; 10171:     if (pcchNewDestLength)
; 10172:     {
; 10173:         *pcchNewDestLength = cchNewDestLength;
; 10174:     }
; 10175: 
; 10176:     return hr;

	strh        wzr,[x20,x21 lsl #1]
|$LN7@StringVPri|
	mov         w0,w19
	ldp         fp,lr,[sp],#0x10
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x30
	ret
|$LN17@StringVPri|
	DCD         0x8007007a

	ENDP  ; |?StringVPrintfWorkerW@@YAJPEA_W_KPEA_KPEB_WPEAD@Z|, StringVPrintfWorkerW

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??0exception@std@@QEAA@XZ| PROC			; std::exception::exception

; 55   :     {

	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	movi        v16.16b,#0
	str         x8,[x0]
	stur        q16,[x0,#8]
	ret

	ENDP  ; |??0exception@std@@QEAA@XZ|, std::exception::exception

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??0exception@std@@QEAA@AEBV01@@Z| PROC			; std::exception::exception

; 73   :     {

|$LN8|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	movi        v16.16b,#0
	mov         x19,x0
	mov         x9,x1
	str         x8,[x19]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	add         x1,x19,#8
	add         x0,x9,#8
	stur        q16,[x19,#8]
	bl          __std_exception_copy

; 75   :     }

	mov         x0,x19
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |??0exception@std@@QEAA@AEBV01@@Z|, std::exception::exception

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??1exception@std@@UEAA@XZ| PROC			; std::exception::~exception

; 90   :     {

	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	str         x8,[x0],#8

; 91   :         __std_exception_destroy(&_Data);

	b           __std_exception_destroy

	ENDP  ; |??1exception@std@@UEAA@XZ|, std::exception::~exception

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|?what@exception@std@@UEBAPEBDXZ| PROC			; std::exception::what

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	ldr         x9,[x0,#8]
	adrp        x8,|??_C@_0BC@EOODALEL@Unknown?5exception@|
	add         x8,x8,|??_C@_0BC@EOODALEL@Unknown?5exception@|
	cmp         x9,#0
	cselne      x0,x9,x8
	ret

	ENDP  ; |?what@exception@std@@UEBAPEBDXZ|, std::exception::what

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??_Gexception@std@@UEAAPEAXI@Z| PROC			; std::exception::`scalar deleting destructor'
|$LN15|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 90   :     {

	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	mov         x19,x0

; 91   :         __std_exception_destroy(&_Data);

	add         x0,x19,#8
	str         x8,[x19]
	mov         w20,w1
	bl          __std_exception_destroy
	tbz         w20,#0,|$LN12@scalar|
	mov         x1,#0x18
	mov         x0,x19
	bl          |??3@YAXPEAX_K@Z|
|$LN12@scalar|
	mov         x0,x19
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |??_Gexception@std@@UEAAPEAXI@Z|, std::exception::`scalar deleting destructor'

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ| PROC ; wil::details::LogStringPrintf

; 1760 :     {

|$LN36|
	stp         x19,x20,[sp,#-0x50]!
	stp         x21,x22,[sp,#0x10]
	stp         x3,x4,[sp,#0x28]
	stp         x5,x6,[sp,#0x38]
	str         x7,[sp,#0x48]
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         x19,x0
	mov         x21,x1

; 1761 :         va_list argList;
; 1762 :         va_start(argList, format);
; 1763 :         StringCchVPrintfW(dest, (destEnd - dest), format, argList);

	sub         x8,x21,x19
	asr         x9,x8,#1
	mov         x22,x2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 9723 :     if ((cchDest == 0) || (cchDest > cchMax))

	cbz         x9,|$LN8@LogStringP|
	mov         x8,#0x7FFFFFFF
	cmp         x9,x8
	bhi         |$LN27@LogStringP|

; 10135:     cchMax = cchDest - 1;

	sub         x20,x9,#1
	str         x20,[sp,#0x10]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h

; 1062 :         int const _Result = __stdio_common_vswprintf(

	bl          __local_stdio_printf_options
	add         x5,sp,#0x48
	ldr         x8,[x0]
	mov         x3,x22
	mov         x2,x20
	mov         x1,x19
	mov         x4,#0
	orr         x0,x8,#1
	bl          __stdio_common_vswprintf

; 1063 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1064 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1065 : 
; 1066 :         return _Result < 0 ? -1 : _Result;

	cmp         w0,#0
	csinvge     w8,w0,wzr
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 10147:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	tbnz        w8,#0x1F,|$LN17@LogStringP|
	cmp         x20,w8,sxtw #0
	blo         |$LN17@LogStringP|

; 10152: 
; 10153:         cchNewDestLength = cchMax;
; 10154: 
; 10155:         // we have truncated pszDest
; 10156:         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 10157:     }
; 10158:     else if (((size_t)iRet) == cchMax)

	bne         |$LN8@LogStringP|

; 10159:     {
; 10160:         // need to null terminate the string
; 10161:         pszDest += cchMax;
; 10162:         *pszDest = L'\0';

	strh        wzr,[x19,x20 lsl #1]

; 10163: 
; 10164:         cchNewDestLength = cchMax;
; 10165:     }

	b           |$LN8@LogStringP|
|$LN17@LogStringP|

; 10148:     {
; 10149:         // need to null terminate the string
; 10150:         pszDest += cchMax;
; 10151:         *pszDest = L'\0';

	ldr         x20,[sp,#0x10]
	strh        wzr,[x19,x20 lsl #1]

; 4571 :     }

	b           |$LN8@LogStringP|
|$LN27@LogStringP|

; 4572 :     else if (cchDest > 0)
; 4573 :     {
; 4574 :         *pszDest = L'\0';

	strh        wzr,[x19]
|$LN8@LogStringP|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 1764 :         return (destEnd == dest) ? dest : (dest + wcslen(dest));

	cmp         x21,x19
	cseleq      x0,x19,x0
	beq         |$LN4@LogStringP|
	mov         x8,x19
	ldrsh       w9,[x8]
	cbz         w9,|$LN34@LogStringP|
|$LL33@LogStringP|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL33@LogStringP|
|$LN34@LogStringP|
	sub         x8,x8,x19
	asr         x8,x8,#1
	add         x0,x19,x8,lsl #1
|$LN4@LogStringP|
	ldp         fp,lr,[sp],#0x20
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x50
	ret

	ENDP  ; |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|, wil::details::LogStringPrintf

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z| PROC ; wil::GetFailureLogString

; 1776 : {

|$LN44|
	stp         fp,lr,[sp,#-0x50]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x210
	mov         x26,sp
	mov         xip0,#-2
	str         xip0,[x26]
	mov         x25,x0
	mov         x24,x1
	mov         x23,x2
	mov         x22,x2

; 1777 :     // This function was lenient to empty strings at one point and some callers became dependent on this behavior
; 1778 :     if ((cchDest == 0) || (pszDest == nullptr))

	cbz         x24,|$LN5@GetFailure|
	cbz         x25,|$LN5@GetFailure|

; 1781 :     }
; 1782 : 
; 1783 :     pszDest[0] = L'\0';
; 1784 : 
; 1785 :     // Call the logging callback (if present) to allow them to generate the debug string that will be pushed to the console
; 1786 :     // or the platform exception object if the caller desires it.
; 1787 :     if ((g_pfnResultLoggingCallback != nullptr) && details::g_resultMessageCallbackSet)

	adrp        x8,g_pfnResultLoggingCallback
	ldr         x9,[x8,g_pfnResultLoggingCallback]
	strh        wzr,[x25]
	cbz         x9,|$LN32@GetFailure|
	adrp        x8,|?g_resultMessageCallbackSet@details@wil@@3_NA|
	ldrb        w8,[x8,|?g_resultMessageCallbackSet@details@wil@@3_NA|]
	cbz         w8,|$LN32@GetFailure|

; 1788 :     {
; 1789 :         // older-form callback was a non-const FailureInfo*; conceptually this is const as callers should not be modifying
; 1790 :         g_pfnResultLoggingCallback(const_cast<FailureInfo*>(&failure), pszDest, cchDest);

	mov         x2,x24
	mov         x1,x25
	mov         x0,x23
	blr         x9

; 1791 :     }
; 1792 : 
; 1793 :     // The callback only optionally needs to supply the debug string -- if the callback didn't populate it, yet we still want
; 1794 :     // it for OutputDebugString or exception message, then generate the default string.
; 1795 :     if (pszDest[0] == L'\0')

	ldrh        w8,[x25]
	cbnz        w8,|$LN5@GetFailure|
|$LN32@GetFailure|

; 1796 :     {
; 1797 :         PCSTR pszType = "";
; 1798 :         switch (failure.type)

	ldr         w10,[x23]
	adrp        x8,|??_C@_00CNPNBAHC@@|
	add         x21,x8,|??_C@_00CNPNBAHC@@|
	cmp         w10,#3
	bhi         |$LN2@GetFailure|
	adr         x9,__swt
	ldrsw       x8,[x9,w10 uxtw #2]
	adr         x9,|$LN39@GetFailure|
	add         x8,x9,x8,lsl #2
	br          x8
|$LN8@GetFailure|

; 1799 :         {
; 1800 :         case FailureType::Exception:
; 1801 :             pszType = "Exception";

	adrp        x8,|??_C@_09FBNMMHMJ@Exception@|
	add         x21,x8,|??_C@_09FBNMMHMJ@Exception@|

; 1802 :             break;

	b           |$LN2@GetFailure|
|$LN9@GetFailure|

; 1803 :         case FailureType::Return:
; 1804 :             if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	ldr         w8,[x23,#4]
	tst         w8,#8

; 1805 :             {
; 1806 :                 pszType = "ReturnNt";
; 1807 :             }
; 1808 :             else
; 1809 :             {
; 1810 :                 pszType = "ReturnHr";
; 1811 :             }
; 1812 :             break;

	adrp        x8,|??_C@_08KFPKLAKH@ReturnHr@|
	add         x9,x8,|??_C@_08KFPKLAKH@ReturnHr@|
	adrp        x8,|??_C@_08PHCNGLJD@ReturnNt@|
	add         x8,x8,|??_C@_08PHCNGLJD@ReturnNt@|
	cseleq      x21,x9,x8
	b           |$LN2@GetFailure|
|$LN12@GetFailure|
|$LN39@GetFailure|

; 1813 :         case FailureType::Log:
; 1814 :             if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	ldr         w8,[x23,#4]
	tst         w8,#8

; 1815 :             {
; 1816 :                 pszType = "LogNt";
; 1817 :             }
; 1818 :             else
; 1819 :             {
; 1820 :                 pszType = "LogHr";
; 1821 :             }
; 1822 :             break;

	adrp        x8,|??_C@_05OILEHMGB@LogHr@|
	add         x9,x8,|??_C@_05OILEHMGB@LogHr@|
	adrp        x8,|??_C@_05LKGDKHFF@LogNt@|
	add         x8,x8,|??_C@_05LKGDKHFF@LogNt@|
	cseleq      x21,x9,x8
	b           |$LN2@GetFailure|
|$LN15@GetFailure|

; 1823 :         case FailureType::FailFast:
; 1824 :             pszType = "FailFast";

	adrp        x8,|??_C@_08IAOKKAJK@FailFast@|
	add         x21,x8,|??_C@_08IAOKKAJK@FailFast@|
|$LN2@GetFailure|

; 1825 :             break;
; 1826 :         }
; 1827 : 
; 1828 :         wchar_t szErrorText[256]{};

	movi        v16.16b,#0

; 1829 :         LONG errorCode = 0;
; 1830 : 
; 1831 :         if (WI_IsFlagSet(failure.flags, FailureFlags::NtStatus))

	ldr         w8,[x23,#4]
	stp         q16,q16,[x26,#0x10]
	stp         q16,q16,[x26,#0x30]
	stp         q16,q16,[x26,#0x50]
	stp         q16,q16,[x26,#0x70]
	stp         q16,q16,[x26,#0x90]
	stp         q16,q16,[x26,#0xB0]
	stp         q16,q16,[x26,#0xD0]
	stp         q16,q16,[x26,#0xF0]
	stp         q16,q16,[x26,#0x110]
	stp         q16,q16,[x26,#0x130]
	stp         q16,q16,[x26,#0x150]
	stp         q16,q16,[x26,#0x170]
	stp         q16,q16,[x26,#0x190]
	stp         q16,q16,[x26,#0x1B0]
	stp         q16,q16,[x26,#0x1D0]
	stp         q16,q16,[x26,#0x1F0]
	tbz         w8,#3,|$LN16@GetFailure|

; 1832 :         {
; 1833 :             errorCode = failure.status;
; 1834 :             if (wil::details::g_pfnFormatNtStatusMsg)

	adrp        x8,|?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA|
	ldr         x8,[x8,|?g_pfnFormatNtStatusMsg@details@wil@@3P6AXJPEA_WK@ZEA|]
	ldr         w20,[x23,#0xC]
	cbz         x8,|$LN17@GetFailure|

; 1835 :             {
; 1836 :                 wil::details::g_pfnFormatNtStatusMsg(failure.status, szErrorText, ARRAYSIZE(szErrorText));

	mov         w2,#0x100
	add         x1,x26,#0x10
	mov         w0,w20
	blr         x8

; 1837 :             }
; 1838 :         }

	b           |$LN17@GetFailure|
|$LN16@GetFailure|

; 1839 :         else
; 1840 :         {
; 1841 :             errorCode = failure.hr;
; 1842 :             FormatMessageW(

	adrp        x8,__imp_FormatMessageW
	ldr         x8,[x8,__imp_FormatMessageW]
	ldr         w2,[x23,#8]
	mov         x6,#0
	mov         w5,#0x100
	add         x4,x26,#0x10
	mov         w3,#0x400
	mov         x1,#0
	mov         w0,#0x1200
	mov         w20,w2
	blr         x8
|$LN17@GetFailure|

; 1843 :                 FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
; 1844 :                 nullptr,
; 1845 :                 failure.hr,
; 1846 :                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 1847 :                 szErrorText,
; 1848 :                 ARRAYSIZE(szErrorText),
; 1849 :                 nullptr);
; 1850 :         }
; 1851 : 
; 1852 :         // %FILENAME(%LINE): %TYPE(%count) tid(%threadid) %HRESULT %SystemMessage
; 1853 :         //     %Caller_MSG [%CODE(%FUNCTION)]
; 1854 : 
; 1855 :         PWSTR dest = pszDest;
; 1856 :         PCWSTR destEnd = (pszDest + cchDest);
; 1857 : 
; 1858 :         if (failure.pszFile != nullptr)

	ldr         x3,[x23,#0x38]
	add         x1,x25,x24,lsl #1
	mov         x0,x25
	ldp         x5,x4,[x22,#0x80]
	cbz         x3,|$LN19@GetFailure|

; 1859 :         {
; 1860 :             dest = details::LogStringPrintf(

	mov         x6,x4
	ldr         w4,[x23,#0x40]
	adrp        x8,|??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@|
	add         x2,x8,|??_C@_1CC@NCIPMFAO@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAu?$AA?$CJ?$AA?2?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3@|
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

; 1861 :                 dest, destEnd, L"%hs(%u)\\%hs!%p: ", failure.pszFile, failure.uLineNumber, failure.pszModule, failure.returnAddress);
; 1862 :         }

	b           |$LN35@GetFailure|
|$LN19@GetFailure|

; 1863 :         else
; 1864 :         {
; 1865 :             dest = details::LogStringPrintf(dest, destEnd, L"%hs!%p: ", failure.pszModule, failure.returnAddress);

	adrp        x8,|??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@|
	add         x2,x8,|??_C@_1BC@HOGHCIFF@?$AA?$CF?$AAh?$AAs?$AA?$CB?$AA?$CF?$AAp?$AA?3?$AA?5@|
	mov         x3,x5
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|
|$LN35@GetFailure|

; 1866 :         }
; 1867 : 
; 1868 :         if (failure.callerReturnAddress != nullptr)

	ldr         x3,[x23,#0x90]
	mov         x19,x0
	cbz         x3,|$LN21@GetFailure|

; 1869 :         {
; 1870 :             dest = details::LogStringPrintf(dest, destEnd, L"(caller: %p) ", failure.callerReturnAddress);

	adrp        x8,|??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@|
	add         x2,x8,|??_C@_1BM@EAHLIJPA@?$AA?$CI?$AAc?$AAa?$AAl?$AAl?$AAe?$AAr?$AA?3?$AA?5?$AA?$CF?$AAp?$AA?$CJ?$AA?5@|
	add         x1,x25,x24,lsl #1
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|
	mov         x19,x0
|$LN21@GetFailure|

; 1871 :         }
; 1872 : 
; 1873 :         dest = details::LogStringPrintf(

	adrp        x8,__imp_GetCurrentThreadId
	ldr         x8,[x8,__imp_GetCurrentThreadId]
	blr         x8
	ldr         w4,[x23,#0x44]
	adrp        x8,|??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@|
	add         x1,x25,x24,lsl #1
	add         x7,x26,#0x10
	mov         w5,w0
	mov         x0,x19
	mov         w6,w20
	mov         x3,x21
	add         x2,x8,|??_C@_1DC@MFHOKFOG@?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAd?$AA?$CJ?$AA?5?$AAt?$AAi?$AAd?$AA?$CI?$AA?$CF?$AAx?$AA?$CJ@|
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

; 1874 :             dest, destEnd, L"%hs(%d) tid(%x) %08X %ws", pszType, failure.cFailureCount, ::GetCurrentThreadId(), errorCode, szErrorText);
; 1875 : 
; 1876 :         if ((failure.pszMessage != nullptr) || (failure.pszCallContext != nullptr) || (failure.pszFunction != nullptr))

	ldr         x8,[x23,#0x18]
	cbnz        x8,|$LN23@GetFailure|
	ldr         x8,[x23,#0x48]
	cbnz        x8,|$LN23@GetFailure|
	ldr         x8,[x23,#0x30]
	cbz         x8,|$LN5@GetFailure|
|$LN23@GetFailure|

; 1877 :         {
; 1878 :             dest = details::LogStringPrintf(dest, destEnd, L"    ");

	adrp        x8,|??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@|
	add         x2,x8,|??_C@_19NMAFMAH@?$AA?5?$AA?5?$AA?5?$AA?5@|
	add         x1,x25,x24,lsl #1
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

; 1879 :             if (failure.pszMessage != nullptr)

	ldr         x3,[x23,#0x18]
	cbz         x3,|$LN24@GetFailure|

; 1880 :             {
; 1881 :                 dest = details::LogStringPrintf(dest, destEnd, L"Msg:[%ws] ", failure.pszMessage);

	adrp        x8,|??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@|
	add         x2,x8,|??_C@_1BG@MCLOHHAM@?$AAM?$AAs?$AAg?$AA?3?$AA?$FL?$AA?$CF?$AAw?$AAs?$AA?$FN?$AA?5@|
	add         x1,x25,x24,lsl #1
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|
|$LN24@GetFailure|

; 1882 :             }
; 1883 :             if (failure.pszCallContext != nullptr)

	ldr         x3,[x23,#0x48]
	cbz         x3,|$LN25@GetFailure|

; 1884 :             {
; 1885 :                 dest = details::LogStringPrintf(dest, destEnd, L"CallContext:[%hs] ", failure.pszCallContext);

	adrp        x8,|??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@|
	add         x2,x8,|??_C@_1CG@CGJKEFKG@?$AAC?$AAa?$AAl?$AAl?$AAC?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?3?$AA?$FL?$AA?$CF?$AAh@|
	add         x1,x25,x24,lsl #1
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|
|$LN25@GetFailure|

; 1886 :             }
; 1887 : 
; 1888 :             if (failure.pszCode != nullptr)

	ldr         x4,[x23,#0x28]
	add         x1,x25,x24,lsl #1
	ldr         x3,[x22,#0x30]
	cbz         x4,|$LN26@GetFailure|

; 1889 :             {
; 1890 :                 dest = details::LogStringPrintf(dest, destEnd, L"[%hs(%hs)]\n", failure.pszFunction, failure.pszCode);

	adrp        x8,|??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@|
	add         x2,x8,|??_C@_1BI@PKOCHLJN@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$CI?$AA?$CF?$AAh?$AAs?$AA?$CJ?$AA?$FN?$AA?6@|
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

; 1891 :             }

	b           |$LN5@GetFailure|
|$LN26@GetFailure|

; 1892 :             else if (failure.pszFunction != nullptr)

	cbz         x3,|$LN28@GetFailure|

; 1893 :             {
; 1894 :                 dest = details::LogStringPrintf(dest, destEnd, L"[%hs]\n", failure.pszFunction);

	adrp        x8,|??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@|
	add         x2,x8,|??_C@_1O@PJKHPDBK@?$AA?$FL?$AA?$CF?$AAh?$AAs?$AA?$FN?$AA?6@|
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|

; 1895 :             }

	b           |$LN5@GetFailure|
|$LN28@GetFailure|

; 1896 :             else
; 1897 :             {
; 1898 :                 dest = details::LogStringPrintf(dest, destEnd, L"\n");

	adrp        x8,|??_C@_13LBAGMAIH@?$AA?6@|
	add         x2,x8,|??_C@_13LBAGMAIH@?$AA?6@|
	bl          |?LogStringPrintf@details@wil@@YAPEA_WPEA_WPEB_W1ZZ|
|$LN5@GetFailure|

; 1779 :     {
; 1780 :         return S_OK;

	mov         w0,#0
	add         sp,sp,#0x210
	bl          __security_pop_cookie
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x50
	ret
|__swt|
|$LN40@GetFailure|

; 1796 :     {
; 1797 :         PCSTR pszType = "";
; 1798 :         switch (failure.type)

	DCD         0xfffffff5
|$LN41@GetFailure|
	DCD         0xfffffff8
|$LN42@GetFailure|
	DCD         0x0
|$LN43@GetFailure|
	DCD         0x8

	ENDP  ; |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|, wil::GetFailureLogString

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z| PROC ; wil::details::ResultStatus::FromResult

; 1937 :         {

|$LN6|
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	str         w0,[sp,#0x10]
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|
	mov         w1,#0
	str         w0,[sp,#0x14]
	ldr         x0,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?FromResult@ResultStatus@details@wil@@SA?AU123@J@Z|, wil::details::ResultStatus::FromResult

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z| PROC ; wil::details::ResultStatus::FromFailureInfo

; 1945 :         {

|$LN6|
	sub         sp,sp,#0x10

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	ldp         w8,w9,[x0,#4]
	ldr         w10,[x0,#0xC]
	ubfx        w1,w8,#3,#1
	stp         w9,w10,[sp]
	ldr         x0,[sp]
	add         sp,sp,#0x10
	ret

	ENDP  ; |?FromFailureInfo@ResultStatus@details@wil@@SA?AU123@AEBUFailureInfo@3@@Z|, wil::details::ResultStatus::FromFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0shared_buffer@details@wil@@QEAA@XZ| PROC		; wil::details::shared_buffer::shared_buffer

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x0]
	ret

	ENDP  ; |??0shared_buffer@details@wil@@QEAA@XZ|, wil::details::shared_buffer::shared_buffer

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0shared_buffer@details@wil@@QEAA@AEBV012@@Z| PROC	; wil::details::shared_buffer::shared_buffer

; 2254 :         {

|$LN20|
	sub         sp,sp,#0x10
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x0]

; 2255 :             assign(other.m_pCopy, other.m_size);

	ldp         x9,x8,[x1]

; 2363 :             if (pCopy != nullptr)

	cbz         x9,|$LN5@shared_buf|
	str         x19,[sp,#0x10]
	mov         x19,x0

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	stp         x9,x8,[x19]

; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	mov         x0,x9
	bl          _InterlockedIncrement_nf
	mov         x0,x19
	ldr         x19,[sp,#0x10]
|$LN5@shared_buf|
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x10
	ret

	ENDP  ; |??0shared_buffer@details@wil@@QEAA@AEBV012@@Z|, wil::details::shared_buffer::shared_buffer

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??1shared_buffer@details@wil@@QEAA@XZ| PROC		; wil::details::shared_buffer::~shared_buffer

; 2265 :         {

|$LN16|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x8,[x0]
	cbz         x8,|$LN5@shared_buf|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	mov         x0,x8

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN6@shared_buf|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x20,[x19]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x20
	mov         w1,#0
	blr         x8
|$LN6@shared_buf|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x19]
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
|$LN5@shared_buf|
	ret

	ENDP  ; |??1shared_buffer@details@wil@@QEAA@XZ|, wil::details::shared_buffer::~shared_buffer

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?reset@shared_buffer@details@wil@@QEAAXXZ| PROC	; wil::details::shared_buffer::reset

; 2292 :         {

|$LN13|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x8,[x0]
	cbz         x8,|$LN2@reset|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	mov         x0,x8

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN3@reset|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x20,[x19]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x20
	mov         w1,#0
	blr         x8
|$LN3@reset|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x19]
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
|$LN2@reset|
	ret

	ENDP  ; |?reset@shared_buffer@details@wil@@QEAAXXZ|, wil::details::shared_buffer::reset

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z| PROC ; wil::details::shared_buffer::create

; 2305 :         {

|$LN26|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x21,x0
	mov         x20,x2

; 2306 :             if (cbData == 0)

	cbnz        x20,|$LN2@create|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x21]
	cbz         x0,|$LN8@create|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN9@create|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x19,[x21]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x19
	mov         w1,#0
	blr         x8
|$LN9@create|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x21]

; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }

	mov         w0,#1
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN2@create|

; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	blr         x8
	adrp        x8,__imp_HeapAlloc
	ldr         x8,[x8,__imp_HeapAlloc]
	add         x2,x20,#4
	mov         w1,#0
	blr         x8
	mov         x19,x0

; 2313 :             if (pCopyRefCount == nullptr)

	cbnz        x19,|$LN3@create|

; 2314 :             {
; 2315 :                 return false;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN3@create|

; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;

	str         wzr,[x19]

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x21]
	cbz         x0,|$LN21@create|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN21@create|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x22,[x21]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x22
	mov         w1,#0
	blr         x8
|$LN21@create|

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	mov         x0,x19
	stp         x19,x20,[x21]
	bl          _InterlockedIncrement_nf
|$LN8@create|

; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }

	mov         w0,#1
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |?create@shared_buffer@details@wil@@QEAA_NPEBX_K@Z|, wil::details::shared_buffer::create

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?create@shared_buffer@details@wil@@QEAA_N_K@Z| PROC	; wil::details::shared_buffer::create

; 2328 :         {

|$LN29|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x21,x0
	mov         x20,x1

; 2306 :             if (cbData == 0)

	cbnz        x20,|$LN5@create|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x21]
	cbz         x0,|$LN11@create|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN12@create|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x19,[x21]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x19
	mov         w1,#0
	blr         x8
|$LN12@create|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x21]

; 2329 :             return create(nullptr, cbData);
; 2330 :         }

	mov         w0,#1
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN5@create|

; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	blr         x8
	adrp        x8,__imp_HeapAlloc
	ldr         x8,[x8,__imp_HeapAlloc]
	add         x2,x20,#4
	mov         w1,#0
	blr         x8
	mov         x19,x0

; 2313 :             if (pCopyRefCount == nullptr)

	cbnz        x19,|$LN6@create|

; 2314 :             {
; 2315 :                 return false;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN6@create|

; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;

	str         wzr,[x19]

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x21]
	cbz         x0,|$LN24@create|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN24@create|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x22,[x21]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x22
	mov         w1,#0
	blr         x8
|$LN24@create|

; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	mov         x0,x19
	stp         x19,x20,[x21]
	bl          _InterlockedIncrement_nf
|$LN11@create|

; 2329 :             return create(nullptr, cbData);
; 2330 :         }

	mov         w0,#1
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |?create@shared_buffer@details@wil@@QEAA_N_K@Z|, wil::details::shared_buffer::create

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z| PROC	; wil::details::shared_buffer::get

; 2334 :             if (pSize != nullptr)

	cbz         x1,|$LN11@get|

; 2335 :             {
; 2336 :                 *pSize = m_size;

	ldr         x8,[x0,#8]
	str         x8,[x1]
|$LN11@get|

; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	ldr         x9,[x0]
	add         x8,x9,#4
	cmp         x9,#0
	cselne      x0,x8,xzr
	ret

	ENDP  ; |?get@shared_buffer@details@wil@@QEBAPEAXPEA_K@Z|, wil::details::shared_buffer::get

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?size@shared_buffer@details@wil@@QEBA_KXZ| PROC	; wil::details::shared_buffer::size

; 2343 :             return m_size;

	ldr         x0,[x0,#8]
	ret

	ENDP  ; |?size@shared_buffer@details@wil@@QEBA_KXZ|, wil::details::shared_buffer::size

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??Bshared_buffer@details@wil@@QEBA_NXZ| PROC		; wil::details::shared_buffer::operator bool

; 2348 :             return (m_pCopy != nullptr);

	ldr         x8,[x0]
	cmp         x8,#0
	csetne      w0
	ret

	ENDP  ; |??Bshared_buffer@details@wil@@QEBA_NXZ|, wil::details::shared_buffer::operator bool

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?unique@shared_buffer@details@wil@@QEBA_NXZ| PROC	; wil::details::shared_buffer::unique

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	ldr         x8,[x0]
	cbz         x8,|$LN3@unique|
	ldr         w8,[x8]
	mov         w0,#1
	cmp         w8,#1
	beq         |$LN4@unique|
|$LN3@unique|
	mov         w0,#0
|$LN4@unique|
	ret

	ENDP  ; |?unique@shared_buffer@details@wil@@QEBA_NXZ|, wil::details::shared_buffer::unique

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z| PROC	; wil::details::shared_buffer::assign

; 2361 :         {

|$LN15|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x21,x0

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x21]
	mov         x20,x1
	mov         x19,x2
	cbz         x0,|$LN10@assign|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN7@assign|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x22,[x21]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x22
	mov         w1,#0
	blr         x8
|$LN7@assign|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x21]
|$LN10@assign|

; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)

	add         x8,x21,#8
	cbz         x20,|$LN2@assign|

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	mov         x0,x20
	str         x20,[x21]
	str         x19,[x8]
	bl          _InterlockedIncrement_nf
|$LN2@assign|
	ldp         fp,lr,[sp],#0x10
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |?assign@shared_buffer@details@wil@@AEAAXPEAJ_K@Z|, wil::details::shared_buffer::assign

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?RecordFailFast@details@wil@@YAHJ@Z| PROC		; wil::details::RecordFailFast

; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;

	adrp        x8,|?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC|
	str         w0,[x8,|?s_hrErrorLast@?1??RecordFailFast@details@wil@@YAHJ@Z@4JC|]

; 2554 :         return 1;

	mov         w0,#1
	ret

	ENDP  ; |?RecordFailFast@details@wil@@YAHJ@Z|, wil::details::RecordFailFast

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z| PROC ; wil::details::K32GetModuleInformation

; 2573 :     {

|$LN56|
	stp         fp,lr,[sp,#-0x30]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x110
	mov         x21,x0

; 2574 :         HMODULE hModule = nullptr;

	str         xzr,[sp]
	mov         x0,#0
	mov         x22,x1
	mov         x19,x2
	mov         x20,x3

; 2575 :         if (address && !GetModuleHandleExW(

	cbz         x21,|$LN4@K32GetModu|
	adrp        x8,__imp_GetModuleHandleExW
	ldr         x8,[x8,__imp_GetModuleHandleExW]
	mov         x2,sp
	mov         x1,x21
	mov         w0,#6
	blr         x8
	cbnz        w0,|$LN41@K32GetModu|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN37@K32GetModu|

; 646  :     {
; 647  :         *outParam = val;

	str         wzr,[x22]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2594 :                 return false;

	b           |$LN1@K32GetModu|
|$LN41@K32GetModu|

; 2575 :         if (address && !GetModuleHandleExW(

	ldr         x0,[sp]
|$LN4@K32GetModu|

; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)

	cbz         x22,|$LN5@K32GetModu|

; 2584 :         {
; 2585 :             *addressOffset =

	sub         w8,w21,w0
	cmp         x21,#0
	cselne      w8,w8,wzr
	str         w8,[x22]
|$LN5@K32GetModu|

; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)

	cbz         x19,|$LN16@K32GetModu|

; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))

	adrp        x8,__imp_GetModuleFileNameA
	ldr         x8,[x8,__imp_GetModuleFileNameA]
	mov         w2,#0x104
	add         x1,sp,#8
	blr         x8
	cbnz        w0,|$LN7@K32GetModu|
|$LN37@K32GetModu|

; 2594 :                 return false;

	mov         w0,#0
	b           |$LN1@K32GetModu|
|$LN7@K32GetModu|

; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);

	add         x9,sp,#8
	mov         x8,x9
	ldrsb       w10,[x8]
	cbz         w10,|$LN46@K32GetModu|
|$LL45@K32GetModu|
	ldrsb       w10,[x8,#1]!
	cbnz        w10,|$LL45@K32GetModu|
|$LN46@K32GetModu|
	sub         x9,x8,x9
	add         x8,sp,#8
	add         x8,x9,x8

; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))

	add         x9,sp,#8
	cmp         x8,x9
	bls         |$LN49@K32GetModu|
	add         x9,sp,#8
|$LL2@K32GetModu|
	ldursb      w10,[x8,#-1]
	cmp         w10,#0x5C
	beq         |$LN49@K32GetModu|

; 2599 :             {
; 2600 :                 start--;

	sub         x8,x8,#1
	cmp         x8,x9
	bhi         |$LL2@K32GetModu|
|$LN49@K32GetModu|
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 9669 :     if ((cchDest == 0) || (cchDest > cchMax))

	cbz         x20,|$LN16@K32GetModu|
	mov         x9,#0x7FFFFFFF
	cmp         x20,x9
	bls         |$LN36@K32GetModu|

; 557  :         *pszDest = '\0';

	strb        wzr,[x19]
	b           |$LN16@K32GetModu|
|$LN36@K32GetModu|

; 549  :         hr = StringCopyWorkerA(pszDest,

	mov         x9,#0x7FFFFFFE
	sub         x9,x9,x20
	sub         x8,x8,x19
|$LL23@K32GetModu|

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	add         x10,x9,x20
	cbz         x10,|$LN53@K32GetModu|
	ldrsb       w10,[x8,x19]
	cbz         w10,|$LN53@K32GetModu|

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	strb        w10,[x19]
	add         x19,x19,#1

; 9919 :         cchDest--;

	sub         x20,x20,#1
	cbnz        x20,|$LL23@K32GetModu|
|$LN53@K32GetModu|

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	sub         x8,x19,#1
	cmp         x20,#0
	cselne      x8,x19,x8
	strb        wzr,[x8]
|$LN16@K32GetModu|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2604 :         return true;

	mov         w0,#1
|$LN1@K32GetModu|
	add         sp,sp,#0x110
	bl          __security_pop_cookie
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x30
	ret

	ENDP  ; |?K32GetModuleInformation@details@wil@@YA_NPEAXPEAIPEAD_K@Z|, wil::details::K32GetModuleInformation

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?GetCurrentModuleName@details@wil@@YAPEBDXZ| PROC	; wil::details::GetCurrentModuleName

; 2610 :     {

|$LN59|

; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable

	adrp        x1,|?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC|
	ldrb        w8,[x1,|?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC|]
	cmp         w8,#0
	adrp        x8,|?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA|
	add         x0,x8,|?s_szModule@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4PADA|
	bne         |$LN2@GetCurrent|
	stp         fp,lr,[sp,#-0x20]!
	stp         x19,x20,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x110
	mov         x20,x1
	mov         x19,x0

; 2574 :         HMODULE hModule = nullptr;

	str         xzr,[sp]

; 2575 :         if (address && !GetModuleHandleExW(

	mov         x2,sp
	adrp        x8,|?RecordFailFast@details@wil@@YAHJ@Z|
	add         x1,x8,|?RecordFailFast@details@wil@@YAHJ@Z|
	mov         w0,#6
	adrp        x8,__imp_GetModuleHandleExW
	ldr         x8,[x8,__imp_GetModuleHandleExW]
	blr         x8
	cbz         w0,|$LN20@GetCurrent|

; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))

	adrp        x8,__imp_GetModuleFileNameA
	ldr         x8,[x8,__imp_GetModuleFileNameA]
	ldr         x0,[sp]
	mov         w2,#0x104
	add         x1,sp,#8
	blr         x8
	cbz         w0,|$LN20@GetCurrent|

; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);

	add         x9,sp,#8
	mov         x8,x9
	ldrsb       w10,[x8]
	cbz         w10,|$LN47@GetCurrent|
|$LL46@GetCurrent|
	ldrsb       w10,[x8,#1]!
	cbnz        w10,|$LL46@GetCurrent|
|$LN47@GetCurrent|
	sub         x9,x8,x9
	add         x8,sp,#8
	add         x10,x9,x8

; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))

	add         x8,sp,#8
	cmp         x10,x8
	bls         |$LN50@GetCurrent|
	add         x8,sp,#8
|$LL6@GetCurrent|
	ldursb      w9,[x10,#-1]
	cmp         w9,#0x5C
	beq         |$LN50@GetCurrent|

; 2599 :             {
; 2600 :                 start--;

	sub         x10,x10,#1
	cmp         x10,x8
	bhi         |$LL6@GetCurrent|
|$LN50@GetCurrent|
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\strsafe.h

; 549  :         hr = StringCopyWorkerA(pszDest,

	sub         x11,x10,x19
	mov         x10,#0xFFBE
	movk        x10,#0x7FFF,lsl #0x10
	mov         x9,#0x40
	mov         x8,x19
|$LL27@GetCurrent|

; 9916 :     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	add         x12,x9,x10
	cbz         x12,|$LN54@GetCurrent|
	ldrsb       w12,[x11,x8]
	cbz         w12,|$LN54@GetCurrent|

; 9917 :     {
; 9918 :         *pszDest++ = *pszSrc++;

	strb        w12,[x8]
	add         x8,x8,#1

; 9919 :         cchDest--;

	sub         x9,x9,#1
	cbnz        x9,|$LL27@GetCurrent|
|$LN54@GetCurrent|

; 9920 :         cchToCopy--;
; 9921 : 
; 9922 :         cchNewDestLength++;
; 9923 :     }
; 9924 : 
; 9925 :     if (cchDest == 0)
; 9926 :     {
; 9927 :         // we are going to truncate pszDest
; 9928 :         pszDest--;
; 9929 :         cchNewDestLength--;
; 9930 : 
; 9931 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 9932 :     }
; 9933 : 
; 9934 :     *pszDest = '\0';

	sub         x10,x8,#1
	cmp         x9,#0
	cselne      x8,x8,x10
	strb        wzr,[x8]
|$LN20@GetCurrent|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2616 :             s_fModuleValid = true;

	mov         w8,#1
	strb        w8,[x20,|?s_fModuleValid@?1??GetCurrentModuleName@details@wil@@YAPEBDXZ@4_NC|]
	mov         x0,x19
	add         sp,sp,#0x110
	bl          __security_pop_cookie
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
|$LN2@GetCurrent|
	ret

	ENDP  ; |?GetCurrentModuleName@details@wil@@YAPEBDXZ|, wil::details::GetCurrentModuleName

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?DebugBreak@details@wil@@YAXXZ| PROC			; wil::details::DebugBreak

; 2623 :     {

|$LN8|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 2624 :         ::DebugBreak();

	adrp        x8,__imp_DebugBreak
	ldr         x8,[x8,__imp_DebugBreak]
	blr         x8
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?DebugBreak@details@wil@@YAXXZ|, wil::details::DebugBreak

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z| PROC ; wil::details::WilDynamicLoadRaiseFailFastException

; 2628 :     {

|$LN14|
	stp         x19,x20,[sp,#-0x20]!
	str         x21,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x21,x0

; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");

	adrp        x8,|??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@|
	add         x0,x8,|??_C@_1BO@MFOKJHPK@?$AAk?$AAe?$AAr?$AAn?$AAe?$AAl?$AAb?$AAa?$AAs?$AAe?$AA?4?$AAd?$AAl?$AAl@|
	adrp        x8,__imp_GetModuleHandleW
	ldr         x8,[x8,__imp_GetModuleHandleW]
	mov         x20,x1
	mov         w19,w2
	blr         x8

; 1700 :         return reinterpret_cast<FuncPtr>(reinterpret_cast<void (*)()>(::GetProcAddress(module, procName)));

	adrp        x8,|??_C@_0BH@EEDPADAA@RaiseFailFastException@|
	add         x1,x8,|??_C@_0BH@EEDPADAA@RaiseFailFastException@|
	adrp        x8,__imp_GetProcAddress
	ldr         x8,[x8,__imp_GetProcAddress]
	blr         x8
	mov         x3,x0

; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)

	cbz         x3,|$LN11@WilDynamic|

; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);

	mov         w2,w19
	mov         x1,x20
	mov         x0,x21
	blr         x3
|$LN11@WilDynamic|
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |?WilDynamicLoadRaiseFailFastException@details@wil@@YAXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z|, wil::details::WilDynamicLoadRaiseFailFastException

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?HrToNtStatus@details@wil@@YAJJ@Z| PROC		; wil::details::HrToNtStatus

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	ldr         w8,|$LN60@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN33@HrToNtStat|
	beq         |$LN12@HrToNtStat|
	ldr         w8,|$LN61@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN34@HrToNtStat|
	beq         |$LN5@HrToNtStat|
	ldr         w8,|$LN62@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN35@HrToNtStat|
	beq         |$LN10@HrToNtStat|
	ldr         w8,|$LN63@HrToNtStat|
	cmp         w0,w8
	beq         |$LN22@HrToNtStat|
	ldr         w8,|$LN64@HrToNtStat|
	cmp         w0,w8
	bne         |$LN25@HrToNtStat|

; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;

	ldr         w0,|$LN65@HrToNtStat|
	ret
|$LN22@HrToNtStat|

; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;

	mov         w0,#0xC0000001
	ret
|$LN10@HrToNtStat|

; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;

	ldr         w0,|$LN66@HrToNtStat|
	ret
|$LN35@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	ldr         w8,|$LN67@HrToNtStat|
	cmp         w0,w8
	beq         |$LN9@HrToNtStat|
	ldr         w8,|$LN68@HrToNtStat|
	cmp         w0,w8
	bne         |$LN25@HrToNtStat|

; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;

	ldr         w0,|$LN69@HrToNtStat|
	ret
|$LN9@HrToNtStat|

; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;

	ldr         w0,|$LN70@HrToNtStat|
	ret
|$LN5@HrToNtStat|

; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;

	ldr         w0,|$LN71@HrToNtStat|
	ret
|$LN34@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	mov         w8,#0xFF90
	movk        w8,#0x7FF8,lsl #0x10
	add         w10,w0,w8
	cmp         w10,#0xE
	bhi         |$LN25@HrToNtStat|
	adr         x9,__swt
	ldrsb       x8,[x9,w10 uxtw #0]
	add         x8,x9,x8,lsl #2
	br          x8
|$LN17@HrToNtStat|

; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;

	ldr         w0,|$LN72@HrToNtStat|
	ret
|$LN18@HrToNtStat|

; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;

	mov         w0,#0xC000007F
	ret
|$LN19@HrToNtStat|

; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;

	ldr         w0,|$LN73@HrToNtStat|
	ret
|$LN20@HrToNtStat|

; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;

	ldr         w0,|$LN74@HrToNtStat|
	ret
|$LN12@HrToNtStat|

; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;

	ldr         w0,|$LN75@HrToNtStat|
	ret
|$LN33@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	ldr         w8,|$LN76@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN36@HrToNtStat|
	beq         |$LN21@HrToNtStat|
	ldr         w8,|$LN77@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN37@HrToNtStat|
	beq         |$LN15@HrToNtStat|
	ldr         w8,|$LN78@HrToNtStat|
	cmp         w0,w8
	beq         |$LN8@HrToNtStat|
	ldr         w8,|$LN79@HrToNtStat|
	cmp         w0,w8
	bne         |$LN25@HrToNtStat|

; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;

	ldr         w0,|$LN80@HrToNtStat|
	ret
|$LN8@HrToNtStat|

; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;

	ldr         w0,|$LN81@HrToNtStat|
	ret
|$LN15@HrToNtStat|

; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;

	ldr         w0,|$LN82@HrToNtStat|
	ret
|$LN37@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	ldr         w8,|$LN83@HrToNtStat|
	cmp         w0,w8
	beq         |$LN16@HrToNtStat|
	ldr         w8,|$LN84@HrToNtStat|
	cmp         w0,w8
	bne         |$LN25@HrToNtStat|

; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;

	ldr         w0,|$LN85@HrToNtStat|
	ret
|$LN16@HrToNtStat|

; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;

	ldr         w0,|$LN86@HrToNtStat|
	ret
|$LN21@HrToNtStat|

; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;

	ldr         w0,|$LN87@HrToNtStat|
	ret
|$LN36@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	ldr         w8,|$LN88@HrToNtStat|
	cmp         w0,w8
	bgt         |$LN38@HrToNtStat|
	beq         |$LN23@HrToNtStat|
	ldr         w8,|$LN89@HrToNtStat|
	cmp         w0,w8
	beq         |$LN13@HrToNtStat|
	ldr         w8,|$LN90@HrToNtStat|
	cmp         w0,w8
	bne         |$LN25@HrToNtStat|
|$LN30@HrToNtStat|

; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }

	ldr         w0,|$LN91@HrToNtStat|
	ret
|$LN13@HrToNtStat|

; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;

	ldr         w0,|$LN92@HrToNtStat|
	ret
|$LN23@HrToNtStat|

; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;

	ldr         w0,|$LN93@HrToNtStat|
	ret
|$LN38@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	cbz         w0,|$LN4@HrToNtStat|
|$LN25@HrToNtStat|

; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)

	tbz         w0,#0x1C,|$LN26@HrToNtStat|

; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);

	and         w0,w0,#0xEFFFFFFF
	ret
|$LN26@HrToNtStat|

; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)

	and         w8,w0,#0x1FFF0000
	cmp         w8,#0x70,lsl #0xC
	bne         |$LN28@HrToNtStat|

; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));

	and         w9,w0,#0xFFFF
	mov         w8,#0xC0070000
	orr         w8,w9,w8
	cmp         w9,#0
	csells      w0,w9,w8
	ret
|$LN28@HrToNtStat|

; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)

	and         w8,w0,#0x1FFF0000
	cmp         w8,#0x90,lsl #0xC
	bne         |$LN30@HrToNtStat|

; 2787 :             {
; 2788 :                 status =

	and         w9,w0,#0xFFFF
	mov         w8,#0xC0090000
	orr         w8,w9,w8
	cmp         w0,#0
	cselle      w0,w0,w8
	ret
|$LN4@HrToNtStat|

; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;

	mov         w0,#0
	ret
|__swt|
|$LN45@HrToNtStat|

; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)

	DCB         0xb0
|$LN46@HrToNtStat|
	DCB         0xe9
|$LN47@HrToNtStat|
	DCB         0xe9
|$LN48@HrToNtStat|
	DCB         0xe9
|$LN49@HrToNtStat|
	DCB         0xe9
|$LN50@HrToNtStat|
	DCB         0xe9
|$LN51@HrToNtStat|
	DCB         0xe9
|$LN52@HrToNtStat|
	DCB         0xe9
|$LN53@HrToNtStat|
	DCB         0xe9
|$LN54@HrToNtStat|
	DCB         0xe9
|$LN55@HrToNtStat|
	DCB         0xae
|$LN56@HrToNtStat|
	DCB         0xb2
|$LN57@HrToNtStat|
	DCB         0xe9
|$LN58@HrToNtStat|
	DCB         0xe9
|$LN59@HrToNtStat|
	DCB         0xb4
|$LN94@HrToNtStat|
	DCB         0xb4
	nop
|$LN60@HrToNtStat|
	DCD         0x800700ea
|$LN61@HrToNtStat|
	DCD         0x80070057
|$LN62@HrToNtStat|
	DCD         0x80070002
|$LN63@HrToNtStat|
	DCD         0x80004005
|$LN64@HrToNtStat|
	DCD         0x80070001
|$LN65@HrToNtStat|
	DCD         0xc0000002
|$LN66@HrToNtStat|
	DCD         0xc0000034
|$LN67@HrToNtStat|
	DCD         0x80070003
|$LN68@HrToNtStat|
	DCD         0x8007000e
|$LN69@HrToNtStat|
	DCD         0xc0000017
|$LN70@HrToNtStat|
	DCD         0xc000003a
|$LN71@HrToNtStat|
	DCD         0xc000000d
|$LN72@HrToNtStat|
	DCD         0xc0000023
|$LN73@HrToNtStat|
	DCD         0xc0000033
|$LN74@HrToNtStat|
	DCD         0xc0000135
|$LN75@HrToNtStat|
	DCD         0x80000005
|$LN76@HrToNtStat|
	DCD         0x8007047e
|$LN77@HrToNtStat|
	DCD         0x80070246
|$LN78@HrToNtStat|
	DCD         0x80070216
|$LN79@HrToNtStat|
	DCD         0x8007023e
|$LN80@HrToNtStat|
	DCD         0xc0000025
|$LN81@HrToNtStat|
	DCD         0xc0000095
|$LN82@HrToNtStat|
	DCD         0xc0000161
|$LN83@HrToNtStat|
	DCD         0x80070247
|$LN84@HrToNtStat|
	DCD         0x80070272
|$LN85@HrToNtStat|
	DCD         0xc0000273
|$LN86@HrToNtStat|
	DCD         0xc0000163
|$LN87@HrToNtStat|
	DCD         0xc0000059
|$LN88@HrToNtStat|
	DCD         0x800705b9
|$LN89@HrToNtStat|
	DCD         0x8007050c
|$LN90@HrToNtStat|
	DCD         0x8007054f
|$LN91@HrToNtStat|
	DCD         0xc00000e5
|$LN92@HrToNtStat|
	DCD         0xc000042b
|$LN93@HrToNtStat|
	DCD         0xc000a083

	ENDP  ; |?HrToNtStatus@details@wil@@YAJJ@Z|, wil::details::HrToNtStatus

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?ResultStringSize@details@wil@@YA_KPEBD@Z| PROC	; wil::details::ResultStringSize

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x0,|$LN3@ResultStri|
	mov         x0,#1
	ret
|$LN3@ResultStri|
	mov         x8,x0
	ldrsb       w9,[x8]
	cbz         w9,|$LN11@ResultStri|
|$LL10@ResultStri|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL10@ResultStri|
|$LN11@ResultStri|
	sub         x8,x8,x0
	add         x0,x8,#1
	ret

	ENDP  ; |?ResultStringSize@details@wil@@YA_KPEBD@Z|, wil::details::ResultStringSize

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?ResultStringSize@details@wil@@YA_KPEB_W@Z| PROC	; wil::details::ResultStringSize

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	cbnz        x0,|$LN3@ResultStri|
	mov         x0,#2
	ret
|$LN3@ResultStri|
	mov         x8,x0
	ldrsh       w9,[x8]
	cbz         w9,|$LN11@ResultStri|
|$LL10@ResultStri|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL10@ResultStri|
|$LN11@ResultStri|
	sub         x8,x8,x0
	asr         x8,x8,#1
	add         x8,x8,#1
	lsl         x0,x8,#1
	ret

	ENDP  ; |?ResultStringSize@details@wil@@YA_KPEB_W@Z|, wil::details::ResultStringSize

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ| PROC ; wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse

; 3113 : {

	ret

	ENDP  ; |?WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse@wil@@YAXXZ|, wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??R<lambda_1>@details@wil@@QEBA@XZ| PROC		; wil::details::<lambda_1>::operator()

; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {

	mov         w0,#1
	ret

	ENDP  ; |??R<lambda_1>@details@wil@@QEBA@XZ|, wil::details::<lambda_1>::operator()

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z| PROC ; wil::StoredFailureInfo::StoredFailureInfo

; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT

|$LN11|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x19,#0x98]

; 3359 :     {
; 3360 :         SetFailureInfo(other);

	bl          |?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z|

; 3361 :     }

	mov         x0,x19
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |??0StoredFailureInfo@wil@@QEAA@AEBUFailureInfo@1@@Z|, wil::StoredFailureInfo::StoredFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ| PROC ; wil::StoredFailureInfo::GetFailureInfo

; 3364 :     {

	ret

	ENDP  ; |?GetFailureInfo@StoredFailureInfo@wil@@QEBAAEBUFailureInfo@2@XZ|, wil::StoredFailureInfo::GetFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z| PROC ; wil::StoredFailureInfo::SetFailureInfo

; 3369 :     {

|$LN362|
	stp         x19,x20,[sp,#-0x30]!
	stp         x21,x22,[sp,#0x10]
	stp         x23,x24,[sp,#0x20]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x21,x1

; 3370 :         m_failureInfo = failure;

	ldp         q17,q16,[x21]
	mov         x20,x0
	stp         q17,q16,[x20]
	ldp         q17,q16,[x21,#0x20]
	stp         q17,q16,[x20,#0x20]
	ldp         q17,q16,[x21,#0x40]
	stp         q17,q16,[x20,#0x40]
	ldp         q17,q16,[x21,#0x60]
	stp         q17,q16,[x20,#0x60]
	ldr         q16,[x21,#0x80]
	str         q16,[x20,#0x80]
	ldr         x8,[x21,#0x90]
	str         x8,[x20,#0x90]

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x9,[x21,#0x18]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	cbnz        x9,|$LN9@SetFailure|
	mov         x11,#2
	b           |$LN10@SetFailure|
|$LN9@SetFailure|
	mov         x8,x9
	ldrsh       w10,[x8]
	cbz         w10,|$LN321@SetFailure|
|$LL320@SetFailure|
	ldrsh       w10,[x8,#2]!
	cbnz        w10,|$LL320@SetFailure|
|$LN321@SetFailure|
	sub         x8,x8,x9
	asr         x8,x8,#1
	add         x8,x8,#1
	lsl         x11,x8,#1
|$LN10@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x9,[x21,#0x28]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x9,|$LN13@SetFailure|
	mov         x10,#1
	b           |$LN14@SetFailure|
|$LN13@SetFailure|
	mov         x8,x9
	ldrsb       w10,[x8]
	cbz         w10,|$LN323@SetFailure|
|$LL322@SetFailure|
	ldrsb       w10,[x8,#1]!
	cbnz        w10,|$LL322@SetFailure|
|$LN323@SetFailure|
	sub         x8,x8,x9
	add         x10,x8,#1
|$LN14@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x9,[x21,#0x30]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x9,|$LN17@SetFailure|
	mov         x9,#1
	b           |$LN18@SetFailure|
|$LN17@SetFailure|
	mov         x8,x9
	ldrsb       w12,[x8]
	cbz         w12,|$LN325@SetFailure|
|$LL324@SetFailure|
	ldrsb       w12,[x8,#1]!
	cbnz        w12,|$LL324@SetFailure|
|$LN325@SetFailure|
	sub         x8,x8,x9
	add         x9,x8,#1
|$LN18@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x12,[x21,#0x38]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x12,|$LN21@SetFailure|
	mov         x8,#1
	b           |$LN22@SetFailure|
|$LN21@SetFailure|
	mov         x8,x12
	ldrsb       w13,[x8]
	cbz         w13,|$LN327@SetFailure|
|$LL326@SetFailure|
	ldrsb       w13,[x8,#1]!
	cbnz        w13,|$LL326@SetFailure|
|$LN327@SetFailure|
	sub         x8,x8,x12
	add         x8,x8,#1
|$LN22@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x48]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x13,|$LN25@SetFailure|
	mov         x5,#1
	b           |$LN26@SetFailure|
|$LN25@SetFailure|
	mov         x12,x13
	ldrsb       w14,[x12]
	cbz         w14,|$LN329@SetFailure|
|$LL328@SetFailure|
	ldrsb       w14,[x12,#1]!
	cbnz        w14,|$LL328@SetFailure|
|$LN329@SetFailure|
	sub         x12,x12,x13
	add         x5,x12,#1
|$LN26@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x80]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x13,|$LN29@SetFailure|
	mov         x6,#1
	b           |$LN30@SetFailure|
|$LN29@SetFailure|
	mov         x12,x13
	ldrsb       w14,[x12]
	cbz         w14,|$LN331@SetFailure|
|$LL330@SetFailure|
	ldrsb       w14,[x12,#1]!
	cbnz        w14,|$LL330@SetFailure|
|$LN331@SetFailure|
	sub         x12,x12,x13
	add         x6,x12,#1
|$LN30@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x70]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x13,|$LN33@SetFailure|
	mov         x7,#1
	b           |$LN34@SetFailure|
|$LN33@SetFailure|
	mov         x12,x13
	ldrsb       w14,[x12]
	cbz         w14,|$LN333@SetFailure|
|$LL332@SetFailure|
	ldrsb       w14,[x12,#1]!
	cbnz        w14,|$LL332@SetFailure|
|$LN333@SetFailure|
	sub         x12,x12,x13
	add         x7,x12,#1
|$LN34@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x78]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	cbnz        x13,|$LN37@SetFailure|
	mov         x15,#2
	b           |$LN38@SetFailure|
|$LN37@SetFailure|
	mov         x12,x13
	ldrsh       w14,[x12]
	cbz         w14,|$LN335@SetFailure|
|$LL334@SetFailure|
	ldrsh       w14,[x12,#2]!
	cbnz        w14,|$LL334@SetFailure|
|$LN335@SetFailure|
	sub         x12,x12,x13
	asr         x12,x12,#1
	add         x12,x12,#1
	lsl         x15,x12,#1
|$LN38@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x58]

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	cbnz        x13,|$LN41@SetFailure|
	mov         x14,#1
	b           |$LN42@SetFailure|
|$LN41@SetFailure|
	mov         x12,x13
	ldrsb       w14,[x12]
	cbz         w14,|$LN337@SetFailure|
|$LL336@SetFailure|
	ldrsb       w14,[x12,#1]!
	cbnz        w14,|$LL336@SetFailure|
|$LN337@SetFailure|
	sub         x12,x12,x13
	add         x14,x12,#1
|$LN42@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	ldr         x13,[x21,#0x60]

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	cbnz        x13,|$LN45@SetFailure|
	mov         x12,#2
	b           |$LN46@SetFailure|
|$LN45@SetFailure|
	mov         x12,x13
	ldrsh       w4,[x12]
	cbz         w4,|$LN339@SetFailure|
|$LL338@SetFailure|
	ldrsh       w4,[x12,#2]!
	cbnz        w4,|$LL338@SetFailure|
|$LN339@SetFailure|
	sub         x12,x12,x13
	asr         x12,x12,#1
	add         x12,x12,#1
	lsl         x12,x12,#1
|$LN46@SetFailure|

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	add         x12,x12,x14

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	ldr         x0,[x20,#0x98]

; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +

	add         x12,x12,x15
	add         x12,x12,x7
	add         x12,x12,x6
	add         x12,x12,x5
	add         x8,x12,x8
	add         x8,x8,x9
	add         x8,x8,x10
	add         x24,x8,x11

; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));

	cbz         x0,|$LN3@SetFailure|
	ldr         w8,[x0]
	cmp         w8,#1
	bne         |$LN3@SetFailure|

; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))

	ldr         x8,[x20,#0xA0]
	cmp         x8,x24
	bhs         |$LN2@SetFailure|
	add         x22,x20,#0x98
	add         x19,x20,#0x98
	b           |$LN257@SetFailure|
|$LN3@SetFailure|

; 3381 :         {
; 3382 :             m_spStrings.reset();

	add         x22,x20,#0x98
	mov         x19,x22

; 2293 :             if (m_pCopy != nullptr)

	cbz         x0,|$LN245@SetFailure|
|$LN257@SetFailure|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN60@SetFailure|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x23,[x22]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x23
	mov         w1,#0
	blr         x8
|$LN60@SetFailure|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	str         xzr,[x22]

; 2300 :                 m_size = 0;

	str         xzr,[x19,#8]
|$LN245@SetFailure|

; 3383 :             m_spStrings.create(cbNeed);

	mov         x1,x24
	add         x0,x20,#0x98
	bl          |?create@shared_buffer@details@wil@@QEAA_N_K@Z|
|$LN2@SetFailure|

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	ldp         x9,x10,[x20,#0x98]

; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));

	add         x8,x9,#4
	cmp         x9,#0
	cselne      x19,x8,xzr

; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;

	add         x8,x10,x19
	cmp         x19,#0
	cselne      x23,x8,xzr

; 3389 : 
; 3390 :         if (pBuffer)

	cbz         x19,|$LN4@SetFailure|

; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);

	ldr         x2,[x21,#0x18]

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23

; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);

	add         x22,x20,#0x18

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	ccmpne      x2,#0,#4
	beq         |$LN65@SetFailure|
	ldrh        w8,[x2]
	cbz         w8,|$LN65@SetFailure|

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov         x8,x2
	ldrsh       w9,[x8]
	cbz         w9,|$LN341@SetFailure|
|$LL340@SetFailure|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL340@SetFailure|
|$LN341@SetFailure|
	sub         x8,x8,x2
	asr         x8,x8,#1
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24,lsl #1
	bhs         |$LN66@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN76@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN76@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x28]
	add         x22,x20,#0x28
	b           |$LN255@SetFailure|
|$LN66@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	lsl         x3,x24,#1
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN79@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN79@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x19,x24,lsl #1
	b           |$LN63@SetFailure|
|$LN65@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN63@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN63@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);

	ldr         x2,[x21,#0x28]
	add         x22,x20,#0x28

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN83@SetFailure|
|$LN255@SetFailure|
	cbz         x2,|$LN83@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN83@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN343@SetFailure|
|$LL342@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL342@SetFailure|
|$LN343@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN84@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN94@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN94@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x30]
	add         x22,x20,#0x30
	b           |$LN254@SetFailure|
|$LN84@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN97@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN97@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN81@SetFailure|
|$LN83@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN81@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN81@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);

	ldr         x2,[x21,#0x30]
	add         x22,x20,#0x30

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN101@SetFailure|
|$LN254@SetFailure|
	cbz         x2,|$LN101@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN101@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN345@SetFailure|
|$LL344@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL344@SetFailure|
|$LN345@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN102@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN112@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN112@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x38]
	add         x22,x20,#0x38
	b           |$LN253@SetFailure|
|$LN102@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN115@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN115@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN99@SetFailure|
|$LN101@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN99@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN99@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);

	ldr         x2,[x21,#0x38]
	add         x22,x20,#0x38

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN119@SetFailure|
|$LN253@SetFailure|
	cbz         x2,|$LN119@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN119@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN347@SetFailure|
|$LL346@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL346@SetFailure|
|$LN347@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN120@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN130@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN130@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x48]
	add         x22,x20,#0x48
	b           |$LN252@SetFailure|
|$LN120@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN133@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN133@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN117@SetFailure|
|$LN119@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN117@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN117@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);

	ldr         x2,[x21,#0x48]
	add         x22,x20,#0x48

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN137@SetFailure|
|$LN252@SetFailure|
	cbz         x2,|$LN137@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN137@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN349@SetFailure|
|$LL348@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL348@SetFailure|
|$LN349@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN138@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN148@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN148@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x80]
	add         x22,x20,#0x80
	b           |$LN251@SetFailure|
|$LN138@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN151@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN151@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN135@SetFailure|
|$LN137@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN135@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN135@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);

	ldr         x2,[x21,#0x80]
	add         x22,x20,#0x80

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN155@SetFailure|
|$LN251@SetFailure|
	cbz         x2,|$LN155@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN155@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN351@SetFailure|
|$LL350@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL350@SetFailure|
|$LN351@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN156@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN166@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN166@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x70]
	add         x22,x20,#0x70
	b           |$LN250@SetFailure|
|$LN156@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN169@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN169@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN153@SetFailure|
|$LN155@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN153@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN153@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3398 :             pBuffer = details::WriteResultString(

	ldr         x2,[x21,#0x70]
	add         x22,x20,#0x70

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN173@SetFailure|
|$LN250@SetFailure|
	cbz         x2,|$LN173@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN173@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN353@SetFailure|
|$LL352@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL352@SetFailure|
|$LN353@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN174@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN184@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN184@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x78]
	add         x22,x20,#0x78
	b           |$LN249@SetFailure|
|$LN174@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN187@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN187@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN171@SetFailure|
|$LN173@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN171@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN171@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3400 :             pBuffer = details::WriteResultString(

	ldr         x2,[x21,#0x78]
	add         x22,x20,#0x78

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN191@SetFailure|
|$LN249@SetFailure|
	cbz         x2,|$LN191@SetFailure|
	ldrh        w8,[x2]
	cbz         w8,|$LN191@SetFailure|

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov         x8,x2
	ldrsh       w9,[x8]
	cbz         w9,|$LN355@SetFailure|
|$LL354@SetFailure|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL354@SetFailure|
|$LN355@SetFailure|
	sub         x8,x8,x2
	asr         x8,x8,#1
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24,lsl #1
	bhs         |$LN192@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN202@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN202@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x58]
	add         x22,x20,#0x58
	b           |$LN248@SetFailure|
|$LN192@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	lsl         x3,x24,#1
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN205@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN205@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x19,x24,lsl #1
	b           |$LN189@SetFailure|
|$LN191@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN189@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN189@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3402 :             pBuffer = details::WriteResultString(

	ldr         x2,[x21,#0x58]
	add         x22,x20,#0x58

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN209@SetFailure|
|$LN248@SetFailure|
	cbz         x2,|$LN209@SetFailure|
	ldrsb       w8,[x2]
	cbz         w8,|$LN209@SetFailure|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN357@SetFailure|
|$LL356@SetFailure|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL356@SetFailure|
|$LN357@SetFailure|
	sub         x8,x8,x2
	add         x24,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x24
	bhs         |$LN210@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN220@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN220@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3052 :             return pStart;

	ldr         x2,[x21,#0x60]
	add         x20,x20,#0x60
	b           |$LN247@SetFailure|
|$LN210@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x3,x24
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x22,|$LN223@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x22]
|$LN223@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x24,x19
	b           |$LN207@SetFailure|
|$LN209@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 656  :     if (outParam != nullptr)

	cbz         x22,|$LN207@SetFailure|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x22]
|$LN207@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3404 :             pBuffer = details::WriteResultString(

	ldr         x2,[x21,#0x60]
	add         x20,x20,#0x60

; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x23
	beq         |$LN227@SetFailure|
|$LN247@SetFailure|
	cbz         x2,|$LN227@SetFailure|
	ldrh        w8,[x2]
	cbz         w8,|$LN227@SetFailure|

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov         x8,x2
	ldrsh       w9,[x8]
	cbz         w9,|$LN359@SetFailure|
|$LL358@SetFailure|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL358@SetFailure|
|$LN359@SetFailure|
	sub         x8,x8,x2
	asr         x8,x8,#1
	add         x21,x8,#1

; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x23,x19

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x21,lsl #1
	blo         |$LN227@SetFailure|

; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	lsl         x3,x21,#1
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x20,|$LN241@SetFailure|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x20]
|$LN241@SetFailure|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	add         x19,x19,x21,lsl #1
	b           |$LN225@SetFailure|
|$LN227@SetFailure|

; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);

	cbz         x20,|$LN225@SetFailure|
	str         xzr,[x20]
|$LN225@SetFailure|
	sub         x2,x23,x19
	mov         w1,#0
	mov         x0,x19
	bl          memset
|$LN4@SetFailure|
	ldp         fp,lr,[sp],#0x10
	ldp         x23,x24,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x30
	ret

	ENDP  ; |?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z|, wil::StoredFailureInfo::SetFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z| PROC ; wil::ResultException::ResultException

; 3430 :     {

|$LN22|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 54   :         : _Data()

	movi        v16.16b,#0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3430 :     {

	adrp        x8,|??_7ResultException@wil@@6B@|
	add         x8,x8,|??_7ResultException@wil@@6B@|
	mov         x19,x0

; 3360 :         SetFailureInfo(other);

	add         x0,x19,#0x18
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 54   :         : _Data()

	stur        q16,[x19,#8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3430 :     {

	str         x8,[x19]

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x19,#0xB0]

; 3360 :         SetFailureInfo(other);

	bl          |?SetFailureInfo@StoredFailureInfo@wil@@QEAAXAEBUFailureInfo@2@@Z|

; 3431 :     }

	mov         x0,x19

; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x19,#0xC0]
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z|, wil::ResultException::ResultException

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ| PROC ; wil::ResultException::GetFailureInfo

; 3457 :         return m_failure.GetFailureInfo();

	add         x0,x0,#0x18
	ret

	ENDP  ; |?GetFailureInfo@ResultException@wil@@QEBAAEBUFailureInfo@2@XZ|, wil::ResultException::GetFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?what@ResultException@wil@@UEBAPEBDXZ| PROC		; wil::ResultException::what

; 3468 :     {

|$LN29|
	stp         fp,lr,[sp,#-0x20]!
	stp         x19,x20,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	mov         x15,#0x100
	bl          __chkstk
	sub         sp,sp,x15,lsl #4

; 2348 :             return (m_pCopy != nullptr);

	ldr         x8,[x0,#0xC0]

; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)

	cbnz        x8,|$LN2@what|
	mov         x20,x0

; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());

	add         x2,x20,#0x18
	mov         x1,#0x800
	mov         x0,sp
	bl          |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|

; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);

	adrp        x8,__imp_WideCharToMultiByte
	ldr         x8,[x8,__imp_WideCharToMultiByte]
	mov         x7,#0
	mov         x6,#0
	mov         w5,#0
	mov         x4,#0
	mov         w3,#-1
	mov         x2,sp
	mov         w1,#0
	mov         w0,#0
	blr         x8
	mov         w19,w0

; 3476 :             if (!m_what.create(len))

	sxtw        x1,w19
	add         x0,x20,#0xC0
	bl          |?create@shared_buffer@details@wil@@QEAA_N_K@Z|
	tbnz        w0,#0,|$LN3@what|

; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";

	adrp        x8,|??_C@_0O@KIMGFJMA@WIL?5Exception@|
	add         x0,x8,|??_C@_0O@KIMGFJMA@WIL?5Exception@|
	b           |$LN1@what|
|$LN3@what|

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	ldr         x9,[x20,#0xC0]

; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);

	mov         x7,#0
	mov         x6,#0
	mov         w5,w19
	mov         w3,#-1
	add         x8,x9,#4
	cmp         x9,#0
	cselne      x4,x8,xzr
	adrp        x8,__imp_WideCharToMultiByte
	ldr         x8,[x8,__imp_WideCharToMultiByte]
	mov         x2,sp
	mov         w1,#0
	mov         w0,#0
	blr         x8
	mov         x0,x20
|$LN2@what|

; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);

	ldr         x9,[x0,#0xC0]

; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());

	add         x8,x9,#4
	cmp         x9,#0
	cselne      x0,x8,xzr
|$LN1@what|
	mov         x15,#0x100
	add         sp,sp,x15,lsl #4
	bl          __security_pop_cookie
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?what@ResultException@wil@@UEBAPEBDXZ|, wil::ResultException::what

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??_GResultException@wil@@UEAAPEAXI@Z| PROC		; wil::ResultException::`scalar deleting destructor'
|$LN38|
	stp         x19,x20,[sp,#-0x20]!
	str         x21,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x20,x0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x20,#0xC0]
	mov         w19,w1
	cbz         x0,|$LN14@scalar|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN15@scalar|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x21,[x20,#0xC0]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x21
	mov         w1,#0
	blr         x8
|$LN15@scalar|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x20,#0xC0]
|$LN14@scalar|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x20,#0xB0]
	cbz         x0,|$LN27@scalar|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN28@scalar|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x21,[x20,#0xB0]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x21
	mov         w1,#0
	blr         x8
|$LN28@scalar|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x20,#0xB0]
|$LN27@scalar|
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 90   :     {

	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|

; 91   :         __std_exception_destroy(&_Data);

	add         x0,x20,#8
	str         x8,[x20]
	bl          __std_exception_destroy
	tbz         w19,#0,|$LN2@scalar|
	mov         x1,#0xD0
	mov         x0,x20
	bl          |??3@YAXPEAX_K@Z|
|$LN2@scalar|
	mov         x0,x20
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |??_GResultException@wil@@UEAAPEAXI@Z|, wil::ResultException::`scalar deleting destructor'

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

	AREA	|.text$mn|, CODE, ARM64

|??1ResultException@wil@@UEAA@XZ| PROC			; wil::ResultException::~ResultException
|$LN32|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x19,#0xC0]
	cbz         x0,|$LN8@ResultExce|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN9@ResultExce|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x20,[x19,#0xC0]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x20
	mov         w1,#0
	blr         x8
|$LN9@ResultExce|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x19,#0xC0]
|$LN8@ResultExce|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x0,[x19,#0xB0]
	cbz         x0,|$LN21@ResultExce|

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN22@ResultExce|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x20,[x19,#0xB0]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x20
	mov         w1,#0
	blr         x8
|$LN22@ResultExce|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x19,#0xB0]
|$LN21@ResultExce|
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 91   :         __std_exception_destroy(&_Data);

	add         x0,x19,#8
	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	str         x8,[x19]
	bl          __std_exception_destroy
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |??1ResultException@wil@@UEAA@XZ|, wil::ResultException::~ResultException

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??1StoredFailureInfo@wil@@QEAA@XZ| PROC		; wil::StoredFailureInfo::~StoredFailureInfo
|$LN19|

; 2293 :             if (m_pCopy != nullptr)

	ldr         x8,[x0,#0x98]
	cbz         x8,|$LN8@StoredFail|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	mov         x0,x8

; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))

	bl          _InterlockedDecrement_rel
	cbnz        w0,|$LN9@StoredFail|

; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);

	adrp        x8,__imp_GetProcessHeap
	ldr         x8,[x8,__imp_GetProcessHeap]
	ldr         x20,[x19,#0x98]
	blr         x8
	adrp        x8,__imp_HeapFree
	ldr         x8,[x8,__imp_HeapFree]
	mov         x2,x20
	mov         w1,#0
	blr         x8
|$LN9@StoredFail|

; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;

	stp         xzr,xzr,[x19,#0x98]
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
|$LN8@StoredFail|
	ret

	ENDP  ; |??1StoredFailureInfo@wil@@QEAA@XZ|, wil::StoredFailureInfo::~StoredFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z| PROC ; wil::details::MaybeGetExceptionString

; 3595 :     {

	mov         x3,x0
	mov         x0,x1
	mov         x1,x2

; 3596 :         if (debugString)

	cbz         x0,|$LN8@MaybeGetEx|

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	add         x2,x3,#0x18
	b           |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|
|$LN8@MaybeGetEx|
	ret

	ENDP  ; |?MaybeGetExceptionString@details@wil@@YAXAEBVResultException@2@PEA_W_K@Z|, wil::details::MaybeGetExceptionString

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z| PROC ; wil::details::MaybeGetExceptionString

; 3606 :     {

|$LN10|

; 3607 :         if (debugString)

	cbz         x1,|$LN2@MaybeGetEx|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x20,x1
	mov         x19,x2

; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());

	ldr         x8,[x0]
	ldr         x8,[x8,#8]
	blr         x8
	mov         x3,x0
	adrp        x8,|??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@|
	add         x2,x8,|??_C@_1CI@KEGLKJIE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAe?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@|
	mov         x1,x19
	mov         x0,x20
	bl          |?StringCchPrintfW@@YAJPEA_W_KPEB_WZZ|
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
|$LN2@MaybeGetEx|
	ret

	ENDP  ; |?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|, wil::details::MaybeGetExceptionString

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z| PROC ; wil::details::RecognizeCaughtExceptionFromCallback

; 3663 :     {

|$LN22|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x40]!
	mov         fp,sp
	mov         xip0,#-2
	str         xip0,[fp,#0x28]

; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();

	adrp        x8,|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA|
	ldr         x8,[x8,|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA|]
	mov         x19,x0
	stp         x1,x19,[fp,#0x18]
	blr         x8
	str         w0,[fp,#0x10]

; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)

	tbz         w0,#0x1F,|$LN3@RecognizeC|
	cbnz        x19,|$LN3@RecognizeC|
	b           |$LN6@RecognizeC|
|$LN13@RecognizeC|
	ldr         w0,[fp,#0x10]
|$LN6@RecognizeC|
	ldp         fp,lr,[sp],#0x40
	ldr         x19,[sp],#0x10
	ret
|$LN3@RecognizeC|

; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;

	mov         w1,#0
	mov         w0,#0
	bl          _CxxThrowException
	brk         #0xF000
|$LN20@RecognizeC|
|$LN16@RecognizeC|

	ENDP  ; |?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|, wil::details::RecognizeCaughtExceptionFromCallback

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$0@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| PROC ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$0

; 3676 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z$0|

; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);

	ldp         x2,x1,[fp,#0x18]
	ldr         x0,[fp,#0x30]
	bl          |?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|

; 3678 :                 if (SUCCEEDED(hr))

	ldr         w9,[fp,#0x10]
	ldr         w8,|$LN21@catch$0|
	cmp         w9,#0
	cselge      w8,w8,w9
	str         w8,[fp,#0x10]

; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }

	adrp        x0,|$LN13@catch$0|
	add         x0,x0,|$LN13@catch$0|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3
|$LN21@catch$0|
	DCD         0x8007023e

	ENDP  ; |?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|, wil::details::RecognizeCaughtExceptionFromCallback

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$1@?0??RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z@4HA| PROC ; `wil::details::RecognizeCaughtExceptionFromCallback'::`1'::catch$1

; 3684 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z$1|

; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }

	adrp        x0,|$LN13@catch$1|
	add         x0,x0,|$LN13@catch$1|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|, wil::details::RecognizeCaughtExceptionFromCallback

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?Rethrow@details@wil@@YAXXZ| PROC			; wil::details::Rethrow

; 3926 :         throw;

	mov         w1,#0
	mov         w0,#0
	b           _CxxThrowException

	ENDP  ; |?Rethrow@details@wil@@YAXXZ|, wil::details::Rethrow

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z| PROC ; wil::details::ThrowResultExceptionInternal

; 3930 :     {

|$LN7|
	stp         fp,lr,[sp,#-0xE0]!
	mov         fp,sp
	mov         x1,x0

; 3931 :         throw ResultException(failure);

	add         x0,sp,#0x10
	bl          |??0ResultException@wil@@QEAA@AEBUFailureInfo@1@@Z|
	adrp        x8,|_TI2?AVResultException@wil@@|
	add         x1,x8,|_TI2?AVResultException@wil@@|
	add         x0,sp,#0x10
	bl          _CxxThrowException
	brk         #0xF000
|$LN6@ThrowResul|
|$LN5@ThrowResul|

	ENDP  ; |?ThrowResultExceptionInternal@details@wil@@YAXAEBUFailureInfo@2@@Z|, wil::details::ThrowResultExceptionInternal

; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0ResultException@wil@@QEAA@AEBV01@@Z| PROC		; wil::ResultException::ResultException
|$LN40|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h

; 73   :     {

	adrp        x8,|??_7exception@std@@6B@|
	add         x8,x8,|??_7exception@std@@6B@|
	movi        v16.16b,#0
	mov         x20,x0
	mov         x19,x1
	str         x8,[x20]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	add         x1,x20,#8
	add         x0,x19,#8
	stur        q16,[x20,#8]
	bl          __std_exception_copy
	adrp        x8,|??_7ResultException@wil@@6B@|
	add         x8,x8,|??_7ResultException@wil@@6B@|
	add         x9,x19,#0x18
	str         x8,[x20]
	add         x10,x20,#0x18
	ldp         q17,q16,[x9]
	stp         q17,q16,[x10]
	ldp         q17,q16,[x9,#0x20]
	stp         q17,q16,[x10,#0x20]
	ldp         q17,q16,[x9,#0x40]
	stp         q17,q16,[x10,#0x40]
	ldp         q17,q16,[x9,#0x60]
	stp         q17,q16,[x10,#0x60]
	ldr         q16,[x9,#0x80]
	str         q16,[x10,#0x80]
	ldr         x8,[x9,#0x90]
	stp         x8,xzr,[x10,#0x90]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	str         xzr,[x10,#0xA0]

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	ldp         x0,x8,[x9,#0x98]

; 2363 :             if (pCopy != nullptr)

	cbz         x0,|$LN16@ResultExce|

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	stp         x0,x8,[x10,#0x98]

; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	bl          _InterlockedIncrement_nf
|$LN16@ResultExce|

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	stp         xzr,xzr,[x20,#0xC0]

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	ldp         x0,x8,[x19,#0xC0]

; 2363 :             if (pCopy != nullptr)

	cbz         x0,|$LN28@ResultExce|

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	stp         x0,x8,[x20,#0xC0]

; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	bl          _InterlockedIncrement_nf
|$LN28@ResultExce|
	mov         x0,x20
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |??0ResultException@wil@@QEAA@AEBV01@@Z|, wil::ResultException::ResultException

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z| PROC		; wil::StoredFailureInfo::StoredFailureInfo
|$LN23|
	sub         sp,sp,#0x10
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	ldp         q17,q16,[x1]
	stp         q17,q16,[x0]
	ldp         q17,q16,[x1,#0x20]
	stp         q17,q16,[x0,#0x20]
	ldp         q17,q16,[x1,#0x40]
	stp         q17,q16,[x0,#0x40]
	ldp         q17,q16,[x1,#0x60]
	stp         q17,q16,[x0,#0x60]
	ldr         q16,[x1,#0x80]
	str         q16,[x0,#0x80]
	ldr         x8,[x1,#0x90]
	stp         x8,xzr,[x0,#0x90]

; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)

	str         xzr,[x0,#0xA0]

; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);

	ldp         x9,x8,[x1,#0x98]

; 2363 :             if (pCopy != nullptr)

	cbz         x9,|$LN8@StoredFail|
	str         x19,[sp,#0x10]
	mov         x19,x0

; 2364 :             {
; 2365 :                 m_pCopy = pCopy;

	stp         x9,x8,[x19,#0x98]

; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);

	mov         x0,x9
	bl          _InterlockedIncrement_nf
	mov         x0,x19
	ldr         x19,[sp,#0x10]
|$LN8@StoredFail|
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x10
	ret

	ENDP  ; |??0StoredFailureInfo@wil@@QEAA@AEBV01@@Z|, wil::StoredFailureInfo::StoredFailureInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z| PROC ; wil::details::ResultFromCaughtExceptionInternal

; 3938 :     {

|$LN84|
	stp         x19,x20,[sp,#-0x20]!
	str         x21,[sp,#0x10]
	stp         fp,lr,[sp,#-0x60]!
	mov         fp,sp
	mov         xip0,#-2
	mov         x21,x0
	str         xip0,[fp,#0x40]
	mov         x20,x1
	mov         x19,x2
	stp         x20,x21,[fp,#0x20]
	str         x19,[fp,#0x10]

; 3939 :         if (debugString)

	cbz         x21,|$LN2@ResultFrom|

; 3940 :         {
; 3941 :             *debugString = L'\0';

	strh        wzr,[x21]
|$LN2@ResultFrom|

; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)

	adrp        x8,g_pfnResultFromCaughtException_CppWinRt
	ldr         x8,[x8,g_pfnResultFromCaughtException_CppWinRt]
	strb        wzr,[x19]
	cbz         x8,|$LN4@ResultFrom|

; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);

	mov         x2,x19
	mov         x1,x20
	mov         x0,x21
	blr         x8

; 3948 :             if (FAILED(hr))

	tbnz        w0,#0x1F,|$LN69@ResultFrom|
|$LN4@ResultFrom|

; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)

	adrp        x8,g_pfnResultFromCaughtException_WinRt
	ldr         x8,[x8,g_pfnResultFromCaughtException_WinRt]
	cbz         x8,|$LN5@ResultFrom|

; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);

	mov         x2,x19
	mov         x1,x20
	mov         x0,x21
	blr         x8
|$LN69@ResultFrom|

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	str         w0,[fp,#0x10]
	b           |$LN67@ResultFrom|
|$LN5@ResultFrom|

; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)

	adrp        x8,|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA|
	ldr         x8,[x8,|?g_pfnResultFromCaughtException@wil@@3P6AJX_EEA|]
	cbnz        x8,|$LN78@ResultFrom|
	b           |$LN6@ResultFrom|
|$LN23@ResultFrom|

; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {
; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));
; 4007 :             }
; 4008 :             catch (...)
; 4009 :             {
; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }
; 4012 :         }
; 4013 : 
; 4014 :         // Tell the caller that we were unable to map the exception by succeeding...
; 4015 :         return ResultStatus::FromResult(S_OK);

	ldr         w1,[fp,#0x18]
	ldr         x0,[fp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN37@ResultFrom|
	str         wzr,[fp,#0x10]

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	mov         w0,#0
|$LN67@ResultFrom|
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|

; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {
; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));
; 4007 :             }
; 4008 :             catch (...)
; 4009 :             {
; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }
; 4012 :         }
; 4013 : 
; 4014 :         // Tell the caller that we were unable to map the exception by succeeding...
; 4015 :         return ResultStatus::FromResult(S_OK);

	mov         w1,#0
	str         w0,[fp,#0x14]
	ldr         x0,[fp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN6@ResultFrom|

; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;

	mov         w1,#0
	mov         w0,#0
	bl          _CxxThrowException
	nop
|$LN79@ResultFrom|
|$LN78@ResultFrom|

; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;

	mov         w1,#0
	mov         w0,#0
	bl          _CxxThrowException
	brk         #0xF000
|$LN80@ResultFrom|
|$LN66@ResultFrom|

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$0@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$0

; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {

	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$0|

; 3968 :                 *isNormalized = true;

	ldr         x8,[fp,#0x10]
	mov         w9,#1

; 3596 :         if (debugString)

	ldp         x0,x19,[fp,#0x28]

; 3968 :                 *isNormalized = true;

	strb        w9,[x8]

; 3596 :         if (debugString)

	cbz         x0,|$LN43@catch$0|

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	ldr         x1,[fp,#0x20]
	add         x2,x19,#0x18
	bl          |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|
|$LN43@catch$0|

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	ldp         w8,w9,[x19,#0x1C]
	ldr         w10,[x19,#0x24]
	ubfx        w8,w8,#3,#1
	str         w8,[fp,#0x18]
	stp         w9,w10,[fp,#0x10]

; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());

	adrp        x0,|$LN23@catch$0|
	add         x0,x0,|$LN23@catch$0|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$1@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$1

; 1939 :         }
; 1940 :         static ResultStatus FromStatus(const NTSTATUS _status)
; 1941 :         {
; 1942 :             return {wil::details::NtStatusToHr(_status), _status, Kind::NtStatus};
; 1943 :         }
; 1944 :         static ResultStatus FromFailureInfo(const FailureInfo& _failure)
; 1945 :         {
; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};
; 1947 :         }
; 1948 :         HRESULT hr = S_OK;
; 1949 :         NTSTATUS status = STATUS_SUCCESS;
; 1950 :         Kind kind = Kind::NtStatus;
; 1951 :     };
; 1952 : 
; 1953 :     // Fallback telemetry provider callback (set with wil::SetResultTelemetryFallback)
; 1954 :     __declspec(selectany) void(__stdcall* g_pfnTelemetryCallback)(bool alreadyReported, wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1955 : 
; 1956 :     // Result.h plug-in (WIL use only)
; 1957 :     __declspec(selectany) void(__stdcall* g_pfnNotifyFailure)(_Inout_ FailureInfo* pFailure) WI_PFN_NOEXCEPT = nullptr;
; 1958 :     __declspec(selectany) void(__stdcall* g_pfnGetContextAndNotifyFailure)(
; 1959 :         _Inout_ FailureInfo* pFailure,
; 1960 :         _Out_writes_(callContextStringLength) _Post_z_ PSTR callContextString,
; 1961 :         _Pre_satisfies_(callContextStringLength > 0) size_t callContextStringLength) WI_PFN_NOEXCEPT = nullptr;
; 1962 : 
; 1963 :     // Observe all errors flowing through the system with this callback (set with wil::SetResultLoggingCallback); use with custom logging
; 1964 :     __declspec(selectany) void(__stdcall* g_pfnLoggingCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1965 : 
; 1966 :     // Desktop/System Only:  Module fetch function (automatically setup)
; 1967 :     __declspec(selectany) PCSTR(__stdcall* g_pfnGetModuleName)() WI_PFN_NOEXCEPT = nullptr;
; 1968 : 
; 1969 :     // Desktop/System Only:  Retrieve address offset and modulename
; 1970 :     __declspec(selectany) bool(__stdcall* g_pfnGetModuleInformation)(
; 1971 :         void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_PFN_NOEXCEPT = nullptr;
; 1972 : 
; 1973 :     // Called with the expectation that the program will terminate when called inside of a loader callout.
; 1974 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1975 :     __declspec(selectany) void(__stdcall* g_pfnFailFastInLoaderCallout)() WI_PFN_NOEXCEPT = nullptr;
; 1976 : 
; 1977 :     // Called to translate an NTSTATUS value to a Win32 error code
; 1978 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1979 :     __declspec(selectany) ULONG(__stdcall* g_pfnRtlNtStatusToDosErrorNoTeb)(NTSTATUS) WI_PFN_NOEXCEPT = nullptr;
; 1980 : 
; 1981 :     // Desktop/System Only: Call to DebugBreak
; 1982 :     __declspec(selectany) void(__stdcall* g_pfnDebugBreak)() WI_PFN_NOEXCEPT = nullptr;
; 1983 : 
; 1984 :     // Called to determine whether or not termination is happening
; 1985 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1986 :     __declspec(selectany) BOOLEAN(__stdcall* g_pfnDllShutdownInProgress)() WI_PFN_NOEXCEPT = nullptr;
; 1987 :     __declspec(selectany) bool g_processShutdownInProgress = false;
; 1988 : 
; 1989 :     // On Desktop/System WINAPI family: dynalink RaiseFailFastException because we may encounter modules
; 1990 :     // that do not have RaiseFailFastException in kernelbase.  UWP apps will directly link.
; 1991 :     __declspec(selectany) void(__stdcall* g_pfnRaiseFailFastException)(PEXCEPTION_RECORD, PCONTEXT, DWORD) = nullptr;
; 1992 : 
; 1993 :     // Exception-based compiled additions
; 1994 :     __declspec(selectany) HRESULT(__stdcall* g_pfnRunFunctorWithExceptionFilter)(IFunctor& functor, IFunctorHost& host, void* returnAddress) = nullptr;
; 1995 :     __declspec(selectany) void(__stdcall* g_pfnRethrow)() = nullptr;
; 1996 :     __declspec(selectany) void(__stdcall* g_pfnThrowResultException)(const FailureInfo& failure) = nullptr;
; 1997 :     extern "C" __declspec(selectany) ResultStatus(__stdcall* g_pfnResultFromCaughtExceptionInternal)(
; 1998 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 1999 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2000 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2001 : 
; 2002 :     // C++/WinRT additions
; 2003 :     extern "C" __declspec(selectany) HRESULT(__stdcall* g_pfnResultFromCaughtException_CppWinRt)(
; 2004 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 2005 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2006 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2007 : 
; 2008 :     // C++/cx compiled additions
; 2009 :     extern "C" __declspec(selectany) void(__stdcall* g_pfnThrowPlatformException)(FailureInfo const& failure, PCWSTR debugString) = nullptr;
; 2010 :     extern "C" __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromCaughtException_WinRt)(
; 2011 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 2012 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2013 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2014 :     __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromKnownExceptions_WinRt)(
; 2015 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor) = nullptr;
; 2016 : 
; 2017 :     // Plugin to call RoOriginateError (WIL use only)
; 2018 :     __declspec(selectany) void(__stdcall* g_pfnOriginateCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2019 : 
; 2020 :     // Plugin to call RoFailFastWithErrorContext (WIL use only)
; 2021 :     __declspec(selectany) void(__stdcall* g_pfnFailfastWithContextCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2022 : 
; 2023 :     // Allocate and disown the allocation so that Appverifier does not complain about a false leak
; 2024 :     inline PVOID ProcessHeapAlloc(_In_ DWORD flags, _In_ size_t size) WI_NOEXCEPT
; 2025 :     {
; 2026 :         const HANDLE processHeap = ::GetProcessHeap();
; 2027 :         const PVOID allocation = ::HeapAlloc(processHeap, flags, size);
; 2028 : 
; 2029 :         static bool fetchedRtlDisownModuleHeapAllocation = false;
; 2030 :         static NTSTATUS(__stdcall * pfnRtlDisownModuleHeapAllocation)(HANDLE, PVOID) WI_PFN_NOEXCEPT = nullptr;
; 2031 : 
; 2032 :         if (pfnRtlDisownModuleHeapAllocation)
; 2033 :         {
; 2034 :             (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2035 :         }
; 2036 :         else if (!fetchedRtlDisownModuleHeapAllocation)
; 2037 :         {
; 2038 :             if (auto ntdllModule = ::GetModuleHandleW(L"ntdll.dll"))
; 2039 :             {
; 2040 :                 pfnRtlDisownModuleHeapAllocation =
; 2041 :                     details::GetProcAddress<decltype(pfnRtlDisownModuleHeapAllocation)>(ntdllModule, "RtlDisownModuleHeapAllocation");
; 2042 :             }
; 2043 :             fetchedRtlDisownModuleHeapAllocation = true;
; 2044 : 
; 2045 :             if (pfnRtlDisownModuleHeapAllocation)
; 2046 :             {
; 2047 :                 (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2048 :             }
; 2049 :         }
; 2050 : 
; 2051 :         return allocation;
; 2052 :     }
; 2053 : 
; 2054 :     enum class ReportFailureOptions
; 2055 :     {
; 2056 :         None = 0x00,
; 2057 :         ForcePlatformException = 0x01,
; 2058 :         MayRethrow = 0x02,
; 2059 :     };
; 2060 :     DEFINE_ENUM_FLAG_OPERATORS(ReportFailureOptions);
; 2061 : 
; 2062 :     template <typename TFunctor>
; 2063 :     using functor_return_type = decltype((*static_cast<TFunctor*>(nullptr))());
; 2064 : 
; 2065 :     template <typename TFunctor>
; 2066 :     struct functor_wrapper_void : public IFunctor
; 2067 :     {
; 2068 :         TFunctor&& functor;
; 2069 :         functor_wrapper_void(TFunctor&& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2070 :         {
; 2071 :         }
; 2072 : #pragma warning(push)
; 2073 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2074 :         HRESULT Run() override
; 2075 :         {
; 2076 :             functor();
; 2077 :             return S_OK;
; 2078 :         }
; 2079 : #pragma warning(pop)
; 2080 :     };
; 2081 : 
; 2082 :     template <typename TFunctor>
; 2083 :     struct functor_wrapper_HRESULT : public IFunctor
; 2084 :     {
; 2085 :         TFunctor&& functor;
; 2086 :         functor_wrapper_HRESULT(TFunctor& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2087 :         {
; 2088 :         }
; 2089 :         HRESULT Run() override
; 2090 :         {
; 2091 :             return functor();
; 2092 :         }
; 2093 :     };
; 2094 : 
; 2095 :     template <typename TFunctor, typename TReturn>
; 2096 :     struct functor_wrapper_other : public IFunctor
; 2097 :     {
; 2098 :         TFunctor&& functor;
; 2099 :         TReturn& retVal;
; 2100 :         functor_wrapper_other(TFunctor& functor_, TReturn& retval_) : functor(wistd::forward<TFunctor>(functor_)), retVal(retval_)
; 2101 :         {
; 2102 :         }
; 2103 : #pragma warning(push)
; 2104 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2105 :         HRESULT Run() override
; 2106 :         {
; 2107 :             retVal = functor();
; 2108 :             return S_OK;
; 2109 :         }
; 2110 : #pragma warning(pop)
; 2111 :     };
; 2112 : 
; 2113 :     struct tag_return_void : public wistd::integral_constant<size_t, 0>
; 2114 :     {
; 2115 :         template <typename TFunctor>
; 2116 :         using functor_wrapper = functor_wrapper_void<TFunctor>;
; 2117 :     };
; 2118 : 
; 2119 :     struct tag_return_HRESULT : public wistd::integral_constant<size_t, 1>
; 2120 :     {
; 2121 :         template <typename TFunctor>
; 2122 :         using functor_wrapper = functor_wrapper_HRESULT<TFunctor>;
; 2123 :     };
; 2124 : 
; 2125 :     struct tag_return_other : public wistd::integral_constant<size_t, 2>
; 2126 :     {
; 2127 :         template <typename TFunctor, typename TReturn>
; 2128 :         using functor_wrapper = functor_wrapper_other<TFunctor, TReturn>;
; 2129 :     };
; 2130 : 
; 2131 :     // type-trait to help discover the return type of a functor for tag/dispatch.
; 2132 : 
; 2133 :     template <ErrorReturn errorReturn, typename T>
; 2134 :     struct return_type
; 2135 :     {
; 2136 :         using type = tag_return_other;
; 2137 :     };
; 2138 : 
; 2139 :     template <>
; 2140 :     struct return_type<ErrorReturn::Auto, HRESULT>
; 2141 :     {
; 2142 :         using type = tag_return_HRESULT;
; 2143 :     };
; 2144 : 
; 2145 :     template <>
; 2146 :     struct return_type<ErrorReturn::Auto, void>
; 2147 :     {
; 2148 :         using type = tag_return_void;
; 2149 :     };
; 2150 : 
; 2151 :     template <>
; 2152 :     struct return_type<ErrorReturn::None, void>
; 2153 :     {
; 2154 :         using type = tag_return_void;
; 2155 :     };
; 2156 : 
; 2157 :     template <ErrorReturn errorReturn, typename Functor>
; 2158 :     using functor_tag = typename return_type<errorReturn, functor_return_type<Functor>>::type;
; 2159 : 
; 2160 :     // Forward declarations to enable use of fail fast and reporting internally...
; 2161 :     namespace __R_NS_NAME
; 2162 :     {
; 2163 :         _Post_satisfies_(return == hr) __R_DIRECT_METHOD(HRESULT, Log_Hr)(__R_DIRECT_FN_PARAMS HRESULT hr) WI_NOEXCEPT;
; 2164 :         _Post_satisfies_(return == hr)
; 2165 :             __R_DIRECT_METHOD(HRESULT, Log_HrMsg)(__R_DIRECT_FN_PARAMS HRESULT hr, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2166 :         _Post_satisfies_(return == err)
; 2167 :             __R_DIRECT_METHOD(DWORD, Log_Win32Msg)(__R_DIRECT_FN_PARAMS DWORD err, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2168 :     } // namespace __R_NS_NAME
; 2169 :     namespace __RFF_NS_NAME
; 2170 :     {
; 2171 :         __RFF_DIRECT_NORET_METHOD(void, FailFast_Unexpected)(__RFF_DIRECT_FN_PARAMS_ONLY) WI_NOEXCEPT;
; 2172 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2173 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_If)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2174 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2175 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_HrIf)(__RFF_CONDITIONAL_FN_PARAMS HRESULT hr, bool condition) WI_NOEXCEPT;
; 2176 :         _Post_satisfies_(return == condition) _When_(!condition, _Analysis_noreturn_)
; 2177 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_IfFalse)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2178 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2179 :         __RFF_CONDITIONAL_METHOD(bool, FailFastImmediate_If)(bool condition) WI_NOEXCEPT;
; 2180 :     } // namespace __RFF_NS_NAME
; 2181 : 
; 2182 :     RESULT_NORETURN inline void __stdcall WilFailFast(const FailureInfo& info);
; 2183 :     inline void LogFailure(
; 2184 :         __R_FN_PARAMS_FULL,
; 2185 :         FailureType type,
; 2186 :         const ResultStatus& resultPair,
; 2187 :         _In_opt_ PCWSTR message,
; 2188 :         bool fWantDebugString,
; 2189 :         _Out_writes_(debugStringSizeChars) _Post_z_ PWSTR debugString,
; 2190 :         _Pre_satisfies_(debugStringSizeChars > 0) size_t debugStringSizeChars,
; 2191 :         _Out_writes_(callContextStringSizeChars) _Post_z_ PSTR callContextString,
; 2192 :         _Pre_satisfies_(callContextStringSizeChars > 0) size_t callContextStringSizeChars,
; 2193 :         FailureFlags flags,
; 2194 :         _Out_ FailureInfo* failure) WI_NOEXCEPT;
; 2195 : 
; 2196 :     __declspec(noinline) inline void ReportFailure(
; 2197 :         __R_FN_PARAMS_FULL,
; 2198 :         FailureType type,
; 2199 :         const ResultStatus& resultPair,
; 2200 :         _In_opt_ PCWSTR message = nullptr,
; 2201 :         ReportFailureOptions options = ReportFailureOptions::None);
; 2202 :     template <FailureType, bool = false>
; 2203 :     __declspec(noinline) inline void ReportFailure_Base(
; 2204 :         __R_FN_PARAMS_FULL,
; 2205 :         const ResultStatus& resultPair,
; 2206 :         _In_opt_ PCWSTR message = nullptr,
; 2207 :         ReportFailureOptions options = ReportFailureOptions::None,
; 2208 :         FailureFlags flags = FailureFlags::None);
; 2209 :     template <FailureType>
; 2210 :     inline void ReportFailure_ReplaceMsg(__R_FN_PARAMS_FULL, HRESULT hr, _Printf_format_string_ PCSTR formatString, ...);
; 2211 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, FailureType type, HRESULT hr);
; 2212 :     template <FailureType>
; 2213 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, HRESULT hr, FailureFlags flags = FailureFlags::None);
; 2214 :     template <FailureType>
; 2215 :     __declspec(noinline) inline HRESULT ReportFailure_CaughtException(
; 2216 :         __R_FN_PARAMS_FULL, SupportedExceptions supported = SupportedExceptions::Default);
; 2217 : 
; 2218 : //*****************************************************************************
; 2219 : // Fail fast helpers (for use only internally to WIL)
; 2220 : //*****************************************************************************
; 2221 : 
; 2222 : /// @cond
; 2223 : #define __FAIL_FAST_ASSERT__(condition) \
; 2224 :     do \
; 2225 :     { \
; 2226 :         if (!(condition)) \
; 2227 :         { \
; 2228 :             __RFF_FN(FailFast_Unexpected)(__RFF_INFO_ONLY(#condition)); \
; 2229 :         } \
; 2230 :     } while ((void)0, 0)
; 2231 : #define __FAIL_FAST_IMMEDIATE_ASSERT__(condition) \
; 2232 :     do \
; 2233 :     { \
; 2234 :         if (!(condition)) \
; 2235 :         { \
; 2236 :             wil::FailureInfo failure{}; \
; 2237 :             wil::details::WilFailFast(failure); \
; 2238 :         } \
; 2239 :     } while ((void)0, 0)
; 2240 : #define __FAIL_FAST_ASSERT_WIN32_BOOL_FALSE__(condition) \
; 2241 :     __RFF_FN(FailFast_IfWin32BoolFalse)(__RFF_INFO(#condition) wil::verify_BOOL(condition))
; 2242 : 
; 2243 :     // A simple ref-counted buffer class.  The interface is very similar to shared_ptr<>, only it manages
; 2244 :     // an allocated buffer and maintains the size.
; 2245 : 
; 2246 :     class shared_buffer
; 2247 :     {
; 2248 :     public:
; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2250 :         {
; 2251 :         }
; 2252 : 
; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);
; 2256 :         }
; 2257 : 
; 2258 :         shared_buffer(shared_buffer&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy), m_size(other.m_size)
; 2259 :         {
; 2260 :             other.m_pCopy = nullptr;
; 2261 :             other.m_size = 0;
; 2262 :         }
; 2263 : 
; 2264 :         ~shared_buffer() WI_NOEXCEPT
; 2265 :         {
; 2266 :             reset();
; 2267 :         }
; 2268 : 
; 2269 :         shared_buffer& operator=(shared_buffer const& other) WI_NOEXCEPT
; 2270 :         {
; 2271 :             if (this != wistd::addressof(other))
; 2272 :             {
; 2273 :                 assign(other.m_pCopy, other.m_size);
; 2274 :             }
; 2275 :             return *this;
; 2276 :         }
; 2277 : 
; 2278 :         shared_buffer& operator=(shared_buffer&& other) WI_NOEXCEPT
; 2279 :         {
; 2280 :             if (this != wistd::addressof(other))
; 2281 :             {
; 2282 :                 reset();
; 2283 :                 m_pCopy = other.m_pCopy;
; 2284 :                 m_size = other.m_size;
; 2285 :                 other.m_pCopy = nullptr;
; 2286 :                 other.m_size = 0;
; 2287 :             }
; 2288 :             return *this;
; 2289 :         }
; 2290 : 
; 2291 :         void reset() WI_NOEXCEPT
; 2292 :         {
; 2293 :             if (m_pCopy != nullptr)
; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))
; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);
; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;
; 2300 :                 m_size = 0;
; 2301 :             }
; 2302 :         }
; 2303 : 
; 2304 :         bool create(_In_reads_bytes_opt_(cbData) void const* pData, size_t cbData) WI_NOEXCEPT
; 2305 :         {
; 2306 :             if (cbData == 0)
; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));
; 2313 :             if (pCopyRefCount == nullptr)
; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;
; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }
; 2326 : 
; 2327 :         bool create(size_t cbData) WI_NOEXCEPT
; 2328 :         {
; 2329 :             return create(nullptr, cbData);
; 2330 :         }
; 2331 : 
; 2332 :         WI_NODISCARD void* get(_Out_opt_ size_t* pSize = nullptr) const WI_NOEXCEPT
; 2333 :         {
; 2334 :             if (pSize != nullptr)
; 2335 :             {
; 2336 :                 *pSize = m_size;
; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);
; 2339 :         }
; 2340 : 
; 2341 :         WI_NODISCARD size_t size() const WI_NOEXCEPT
; 2342 :         {
; 2343 :             return m_size;
; 2344 :         }
; 2345 : 
; 2346 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2347 :         {
; 2348 :             return (m_pCopy != nullptr);
; 2349 :         }
; 2350 : 
; 2351 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2352 :         {
; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));
; 2354 :         }
; 2355 : 
; 2356 :     private:
; 2357 :         long* m_pCopy; // pointer to allocation: refcount + data
; 2358 :         size_t m_size; // size of the data from m_pCopy
; 2359 : 
; 2360 :         void assign(_In_opt_ long* pCopy, size_t cbSize) WI_NOEXCEPT
; 2361 :         {
; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)
; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);
; 2368 :             }
; 2369 :         }
; 2370 :     };
; 2371 : 
; 2372 :     inline shared_buffer make_shared_buffer_nothrow(_In_reads_bytes_opt_(countBytes) void* pData, size_t countBytes) WI_NOEXCEPT
; 2373 :     {
; 2374 :         shared_buffer buffer;
; 2375 :         buffer.create(pData, countBytes);
; 2376 :         return buffer;
; 2377 :     }
; 2378 : 
; 2379 :     inline shared_buffer make_shared_buffer_nothrow(size_t countBytes) WI_NOEXCEPT
; 2380 :     {
; 2381 :         shared_buffer buffer;
; 2382 :         buffer.create(countBytes);
; 2383 :         return buffer;
; 2384 :     }
; 2385 : 
; 2386 :     // A small mimic of the STL shared_ptr class, but unlike shared_ptr, a pointer is not attached to the class, but is
; 2387 :     // always simply contained within (it cannot be attached or detached).
; 2388 : 
; 2389 :     template <typename object_t>
; 2390 :     class shared_object
; 2391 :     {
; 2392 :     public:
; 2393 :         shared_object() WI_NOEXCEPT : m_pCopy(nullptr)
; 2394 :         {
; 2395 :         }
; 2396 : 
; 2397 :         shared_object(shared_object const& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2398 :         {
; 2399 :             if (m_pCopy != nullptr)
; 2400 :             {
; 2401 :                 ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2402 :             }
; 2403 :         }
; 2404 : 
; 2405 :         shared_object(shared_object&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2406 :         {
; 2407 :             other.m_pCopy = nullptr;
; 2408 :         }
; 2409 : 
; 2410 :         ~shared_object() WI_NOEXCEPT
; 2411 :         {
; 2412 :             reset();
; 2413 :         }
; 2414 : 
; 2415 :         shared_object& operator=(shared_object const& other) WI_NOEXCEPT
; 2416 :         {
; 2417 :             if (this != wistd::addressof(other))
; 2418 :             {
; 2419 :                 reset();
; 2420 :                 m_pCopy = other.m_pCopy;
; 2421 :                 if (m_pCopy != nullptr)
; 2422 :                 {
; 2423 :                     ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2424 :                 }
; 2425 :             }
; 2426 :             return *this;
; 2427 :         }
; 2428 : 
; 2429 :         shared_object& operator=(shared_object&& other) WI_NOEXCEPT
; 2430 :         {
; 2431 :             if (this != wistd::addressof(other))
; 2432 :             {
; 2433 :                 reset();
; 2434 :                 m_pCopy = other.m_pCopy;
; 2435 :                 other.m_pCopy = nullptr;
; 2436 :             }
; 2437 :             return *this;
; 2438 :         }
; 2439 : 
; 2440 :         void reset() WI_NOEXCEPT
; 2441 :         {
; 2442 :             if (m_pCopy != nullptr)
; 2443 :             {
; 2444 :                 if (0 == ::InterlockedDecrementRelease(&m_pCopy->m_refCount))
; 2445 :                 {
; 2446 :                     delete m_pCopy;
; 2447 :                 }
; 2448 :                 m_pCopy = nullptr;
; 2449 :             }
; 2450 :         }
; 2451 : 
; 2452 :         bool create()
; 2453 :         {
; 2454 :             RefAndObject* pObject = new (std::nothrow) RefAndObject();
; 2455 :             if (pObject == nullptr)
; 2456 :             {
; 2457 :                 return false;
; 2458 :             }
; 2459 :             reset();
; 2460 :             m_pCopy = pObject;
; 2461 :             return true;
; 2462 :         }
; 2463 : 
; 2464 :         template <typename param_t>
; 2465 :         bool create(param_t&& param1)
; 2466 :         {
; 2467 :             RefAndObject* pObject = new (std::nothrow) RefAndObject(wistd::forward<param_t>(param1));
; 2468 :             if (pObject == nullptr)
; 2469 :             {
; 2470 :                 return false;
; 2471 :             }
; 2472 :             reset();
; 2473 :             m_pCopy = pObject;
; 2474 :             return true;
; 2475 :         }
; 2476 : 
; 2477 :         WI_NODISCARD object_t* get() const WI_NOEXCEPT
; 2478 :         {
; 2479 :             return (m_pCopy == nullptr) ? nullptr : &m_pCopy->m_object;
; 2480 :         }
; 2481 : 
; 2482 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2483 :         {
; 2484 :             return (m_pCopy != nullptr);
; 2485 :         }
; 2486 : 
; 2487 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2488 :         {
; 2489 :             return ((m_pCopy != nullptr) && (m_pCopy->m_refCount == 1));
; 2490 :         }
; 2491 : 
; 2492 :         WI_NODISCARD object_t* operator->() const WI_NOEXCEPT
; 2493 :         {
; 2494 :             return get();
; 2495 :         }
; 2496 : 
; 2497 :     private:
; 2498 :         struct RefAndObject
; 2499 :         {
; 2500 :             long m_refCount;
; 2501 :             object_t m_object;
; 2502 : 
; 2503 :             RefAndObject() : m_refCount(1), m_object()
; 2504 :             {
; 2505 :             }
; 2506 : 
; 2507 :             template <typename param_t>
; 2508 :             RefAndObject(param_t&& param1) : m_refCount(1), m_object(wistd::forward<param_t>(param1))
; 2509 :             {
; 2510 :             }
; 2511 :         };
; 2512 : 
; 2513 :         RefAndObject* m_pCopy;
; 2514 :     };
; 2515 : 
; 2516 :     // The following functions are basically the same, but are kept separated to:
; 2517 :     // 1) Provide a unique count and last error code per-type
; 2518 :     // 2) Avoid merging the types to allow easy debugging (breakpoints, conditional breakpoints based
; 2519 :     //      upon count of errors from a particular type, etc)
; 2520 :     __WI_PUSH_WARNINGS
; 2521 : #if __clang_major__ >= 13
; 2522 :     __WI_CLANG_DISABLE_WARNING(-Wunused-but-set-variable) // s_hrErrorLast used for debugging. We intentionally only assign to it
; 2523 : #endif
; 2524 :     __WI_MSVC_DISABLE_WARNING(4746) // s_hrErrorLast' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2525 : 
; 2526 :     __declspec(noinline) inline int RecordException(HRESULT hr) WI_NOEXCEPT
; 2527 :     {
; 2528 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2529 :         static long volatile s_cErrorCount = 0;
; 2530 :         s_hrErrorLast = hr;
; 2531 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2532 :     }
; 2533 : 
; 2534 :     __declspec(noinline) inline int RecordReturn(HRESULT hr) WI_NOEXCEPT
; 2535 :     {
; 2536 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2537 :         static long volatile s_cErrorCount = 0;
; 2538 :         s_hrErrorLast = hr;
; 2539 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2540 :     }
; 2541 : 
; 2542 :     __declspec(noinline) inline int RecordLog(HRESULT hr) WI_NOEXCEPT
; 2543 :     {
; 2544 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2545 :         static long volatile s_cErrorCount = 0;
; 2546 :         s_hrErrorLast = hr;
; 2547 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2548 :     }
; 2549 : 
; 2550 :     __declspec(noinline) inline int RecordFailFast(HRESULT hr) WI_NOEXCEPT
; 2551 :     {
; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;
; 2554 :         return 1;
; 2555 :     }
; 2556 :     __WI_POP_WARNINGS
; 2557 : 
; 2558 :     inline RESULT_NORETURN void __stdcall WilRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_opt_ PCONTEXT cr, _In_ DWORD flags)
; 2559 :     {
; 2560 :         // if we managed to load the pointer either through WilDynamicRaiseFailFastException (PARTITION_DESKTOP etc.)
; 2561 :         // or via direct linkage (e.g. UWP apps), then use it.
; 2562 :         if (g_pfnRaiseFailFastException)
; 2563 :         {
; 2564 :             g_pfnRaiseFailFastException(er, cr, flags);
; 2565 :         }
; 2566 :         // if not, as a best effort, we are just going to call the intrinsic.
; 2567 :         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
; 2568 :     }
; 2569 : 
; 2570 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2571 :     inline bool __stdcall GetModuleInformation(
; 2572 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_NOEXCEPT
; 2573 :     {
; 2574 :         HMODULE hModule = nullptr;
; 2575 :         if (address && !GetModuleHandleExW(
; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))
; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);
; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))
; 2599 :             {
; 2600 :                 start--;
; 2601 :             }
; 2602 :             StringCchCopyA(name, size, start);
; 2603 :         }
; 2604 :         return true;
; 2605 :     }
; 2606 : 
; 2607 :     __WI_PUSH_WARNINGS
; 2608 :     __WI_MSVC_DISABLE_WARNING(4746) // s_fModuleValid' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2609 :     inline PCSTR __stdcall GetCurrentModuleName() WI_NOEXCEPT
; 2610 :     {
; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable
; 2614 :         {
; 2615 :             GetModuleInformation(reinterpret_cast<void*>(&RecordFailFast), nullptr, s_szModule, ARRAYSIZE(s_szModule));
; 2616 :             s_fModuleValid = true;
; 2617 :         }
; 2618 :         return s_szModule;
; 2619 :     }
; 2620 :     __WI_POP_WARNINGS
; 2621 : 
; 2622 :     inline void __stdcall DebugBreak() WI_NOEXCEPT
; 2623 :     {
; 2624 :         ::DebugBreak();
; 2625 :     }
; 2626 : 
; 2627 :     inline void __stdcall WilDynamicLoadRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_ PCONTEXT cr, _In_ DWORD flags)
; 2628 :     {
; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");
; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)
; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);
; 2636 :         }
; 2637 :     }
; 2638 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2639 : 
; 2640 :     inline bool __stdcall GetModuleInformationFromAddress(
; 2641 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* buffer, size_t size) WI_NOEXCEPT
; 2642 :     {
; 2643 :         if (size > 0)
; 2644 :         {
; 2645 :             assign_to_opt_param(buffer, '\0');
; 2646 :         }
; 2647 :         if (addressOffset)
; 2648 :         {
; 2649 :             *addressOffset = 0;
; 2650 :         }
; 2651 :         if (g_pfnGetModuleInformation)
; 2652 :         {
; 2653 :             return g_pfnGetModuleInformation(address, addressOffset, buffer, size);
; 2654 :         }
; 2655 :         return false;
; 2656 :     }
; 2657 : 
; 2658 :     __declspec(noinline) inline HRESULT NtStatusToHr(NTSTATUS status) WI_NOEXCEPT
; 2659 :     {
; 2660 :         // The following conversions are the only known incorrect mappings in RtlNtStatusToDosErrorNoTeb
; 2661 :         if (SUCCEEDED_NTSTATUS(status))
; 2662 :         {
; 2663 :             // All successful status codes have only one hresult equivalent, S_OK
; 2664 :             return S_OK;
; 2665 :         }
; 2666 :         if (status == static_cast<NTSTATUS>(STATUS_NO_MEMORY))
; 2667 :         {
; 2668 :             // RtlNtStatusToDosErrorNoTeb maps STATUS_NO_MEMORY to the less popular of two Win32 no memory error codes resulting in an unexpected mapping
; 2669 :             return E_OUTOFMEMORY;
; 2670 :         }
; 2671 : 
; 2672 :         if (g_pfnRtlNtStatusToDosErrorNoTeb != nullptr)
; 2673 :         {
; 2674 :             DWORD err = g_pfnRtlNtStatusToDosErrorNoTeb(status);
; 2675 : 
; 2676 :             // ERROR_MR_MID_NOT_FOUND indicates a bug in the originator of the error (failure to add a mapping to the Win32 error codes).
; 2677 :             // There are known instances of this bug which are unlikely to be fixed soon, and it's always possible that additional instances
; 2678 :             // could be added in the future. In these cases, it's better to use HRESULT_FROM_NT rather than returning a meaningless error.
; 2679 :             if ((err != 0) && (err != ERROR_MR_MID_NOT_FOUND))
; 2680 :             {
; 2681 :                 return __HRESULT_FROM_WIN32(err);
; 2682 :             }
; 2683 :         }
; 2684 : 
; 2685 :         return HRESULT_FROM_NT(status);
; 2686 :     }
; 2687 : 
; 2688 :     __declspec(noinline) inline NTSTATUS HrToNtStatus(HRESULT hr) WI_NOEXCEPT
; 2689 :     {
; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)
; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;
; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;
; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;
; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;
; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;
; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;
; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;
; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;
; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;
; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;
; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;
; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;
; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;
; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;
; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;
; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;
; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;
; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;
; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;
; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;
; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)
; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);
; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));
; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)
; 2787 :             {
; 2788 :                 status =
; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }
; 2800 : 
; 2801 :     // The following set of functions all differ only based upon number of arguments.  They are unified in their handling
; 2802 :     // of data from each of the various error-handling types (fast fail, exceptions, etc.).
; 2803 :     _Post_equals_last_error_ inline DWORD GetLastErrorFail(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2804 :     {
; 2805 :         __R_FN_UNREFERENCED;
; 2806 :         auto err = ::GetLastError();
; 2807 :         if (SUCCEEDED_WIN32(err))
; 2808 :         {
; 2809 :             // This function should only be called when GetLastError() is set to a FAILURE.
; 2810 :             // If you hit this assert (or are reviewing this failure telemetry), then there are one of three issues:
; 2811 :             //  1) Your code is using a macro (such as RETURN_IF_WIN32_BOOL_FALSE()) on a function that does not actually
; 2812 :             //      set the last error (consult MSDN).
; 2813 :             //  2) Your macro check against the error is not immediately after the API call.  Pushing it later can result
; 2814 :             //      in another API call between the previous one and the check resetting the last error.
; 2815 :             //  3) The API you're calling has a bug in it and does not accurately set the last error (there are a few
; 2816 :             //      examples here, such as SendMessageTimeout() that don't accurately set the last error).
; 2817 :             //      [MSFT internal] For these, please send mail to 'wildisc' when found and work-around with win32errorhelpers.
; 2818 : 
; 2819 :             WI_USAGE_ERROR_FORWARD("CALLER BUG: Macro usage error detected.  GetLastError() does not have an error.");
; 2820 :             return ERROR_ASSERTION_FAILURE;
; 2821 :         }
; 2822 :         return err;
; 2823 :     }
; 2824 : 
; 2825 :     inline __declspec(noinline) DWORD GetLastErrorFail() WI_NOEXCEPT
; 2826 :     {
; 2827 :         __R_FN_LOCALS_FULL_RA;
; 2828 :         return GetLastErrorFail(__R_FN_CALL_FULL);
; 2829 :     }
; 2830 : 
; 2831 :     _Translates_last_error_to_HRESULT_
; 2832 :     inline HRESULT GetLastErrorFailHr(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2833 :     {
; 2834 :         return HRESULT_FROM_WIN32(GetLastErrorFail(__R_FN_CALL_FULL));
; 2835 :     }
; 2836 : 
; 2837 :     _Translates_last_error_to_HRESULT_
; 2838 :     inline __declspec(noinline) HRESULT GetLastErrorFailHr() WI_NOEXCEPT
; 2839 :     {
; 2840 :         __R_FN_LOCALS_FULL_RA;
; 2841 :         return GetLastErrorFailHr(__R_FN_CALL_FULL);
; 2842 :     }
; 2843 : 
; 2844 :     inline void PrintLoggingMessage(
; 2845 :         _Out_writes_(cchDest) _Post_z_ PWSTR pszDest,
; 2846 :         _Pre_satisfies_(cchDest > 0) size_t cchDest,
; 2847 :         _In_opt_ _Printf_format_string_ PCSTR formatString,
; 2848 :         _In_opt_ va_list argList) WI_NOEXCEPT
; 2849 :     {
; 2850 :         if (formatString == nullptr)
; 2851 :         {
; 2852 :             pszDest[0] = L'\0';
; 2853 :         }
; 2854 :         else if (argList == nullptr)
; 2855 :         {
; 2856 :             StringCchPrintfW(pszDest, cchDest, L"%hs", formatString);
; 2857 :         }
; 2858 :         else
; 2859 :         {
; 2860 :             wchar_t szFormatWide[2048];
; 2861 :             StringCchPrintfW(szFormatWide, ARRAYSIZE(szFormatWide), L"%hs", formatString);
; 2862 :             StringCchVPrintfW(pszDest, cchDest, szFormatWide, argList);
; 2863 :         }
; 2864 :     }
; 2865 : 
; 2866 : #pragma warning(push)
; 2867 : #pragma warning(disable : __WARNING_RETURNING_BAD_RESULT)
; 2868 :     // NOTE: The following two functions are unfortunate copies of strsafe.h functions that have been copied to reduce the friction associated with using
; 2869 :     // Result.h and ResultException.h in a build that does not have WINAPI_PARTITION_DESKTOP defined (where these are conditionally enabled).
; 2870 : 
; 2871 :     inline HRESULT WilStringLengthWorkerA(
; 2872 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2873 :         _In_ _In_range_(<=, STRSAFE_MAX_CCH) size_t cchMax,
; 2874 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2875 :     {
; 2876 :         HRESULT hr = S_OK;
; 2877 :         size_t cchOriginalMax = cchMax;
; 2878 :         while (cchMax && (*psz != '\0'))
; 2879 :         {
; 2880 :             psz++;
; 2881 :             cchMax--;
; 2882 :         }
; 2883 :         if (cchMax == 0)
; 2884 :         {
; 2885 :             // the string is longer than cchMax
; 2886 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2887 :         }
; 2888 :         if (pcchLength)
; 2889 :         {
; 2890 :             if (SUCCEEDED(hr))
; 2891 :             {
; 2892 :                 *pcchLength = cchOriginalMax - cchMax;
; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 *pcchLength = 0;
; 2897 :             }
; 2898 :         }
; 2899 :         return hr;
; 2900 :     }
; 2901 : 
; 2902 :     _Must_inspect_result_
; 2903 :     inline HRESULT StringCchLengthA(
; 2904 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2905 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
; 2906 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2907 :     {
; 2908 :         HRESULT hr = S_OK;
; 2909 :         if ((psz == nullptr) || (cchMax > STRSAFE_MAX_CCH))
; 2910 :         {
; 2911 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2912 :         }
; 2913 :         else
; 2914 :         {
; 2915 :             hr = WilStringLengthWorkerA(psz, cchMax, pcchLength);
; 2916 :         }
; 2917 :         if (FAILED(hr) && pcchLength)
; 2918 :         {
; 2919 :             *pcchLength = 0;
; 2920 :         }
; 2921 :         return hr;
; 2922 :     }
; 2923 : #pragma warning(pop)
; 2924 : 
; 2925 :     _Post_satisfies_(cchDest > 0 && cchDest <= cchMax) inline HRESULT
; 2926 :         WilStringValidateDestA(_In_reads_opt_(cchDest) PCNZCH /*pszDest*/, _In_ size_t cchDest, _In_ const size_t cchMax)
; 2927 :     {
; 2928 :         HRESULT hr = S_OK;
; 2929 :         if ((cchDest == 0) || (cchDest > cchMax))
; 2930 :         {
; 2931 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2932 :         }
; 2933 :         return hr;
; 2934 :     }
; 2935 : 
; 2936 :     inline HRESULT WilStringVPrintfWorkerA(
; 2937 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2938 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchDest,
; 2939 :         _Always_(_Out_opt_ _Deref_out_range_(<=, cchDest - 1)) size_t* pcchNewDestLength,
; 2940 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2941 :         _In_ va_list argList)
; 2942 :     {
; 2943 :         HRESULT hr = S_OK;
; 2944 :         int iRet{};
; 2945 : 
; 2946 :         // leave the last space for the null terminator
; 2947 :         size_t cchMax = cchDest - 1;
; 2948 :         size_t cchNewDestLength = 0;
; 2949 : #undef STRSAFE_USE_SECURE_CRT
; 2950 : #define STRSAFE_USE_SECURE_CRT 1
; 2951 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 2952 :         iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 2953 : #else
; 2954 : #pragma warning(push)
; 2955 : #pragma warning(disable : __WARNING_BANNED_API_USAGE) // "STRSAFE not included"
; 2956 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
; 2957 : #pragma warning(pop)
; 2958 : #endif
; 2959 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 2960 : 
; 2961 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))
; 2962 :         {
; 2963 :             // need to null terminate the string
; 2964 :             pszDest += cchMax;
; 2965 :             *pszDest = '\0';
; 2966 : 
; 2967 :             cchNewDestLength = cchMax;
; 2968 : 
; 2969 :             // we have truncated pszDest
; 2970 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 2971 :         }
; 2972 :         else if (((size_t)iRet) == cchMax)
; 2973 :         {
; 2974 :             // need to null terminate the string
; 2975 :             pszDest += cchMax;
; 2976 :             *pszDest = '\0';
; 2977 : 
; 2978 :             cchNewDestLength = cchMax;
; 2979 :         }
; 2980 :         else
; 2981 :         {
; 2982 :             cchNewDestLength = (size_t)iRet;
; 2983 :         }
; 2984 : 
; 2985 :         if (pcchNewDestLength)
; 2986 :         {
; 2987 :             *pcchNewDestLength = cchNewDestLength;
; 2988 :         }
; 2989 : 
; 2990 :         return hr;
; 2991 :     }
; 2992 : 
; 2993 :     inline HRESULT StringCchPrintfA(
; 2994 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2995 :         _In_ size_t cchDest,
; 2996 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2997 :         ...)
; 2998 :     {
; 2999 :         HRESULT hr;
; 3000 :         hr = wil::details::WilStringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 3001 :         if (SUCCEEDED(hr))
; 3002 :         {
; 3003 :             va_list argList;
; 3004 :             va_start(argList, pszFormat);
; 3005 :             hr = wil::details::WilStringVPrintfWorkerA(pszDest, cchDest, nullptr, pszFormat, argList);
; 3006 :             va_end(argList);
; 3007 :         }
; 3008 :         else if (cchDest > 0)
; 3009 :         {
; 3010 :             *pszDest = '\0';
; 3011 :         }
; 3012 :         return hr;
; 3013 :     }
; 3014 : 
; 3015 :     _Ret_range_(sizeof(char), (psz == nullptr) ? sizeof(char) : (_String_length_(psz) + sizeof(char)))
; 3016 :     inline size_t ResultStringSize(_In_opt_ PCSTR psz)
; 3017 :     {
; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));
; 3019 :     }
; 3020 : 
; 3021 :     _Ret_range_(sizeof(wchar_t), (psz == nullptr) ? sizeof(wchar_t) : ((_String_length_(psz) + 1) * sizeof(wchar_t)))
; 3022 :     inline size_t ResultStringSize(_In_opt_ PCWSTR psz)
; 3023 :     {
; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);
; 3025 :     }
; 3026 : 
; 3027 :     template <typename TString>
; 3028 :     _Ret_range_(pStart, pEnd)
; 3029 :     inline unsigned char* WriteResultString(
; 3030 :         _Pre_satisfies_(pStart <= pEnd) _When_((pStart == pEnd) || (pszString == nullptr) || (pszString[0] == 0), _In_opt_) _When_(
; 3031 :             (pStart != pEnd) && (pszString != nullptr) && (pszString[0] != 0),
; 3032 :             _Out_writes_bytes_opt_(_String_length_(pszString) * sizeof(pszString[0]))) unsigned char* pStart,
; 3033 :         _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd,
; 3034 :         _In_opt_z_ TString pszString,
; 3035 :         _Outptr_result_maybenull_z_ TString* ppszBufferString)
; 3036 :     {
; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)
; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;
; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;
; 3049 :         if (bufferSize < stringSize)
; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);
; 3056 :         assign_to_opt_param(
; 3057 :             ppszBufferString,
; 3058 :             reinterpret_cast<TString>(
; 3059 :                 pStart)); // lgtm[cpp/incorrect-string-type-conversion] False positive - The query is misinterpreting a buffer (char *) with a MBS string, the cast to TString is expected.
; 3060 :         return pStart + stringSize;
; 3061 :     }
; 3062 : 
; 3063 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3064 :     inline size_t UntrustedStringLength(_In_ PCSTR psz, _In_ size_t cchMax)
; 3065 :     {
; 3066 :         size_t cbLength;
; 3067 :         return SUCCEEDED(wil::details::StringCchLengthA(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3068 :     }
; 3069 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3070 :     inline size_t UntrustedStringLength(_In_ PCWSTR psz, _In_ size_t cchMax)
; 3071 :     {
; 3072 :         size_t cbLength;
; 3073 :         return SUCCEEDED(::StringCchLengthW(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3074 :     }
; 3075 : 
; 3076 :     template <typename TString>
; 3077 :     _Ret_range_(pStart, pEnd)
; 3078 :     inline unsigned char* GetResultString(
; 3079 :         _In_reads_to_ptr_opt_(pEnd) unsigned char* pStart, _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd, _Out_ TString* ppszBufferString)
; 3080 :     {
; 3081 :         size_t cchLen = UntrustedStringLength(reinterpret_cast<TString>(pStart), (pEnd - pStart) / sizeof((*ppszBufferString)[0]));
; 3082 :         *ppszBufferString = (cchLen > 0) ? reinterpret_cast<TString>(pStart) : nullptr;
; 3083 :         auto pReturn = (wistd::min)(pEnd, pStart + ((cchLen + 1) * sizeof((*ppszBufferString)[0])));
; 3084 :         __analysis_assume((pReturn >= pStart) && (pReturn <= pEnd));
; 3085 :         return pReturn;
; 3086 :     }
; 3087 : } // namespace details
; 3088 : /// @endcond
; 3089 : 
; 3090 : //*****************************************************************************
; 3091 : // WIL result handling initializers
; 3092 : //
; 3093 : // Generally, callers do not need to manually initialize WIL. This header creates
; 3094 : // the appropriate .CRT init section pieces through global objects to ensure that
; 3095 : // WilInitialize... is called before DllMain or main().
; 3096 : //
; 3097 : // Certain binaries do not link with the CRT or do not support .CRT-section based
; 3098 : // initializers. Those binaries must link only with other static libraries that
; 3099 : // also set RESULT_SUPPRESS_STATIC_INITIALIZERS to ensure no .CRT inits are left,
; 3100 : // and they should call one of the WilInitialize_ResultMacros_??? methods during
; 3101 : // their initialization phase.  Skipping this initialization path is OK as well,
; 3102 : // but results in a slightly degraded experience with result reporting.
; 3103 : //
; 3104 : // Calling WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse provides:
; 3105 : // - The name of the current module in wil::FailureInfo::pszModule
; 3106 : // - The name of the returning-to module during wil/staging.h failures
; 3107 : //*****************************************************************************
; 3108 : 
; 3109 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3110 : //! Call this method to initialize WIL manually in a module where RESULT_SUPPRESS_STATIC_INITIALIZERS is required. WIL will
; 3111 : //! only use publicly documented APIs.
; 3112 : inline void WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse()
; 3113 : {
; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }
; 3119 : 
; 3120 : /// @cond
; 3121 : namespace details
; 3122 : {
; 3123 : #ifndef RESULT_SUPPRESS_STATIC_INITIALIZERS
; 3124 : #if !defined(BUILD_WINDOWS) || defined(WIL_SUPPRESS_PRIVATE_API_USE)
; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {
; 3126 :         ::wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse();
; 3127 :         return 1;
; 3128 :     });
; 3129 : #endif
; 3130 : #endif
; 3131 : } // namespace details
; 3132 : /// @endcond
; 3133 : #else  // !WINAPI_PARTITION_DESKTOP, !WINAPI_PARTITION_SYSTEM, explicitly assume these modules can direct link
; 3134 : namespace details
; 3135 : {
; 3136 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_AppOnly, [] {
; 3137 :         g_pfnRaiseFailFastException = ::RaiseFailFastException;
; 3138 :         return 1;
; 3139 :     });
; 3140 : } // namespace details
; 3141 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3142 : 
; 3143 : //*****************************************************************************
; 3144 : // Public Error Handling Helpers
; 3145 : //*****************************************************************************
; 3146 : 
; 3147 : //! Call this method to determine if process shutdown is in progress (allows avoiding work during dll unload).
; 3148 : inline bool ProcessShutdownInProgress()
; 3149 : {
; 3150 :     return (details::g_processShutdownInProgress || (details::g_pfnDllShutdownInProgress ? details::g_pfnDllShutdownInProgress() : false));
; 3151 : }
; 3152 : 
; 3153 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down,
; 3154 : but the hosting DLL doesn't support CRT initializers (such as kernelbase.dll).  The hosting DLL is responsible for calling
; 3155 : Construct() and Destroy() to manually run the constructor and destructor during DLL load & unload.
; 3156 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3157 : called as is typical. */
; 3158 : template <class T>
; 3159 : class manually_managed_shutdown_aware_object
; 3160 : {
; 3161 : public:
; 3162 :     manually_managed_shutdown_aware_object() = default;
; 3163 :     manually_managed_shutdown_aware_object(manually_managed_shutdown_aware_object const&) = delete;
; 3164 :     void operator=(manually_managed_shutdown_aware_object const&) = delete;
; 3165 : 
; 3166 :     void construct()
; 3167 :     {
; 3168 :         void* var = &m_raw;
; 3169 :         ::new (var) T();
; 3170 :     }
; 3171 : 
; 3172 :     void destroy()
; 3173 :     {
; 3174 :         if (ProcessShutdownInProgress())
; 3175 :         {
; 3176 :             get().ProcessShutdown();
; 3177 :         }
; 3178 :         else
; 3179 :         {
; 3180 :             (&get())->~T();
; 3181 :         }
; 3182 :     }
; 3183 : 
; 3184 :     //! Retrieves a reference to the contained object
; 3185 :     T& get() WI_NOEXCEPT
; 3186 :     {
; 3187 :         return *reinterpret_cast<T*>(&m_raw);
; 3188 :     }
; 3189 : 
; 3190 : private:
; 3191 :     alignas(T) unsigned char m_raw[sizeof(T)];
; 3192 : };
; 3193 : 
; 3194 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down.
; 3195 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3196 : called as is typical. */
; 3197 : template <class T>
; 3198 : class shutdown_aware_object
; 3199 : {
; 3200 : public:
; 3201 :     shutdown_aware_object()
; 3202 :     {
; 3203 :         m_object.construct();
; 3204 :     }
; 3205 : 
; 3206 :     ~shutdown_aware_object()
; 3207 :     {
; 3208 :         m_object.destroy();
; 3209 :     }
; 3210 : 
; 3211 :     shutdown_aware_object(shutdown_aware_object const&) = delete;
; 3212 :     void operator=(shutdown_aware_object const&) = delete;
; 3213 : 
; 3214 :     //! Retrieves a reference to the contained object
; 3215 :     T& get() WI_NOEXCEPT
; 3216 :     {
; 3217 :         return m_object.get();
; 3218 :     }
; 3219 : 
; 3220 : private:
; 3221 :     manually_managed_shutdown_aware_object<T> m_object;
; 3222 : };
; 3223 : 
; 3224 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down. */
; 3225 : template <class T>
; 3226 : class object_without_destructor_on_shutdown
; 3227 : {
; 3228 : public:
; 3229 :     object_without_destructor_on_shutdown()
; 3230 :     {
; 3231 :         void* var = &m_raw;
; 3232 :         ::new (var) T();
; 3233 :     }
; 3234 : 
; 3235 :     ~object_without_destructor_on_shutdown()
; 3236 :     {
; 3237 :         if (!ProcessShutdownInProgress())
; 3238 :         {
; 3239 :             get().~T();
; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     object_without_destructor_on_shutdown(object_without_destructor_on_shutdown const&) = delete;
; 3244 :     void operator=(object_without_destructor_on_shutdown const&) = delete;
; 3245 : 
; 3246 :     //! Retrieves a reference to the contained object
; 3247 :     T& get() WI_NOEXCEPT
; 3248 :     {
; 3249 :         return *reinterpret_cast<T*>(&m_raw);
; 3250 :     }
; 3251 : 
; 3252 : private:
; 3253 :     alignas(T) unsigned char m_raw[sizeof(T)]{};
; 3254 : };
; 3255 : 
; 3256 : /** Forward your DLLMain to this function so that WIL can have visibility into whether a DLL unload is because
; 3257 : of termination or normal unload.  Note that when g_pfnDllShutdownInProgress is set, WIL attempts to make this
; 3258 : determination on its own without this callback.  Suppressing private APIs requires use of this. */
; 3259 : inline void DLLMain(HINSTANCE, DWORD reason, _In_opt_ LPVOID reserved)
; 3260 : {
; 3261 :     if (!details::g_processShutdownInProgress)
; 3262 :     {
; 3263 :         if ((reason == DLL_PROCESS_DETACH) && (reserved != nullptr))
; 3264 :         {
; 3265 :             details::g_processShutdownInProgress = true;
; 3266 :         }
; 3267 :     }
; 3268 : }
; 3269 : 
; 3270 : // [optionally] Plug in fallback telemetry reporting
; 3271 : // Normally, the callback is owned by including ResultLogging.h in the including module.  Alternatively a module
; 3272 : // could re-route fallback telemetry to any ONE specific provider by calling this method.
; 3273 : inline void SetResultTelemetryFallback(_In_opt_ decltype(details::g_pfnTelemetryCallback) callbackFunction)
; 3274 : {
; 3275 :     // Only ONE telemetry provider can own the fallback telemetry callback.
; 3276 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3277 :         (details::g_pfnTelemetryCallback == nullptr) || (callbackFunction == nullptr) ||
; 3278 :         (details::g_pfnTelemetryCallback == callbackFunction));
; 3279 :     details::g_pfnTelemetryCallback = callbackFunction;
; 3280 : }
; 3281 : 
; 3282 : // [optionally] Plug in result logging (do not use for telemetry)
; 3283 : // This provides the ability for a module to hook all failures flowing through the system for inspection
; 3284 : // and/or logging.
; 3285 : inline void SetResultLoggingCallback(_In_opt_ decltype(details::g_pfnLoggingCallback) callbackFunction)
; 3286 : {
; 3287 :     // Only ONE function can own the result logging callback
; 3288 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3289 :         (details::g_pfnLoggingCallback == nullptr) || (callbackFunction == nullptr) ||
; 3290 :         (details::g_pfnLoggingCallback == callbackFunction));
; 3291 :     details::g_pfnLoggingCallback = callbackFunction;
; 3292 : }
; 3293 : 
; 3294 : // [optionally] Plug in custom result messages
; 3295 : // There are some purposes that require translating the full information that is known about a failure
; 3296 : // into a message to be logged (either through the console for debugging OR as the message attached
; 3297 : // to a Platform::Exception^).  This callback allows a module to format the string itself away from the
; 3298 : // default.
; 3299 : inline void SetResultMessageCallback(_In_opt_ decltype(wil::g_pfnResultLoggingCallback) callbackFunction)
; 3300 : {
; 3301 :     // Only ONE function can own the result message callback
; 3302 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3303 :         (g_pfnResultLoggingCallback == nullptr) || (callbackFunction == nullptr) || (g_pfnResultLoggingCallback == callbackFunction));
; 3304 :     details::g_resultMessageCallbackSet = true;
; 3305 :     g_pfnResultLoggingCallback = callbackFunction;
; 3306 : }
; 3307 : 
; 3308 : // [optionally] Plug in exception remapping
; 3309 : // A module can plug a callback in using this function to setup custom exception handling to allow any
; 3310 : // exception type to be converted into an HRESULT from exception barriers.
; 3311 : inline void SetResultFromCaughtExceptionCallback(_In_opt_ decltype(wil::g_pfnResultFromCaughtException) callbackFunction)
; 3312 : {
; 3313 :     // Only ONE function can own the exception conversion
; 3314 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3315 :         (g_pfnResultFromCaughtException == nullptr) || (callbackFunction == nullptr) ||
; 3316 :         (g_pfnResultFromCaughtException == callbackFunction));
; 3317 :     g_pfnResultFromCaughtException = callbackFunction;
; 3318 : }
; 3319 : 
; 3320 : // [optionally] Plug in exception remapping
; 3321 : // This provides the ability for a module to call RoOriginateError in case of a failure.
; 3322 : // Normally, the callback is owned by including result_originate.h in the including module.  Alternatively a module
; 3323 : // could re-route error origination callback to its own implementation.
; 3324 : inline void SetOriginateErrorCallback(_In_opt_ decltype(details::g_pfnOriginateCallback) callbackFunction)
; 3325 : {
; 3326 :     // Only ONE function can own the error origination callback
; 3327 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3328 :         (details::g_pfnOriginateCallback == nullptr) || (callbackFunction == nullptr) ||
; 3329 :         (details::g_pfnOriginateCallback == callbackFunction));
; 3330 :     details::g_pfnOriginateCallback = callbackFunction;
; 3331 : }
; 3332 : 
; 3333 : // [optionally] Plug in failfast callback
; 3334 : // This provides the ability for a module to call RoFailFastWithErrorContext in the failfast handler -if- there is stowed
; 3335 : // exception data available.  Normally, the callback is owned by including result_originate.h in the including module.
; 3336 : // Alternatively a module could re-route to its own implementation.
; 3337 : inline void SetFailfastWithContextCallback(_In_opt_ decltype(details::g_pfnFailfastWithContextCallback) callbackFunction)
; 3338 : {
; 3339 :     // Only ONE function can own the failfast with context callback
; 3340 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3341 :         (details::g_pfnFailfastWithContextCallback == nullptr) || (callbackFunction == nullptr) ||
; 3342 :         (details::g_pfnFailfastWithContextCallback == callbackFunction));
; 3343 :     details::g_pfnFailfastWithContextCallback = callbackFunction;
; 3344 : }
; 3345 : 
; 3346 : // A RAII wrapper around the storage of a FailureInfo struct (which is normally meant to be consumed
; 3347 : // on the stack or from the caller).  The storage of FailureInfo needs to copy some data internally
; 3348 : // for lifetime purposes.
; 3349 : 
; 3350 : class StoredFailureInfo
; 3351 : {
; 3352 : public:
; 3353 :     StoredFailureInfo() WI_NOEXCEPT
; 3354 :     {
; 3355 :         ::ZeroMemory(&m_failureInfo, sizeof(m_failureInfo));
; 3356 :     }
; 3357 : 
; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT
; 3359 :     {
; 3360 :         SetFailureInfo(other);
; 3361 :     }
; 3362 : 
; 3363 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3364 :     {
; 3365 :         return m_failureInfo;
; 3366 :     }
; 3367 : 
; 3368 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3369 :     {
; 3370 :         m_failureInfo = failure;
; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +
; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))
; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);
; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;
; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);
; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);
; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);
; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);
; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);
; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);
; 3398 :             pBuffer = details::WriteResultString(
; 3399 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextName, &m_failureInfo.callContextCurrent.contextName);
; 3400 :             pBuffer = details::WriteResultString(
; 3401 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextMessage, &m_failureInfo.callContextCurrent.contextMessage);
; 3402 :             pBuffer = details::WriteResultString(
; 3403 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextName, &m_failureInfo.callContextOriginating.contextName);
; 3404 :             pBuffer = details::WriteResultString(
; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);
; 3407 :         }
; 3408 :     }
; 3409 : 
; 3410 :     // Relies upon generated copy constructor and assignment operator
; 3411 : 
; 3412 : protected:
; 3413 :     FailureInfo m_failureInfo;
; 3414 :     details::shared_buffer m_spStrings;
; 3415 : };
; 3416 : 
; 3417 : #if defined(WIL_ENABLE_EXCEPTIONS) || defined(WIL_FORCE_INCLUDE_RESULT_EXCEPTION)
; 3418 : 
; 3419 : //! This is WIL's default exception class thrown from all THROW_XXX macros (outside of c++/cx).
; 3420 : //! This class stores all of the FailureInfo context that is available when the exception is thrown.  It's also caught by
; 3421 : //! exception guards for automatic conversion to HRESULT.
; 3422 : //!
; 3423 : //! In c++/cx, Platform::Exception^ is used instead of this class (unless @ref wil::g_fResultThrowPlatformException has been
; 3424 : //! changed).
; 3425 : class ResultException : public std::exception
; 3426 : {
; 3427 : public:
; 3428 :     //! Constructs a new ResultException from an existing FailureInfo.
; 3429 :     ResultException(const FailureInfo& failure) WI_NOEXCEPT : m_failure(failure)
; 3430 :     {
; 3431 :     }
; 3432 : 
; 3433 :     //! Constructs a new exception type from a given HRESULT (use only for constructing custom exception types).
; 3434 :     ResultException(_Pre_satisfies_(hr < 0) HRESULT hr) WI_NOEXCEPT : m_failure(CustomExceptionFailureInfo(hr))
; 3435 :     {
; 3436 :     }
; 3437 : 
; 3438 :     //! Returns the failed HRESULT that this exception represents.
; 3439 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) HRESULT GetErrorCode() const WI_NOEXCEPT
; 3440 :     {
; 3441 :         HRESULT const hr = m_failure.GetFailureInfo().hr;
; 3442 :         __analysis_assume(hr < 0);
; 3443 :         return hr;
; 3444 :     }
; 3445 : 
; 3446 :     //! Returns the failed NTSTATUS that this exception represents.
; 3447 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) NTSTATUS GetStatusCode() const WI_NOEXCEPT
; 3448 :     {
; 3449 :         NTSTATUS const status = m_failure.GetFailureInfo().status;
; 3450 :         __analysis_assume(status < 0);
; 3451 :         return status;
; 3452 :     }
; 3453 : 
; 3454 :     //! Get a reference to the stored FailureInfo.
; 3455 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3456 :     {
; 3457 :         return m_failure.GetFailureInfo();
; 3458 :     }
; 3459 : 
; 3460 :     //! Sets the stored FailureInfo (use primarily only when constructing custom exception types).
; 3461 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3462 :     {
; 3463 :         m_failure.SetFailureInfo(failure);
; 3464 :     }
; 3465 : 
; 3466 :     //! Provides a string representing the FailureInfo from this exception.
; 3467 :     WI_NODISCARD inline const char* __CLR_OR_THIS_CALL what() const WI_NOEXCEPT override
; 3468 :     {
; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)
; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);
; 3476 :             if (!m_what.create(len))
; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";
; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);
; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());
; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }
; 3498 : 
; 3499 :     // Relies upon auto-generated copy constructor and assignment operator
; 3500 : protected:
; 3501 :     StoredFailureInfo m_failure;           //!< The failure information for this exception
; 3502 :     mutable details::shared_buffer m_what; //!< The on-demand generated what() string
; 3503 : 
; 3504 :     //! Use to produce a custom FailureInfo from an HRESULT (use only when constructing custom exception types).
; 3505 :     static FailureInfo CustomExceptionFailureInfo(HRESULT hr) WI_NOEXCEPT
; 3506 :     {
; 3507 :         FailureInfo fi = {};
; 3508 :         fi.type = FailureType::Exception;
; 3509 :         fi.hr = hr;
; 3510 :         return fi;
; 3511 :     }
; 3512 : };
; 3513 : #endif
; 3514 : 
; 3515 : //*****************************************************************************
; 3516 : // Public Helpers that catch -- mostly only enabled when exceptions are enabled
; 3517 : //*****************************************************************************
; 3518 : 
; 3519 : // ResultFromCaughtException is a function that is meant to be called from within a catch(...) block.  Internally
; 3520 : // it re-throws and catches the exception to convert it to an HRESULT.  If an exception is of an unrecognized type
; 3521 : // the function will fail fast.
; 3522 : //
; 3523 : // try
; 3524 : // {
; 3525 : //     // Code
; 3526 : // }
; 3527 : // catch (...)
; 3528 : // {
; 3529 : //     hr = wil::ResultFromCaughtException();
; 3530 : // }
; 3531 : _Always_(_Post_satisfies_(return < 0)) __declspec(noinline) inline HRESULT ResultFromCaughtException() WI_NOEXCEPT
; 3532 : {
; 3533 :     bool isNormalized = false;
; 3534 :     HRESULT hr = S_OK;
; 3535 :     if (details::g_pfnResultFromCaughtExceptionInternal)
; 3536 :     {
; 3537 :         hr = details::g_pfnResultFromCaughtExceptionInternal(nullptr, 0, &isNormalized).hr;
; 3538 :     }
; 3539 :     if (FAILED(hr))
; 3540 :     {
; 3541 :         return hr;
; 3542 :     }
; 3543 : 
; 3544 :     // Caller bug: an unknown exception was thrown
; 3545 :     __WIL_PRIVATE_FAIL_FAST_HR_IF(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION), g_fResultFailFastUnknownExceptions);
; 3546 :     return __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3547 : }
; 3548 : 
; 3549 : //! Identical to 'throw;', but can be called from error-code neutral code to rethrow in code that *may* be running under an
; 3550 : //! exception context
; 3551 : inline void RethrowCaughtException()
; 3552 : {
; 3553 :     // We always want to rethrow the exception under normal circumstances.  Ordinarily, we could actually guarantee
; 3554 :     // this as we should be able to rethrow if we caught an exception, but if we got here in the middle of running
; 3555 :     // dynamic initializers, then it's possible that we haven't yet setup the rethrow function pointer, thus the
; 3556 :     // runtime check without the noreturn annotation.
; 3557 : 
; 3558 :     if (details::g_pfnRethrow)
; 3559 :     {
; 3560 :         details::g_pfnRethrow();
; 3561 :     }
; 3562 : }
; 3563 : 
; 3564 : //! Identical to 'throw ResultException(failure);', but can be referenced from error-code neutral code
; 3565 : inline void ThrowResultException(const FailureInfo& failure)
; 3566 : {
; 3567 :     if (details::g_pfnThrowResultException)
; 3568 :     {
; 3569 :         details::g_pfnThrowResultException(failure);
; 3570 :     }
; 3571 : }
; 3572 : 
; 3573 : /// @cond
; 3574 : namespace details
; 3575 : {
; 3576 : #ifdef WIL_ENABLE_EXCEPTIONS
; 3577 :     //*****************************************************************************
; 3578 :     // Private helpers to catch and propagate exceptions
; 3579 :     //*****************************************************************************
; 3580 : 
; 3581 :     RESULT_NORETURN inline void TerminateAndReportError(_In_opt_ PEXCEPTION_POINTERS)
; 3582 :     {
; 3583 :         // This is an intentional fail-fast that was caught by an exception guard with WIL.  Look back up the callstack to
; 3584 :         // determine the source of the actual exception being thrown.  The exception guard used by the calling code did not expect
; 3585 :         // this exception type to be thrown or is specifically requesting fail-fast for this class of exception.
; 3586 : 
; 3587 :         FailureInfo failure{};
; 3588 :         WilFailFast(failure);
; 3589 :     }
; 3590 : 
; 3591 :     inline void MaybeGetExceptionString(
; 3592 :         const ResultException& exception,
; 3593 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3594 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3595 :     {
; 3596 :         if (debugString)
; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());
; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$1|

; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);

	ldp         x2,x1,[fp,#0x20]
	ldr         x0,[fp,#0x48]
	bl          |?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	ldr         w0,|$LN81@catch$1|
	str         w0,[fp,#0x10]
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|
	stp         w0,wzr,[fp,#0x14]

; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);

	adrp        x0,|$LN23@catch$1|
	add         x0,x0,|$LN23@catch$1|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3
	nop
|$LN81@catch$1|
	DCD         0x8007000e

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$2@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$2

; 1939 :         }
; 1940 :         static ResultStatus FromStatus(const NTSTATUS _status)
; 1941 :         {
; 1942 :             return {wil::details::NtStatusToHr(_status), _status, Kind::NtStatus};
; 1943 :         }
; 1944 :         static ResultStatus FromFailureInfo(const FailureInfo& _failure)
; 1945 :         {
; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};
; 1947 :         }
; 1948 :         HRESULT hr = S_OK;
; 1949 :         NTSTATUS status = STATUS_SUCCESS;
; 1950 :         Kind kind = Kind::NtStatus;
; 1951 :     };
; 1952 : 
; 1953 :     // Fallback telemetry provider callback (set with wil::SetResultTelemetryFallback)
; 1954 :     __declspec(selectany) void(__stdcall* g_pfnTelemetryCallback)(bool alreadyReported, wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1955 : 
; 1956 :     // Result.h plug-in (WIL use only)
; 1957 :     __declspec(selectany) void(__stdcall* g_pfnNotifyFailure)(_Inout_ FailureInfo* pFailure) WI_PFN_NOEXCEPT = nullptr;
; 1958 :     __declspec(selectany) void(__stdcall* g_pfnGetContextAndNotifyFailure)(
; 1959 :         _Inout_ FailureInfo* pFailure,
; 1960 :         _Out_writes_(callContextStringLength) _Post_z_ PSTR callContextString,
; 1961 :         _Pre_satisfies_(callContextStringLength > 0) size_t callContextStringLength) WI_PFN_NOEXCEPT = nullptr;
; 1962 : 
; 1963 :     // Observe all errors flowing through the system with this callback (set with wil::SetResultLoggingCallback); use with custom logging
; 1964 :     __declspec(selectany) void(__stdcall* g_pfnLoggingCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1965 : 
; 1966 :     // Desktop/System Only:  Module fetch function (automatically setup)
; 1967 :     __declspec(selectany) PCSTR(__stdcall* g_pfnGetModuleName)() WI_PFN_NOEXCEPT = nullptr;
; 1968 : 
; 1969 :     // Desktop/System Only:  Retrieve address offset and modulename
; 1970 :     __declspec(selectany) bool(__stdcall* g_pfnGetModuleInformation)(
; 1971 :         void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_PFN_NOEXCEPT = nullptr;
; 1972 : 
; 1973 :     // Called with the expectation that the program will terminate when called inside of a loader callout.
; 1974 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1975 :     __declspec(selectany) void(__stdcall* g_pfnFailFastInLoaderCallout)() WI_PFN_NOEXCEPT = nullptr;
; 1976 : 
; 1977 :     // Called to translate an NTSTATUS value to a Win32 error code
; 1978 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1979 :     __declspec(selectany) ULONG(__stdcall* g_pfnRtlNtStatusToDosErrorNoTeb)(NTSTATUS) WI_PFN_NOEXCEPT = nullptr;
; 1980 : 
; 1981 :     // Desktop/System Only: Call to DebugBreak
; 1982 :     __declspec(selectany) void(__stdcall* g_pfnDebugBreak)() WI_PFN_NOEXCEPT = nullptr;
; 1983 : 
; 1984 :     // Called to determine whether or not termination is happening
; 1985 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1986 :     __declspec(selectany) BOOLEAN(__stdcall* g_pfnDllShutdownInProgress)() WI_PFN_NOEXCEPT = nullptr;
; 1987 :     __declspec(selectany) bool g_processShutdownInProgress = false;
; 1988 : 
; 1989 :     // On Desktop/System WINAPI family: dynalink RaiseFailFastException because we may encounter modules
; 1990 :     // that do not have RaiseFailFastException in kernelbase.  UWP apps will directly link.
; 1991 :     __declspec(selectany) void(__stdcall* g_pfnRaiseFailFastException)(PEXCEPTION_RECORD, PCONTEXT, DWORD) = nullptr;
; 1992 : 
; 1993 :     // Exception-based compiled additions
; 1994 :     __declspec(selectany) HRESULT(__stdcall* g_pfnRunFunctorWithExceptionFilter)(IFunctor& functor, IFunctorHost& host, void* returnAddress) = nullptr;
; 1995 :     __declspec(selectany) void(__stdcall* g_pfnRethrow)() = nullptr;
; 1996 :     __declspec(selectany) void(__stdcall* g_pfnThrowResultException)(const FailureInfo& failure) = nullptr;
; 1997 :     extern "C" __declspec(selectany) ResultStatus(__stdcall* g_pfnResultFromCaughtExceptionInternal)(
; 1998 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 1999 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2000 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2001 : 
; 2002 :     // C++/WinRT additions
; 2003 :     extern "C" __declspec(selectany) HRESULT(__stdcall* g_pfnResultFromCaughtException_CppWinRt)(
; 2004 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 2005 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2006 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2007 : 
; 2008 :     // C++/cx compiled additions
; 2009 :     extern "C" __declspec(selectany) void(__stdcall* g_pfnThrowPlatformException)(FailureInfo const& failure, PCWSTR debugString) = nullptr;
; 2010 :     extern "C" __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromCaughtException_WinRt)(
; 2011 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 2012 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2013 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2014 :     __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromKnownExceptions_WinRt)(
; 2015 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor) = nullptr;
; 2016 : 
; 2017 :     // Plugin to call RoOriginateError (WIL use only)
; 2018 :     __declspec(selectany) void(__stdcall* g_pfnOriginateCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2019 : 
; 2020 :     // Plugin to call RoFailFastWithErrorContext (WIL use only)
; 2021 :     __declspec(selectany) void(__stdcall* g_pfnFailfastWithContextCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2022 : 
; 2023 :     // Allocate and disown the allocation so that Appverifier does not complain about a false leak
; 2024 :     inline PVOID ProcessHeapAlloc(_In_ DWORD flags, _In_ size_t size) WI_NOEXCEPT
; 2025 :     {
; 2026 :         const HANDLE processHeap = ::GetProcessHeap();
; 2027 :         const PVOID allocation = ::HeapAlloc(processHeap, flags, size);
; 2028 : 
; 2029 :         static bool fetchedRtlDisownModuleHeapAllocation = false;
; 2030 :         static NTSTATUS(__stdcall * pfnRtlDisownModuleHeapAllocation)(HANDLE, PVOID) WI_PFN_NOEXCEPT = nullptr;
; 2031 : 
; 2032 :         if (pfnRtlDisownModuleHeapAllocation)
; 2033 :         {
; 2034 :             (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2035 :         }
; 2036 :         else if (!fetchedRtlDisownModuleHeapAllocation)
; 2037 :         {
; 2038 :             if (auto ntdllModule = ::GetModuleHandleW(L"ntdll.dll"))
; 2039 :             {
; 2040 :                 pfnRtlDisownModuleHeapAllocation =
; 2041 :                     details::GetProcAddress<decltype(pfnRtlDisownModuleHeapAllocation)>(ntdllModule, "RtlDisownModuleHeapAllocation");
; 2042 :             }
; 2043 :             fetchedRtlDisownModuleHeapAllocation = true;
; 2044 : 
; 2045 :             if (pfnRtlDisownModuleHeapAllocation)
; 2046 :             {
; 2047 :                 (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2048 :             }
; 2049 :         }
; 2050 : 
; 2051 :         return allocation;
; 2052 :     }
; 2053 : 
; 2054 :     enum class ReportFailureOptions
; 2055 :     {
; 2056 :         None = 0x00,
; 2057 :         ForcePlatformException = 0x01,
; 2058 :         MayRethrow = 0x02,
; 2059 :     };
; 2060 :     DEFINE_ENUM_FLAG_OPERATORS(ReportFailureOptions);
; 2061 : 
; 2062 :     template <typename TFunctor>
; 2063 :     using functor_return_type = decltype((*static_cast<TFunctor*>(nullptr))());
; 2064 : 
; 2065 :     template <typename TFunctor>
; 2066 :     struct functor_wrapper_void : public IFunctor
; 2067 :     {
; 2068 :         TFunctor&& functor;
; 2069 :         functor_wrapper_void(TFunctor&& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2070 :         {
; 2071 :         }
; 2072 : #pragma warning(push)
; 2073 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2074 :         HRESULT Run() override
; 2075 :         {
; 2076 :             functor();
; 2077 :             return S_OK;
; 2078 :         }
; 2079 : #pragma warning(pop)
; 2080 :     };
; 2081 : 
; 2082 :     template <typename TFunctor>
; 2083 :     struct functor_wrapper_HRESULT : public IFunctor
; 2084 :     {
; 2085 :         TFunctor&& functor;
; 2086 :         functor_wrapper_HRESULT(TFunctor& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2087 :         {
; 2088 :         }
; 2089 :         HRESULT Run() override
; 2090 :         {
; 2091 :             return functor();
; 2092 :         }
; 2093 :     };
; 2094 : 
; 2095 :     template <typename TFunctor, typename TReturn>
; 2096 :     struct functor_wrapper_other : public IFunctor
; 2097 :     {
; 2098 :         TFunctor&& functor;
; 2099 :         TReturn& retVal;
; 2100 :         functor_wrapper_other(TFunctor& functor_, TReturn& retval_) : functor(wistd::forward<TFunctor>(functor_)), retVal(retval_)
; 2101 :         {
; 2102 :         }
; 2103 : #pragma warning(push)
; 2104 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2105 :         HRESULT Run() override
; 2106 :         {
; 2107 :             retVal = functor();
; 2108 :             return S_OK;
; 2109 :         }
; 2110 : #pragma warning(pop)
; 2111 :     };
; 2112 : 
; 2113 :     struct tag_return_void : public wistd::integral_constant<size_t, 0>
; 2114 :     {
; 2115 :         template <typename TFunctor>
; 2116 :         using functor_wrapper = functor_wrapper_void<TFunctor>;
; 2117 :     };
; 2118 : 
; 2119 :     struct tag_return_HRESULT : public wistd::integral_constant<size_t, 1>
; 2120 :     {
; 2121 :         template <typename TFunctor>
; 2122 :         using functor_wrapper = functor_wrapper_HRESULT<TFunctor>;
; 2123 :     };
; 2124 : 
; 2125 :     struct tag_return_other : public wistd::integral_constant<size_t, 2>
; 2126 :     {
; 2127 :         template <typename TFunctor, typename TReturn>
; 2128 :         using functor_wrapper = functor_wrapper_other<TFunctor, TReturn>;
; 2129 :     };
; 2130 : 
; 2131 :     // type-trait to help discover the return type of a functor for tag/dispatch.
; 2132 : 
; 2133 :     template <ErrorReturn errorReturn, typename T>
; 2134 :     struct return_type
; 2135 :     {
; 2136 :         using type = tag_return_other;
; 2137 :     };
; 2138 : 
; 2139 :     template <>
; 2140 :     struct return_type<ErrorReturn::Auto, HRESULT>
; 2141 :     {
; 2142 :         using type = tag_return_HRESULT;
; 2143 :     };
; 2144 : 
; 2145 :     template <>
; 2146 :     struct return_type<ErrorReturn::Auto, void>
; 2147 :     {
; 2148 :         using type = tag_return_void;
; 2149 :     };
; 2150 : 
; 2151 :     template <>
; 2152 :     struct return_type<ErrorReturn::None, void>
; 2153 :     {
; 2154 :         using type = tag_return_void;
; 2155 :     };
; 2156 : 
; 2157 :     template <ErrorReturn errorReturn, typename Functor>
; 2158 :     using functor_tag = typename return_type<errorReturn, functor_return_type<Functor>>::type;
; 2159 : 
; 2160 :     // Forward declarations to enable use of fail fast and reporting internally...
; 2161 :     namespace __R_NS_NAME
; 2162 :     {
; 2163 :         _Post_satisfies_(return == hr) __R_DIRECT_METHOD(HRESULT, Log_Hr)(__R_DIRECT_FN_PARAMS HRESULT hr) WI_NOEXCEPT;
; 2164 :         _Post_satisfies_(return == hr)
; 2165 :             __R_DIRECT_METHOD(HRESULT, Log_HrMsg)(__R_DIRECT_FN_PARAMS HRESULT hr, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2166 :         _Post_satisfies_(return == err)
; 2167 :             __R_DIRECT_METHOD(DWORD, Log_Win32Msg)(__R_DIRECT_FN_PARAMS DWORD err, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2168 :     } // namespace __R_NS_NAME
; 2169 :     namespace __RFF_NS_NAME
; 2170 :     {
; 2171 :         __RFF_DIRECT_NORET_METHOD(void, FailFast_Unexpected)(__RFF_DIRECT_FN_PARAMS_ONLY) WI_NOEXCEPT;
; 2172 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2173 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_If)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2174 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2175 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_HrIf)(__RFF_CONDITIONAL_FN_PARAMS HRESULT hr, bool condition) WI_NOEXCEPT;
; 2176 :         _Post_satisfies_(return == condition) _When_(!condition, _Analysis_noreturn_)
; 2177 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_IfFalse)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2178 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2179 :         __RFF_CONDITIONAL_METHOD(bool, FailFastImmediate_If)(bool condition) WI_NOEXCEPT;
; 2180 :     } // namespace __RFF_NS_NAME
; 2181 : 
; 2182 :     RESULT_NORETURN inline void __stdcall WilFailFast(const FailureInfo& info);
; 2183 :     inline void LogFailure(
; 2184 :         __R_FN_PARAMS_FULL,
; 2185 :         FailureType type,
; 2186 :         const ResultStatus& resultPair,
; 2187 :         _In_opt_ PCWSTR message,
; 2188 :         bool fWantDebugString,
; 2189 :         _Out_writes_(debugStringSizeChars) _Post_z_ PWSTR debugString,
; 2190 :         _Pre_satisfies_(debugStringSizeChars > 0) size_t debugStringSizeChars,
; 2191 :         _Out_writes_(callContextStringSizeChars) _Post_z_ PSTR callContextString,
; 2192 :         _Pre_satisfies_(callContextStringSizeChars > 0) size_t callContextStringSizeChars,
; 2193 :         FailureFlags flags,
; 2194 :         _Out_ FailureInfo* failure) WI_NOEXCEPT;
; 2195 : 
; 2196 :     __declspec(noinline) inline void ReportFailure(
; 2197 :         __R_FN_PARAMS_FULL,
; 2198 :         FailureType type,
; 2199 :         const ResultStatus& resultPair,
; 2200 :         _In_opt_ PCWSTR message = nullptr,
; 2201 :         ReportFailureOptions options = ReportFailureOptions::None);
; 2202 :     template <FailureType, bool = false>
; 2203 :     __declspec(noinline) inline void ReportFailure_Base(
; 2204 :         __R_FN_PARAMS_FULL,
; 2205 :         const ResultStatus& resultPair,
; 2206 :         _In_opt_ PCWSTR message = nullptr,
; 2207 :         ReportFailureOptions options = ReportFailureOptions::None,
; 2208 :         FailureFlags flags = FailureFlags::None);
; 2209 :     template <FailureType>
; 2210 :     inline void ReportFailure_ReplaceMsg(__R_FN_PARAMS_FULL, HRESULT hr, _Printf_format_string_ PCSTR formatString, ...);
; 2211 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, FailureType type, HRESULT hr);
; 2212 :     template <FailureType>
; 2213 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, HRESULT hr, FailureFlags flags = FailureFlags::None);
; 2214 :     template <FailureType>
; 2215 :     __declspec(noinline) inline HRESULT ReportFailure_CaughtException(
; 2216 :         __R_FN_PARAMS_FULL, SupportedExceptions supported = SupportedExceptions::Default);
; 2217 : 
; 2218 : //*****************************************************************************
; 2219 : // Fail fast helpers (for use only internally to WIL)
; 2220 : //*****************************************************************************
; 2221 : 
; 2222 : /// @cond
; 2223 : #define __FAIL_FAST_ASSERT__(condition) \
; 2224 :     do \
; 2225 :     { \
; 2226 :         if (!(condition)) \
; 2227 :         { \
; 2228 :             __RFF_FN(FailFast_Unexpected)(__RFF_INFO_ONLY(#condition)); \
; 2229 :         } \
; 2230 :     } while ((void)0, 0)
; 2231 : #define __FAIL_FAST_IMMEDIATE_ASSERT__(condition) \
; 2232 :     do \
; 2233 :     { \
; 2234 :         if (!(condition)) \
; 2235 :         { \
; 2236 :             wil::FailureInfo failure{}; \
; 2237 :             wil::details::WilFailFast(failure); \
; 2238 :         } \
; 2239 :     } while ((void)0, 0)
; 2240 : #define __FAIL_FAST_ASSERT_WIN32_BOOL_FALSE__(condition) \
; 2241 :     __RFF_FN(FailFast_IfWin32BoolFalse)(__RFF_INFO(#condition) wil::verify_BOOL(condition))
; 2242 : 
; 2243 :     // A simple ref-counted buffer class.  The interface is very similar to shared_ptr<>, only it manages
; 2244 :     // an allocated buffer and maintains the size.
; 2245 : 
; 2246 :     class shared_buffer
; 2247 :     {
; 2248 :     public:
; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2250 :         {
; 2251 :         }
; 2252 : 
; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);
; 2256 :         }
; 2257 : 
; 2258 :         shared_buffer(shared_buffer&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy), m_size(other.m_size)
; 2259 :         {
; 2260 :             other.m_pCopy = nullptr;
; 2261 :             other.m_size = 0;
; 2262 :         }
; 2263 : 
; 2264 :         ~shared_buffer() WI_NOEXCEPT
; 2265 :         {
; 2266 :             reset();
; 2267 :         }
; 2268 : 
; 2269 :         shared_buffer& operator=(shared_buffer const& other) WI_NOEXCEPT
; 2270 :         {
; 2271 :             if (this != wistd::addressof(other))
; 2272 :             {
; 2273 :                 assign(other.m_pCopy, other.m_size);
; 2274 :             }
; 2275 :             return *this;
; 2276 :         }
; 2277 : 
; 2278 :         shared_buffer& operator=(shared_buffer&& other) WI_NOEXCEPT
; 2279 :         {
; 2280 :             if (this != wistd::addressof(other))
; 2281 :             {
; 2282 :                 reset();
; 2283 :                 m_pCopy = other.m_pCopy;
; 2284 :                 m_size = other.m_size;
; 2285 :                 other.m_pCopy = nullptr;
; 2286 :                 other.m_size = 0;
; 2287 :             }
; 2288 :             return *this;
; 2289 :         }
; 2290 : 
; 2291 :         void reset() WI_NOEXCEPT
; 2292 :         {
; 2293 :             if (m_pCopy != nullptr)
; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))
; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);
; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;
; 2300 :                 m_size = 0;
; 2301 :             }
; 2302 :         }
; 2303 : 
; 2304 :         bool create(_In_reads_bytes_opt_(cbData) void const* pData, size_t cbData) WI_NOEXCEPT
; 2305 :         {
; 2306 :             if (cbData == 0)
; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));
; 2313 :             if (pCopyRefCount == nullptr)
; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;
; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }
; 2326 : 
; 2327 :         bool create(size_t cbData) WI_NOEXCEPT
; 2328 :         {
; 2329 :             return create(nullptr, cbData);
; 2330 :         }
; 2331 : 
; 2332 :         WI_NODISCARD void* get(_Out_opt_ size_t* pSize = nullptr) const WI_NOEXCEPT
; 2333 :         {
; 2334 :             if (pSize != nullptr)
; 2335 :             {
; 2336 :                 *pSize = m_size;
; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);
; 2339 :         }
; 2340 : 
; 2341 :         WI_NODISCARD size_t size() const WI_NOEXCEPT
; 2342 :         {
; 2343 :             return m_size;
; 2344 :         }
; 2345 : 
; 2346 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2347 :         {
; 2348 :             return (m_pCopy != nullptr);
; 2349 :         }
; 2350 : 
; 2351 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2352 :         {
; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));
; 2354 :         }
; 2355 : 
; 2356 :     private:
; 2357 :         long* m_pCopy; // pointer to allocation: refcount + data
; 2358 :         size_t m_size; // size of the data from m_pCopy
; 2359 : 
; 2360 :         void assign(_In_opt_ long* pCopy, size_t cbSize) WI_NOEXCEPT
; 2361 :         {
; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)
; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);
; 2368 :             }
; 2369 :         }
; 2370 :     };
; 2371 : 
; 2372 :     inline shared_buffer make_shared_buffer_nothrow(_In_reads_bytes_opt_(countBytes) void* pData, size_t countBytes) WI_NOEXCEPT
; 2373 :     {
; 2374 :         shared_buffer buffer;
; 2375 :         buffer.create(pData, countBytes);
; 2376 :         return buffer;
; 2377 :     }
; 2378 : 
; 2379 :     inline shared_buffer make_shared_buffer_nothrow(size_t countBytes) WI_NOEXCEPT
; 2380 :     {
; 2381 :         shared_buffer buffer;
; 2382 :         buffer.create(countBytes);
; 2383 :         return buffer;
; 2384 :     }
; 2385 : 
; 2386 :     // A small mimic of the STL shared_ptr class, but unlike shared_ptr, a pointer is not attached to the class, but is
; 2387 :     // always simply contained within (it cannot be attached or detached).
; 2388 : 
; 2389 :     template <typename object_t>
; 2390 :     class shared_object
; 2391 :     {
; 2392 :     public:
; 2393 :         shared_object() WI_NOEXCEPT : m_pCopy(nullptr)
; 2394 :         {
; 2395 :         }
; 2396 : 
; 2397 :         shared_object(shared_object const& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2398 :         {
; 2399 :             if (m_pCopy != nullptr)
; 2400 :             {
; 2401 :                 ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2402 :             }
; 2403 :         }
; 2404 : 
; 2405 :         shared_object(shared_object&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2406 :         {
; 2407 :             other.m_pCopy = nullptr;
; 2408 :         }
; 2409 : 
; 2410 :         ~shared_object() WI_NOEXCEPT
; 2411 :         {
; 2412 :             reset();
; 2413 :         }
; 2414 : 
; 2415 :         shared_object& operator=(shared_object const& other) WI_NOEXCEPT
; 2416 :         {
; 2417 :             if (this != wistd::addressof(other))
; 2418 :             {
; 2419 :                 reset();
; 2420 :                 m_pCopy = other.m_pCopy;
; 2421 :                 if (m_pCopy != nullptr)
; 2422 :                 {
; 2423 :                     ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2424 :                 }
; 2425 :             }
; 2426 :             return *this;
; 2427 :         }
; 2428 : 
; 2429 :         shared_object& operator=(shared_object&& other) WI_NOEXCEPT
; 2430 :         {
; 2431 :             if (this != wistd::addressof(other))
; 2432 :             {
; 2433 :                 reset();
; 2434 :                 m_pCopy = other.m_pCopy;
; 2435 :                 other.m_pCopy = nullptr;
; 2436 :             }
; 2437 :             return *this;
; 2438 :         }
; 2439 : 
; 2440 :         void reset() WI_NOEXCEPT
; 2441 :         {
; 2442 :             if (m_pCopy != nullptr)
; 2443 :             {
; 2444 :                 if (0 == ::InterlockedDecrementRelease(&m_pCopy->m_refCount))
; 2445 :                 {
; 2446 :                     delete m_pCopy;
; 2447 :                 }
; 2448 :                 m_pCopy = nullptr;
; 2449 :             }
; 2450 :         }
; 2451 : 
; 2452 :         bool create()
; 2453 :         {
; 2454 :             RefAndObject* pObject = new (std::nothrow) RefAndObject();
; 2455 :             if (pObject == nullptr)
; 2456 :             {
; 2457 :                 return false;
; 2458 :             }
; 2459 :             reset();
; 2460 :             m_pCopy = pObject;
; 2461 :             return true;
; 2462 :         }
; 2463 : 
; 2464 :         template <typename param_t>
; 2465 :         bool create(param_t&& param1)
; 2466 :         {
; 2467 :             RefAndObject* pObject = new (std::nothrow) RefAndObject(wistd::forward<param_t>(param1));
; 2468 :             if (pObject == nullptr)
; 2469 :             {
; 2470 :                 return false;
; 2471 :             }
; 2472 :             reset();
; 2473 :             m_pCopy = pObject;
; 2474 :             return true;
; 2475 :         }
; 2476 : 
; 2477 :         WI_NODISCARD object_t* get() const WI_NOEXCEPT
; 2478 :         {
; 2479 :             return (m_pCopy == nullptr) ? nullptr : &m_pCopy->m_object;
; 2480 :         }
; 2481 : 
; 2482 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2483 :         {
; 2484 :             return (m_pCopy != nullptr);
; 2485 :         }
; 2486 : 
; 2487 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2488 :         {
; 2489 :             return ((m_pCopy != nullptr) && (m_pCopy->m_refCount == 1));
; 2490 :         }
; 2491 : 
; 2492 :         WI_NODISCARD object_t* operator->() const WI_NOEXCEPT
; 2493 :         {
; 2494 :             return get();
; 2495 :         }
; 2496 : 
; 2497 :     private:
; 2498 :         struct RefAndObject
; 2499 :         {
; 2500 :             long m_refCount;
; 2501 :             object_t m_object;
; 2502 : 
; 2503 :             RefAndObject() : m_refCount(1), m_object()
; 2504 :             {
; 2505 :             }
; 2506 : 
; 2507 :             template <typename param_t>
; 2508 :             RefAndObject(param_t&& param1) : m_refCount(1), m_object(wistd::forward<param_t>(param1))
; 2509 :             {
; 2510 :             }
; 2511 :         };
; 2512 : 
; 2513 :         RefAndObject* m_pCopy;
; 2514 :     };
; 2515 : 
; 2516 :     // The following functions are basically the same, but are kept separated to:
; 2517 :     // 1) Provide a unique count and last error code per-type
; 2518 :     // 2) Avoid merging the types to allow easy debugging (breakpoints, conditional breakpoints based
; 2519 :     //      upon count of errors from a particular type, etc)
; 2520 :     __WI_PUSH_WARNINGS
; 2521 : #if __clang_major__ >= 13
; 2522 :     __WI_CLANG_DISABLE_WARNING(-Wunused-but-set-variable) // s_hrErrorLast used for debugging. We intentionally only assign to it
; 2523 : #endif
; 2524 :     __WI_MSVC_DISABLE_WARNING(4746) // s_hrErrorLast' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2525 : 
; 2526 :     __declspec(noinline) inline int RecordException(HRESULT hr) WI_NOEXCEPT
; 2527 :     {
; 2528 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2529 :         static long volatile s_cErrorCount = 0;
; 2530 :         s_hrErrorLast = hr;
; 2531 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2532 :     }
; 2533 : 
; 2534 :     __declspec(noinline) inline int RecordReturn(HRESULT hr) WI_NOEXCEPT
; 2535 :     {
; 2536 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2537 :         static long volatile s_cErrorCount = 0;
; 2538 :         s_hrErrorLast = hr;
; 2539 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2540 :     }
; 2541 : 
; 2542 :     __declspec(noinline) inline int RecordLog(HRESULT hr) WI_NOEXCEPT
; 2543 :     {
; 2544 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2545 :         static long volatile s_cErrorCount = 0;
; 2546 :         s_hrErrorLast = hr;
; 2547 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2548 :     }
; 2549 : 
; 2550 :     __declspec(noinline) inline int RecordFailFast(HRESULT hr) WI_NOEXCEPT
; 2551 :     {
; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;
; 2554 :         return 1;
; 2555 :     }
; 2556 :     __WI_POP_WARNINGS
; 2557 : 
; 2558 :     inline RESULT_NORETURN void __stdcall WilRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_opt_ PCONTEXT cr, _In_ DWORD flags)
; 2559 :     {
; 2560 :         // if we managed to load the pointer either through WilDynamicRaiseFailFastException (PARTITION_DESKTOP etc.)
; 2561 :         // or via direct linkage (e.g. UWP apps), then use it.
; 2562 :         if (g_pfnRaiseFailFastException)
; 2563 :         {
; 2564 :             g_pfnRaiseFailFastException(er, cr, flags);
; 2565 :         }
; 2566 :         // if not, as a best effort, we are just going to call the intrinsic.
; 2567 :         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
; 2568 :     }
; 2569 : 
; 2570 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2571 :     inline bool __stdcall GetModuleInformation(
; 2572 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_NOEXCEPT
; 2573 :     {
; 2574 :         HMODULE hModule = nullptr;
; 2575 :         if (address && !GetModuleHandleExW(
; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))
; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);
; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))
; 2599 :             {
; 2600 :                 start--;
; 2601 :             }
; 2602 :             StringCchCopyA(name, size, start);
; 2603 :         }
; 2604 :         return true;
; 2605 :     }
; 2606 : 
; 2607 :     __WI_PUSH_WARNINGS
; 2608 :     __WI_MSVC_DISABLE_WARNING(4746) // s_fModuleValid' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2609 :     inline PCSTR __stdcall GetCurrentModuleName() WI_NOEXCEPT
; 2610 :     {
; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable
; 2614 :         {
; 2615 :             GetModuleInformation(reinterpret_cast<void*>(&RecordFailFast), nullptr, s_szModule, ARRAYSIZE(s_szModule));
; 2616 :             s_fModuleValid = true;
; 2617 :         }
; 2618 :         return s_szModule;
; 2619 :     }
; 2620 :     __WI_POP_WARNINGS
; 2621 : 
; 2622 :     inline void __stdcall DebugBreak() WI_NOEXCEPT
; 2623 :     {
; 2624 :         ::DebugBreak();
; 2625 :     }
; 2626 : 
; 2627 :     inline void __stdcall WilDynamicLoadRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_ PCONTEXT cr, _In_ DWORD flags)
; 2628 :     {
; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");
; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)
; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);
; 2636 :         }
; 2637 :     }
; 2638 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2639 : 
; 2640 :     inline bool __stdcall GetModuleInformationFromAddress(
; 2641 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* buffer, size_t size) WI_NOEXCEPT
; 2642 :     {
; 2643 :         if (size > 0)
; 2644 :         {
; 2645 :             assign_to_opt_param(buffer, '\0');
; 2646 :         }
; 2647 :         if (addressOffset)
; 2648 :         {
; 2649 :             *addressOffset = 0;
; 2650 :         }
; 2651 :         if (g_pfnGetModuleInformation)
; 2652 :         {
; 2653 :             return g_pfnGetModuleInformation(address, addressOffset, buffer, size);
; 2654 :         }
; 2655 :         return false;
; 2656 :     }
; 2657 : 
; 2658 :     __declspec(noinline) inline HRESULT NtStatusToHr(NTSTATUS status) WI_NOEXCEPT
; 2659 :     {
; 2660 :         // The following conversions are the only known incorrect mappings in RtlNtStatusToDosErrorNoTeb
; 2661 :         if (SUCCEEDED_NTSTATUS(status))
; 2662 :         {
; 2663 :             // All successful status codes have only one hresult equivalent, S_OK
; 2664 :             return S_OK;
; 2665 :         }
; 2666 :         if (status == static_cast<NTSTATUS>(STATUS_NO_MEMORY))
; 2667 :         {
; 2668 :             // RtlNtStatusToDosErrorNoTeb maps STATUS_NO_MEMORY to the less popular of two Win32 no memory error codes resulting in an unexpected mapping
; 2669 :             return E_OUTOFMEMORY;
; 2670 :         }
; 2671 : 
; 2672 :         if (g_pfnRtlNtStatusToDosErrorNoTeb != nullptr)
; 2673 :         {
; 2674 :             DWORD err = g_pfnRtlNtStatusToDosErrorNoTeb(status);
; 2675 : 
; 2676 :             // ERROR_MR_MID_NOT_FOUND indicates a bug in the originator of the error (failure to add a mapping to the Win32 error codes).
; 2677 :             // There are known instances of this bug which are unlikely to be fixed soon, and it's always possible that additional instances
; 2678 :             // could be added in the future. In these cases, it's better to use HRESULT_FROM_NT rather than returning a meaningless error.
; 2679 :             if ((err != 0) && (err != ERROR_MR_MID_NOT_FOUND))
; 2680 :             {
; 2681 :                 return __HRESULT_FROM_WIN32(err);
; 2682 :             }
; 2683 :         }
; 2684 : 
; 2685 :         return HRESULT_FROM_NT(status);
; 2686 :     }
; 2687 : 
; 2688 :     __declspec(noinline) inline NTSTATUS HrToNtStatus(HRESULT hr) WI_NOEXCEPT
; 2689 :     {
; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)
; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;
; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;
; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;
; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;
; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;
; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;
; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;
; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;
; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;
; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;
; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;
; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;
; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;
; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;
; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;
; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;
; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;
; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;
; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;
; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;
; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)
; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);
; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));
; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)
; 2787 :             {
; 2788 :                 status =
; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }
; 2800 : 
; 2801 :     // The following set of functions all differ only based upon number of arguments.  They are unified in their handling
; 2802 :     // of data from each of the various error-handling types (fast fail, exceptions, etc.).
; 2803 :     _Post_equals_last_error_ inline DWORD GetLastErrorFail(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2804 :     {
; 2805 :         __R_FN_UNREFERENCED;
; 2806 :         auto err = ::GetLastError();
; 2807 :         if (SUCCEEDED_WIN32(err))
; 2808 :         {
; 2809 :             // This function should only be called when GetLastError() is set to a FAILURE.
; 2810 :             // If you hit this assert (or are reviewing this failure telemetry), then there are one of three issues:
; 2811 :             //  1) Your code is using a macro (such as RETURN_IF_WIN32_BOOL_FALSE()) on a function that does not actually
; 2812 :             //      set the last error (consult MSDN).
; 2813 :             //  2) Your macro check against the error is not immediately after the API call.  Pushing it later can result
; 2814 :             //      in another API call between the previous one and the check resetting the last error.
; 2815 :             //  3) The API you're calling has a bug in it and does not accurately set the last error (there are a few
; 2816 :             //      examples here, such as SendMessageTimeout() that don't accurately set the last error).
; 2817 :             //      [MSFT internal] For these, please send mail to 'wildisc' when found and work-around with win32errorhelpers.
; 2818 : 
; 2819 :             WI_USAGE_ERROR_FORWARD("CALLER BUG: Macro usage error detected.  GetLastError() does not have an error.");
; 2820 :             return ERROR_ASSERTION_FAILURE;
; 2821 :         }
; 2822 :         return err;
; 2823 :     }
; 2824 : 
; 2825 :     inline __declspec(noinline) DWORD GetLastErrorFail() WI_NOEXCEPT
; 2826 :     {
; 2827 :         __R_FN_LOCALS_FULL_RA;
; 2828 :         return GetLastErrorFail(__R_FN_CALL_FULL);
; 2829 :     }
; 2830 : 
; 2831 :     _Translates_last_error_to_HRESULT_
; 2832 :     inline HRESULT GetLastErrorFailHr(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2833 :     {
; 2834 :         return HRESULT_FROM_WIN32(GetLastErrorFail(__R_FN_CALL_FULL));
; 2835 :     }
; 2836 : 
; 2837 :     _Translates_last_error_to_HRESULT_
; 2838 :     inline __declspec(noinline) HRESULT GetLastErrorFailHr() WI_NOEXCEPT
; 2839 :     {
; 2840 :         __R_FN_LOCALS_FULL_RA;
; 2841 :         return GetLastErrorFailHr(__R_FN_CALL_FULL);
; 2842 :     }
; 2843 : 
; 2844 :     inline void PrintLoggingMessage(
; 2845 :         _Out_writes_(cchDest) _Post_z_ PWSTR pszDest,
; 2846 :         _Pre_satisfies_(cchDest > 0) size_t cchDest,
; 2847 :         _In_opt_ _Printf_format_string_ PCSTR formatString,
; 2848 :         _In_opt_ va_list argList) WI_NOEXCEPT
; 2849 :     {
; 2850 :         if (formatString == nullptr)
; 2851 :         {
; 2852 :             pszDest[0] = L'\0';
; 2853 :         }
; 2854 :         else if (argList == nullptr)
; 2855 :         {
; 2856 :             StringCchPrintfW(pszDest, cchDest, L"%hs", formatString);
; 2857 :         }
; 2858 :         else
; 2859 :         {
; 2860 :             wchar_t szFormatWide[2048];
; 2861 :             StringCchPrintfW(szFormatWide, ARRAYSIZE(szFormatWide), L"%hs", formatString);
; 2862 :             StringCchVPrintfW(pszDest, cchDest, szFormatWide, argList);
; 2863 :         }
; 2864 :     }
; 2865 : 
; 2866 : #pragma warning(push)
; 2867 : #pragma warning(disable : __WARNING_RETURNING_BAD_RESULT)
; 2868 :     // NOTE: The following two functions are unfortunate copies of strsafe.h functions that have been copied to reduce the friction associated with using
; 2869 :     // Result.h and ResultException.h in a build that does not have WINAPI_PARTITION_DESKTOP defined (where these are conditionally enabled).
; 2870 : 
; 2871 :     inline HRESULT WilStringLengthWorkerA(
; 2872 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2873 :         _In_ _In_range_(<=, STRSAFE_MAX_CCH) size_t cchMax,
; 2874 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2875 :     {
; 2876 :         HRESULT hr = S_OK;
; 2877 :         size_t cchOriginalMax = cchMax;
; 2878 :         while (cchMax && (*psz != '\0'))
; 2879 :         {
; 2880 :             psz++;
; 2881 :             cchMax--;
; 2882 :         }
; 2883 :         if (cchMax == 0)
; 2884 :         {
; 2885 :             // the string is longer than cchMax
; 2886 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2887 :         }
; 2888 :         if (pcchLength)
; 2889 :         {
; 2890 :             if (SUCCEEDED(hr))
; 2891 :             {
; 2892 :                 *pcchLength = cchOriginalMax - cchMax;
; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 *pcchLength = 0;
; 2897 :             }
; 2898 :         }
; 2899 :         return hr;
; 2900 :     }
; 2901 : 
; 2902 :     _Must_inspect_result_
; 2903 :     inline HRESULT StringCchLengthA(
; 2904 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2905 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
; 2906 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2907 :     {
; 2908 :         HRESULT hr = S_OK;
; 2909 :         if ((psz == nullptr) || (cchMax > STRSAFE_MAX_CCH))
; 2910 :         {
; 2911 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2912 :         }
; 2913 :         else
; 2914 :         {
; 2915 :             hr = WilStringLengthWorkerA(psz, cchMax, pcchLength);
; 2916 :         }
; 2917 :         if (FAILED(hr) && pcchLength)
; 2918 :         {
; 2919 :             *pcchLength = 0;
; 2920 :         }
; 2921 :         return hr;
; 2922 :     }
; 2923 : #pragma warning(pop)
; 2924 : 
; 2925 :     _Post_satisfies_(cchDest > 0 && cchDest <= cchMax) inline HRESULT
; 2926 :         WilStringValidateDestA(_In_reads_opt_(cchDest) PCNZCH /*pszDest*/, _In_ size_t cchDest, _In_ const size_t cchMax)
; 2927 :     {
; 2928 :         HRESULT hr = S_OK;
; 2929 :         if ((cchDest == 0) || (cchDest > cchMax))
; 2930 :         {
; 2931 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2932 :         }
; 2933 :         return hr;
; 2934 :     }
; 2935 : 
; 2936 :     inline HRESULT WilStringVPrintfWorkerA(
; 2937 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2938 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchDest,
; 2939 :         _Always_(_Out_opt_ _Deref_out_range_(<=, cchDest - 1)) size_t* pcchNewDestLength,
; 2940 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2941 :         _In_ va_list argList)
; 2942 :     {
; 2943 :         HRESULT hr = S_OK;
; 2944 :         int iRet{};
; 2945 : 
; 2946 :         // leave the last space for the null terminator
; 2947 :         size_t cchMax = cchDest - 1;
; 2948 :         size_t cchNewDestLength = 0;
; 2949 : #undef STRSAFE_USE_SECURE_CRT
; 2950 : #define STRSAFE_USE_SECURE_CRT 1
; 2951 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 2952 :         iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 2953 : #else
; 2954 : #pragma warning(push)
; 2955 : #pragma warning(disable : __WARNING_BANNED_API_USAGE) // "STRSAFE not included"
; 2956 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
; 2957 : #pragma warning(pop)
; 2958 : #endif
; 2959 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 2960 : 
; 2961 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))
; 2962 :         {
; 2963 :             // need to null terminate the string
; 2964 :             pszDest += cchMax;
; 2965 :             *pszDest = '\0';
; 2966 : 
; 2967 :             cchNewDestLength = cchMax;
; 2968 : 
; 2969 :             // we have truncated pszDest
; 2970 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 2971 :         }
; 2972 :         else if (((size_t)iRet) == cchMax)
; 2973 :         {
; 2974 :             // need to null terminate the string
; 2975 :             pszDest += cchMax;
; 2976 :             *pszDest = '\0';
; 2977 : 
; 2978 :             cchNewDestLength = cchMax;
; 2979 :         }
; 2980 :         else
; 2981 :         {
; 2982 :             cchNewDestLength = (size_t)iRet;
; 2983 :         }
; 2984 : 
; 2985 :         if (pcchNewDestLength)
; 2986 :         {
; 2987 :             *pcchNewDestLength = cchNewDestLength;
; 2988 :         }
; 2989 : 
; 2990 :         return hr;
; 2991 :     }
; 2992 : 
; 2993 :     inline HRESULT StringCchPrintfA(
; 2994 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2995 :         _In_ size_t cchDest,
; 2996 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2997 :         ...)
; 2998 :     {
; 2999 :         HRESULT hr;
; 3000 :         hr = wil::details::WilStringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 3001 :         if (SUCCEEDED(hr))
; 3002 :         {
; 3003 :             va_list argList;
; 3004 :             va_start(argList, pszFormat);
; 3005 :             hr = wil::details::WilStringVPrintfWorkerA(pszDest, cchDest, nullptr, pszFormat, argList);
; 3006 :             va_end(argList);
; 3007 :         }
; 3008 :         else if (cchDest > 0)
; 3009 :         {
; 3010 :             *pszDest = '\0';
; 3011 :         }
; 3012 :         return hr;
; 3013 :     }
; 3014 : 
; 3015 :     _Ret_range_(sizeof(char), (psz == nullptr) ? sizeof(char) : (_String_length_(psz) + sizeof(char)))
; 3016 :     inline size_t ResultStringSize(_In_opt_ PCSTR psz)
; 3017 :     {
; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));
; 3019 :     }
; 3020 : 
; 3021 :     _Ret_range_(sizeof(wchar_t), (psz == nullptr) ? sizeof(wchar_t) : ((_String_length_(psz) + 1) * sizeof(wchar_t)))
; 3022 :     inline size_t ResultStringSize(_In_opt_ PCWSTR psz)
; 3023 :     {
; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);
; 3025 :     }
; 3026 : 
; 3027 :     template <typename TString>
; 3028 :     _Ret_range_(pStart, pEnd)
; 3029 :     inline unsigned char* WriteResultString(
; 3030 :         _Pre_satisfies_(pStart <= pEnd) _When_((pStart == pEnd) || (pszString == nullptr) || (pszString[0] == 0), _In_opt_) _When_(
; 3031 :             (pStart != pEnd) && (pszString != nullptr) && (pszString[0] != 0),
; 3032 :             _Out_writes_bytes_opt_(_String_length_(pszString) * sizeof(pszString[0]))) unsigned char* pStart,
; 3033 :         _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd,
; 3034 :         _In_opt_z_ TString pszString,
; 3035 :         _Outptr_result_maybenull_z_ TString* ppszBufferString)
; 3036 :     {
; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)
; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;
; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;
; 3049 :         if (bufferSize < stringSize)
; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);
; 3056 :         assign_to_opt_param(
; 3057 :             ppszBufferString,
; 3058 :             reinterpret_cast<TString>(
; 3059 :                 pStart)); // lgtm[cpp/incorrect-string-type-conversion] False positive - The query is misinterpreting a buffer (char *) with a MBS string, the cast to TString is expected.
; 3060 :         return pStart + stringSize;
; 3061 :     }
; 3062 : 
; 3063 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3064 :     inline size_t UntrustedStringLength(_In_ PCSTR psz, _In_ size_t cchMax)
; 3065 :     {
; 3066 :         size_t cbLength;
; 3067 :         return SUCCEEDED(wil::details::StringCchLengthA(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3068 :     }
; 3069 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3070 :     inline size_t UntrustedStringLength(_In_ PCWSTR psz, _In_ size_t cchMax)
; 3071 :     {
; 3072 :         size_t cbLength;
; 3073 :         return SUCCEEDED(::StringCchLengthW(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3074 :     }
; 3075 : 
; 3076 :     template <typename TString>
; 3077 :     _Ret_range_(pStart, pEnd)
; 3078 :     inline unsigned char* GetResultString(
; 3079 :         _In_reads_to_ptr_opt_(pEnd) unsigned char* pStart, _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd, _Out_ TString* ppszBufferString)
; 3080 :     {
; 3081 :         size_t cchLen = UntrustedStringLength(reinterpret_cast<TString>(pStart), (pEnd - pStart) / sizeof((*ppszBufferString)[0]));
; 3082 :         *ppszBufferString = (cchLen > 0) ? reinterpret_cast<TString>(pStart) : nullptr;
; 3083 :         auto pReturn = (wistd::min)(pEnd, pStart + ((cchLen + 1) * sizeof((*ppszBufferString)[0])));
; 3084 :         __analysis_assume((pReturn >= pStart) && (pReturn <= pEnd));
; 3085 :         return pReturn;
; 3086 :     }
; 3087 : } // namespace details
; 3088 : /// @endcond
; 3089 : 
; 3090 : //*****************************************************************************
; 3091 : // WIL result handling initializers
; 3092 : //
; 3093 : // Generally, callers do not need to manually initialize WIL. This header creates
; 3094 : // the appropriate .CRT init section pieces through global objects to ensure that
; 3095 : // WilInitialize... is called before DllMain or main().
; 3096 : //
; 3097 : // Certain binaries do not link with the CRT or do not support .CRT-section based
; 3098 : // initializers. Those binaries must link only with other static libraries that
; 3099 : // also set RESULT_SUPPRESS_STATIC_INITIALIZERS to ensure no .CRT inits are left,
; 3100 : // and they should call one of the WilInitialize_ResultMacros_??? methods during
; 3101 : // their initialization phase.  Skipping this initialization path is OK as well,
; 3102 : // but results in a slightly degraded experience with result reporting.
; 3103 : //
; 3104 : // Calling WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse provides:
; 3105 : // - The name of the current module in wil::FailureInfo::pszModule
; 3106 : // - The name of the returning-to module during wil/staging.h failures
; 3107 : //*****************************************************************************
; 3108 : 
; 3109 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3110 : //! Call this method to initialize WIL manually in a module where RESULT_SUPPRESS_STATIC_INITIALIZERS is required. WIL will
; 3111 : //! only use publicly documented APIs.
; 3112 : inline void WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse()
; 3113 : {
; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }
; 3119 : 
; 3120 : /// @cond
; 3121 : namespace details
; 3122 : {
; 3123 : #ifndef RESULT_SUPPRESS_STATIC_INITIALIZERS
; 3124 : #if !defined(BUILD_WINDOWS) || defined(WIL_SUPPRESS_PRIVATE_API_USE)
; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {
; 3126 :         ::wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse();
; 3127 :         return 1;
; 3128 :     });
; 3129 : #endif
; 3130 : #endif
; 3131 : } // namespace details
; 3132 : /// @endcond
; 3133 : #else  // !WINAPI_PARTITION_DESKTOP, !WINAPI_PARTITION_SYSTEM, explicitly assume these modules can direct link
; 3134 : namespace details
; 3135 : {
; 3136 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_AppOnly, [] {
; 3137 :         g_pfnRaiseFailFastException = ::RaiseFailFastException;
; 3138 :         return 1;
; 3139 :     });
; 3140 : } // namespace details
; 3141 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3142 : 
; 3143 : //*****************************************************************************
; 3144 : // Public Error Handling Helpers
; 3145 : //*****************************************************************************
; 3146 : 
; 3147 : //! Call this method to determine if process shutdown is in progress (allows avoiding work during dll unload).
; 3148 : inline bool ProcessShutdownInProgress()
; 3149 : {
; 3150 :     return (details::g_processShutdownInProgress || (details::g_pfnDllShutdownInProgress ? details::g_pfnDllShutdownInProgress() : false));
; 3151 : }
; 3152 : 
; 3153 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down,
; 3154 : but the hosting DLL doesn't support CRT initializers (such as kernelbase.dll).  The hosting DLL is responsible for calling
; 3155 : Construct() and Destroy() to manually run the constructor and destructor during DLL load & unload.
; 3156 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3157 : called as is typical. */
; 3158 : template <class T>
; 3159 : class manually_managed_shutdown_aware_object
; 3160 : {
; 3161 : public:
; 3162 :     manually_managed_shutdown_aware_object() = default;
; 3163 :     manually_managed_shutdown_aware_object(manually_managed_shutdown_aware_object const&) = delete;
; 3164 :     void operator=(manually_managed_shutdown_aware_object const&) = delete;
; 3165 : 
; 3166 :     void construct()
; 3167 :     {
; 3168 :         void* var = &m_raw;
; 3169 :         ::new (var) T();
; 3170 :     }
; 3171 : 
; 3172 :     void destroy()
; 3173 :     {
; 3174 :         if (ProcessShutdownInProgress())
; 3175 :         {
; 3176 :             get().ProcessShutdown();
; 3177 :         }
; 3178 :         else
; 3179 :         {
; 3180 :             (&get())->~T();
; 3181 :         }
; 3182 :     }
; 3183 : 
; 3184 :     //! Retrieves a reference to the contained object
; 3185 :     T& get() WI_NOEXCEPT
; 3186 :     {
; 3187 :         return *reinterpret_cast<T*>(&m_raw);
; 3188 :     }
; 3189 : 
; 3190 : private:
; 3191 :     alignas(T) unsigned char m_raw[sizeof(T)];
; 3192 : };
; 3193 : 
; 3194 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down.
; 3195 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3196 : called as is typical. */
; 3197 : template <class T>
; 3198 : class shutdown_aware_object
; 3199 : {
; 3200 : public:
; 3201 :     shutdown_aware_object()
; 3202 :     {
; 3203 :         m_object.construct();
; 3204 :     }
; 3205 : 
; 3206 :     ~shutdown_aware_object()
; 3207 :     {
; 3208 :         m_object.destroy();
; 3209 :     }
; 3210 : 
; 3211 :     shutdown_aware_object(shutdown_aware_object const&) = delete;
; 3212 :     void operator=(shutdown_aware_object const&) = delete;
; 3213 : 
; 3214 :     //! Retrieves a reference to the contained object
; 3215 :     T& get() WI_NOEXCEPT
; 3216 :     {
; 3217 :         return m_object.get();
; 3218 :     }
; 3219 : 
; 3220 : private:
; 3221 :     manually_managed_shutdown_aware_object<T> m_object;
; 3222 : };
; 3223 : 
; 3224 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down. */
; 3225 : template <class T>
; 3226 : class object_without_destructor_on_shutdown
; 3227 : {
; 3228 : public:
; 3229 :     object_without_destructor_on_shutdown()
; 3230 :     {
; 3231 :         void* var = &m_raw;
; 3232 :         ::new (var) T();
; 3233 :     }
; 3234 : 
; 3235 :     ~object_without_destructor_on_shutdown()
; 3236 :     {
; 3237 :         if (!ProcessShutdownInProgress())
; 3238 :         {
; 3239 :             get().~T();
; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     object_without_destructor_on_shutdown(object_without_destructor_on_shutdown const&) = delete;
; 3244 :     void operator=(object_without_destructor_on_shutdown const&) = delete;
; 3245 : 
; 3246 :     //! Retrieves a reference to the contained object
; 3247 :     T& get() WI_NOEXCEPT
; 3248 :     {
; 3249 :         return *reinterpret_cast<T*>(&m_raw);
; 3250 :     }
; 3251 : 
; 3252 : private:
; 3253 :     alignas(T) unsigned char m_raw[sizeof(T)]{};
; 3254 : };
; 3255 : 
; 3256 : /** Forward your DLLMain to this function so that WIL can have visibility into whether a DLL unload is because
; 3257 : of termination or normal unload.  Note that when g_pfnDllShutdownInProgress is set, WIL attempts to make this
; 3258 : determination on its own without this callback.  Suppressing private APIs requires use of this. */
; 3259 : inline void DLLMain(HINSTANCE, DWORD reason, _In_opt_ LPVOID reserved)
; 3260 : {
; 3261 :     if (!details::g_processShutdownInProgress)
; 3262 :     {
; 3263 :         if ((reason == DLL_PROCESS_DETACH) && (reserved != nullptr))
; 3264 :         {
; 3265 :             details::g_processShutdownInProgress = true;
; 3266 :         }
; 3267 :     }
; 3268 : }
; 3269 : 
; 3270 : // [optionally] Plug in fallback telemetry reporting
; 3271 : // Normally, the callback is owned by including ResultLogging.h in the including module.  Alternatively a module
; 3272 : // could re-route fallback telemetry to any ONE specific provider by calling this method.
; 3273 : inline void SetResultTelemetryFallback(_In_opt_ decltype(details::g_pfnTelemetryCallback) callbackFunction)
; 3274 : {
; 3275 :     // Only ONE telemetry provider can own the fallback telemetry callback.
; 3276 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3277 :         (details::g_pfnTelemetryCallback == nullptr) || (callbackFunction == nullptr) ||
; 3278 :         (details::g_pfnTelemetryCallback == callbackFunction));
; 3279 :     details::g_pfnTelemetryCallback = callbackFunction;
; 3280 : }
; 3281 : 
; 3282 : // [optionally] Plug in result logging (do not use for telemetry)
; 3283 : // This provides the ability for a module to hook all failures flowing through the system for inspection
; 3284 : // and/or logging.
; 3285 : inline void SetResultLoggingCallback(_In_opt_ decltype(details::g_pfnLoggingCallback) callbackFunction)
; 3286 : {
; 3287 :     // Only ONE function can own the result logging callback
; 3288 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3289 :         (details::g_pfnLoggingCallback == nullptr) || (callbackFunction == nullptr) ||
; 3290 :         (details::g_pfnLoggingCallback == callbackFunction));
; 3291 :     details::g_pfnLoggingCallback = callbackFunction;
; 3292 : }
; 3293 : 
; 3294 : // [optionally] Plug in custom result messages
; 3295 : // There are some purposes that require translating the full information that is known about a failure
; 3296 : // into a message to be logged (either through the console for debugging OR as the message attached
; 3297 : // to a Platform::Exception^).  This callback allows a module to format the string itself away from the
; 3298 : // default.
; 3299 : inline void SetResultMessageCallback(_In_opt_ decltype(wil::g_pfnResultLoggingCallback) callbackFunction)
; 3300 : {
; 3301 :     // Only ONE function can own the result message callback
; 3302 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3303 :         (g_pfnResultLoggingCallback == nullptr) || (callbackFunction == nullptr) || (g_pfnResultLoggingCallback == callbackFunction));
; 3304 :     details::g_resultMessageCallbackSet = true;
; 3305 :     g_pfnResultLoggingCallback = callbackFunction;
; 3306 : }
; 3307 : 
; 3308 : // [optionally] Plug in exception remapping
; 3309 : // A module can plug a callback in using this function to setup custom exception handling to allow any
; 3310 : // exception type to be converted into an HRESULT from exception barriers.
; 3311 : inline void SetResultFromCaughtExceptionCallback(_In_opt_ decltype(wil::g_pfnResultFromCaughtException) callbackFunction)
; 3312 : {
; 3313 :     // Only ONE function can own the exception conversion
; 3314 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3315 :         (g_pfnResultFromCaughtException == nullptr) || (callbackFunction == nullptr) ||
; 3316 :         (g_pfnResultFromCaughtException == callbackFunction));
; 3317 :     g_pfnResultFromCaughtException = callbackFunction;
; 3318 : }
; 3319 : 
; 3320 : // [optionally] Plug in exception remapping
; 3321 : // This provides the ability for a module to call RoOriginateError in case of a failure.
; 3322 : // Normally, the callback is owned by including result_originate.h in the including module.  Alternatively a module
; 3323 : // could re-route error origination callback to its own implementation.
; 3324 : inline void SetOriginateErrorCallback(_In_opt_ decltype(details::g_pfnOriginateCallback) callbackFunction)
; 3325 : {
; 3326 :     // Only ONE function can own the error origination callback
; 3327 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3328 :         (details::g_pfnOriginateCallback == nullptr) || (callbackFunction == nullptr) ||
; 3329 :         (details::g_pfnOriginateCallback == callbackFunction));
; 3330 :     details::g_pfnOriginateCallback = callbackFunction;
; 3331 : }
; 3332 : 
; 3333 : // [optionally] Plug in failfast callback
; 3334 : // This provides the ability for a module to call RoFailFastWithErrorContext in the failfast handler -if- there is stowed
; 3335 : // exception data available.  Normally, the callback is owned by including result_originate.h in the including module.
; 3336 : // Alternatively a module could re-route to its own implementation.
; 3337 : inline void SetFailfastWithContextCallback(_In_opt_ decltype(details::g_pfnFailfastWithContextCallback) callbackFunction)
; 3338 : {
; 3339 :     // Only ONE function can own the failfast with context callback
; 3340 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3341 :         (details::g_pfnFailfastWithContextCallback == nullptr) || (callbackFunction == nullptr) ||
; 3342 :         (details::g_pfnFailfastWithContextCallback == callbackFunction));
; 3343 :     details::g_pfnFailfastWithContextCallback = callbackFunction;
; 3344 : }
; 3345 : 
; 3346 : // A RAII wrapper around the storage of a FailureInfo struct (which is normally meant to be consumed
; 3347 : // on the stack or from the caller).  The storage of FailureInfo needs to copy some data internally
; 3348 : // for lifetime purposes.
; 3349 : 
; 3350 : class StoredFailureInfo
; 3351 : {
; 3352 : public:
; 3353 :     StoredFailureInfo() WI_NOEXCEPT
; 3354 :     {
; 3355 :         ::ZeroMemory(&m_failureInfo, sizeof(m_failureInfo));
; 3356 :     }
; 3357 : 
; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT
; 3359 :     {
; 3360 :         SetFailureInfo(other);
; 3361 :     }
; 3362 : 
; 3363 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3364 :     {
; 3365 :         return m_failureInfo;
; 3366 :     }
; 3367 : 
; 3368 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3369 :     {
; 3370 :         m_failureInfo = failure;
; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +
; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))
; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);
; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;
; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);
; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);
; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);
; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);
; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);
; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);
; 3398 :             pBuffer = details::WriteResultString(
; 3399 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextName, &m_failureInfo.callContextCurrent.contextName);
; 3400 :             pBuffer = details::WriteResultString(
; 3401 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextMessage, &m_failureInfo.callContextCurrent.contextMessage);
; 3402 :             pBuffer = details::WriteResultString(
; 3403 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextName, &m_failureInfo.callContextOriginating.contextName);
; 3404 :             pBuffer = details::WriteResultString(
; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);
; 3407 :         }
; 3408 :     }
; 3409 : 
; 3410 :     // Relies upon generated copy constructor and assignment operator
; 3411 : 
; 3412 : protected:
; 3413 :     FailureInfo m_failureInfo;
; 3414 :     details::shared_buffer m_spStrings;
; 3415 : };
; 3416 : 
; 3417 : #if defined(WIL_ENABLE_EXCEPTIONS) || defined(WIL_FORCE_INCLUDE_RESULT_EXCEPTION)
; 3418 : 
; 3419 : //! This is WIL's default exception class thrown from all THROW_XXX macros (outside of c++/cx).
; 3420 : //! This class stores all of the FailureInfo context that is available when the exception is thrown.  It's also caught by
; 3421 : //! exception guards for automatic conversion to HRESULT.
; 3422 : //!
; 3423 : //! In c++/cx, Platform::Exception^ is used instead of this class (unless @ref wil::g_fResultThrowPlatformException has been
; 3424 : //! changed).
; 3425 : class ResultException : public std::exception
; 3426 : {
; 3427 : public:
; 3428 :     //! Constructs a new ResultException from an existing FailureInfo.
; 3429 :     ResultException(const FailureInfo& failure) WI_NOEXCEPT : m_failure(failure)
; 3430 :     {
; 3431 :     }
; 3432 : 
; 3433 :     //! Constructs a new exception type from a given HRESULT (use only for constructing custom exception types).
; 3434 :     ResultException(_Pre_satisfies_(hr < 0) HRESULT hr) WI_NOEXCEPT : m_failure(CustomExceptionFailureInfo(hr))
; 3435 :     {
; 3436 :     }
; 3437 : 
; 3438 :     //! Returns the failed HRESULT that this exception represents.
; 3439 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) HRESULT GetErrorCode() const WI_NOEXCEPT
; 3440 :     {
; 3441 :         HRESULT const hr = m_failure.GetFailureInfo().hr;
; 3442 :         __analysis_assume(hr < 0);
; 3443 :         return hr;
; 3444 :     }
; 3445 : 
; 3446 :     //! Returns the failed NTSTATUS that this exception represents.
; 3447 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) NTSTATUS GetStatusCode() const WI_NOEXCEPT
; 3448 :     {
; 3449 :         NTSTATUS const status = m_failure.GetFailureInfo().status;
; 3450 :         __analysis_assume(status < 0);
; 3451 :         return status;
; 3452 :     }
; 3453 : 
; 3454 :     //! Get a reference to the stored FailureInfo.
; 3455 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3456 :     {
; 3457 :         return m_failure.GetFailureInfo();
; 3458 :     }
; 3459 : 
; 3460 :     //! Sets the stored FailureInfo (use primarily only when constructing custom exception types).
; 3461 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3462 :     {
; 3463 :         m_failure.SetFailureInfo(failure);
; 3464 :     }
; 3465 : 
; 3466 :     //! Provides a string representing the FailureInfo from this exception.
; 3467 :     WI_NODISCARD inline const char* __CLR_OR_THIS_CALL what() const WI_NOEXCEPT override
; 3468 :     {
; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)
; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);
; 3476 :             if (!m_what.create(len))
; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";
; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);
; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());
; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }
; 3498 : 
; 3499 :     // Relies upon auto-generated copy constructor and assignment operator
; 3500 : protected:
; 3501 :     StoredFailureInfo m_failure;           //!< The failure information for this exception
; 3502 :     mutable details::shared_buffer m_what; //!< The on-demand generated what() string
; 3503 : 
; 3504 :     //! Use to produce a custom FailureInfo from an HRESULT (use only when constructing custom exception types).
; 3505 :     static FailureInfo CustomExceptionFailureInfo(HRESULT hr) WI_NOEXCEPT
; 3506 :     {
; 3507 :         FailureInfo fi = {};
; 3508 :         fi.type = FailureType::Exception;
; 3509 :         fi.hr = hr;
; 3510 :         return fi;
; 3511 :     }
; 3512 : };
; 3513 : #endif
; 3514 : 
; 3515 : //*****************************************************************************
; 3516 : // Public Helpers that catch -- mostly only enabled when exceptions are enabled
; 3517 : //*****************************************************************************
; 3518 : 
; 3519 : // ResultFromCaughtException is a function that is meant to be called from within a catch(...) block.  Internally
; 3520 : // it re-throws and catches the exception to convert it to an HRESULT.  If an exception is of an unrecognized type
; 3521 : // the function will fail fast.
; 3522 : //
; 3523 : // try
; 3524 : // {
; 3525 : //     // Code
; 3526 : // }
; 3527 : // catch (...)
; 3528 : // {
; 3529 : //     hr = wil::ResultFromCaughtException();
; 3530 : // }
; 3531 : _Always_(_Post_satisfies_(return < 0)) __declspec(noinline) inline HRESULT ResultFromCaughtException() WI_NOEXCEPT
; 3532 : {
; 3533 :     bool isNormalized = false;
; 3534 :     HRESULT hr = S_OK;
; 3535 :     if (details::g_pfnResultFromCaughtExceptionInternal)
; 3536 :     {
; 3537 :         hr = details::g_pfnResultFromCaughtExceptionInternal(nullptr, 0, &isNormalized).hr;
; 3538 :     }
; 3539 :     if (FAILED(hr))
; 3540 :     {
; 3541 :         return hr;
; 3542 :     }
; 3543 : 
; 3544 :     // Caller bug: an unknown exception was thrown
; 3545 :     __WIL_PRIVATE_FAIL_FAST_HR_IF(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION), g_fResultFailFastUnknownExceptions);
; 3546 :     return __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3547 : }
; 3548 : 
; 3549 : //! Identical to 'throw;', but can be called from error-code neutral code to rethrow in code that *may* be running under an
; 3550 : //! exception context
; 3551 : inline void RethrowCaughtException()
; 3552 : {
; 3553 :     // We always want to rethrow the exception under normal circumstances.  Ordinarily, we could actually guarantee
; 3554 :     // this as we should be able to rethrow if we caught an exception, but if we got here in the middle of running
; 3555 :     // dynamic initializers, then it's possible that we haven't yet setup the rethrow function pointer, thus the
; 3556 :     // runtime check without the noreturn annotation.
; 3557 : 
; 3558 :     if (details::g_pfnRethrow)
; 3559 :     {
; 3560 :         details::g_pfnRethrow();
; 3561 :     }
; 3562 : }
; 3563 : 
; 3564 : //! Identical to 'throw ResultException(failure);', but can be referenced from error-code neutral code
; 3565 : inline void ThrowResultException(const FailureInfo& failure)
; 3566 : {
; 3567 :     if (details::g_pfnThrowResultException)
; 3568 :     {
; 3569 :         details::g_pfnThrowResultException(failure);
; 3570 :     }
; 3571 : }
; 3572 : 
; 3573 : /// @cond
; 3574 : namespace details
; 3575 : {
; 3576 : #ifdef WIL_ENABLE_EXCEPTIONS
; 3577 :     //*****************************************************************************
; 3578 :     // Private helpers to catch and propagate exceptions
; 3579 :     //*****************************************************************************
; 3580 : 
; 3581 :     RESULT_NORETURN inline void TerminateAndReportError(_In_opt_ PEXCEPTION_POINTERS)
; 3582 :     {
; 3583 :         // This is an intentional fail-fast that was caught by an exception guard with WIL.  Look back up the callstack to
; 3584 :         // determine the source of the actual exception being thrown.  The exception guard used by the calling code did not expect
; 3585 :         // this exception type to be thrown or is specifically requesting fail-fast for this class of exception.
; 3586 : 
; 3587 :         FailureInfo failure{};
; 3588 :         WilFailFast(failure);
; 3589 :     }
; 3590 : 
; 3591 :     inline void MaybeGetExceptionString(
; 3592 :         const ResultException& exception,
; 3593 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3594 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3595 :     {
; 3596 :         if (debugString)
; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());
; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$2|

; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);

	ldp         x1,x0,[fp,#0x20]
	bl          |?RecognizeCaughtExceptionFromCallback@details@wil@@YAJPEA_W_K@Z|

; 3980 :                 if (FAILED(hr))

	tbz         w0,#0x1F,|$LN9@catch$2|

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	str         w0,[fp,#0x10]
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|
	stp         w0,wzr,[fp,#0x14]

; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);

	adrp        x0,|$LN23@catch$2|
	add         x0,x0,|$LN23@catch$2|
	b           |$LN72@catch$2|
|$LN9@catch$2|

; 3983 :                 }
; 3984 :             }

	adrp        x0,|$LN37@catch$2|
	add         x0,x0,|$LN37@catch$2|
|$LN72@catch$2|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$3@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$3

; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {

	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$4|

; 3994 :                 *isNormalized = true;

	ldr         x8,[fp,#0x10]
	mov         w9,#1

; 3596 :         if (debugString)

	ldr         x0,[fp,#0x28]
	ldr         x19,[fp,#0x38]

; 3994 :                 *isNormalized = true;

	strb        w9,[x8]

; 3596 :         if (debugString)

	cbz         x0,|$LN52@catch$3|

; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());

	ldr         x1,[fp,#0x20]
	add         x2,x19,#0x18
	bl          |?GetFailureLogString@wil@@YAJPEA_W_KAEBUFailureInfo@1@@Z|
|$LN52@catch$3|

; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};

	ldp         w8,w9,[x19,#0x1C]
	ldr         w10,[x19,#0x24]
	ubfx        w8,w8,#3,#1
	str         w8,[fp,#0x18]
	stp         w9,w10,[fp,#0x10]

; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());

	adrp        x0,|$LN23@catch$3|
	add         x0,x0,|$LN23@catch$3|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$4@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$4

; 1939 :         }
; 1940 :         static ResultStatus FromStatus(const NTSTATUS _status)
; 1941 :         {
; 1942 :             return {wil::details::NtStatusToHr(_status), _status, Kind::NtStatus};
; 1943 :         }
; 1944 :         static ResultStatus FromFailureInfo(const FailureInfo& _failure)
; 1945 :         {
; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};
; 1947 :         }
; 1948 :         HRESULT hr = S_OK;
; 1949 :         NTSTATUS status = STATUS_SUCCESS;
; 1950 :         Kind kind = Kind::NtStatus;
; 1951 :     };
; 1952 : 
; 1953 :     // Fallback telemetry provider callback (set with wil::SetResultTelemetryFallback)
; 1954 :     __declspec(selectany) void(__stdcall* g_pfnTelemetryCallback)(bool alreadyReported, wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1955 : 
; 1956 :     // Result.h plug-in (WIL use only)
; 1957 :     __declspec(selectany) void(__stdcall* g_pfnNotifyFailure)(_Inout_ FailureInfo* pFailure) WI_PFN_NOEXCEPT = nullptr;
; 1958 :     __declspec(selectany) void(__stdcall* g_pfnGetContextAndNotifyFailure)(
; 1959 :         _Inout_ FailureInfo* pFailure,
; 1960 :         _Out_writes_(callContextStringLength) _Post_z_ PSTR callContextString,
; 1961 :         _Pre_satisfies_(callContextStringLength > 0) size_t callContextStringLength) WI_PFN_NOEXCEPT = nullptr;
; 1962 : 
; 1963 :     // Observe all errors flowing through the system with this callback (set with wil::SetResultLoggingCallback); use with custom logging
; 1964 :     __declspec(selectany) void(__stdcall* g_pfnLoggingCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1965 : 
; 1966 :     // Desktop/System Only:  Module fetch function (automatically setup)
; 1967 :     __declspec(selectany) PCSTR(__stdcall* g_pfnGetModuleName)() WI_PFN_NOEXCEPT = nullptr;
; 1968 : 
; 1969 :     // Desktop/System Only:  Retrieve address offset and modulename
; 1970 :     __declspec(selectany) bool(__stdcall* g_pfnGetModuleInformation)(
; 1971 :         void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_PFN_NOEXCEPT = nullptr;
; 1972 : 
; 1973 :     // Called with the expectation that the program will terminate when called inside of a loader callout.
; 1974 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1975 :     __declspec(selectany) void(__stdcall* g_pfnFailFastInLoaderCallout)() WI_PFN_NOEXCEPT = nullptr;
; 1976 : 
; 1977 :     // Called to translate an NTSTATUS value to a Win32 error code
; 1978 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1979 :     __declspec(selectany) ULONG(__stdcall* g_pfnRtlNtStatusToDosErrorNoTeb)(NTSTATUS) WI_PFN_NOEXCEPT = nullptr;
; 1980 : 
; 1981 :     // Desktop/System Only: Call to DebugBreak
; 1982 :     __declspec(selectany) void(__stdcall* g_pfnDebugBreak)() WI_PFN_NOEXCEPT = nullptr;
; 1983 : 
; 1984 :     // Called to determine whether or not termination is happening
; 1985 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1986 :     __declspec(selectany) BOOLEAN(__stdcall* g_pfnDllShutdownInProgress)() WI_PFN_NOEXCEPT = nullptr;
; 1987 :     __declspec(selectany) bool g_processShutdownInProgress = false;
; 1988 : 
; 1989 :     // On Desktop/System WINAPI family: dynalink RaiseFailFastException because we may encounter modules
; 1990 :     // that do not have RaiseFailFastException in kernelbase.  UWP apps will directly link.
; 1991 :     __declspec(selectany) void(__stdcall* g_pfnRaiseFailFastException)(PEXCEPTION_RECORD, PCONTEXT, DWORD) = nullptr;
; 1992 : 
; 1993 :     // Exception-based compiled additions
; 1994 :     __declspec(selectany) HRESULT(__stdcall* g_pfnRunFunctorWithExceptionFilter)(IFunctor& functor, IFunctorHost& host, void* returnAddress) = nullptr;
; 1995 :     __declspec(selectany) void(__stdcall* g_pfnRethrow)() = nullptr;
; 1996 :     __declspec(selectany) void(__stdcall* g_pfnThrowResultException)(const FailureInfo& failure) = nullptr;
; 1997 :     extern "C" __declspec(selectany) ResultStatus(__stdcall* g_pfnResultFromCaughtExceptionInternal)(
; 1998 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 1999 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2000 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2001 : 
; 2002 :     // C++/WinRT additions
; 2003 :     extern "C" __declspec(selectany) HRESULT(__stdcall* g_pfnResultFromCaughtException_CppWinRt)(
; 2004 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 2005 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2006 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2007 : 
; 2008 :     // C++/cx compiled additions
; 2009 :     extern "C" __declspec(selectany) void(__stdcall* g_pfnThrowPlatformException)(FailureInfo const& failure, PCWSTR debugString) = nullptr;
; 2010 :     extern "C" __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromCaughtException_WinRt)(
; 2011 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 2012 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2013 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2014 :     __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromKnownExceptions_WinRt)(
; 2015 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor) = nullptr;
; 2016 : 
; 2017 :     // Plugin to call RoOriginateError (WIL use only)
; 2018 :     __declspec(selectany) void(__stdcall* g_pfnOriginateCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2019 : 
; 2020 :     // Plugin to call RoFailFastWithErrorContext (WIL use only)
; 2021 :     __declspec(selectany) void(__stdcall* g_pfnFailfastWithContextCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2022 : 
; 2023 :     // Allocate and disown the allocation so that Appverifier does not complain about a false leak
; 2024 :     inline PVOID ProcessHeapAlloc(_In_ DWORD flags, _In_ size_t size) WI_NOEXCEPT
; 2025 :     {
; 2026 :         const HANDLE processHeap = ::GetProcessHeap();
; 2027 :         const PVOID allocation = ::HeapAlloc(processHeap, flags, size);
; 2028 : 
; 2029 :         static bool fetchedRtlDisownModuleHeapAllocation = false;
; 2030 :         static NTSTATUS(__stdcall * pfnRtlDisownModuleHeapAllocation)(HANDLE, PVOID) WI_PFN_NOEXCEPT = nullptr;
; 2031 : 
; 2032 :         if (pfnRtlDisownModuleHeapAllocation)
; 2033 :         {
; 2034 :             (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2035 :         }
; 2036 :         else if (!fetchedRtlDisownModuleHeapAllocation)
; 2037 :         {
; 2038 :             if (auto ntdllModule = ::GetModuleHandleW(L"ntdll.dll"))
; 2039 :             {
; 2040 :                 pfnRtlDisownModuleHeapAllocation =
; 2041 :                     details::GetProcAddress<decltype(pfnRtlDisownModuleHeapAllocation)>(ntdllModule, "RtlDisownModuleHeapAllocation");
; 2042 :             }
; 2043 :             fetchedRtlDisownModuleHeapAllocation = true;
; 2044 : 
; 2045 :             if (pfnRtlDisownModuleHeapAllocation)
; 2046 :             {
; 2047 :                 (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2048 :             }
; 2049 :         }
; 2050 : 
; 2051 :         return allocation;
; 2052 :     }
; 2053 : 
; 2054 :     enum class ReportFailureOptions
; 2055 :     {
; 2056 :         None = 0x00,
; 2057 :         ForcePlatformException = 0x01,
; 2058 :         MayRethrow = 0x02,
; 2059 :     };
; 2060 :     DEFINE_ENUM_FLAG_OPERATORS(ReportFailureOptions);
; 2061 : 
; 2062 :     template <typename TFunctor>
; 2063 :     using functor_return_type = decltype((*static_cast<TFunctor*>(nullptr))());
; 2064 : 
; 2065 :     template <typename TFunctor>
; 2066 :     struct functor_wrapper_void : public IFunctor
; 2067 :     {
; 2068 :         TFunctor&& functor;
; 2069 :         functor_wrapper_void(TFunctor&& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2070 :         {
; 2071 :         }
; 2072 : #pragma warning(push)
; 2073 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2074 :         HRESULT Run() override
; 2075 :         {
; 2076 :             functor();
; 2077 :             return S_OK;
; 2078 :         }
; 2079 : #pragma warning(pop)
; 2080 :     };
; 2081 : 
; 2082 :     template <typename TFunctor>
; 2083 :     struct functor_wrapper_HRESULT : public IFunctor
; 2084 :     {
; 2085 :         TFunctor&& functor;
; 2086 :         functor_wrapper_HRESULT(TFunctor& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2087 :         {
; 2088 :         }
; 2089 :         HRESULT Run() override
; 2090 :         {
; 2091 :             return functor();
; 2092 :         }
; 2093 :     };
; 2094 : 
; 2095 :     template <typename TFunctor, typename TReturn>
; 2096 :     struct functor_wrapper_other : public IFunctor
; 2097 :     {
; 2098 :         TFunctor&& functor;
; 2099 :         TReturn& retVal;
; 2100 :         functor_wrapper_other(TFunctor& functor_, TReturn& retval_) : functor(wistd::forward<TFunctor>(functor_)), retVal(retval_)
; 2101 :         {
; 2102 :         }
; 2103 : #pragma warning(push)
; 2104 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2105 :         HRESULT Run() override
; 2106 :         {
; 2107 :             retVal = functor();
; 2108 :             return S_OK;
; 2109 :         }
; 2110 : #pragma warning(pop)
; 2111 :     };
; 2112 : 
; 2113 :     struct tag_return_void : public wistd::integral_constant<size_t, 0>
; 2114 :     {
; 2115 :         template <typename TFunctor>
; 2116 :         using functor_wrapper = functor_wrapper_void<TFunctor>;
; 2117 :     };
; 2118 : 
; 2119 :     struct tag_return_HRESULT : public wistd::integral_constant<size_t, 1>
; 2120 :     {
; 2121 :         template <typename TFunctor>
; 2122 :         using functor_wrapper = functor_wrapper_HRESULT<TFunctor>;
; 2123 :     };
; 2124 : 
; 2125 :     struct tag_return_other : public wistd::integral_constant<size_t, 2>
; 2126 :     {
; 2127 :         template <typename TFunctor, typename TReturn>
; 2128 :         using functor_wrapper = functor_wrapper_other<TFunctor, TReturn>;
; 2129 :     };
; 2130 : 
; 2131 :     // type-trait to help discover the return type of a functor for tag/dispatch.
; 2132 : 
; 2133 :     template <ErrorReturn errorReturn, typename T>
; 2134 :     struct return_type
; 2135 :     {
; 2136 :         using type = tag_return_other;
; 2137 :     };
; 2138 : 
; 2139 :     template <>
; 2140 :     struct return_type<ErrorReturn::Auto, HRESULT>
; 2141 :     {
; 2142 :         using type = tag_return_HRESULT;
; 2143 :     };
; 2144 : 
; 2145 :     template <>
; 2146 :     struct return_type<ErrorReturn::Auto, void>
; 2147 :     {
; 2148 :         using type = tag_return_void;
; 2149 :     };
; 2150 : 
; 2151 :     template <>
; 2152 :     struct return_type<ErrorReturn::None, void>
; 2153 :     {
; 2154 :         using type = tag_return_void;
; 2155 :     };
; 2156 : 
; 2157 :     template <ErrorReturn errorReturn, typename Functor>
; 2158 :     using functor_tag = typename return_type<errorReturn, functor_return_type<Functor>>::type;
; 2159 : 
; 2160 :     // Forward declarations to enable use of fail fast and reporting internally...
; 2161 :     namespace __R_NS_NAME
; 2162 :     {
; 2163 :         _Post_satisfies_(return == hr) __R_DIRECT_METHOD(HRESULT, Log_Hr)(__R_DIRECT_FN_PARAMS HRESULT hr) WI_NOEXCEPT;
; 2164 :         _Post_satisfies_(return == hr)
; 2165 :             __R_DIRECT_METHOD(HRESULT, Log_HrMsg)(__R_DIRECT_FN_PARAMS HRESULT hr, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2166 :         _Post_satisfies_(return == err)
; 2167 :             __R_DIRECT_METHOD(DWORD, Log_Win32Msg)(__R_DIRECT_FN_PARAMS DWORD err, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2168 :     } // namespace __R_NS_NAME
; 2169 :     namespace __RFF_NS_NAME
; 2170 :     {
; 2171 :         __RFF_DIRECT_NORET_METHOD(void, FailFast_Unexpected)(__RFF_DIRECT_FN_PARAMS_ONLY) WI_NOEXCEPT;
; 2172 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2173 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_If)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2174 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2175 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_HrIf)(__RFF_CONDITIONAL_FN_PARAMS HRESULT hr, bool condition) WI_NOEXCEPT;
; 2176 :         _Post_satisfies_(return == condition) _When_(!condition, _Analysis_noreturn_)
; 2177 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_IfFalse)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2178 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2179 :         __RFF_CONDITIONAL_METHOD(bool, FailFastImmediate_If)(bool condition) WI_NOEXCEPT;
; 2180 :     } // namespace __RFF_NS_NAME
; 2181 : 
; 2182 :     RESULT_NORETURN inline void __stdcall WilFailFast(const FailureInfo& info);
; 2183 :     inline void LogFailure(
; 2184 :         __R_FN_PARAMS_FULL,
; 2185 :         FailureType type,
; 2186 :         const ResultStatus& resultPair,
; 2187 :         _In_opt_ PCWSTR message,
; 2188 :         bool fWantDebugString,
; 2189 :         _Out_writes_(debugStringSizeChars) _Post_z_ PWSTR debugString,
; 2190 :         _Pre_satisfies_(debugStringSizeChars > 0) size_t debugStringSizeChars,
; 2191 :         _Out_writes_(callContextStringSizeChars) _Post_z_ PSTR callContextString,
; 2192 :         _Pre_satisfies_(callContextStringSizeChars > 0) size_t callContextStringSizeChars,
; 2193 :         FailureFlags flags,
; 2194 :         _Out_ FailureInfo* failure) WI_NOEXCEPT;
; 2195 : 
; 2196 :     __declspec(noinline) inline void ReportFailure(
; 2197 :         __R_FN_PARAMS_FULL,
; 2198 :         FailureType type,
; 2199 :         const ResultStatus& resultPair,
; 2200 :         _In_opt_ PCWSTR message = nullptr,
; 2201 :         ReportFailureOptions options = ReportFailureOptions::None);
; 2202 :     template <FailureType, bool = false>
; 2203 :     __declspec(noinline) inline void ReportFailure_Base(
; 2204 :         __R_FN_PARAMS_FULL,
; 2205 :         const ResultStatus& resultPair,
; 2206 :         _In_opt_ PCWSTR message = nullptr,
; 2207 :         ReportFailureOptions options = ReportFailureOptions::None,
; 2208 :         FailureFlags flags = FailureFlags::None);
; 2209 :     template <FailureType>
; 2210 :     inline void ReportFailure_ReplaceMsg(__R_FN_PARAMS_FULL, HRESULT hr, _Printf_format_string_ PCSTR formatString, ...);
; 2211 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, FailureType type, HRESULT hr);
; 2212 :     template <FailureType>
; 2213 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, HRESULT hr, FailureFlags flags = FailureFlags::None);
; 2214 :     template <FailureType>
; 2215 :     __declspec(noinline) inline HRESULT ReportFailure_CaughtException(
; 2216 :         __R_FN_PARAMS_FULL, SupportedExceptions supported = SupportedExceptions::Default);
; 2217 : 
; 2218 : //*****************************************************************************
; 2219 : // Fail fast helpers (for use only internally to WIL)
; 2220 : //*****************************************************************************
; 2221 : 
; 2222 : /// @cond
; 2223 : #define __FAIL_FAST_ASSERT__(condition) \
; 2224 :     do \
; 2225 :     { \
; 2226 :         if (!(condition)) \
; 2227 :         { \
; 2228 :             __RFF_FN(FailFast_Unexpected)(__RFF_INFO_ONLY(#condition)); \
; 2229 :         } \
; 2230 :     } while ((void)0, 0)
; 2231 : #define __FAIL_FAST_IMMEDIATE_ASSERT__(condition) \
; 2232 :     do \
; 2233 :     { \
; 2234 :         if (!(condition)) \
; 2235 :         { \
; 2236 :             wil::FailureInfo failure{}; \
; 2237 :             wil::details::WilFailFast(failure); \
; 2238 :         } \
; 2239 :     } while ((void)0, 0)
; 2240 : #define __FAIL_FAST_ASSERT_WIN32_BOOL_FALSE__(condition) \
; 2241 :     __RFF_FN(FailFast_IfWin32BoolFalse)(__RFF_INFO(#condition) wil::verify_BOOL(condition))
; 2242 : 
; 2243 :     // A simple ref-counted buffer class.  The interface is very similar to shared_ptr<>, only it manages
; 2244 :     // an allocated buffer and maintains the size.
; 2245 : 
; 2246 :     class shared_buffer
; 2247 :     {
; 2248 :     public:
; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2250 :         {
; 2251 :         }
; 2252 : 
; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);
; 2256 :         }
; 2257 : 
; 2258 :         shared_buffer(shared_buffer&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy), m_size(other.m_size)
; 2259 :         {
; 2260 :             other.m_pCopy = nullptr;
; 2261 :             other.m_size = 0;
; 2262 :         }
; 2263 : 
; 2264 :         ~shared_buffer() WI_NOEXCEPT
; 2265 :         {
; 2266 :             reset();
; 2267 :         }
; 2268 : 
; 2269 :         shared_buffer& operator=(shared_buffer const& other) WI_NOEXCEPT
; 2270 :         {
; 2271 :             if (this != wistd::addressof(other))
; 2272 :             {
; 2273 :                 assign(other.m_pCopy, other.m_size);
; 2274 :             }
; 2275 :             return *this;
; 2276 :         }
; 2277 : 
; 2278 :         shared_buffer& operator=(shared_buffer&& other) WI_NOEXCEPT
; 2279 :         {
; 2280 :             if (this != wistd::addressof(other))
; 2281 :             {
; 2282 :                 reset();
; 2283 :                 m_pCopy = other.m_pCopy;
; 2284 :                 m_size = other.m_size;
; 2285 :                 other.m_pCopy = nullptr;
; 2286 :                 other.m_size = 0;
; 2287 :             }
; 2288 :             return *this;
; 2289 :         }
; 2290 : 
; 2291 :         void reset() WI_NOEXCEPT
; 2292 :         {
; 2293 :             if (m_pCopy != nullptr)
; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))
; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);
; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;
; 2300 :                 m_size = 0;
; 2301 :             }
; 2302 :         }
; 2303 : 
; 2304 :         bool create(_In_reads_bytes_opt_(cbData) void const* pData, size_t cbData) WI_NOEXCEPT
; 2305 :         {
; 2306 :             if (cbData == 0)
; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));
; 2313 :             if (pCopyRefCount == nullptr)
; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;
; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }
; 2326 : 
; 2327 :         bool create(size_t cbData) WI_NOEXCEPT
; 2328 :         {
; 2329 :             return create(nullptr, cbData);
; 2330 :         }
; 2331 : 
; 2332 :         WI_NODISCARD void* get(_Out_opt_ size_t* pSize = nullptr) const WI_NOEXCEPT
; 2333 :         {
; 2334 :             if (pSize != nullptr)
; 2335 :             {
; 2336 :                 *pSize = m_size;
; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);
; 2339 :         }
; 2340 : 
; 2341 :         WI_NODISCARD size_t size() const WI_NOEXCEPT
; 2342 :         {
; 2343 :             return m_size;
; 2344 :         }
; 2345 : 
; 2346 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2347 :         {
; 2348 :             return (m_pCopy != nullptr);
; 2349 :         }
; 2350 : 
; 2351 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2352 :         {
; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));
; 2354 :         }
; 2355 : 
; 2356 :     private:
; 2357 :         long* m_pCopy; // pointer to allocation: refcount + data
; 2358 :         size_t m_size; // size of the data from m_pCopy
; 2359 : 
; 2360 :         void assign(_In_opt_ long* pCopy, size_t cbSize) WI_NOEXCEPT
; 2361 :         {
; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)
; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);
; 2368 :             }
; 2369 :         }
; 2370 :     };
; 2371 : 
; 2372 :     inline shared_buffer make_shared_buffer_nothrow(_In_reads_bytes_opt_(countBytes) void* pData, size_t countBytes) WI_NOEXCEPT
; 2373 :     {
; 2374 :         shared_buffer buffer;
; 2375 :         buffer.create(pData, countBytes);
; 2376 :         return buffer;
; 2377 :     }
; 2378 : 
; 2379 :     inline shared_buffer make_shared_buffer_nothrow(size_t countBytes) WI_NOEXCEPT
; 2380 :     {
; 2381 :         shared_buffer buffer;
; 2382 :         buffer.create(countBytes);
; 2383 :         return buffer;
; 2384 :     }
; 2385 : 
; 2386 :     // A small mimic of the STL shared_ptr class, but unlike shared_ptr, a pointer is not attached to the class, but is
; 2387 :     // always simply contained within (it cannot be attached or detached).
; 2388 : 
; 2389 :     template <typename object_t>
; 2390 :     class shared_object
; 2391 :     {
; 2392 :     public:
; 2393 :         shared_object() WI_NOEXCEPT : m_pCopy(nullptr)
; 2394 :         {
; 2395 :         }
; 2396 : 
; 2397 :         shared_object(shared_object const& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2398 :         {
; 2399 :             if (m_pCopy != nullptr)
; 2400 :             {
; 2401 :                 ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2402 :             }
; 2403 :         }
; 2404 : 
; 2405 :         shared_object(shared_object&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2406 :         {
; 2407 :             other.m_pCopy = nullptr;
; 2408 :         }
; 2409 : 
; 2410 :         ~shared_object() WI_NOEXCEPT
; 2411 :         {
; 2412 :             reset();
; 2413 :         }
; 2414 : 
; 2415 :         shared_object& operator=(shared_object const& other) WI_NOEXCEPT
; 2416 :         {
; 2417 :             if (this != wistd::addressof(other))
; 2418 :             {
; 2419 :                 reset();
; 2420 :                 m_pCopy = other.m_pCopy;
; 2421 :                 if (m_pCopy != nullptr)
; 2422 :                 {
; 2423 :                     ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2424 :                 }
; 2425 :             }
; 2426 :             return *this;
; 2427 :         }
; 2428 : 
; 2429 :         shared_object& operator=(shared_object&& other) WI_NOEXCEPT
; 2430 :         {
; 2431 :             if (this != wistd::addressof(other))
; 2432 :             {
; 2433 :                 reset();
; 2434 :                 m_pCopy = other.m_pCopy;
; 2435 :                 other.m_pCopy = nullptr;
; 2436 :             }
; 2437 :             return *this;
; 2438 :         }
; 2439 : 
; 2440 :         void reset() WI_NOEXCEPT
; 2441 :         {
; 2442 :             if (m_pCopy != nullptr)
; 2443 :             {
; 2444 :                 if (0 == ::InterlockedDecrementRelease(&m_pCopy->m_refCount))
; 2445 :                 {
; 2446 :                     delete m_pCopy;
; 2447 :                 }
; 2448 :                 m_pCopy = nullptr;
; 2449 :             }
; 2450 :         }
; 2451 : 
; 2452 :         bool create()
; 2453 :         {
; 2454 :             RefAndObject* pObject = new (std::nothrow) RefAndObject();
; 2455 :             if (pObject == nullptr)
; 2456 :             {
; 2457 :                 return false;
; 2458 :             }
; 2459 :             reset();
; 2460 :             m_pCopy = pObject;
; 2461 :             return true;
; 2462 :         }
; 2463 : 
; 2464 :         template <typename param_t>
; 2465 :         bool create(param_t&& param1)
; 2466 :         {
; 2467 :             RefAndObject* pObject = new (std::nothrow) RefAndObject(wistd::forward<param_t>(param1));
; 2468 :             if (pObject == nullptr)
; 2469 :             {
; 2470 :                 return false;
; 2471 :             }
; 2472 :             reset();
; 2473 :             m_pCopy = pObject;
; 2474 :             return true;
; 2475 :         }
; 2476 : 
; 2477 :         WI_NODISCARD object_t* get() const WI_NOEXCEPT
; 2478 :         {
; 2479 :             return (m_pCopy == nullptr) ? nullptr : &m_pCopy->m_object;
; 2480 :         }
; 2481 : 
; 2482 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2483 :         {
; 2484 :             return (m_pCopy != nullptr);
; 2485 :         }
; 2486 : 
; 2487 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2488 :         {
; 2489 :             return ((m_pCopy != nullptr) && (m_pCopy->m_refCount == 1));
; 2490 :         }
; 2491 : 
; 2492 :         WI_NODISCARD object_t* operator->() const WI_NOEXCEPT
; 2493 :         {
; 2494 :             return get();
; 2495 :         }
; 2496 : 
; 2497 :     private:
; 2498 :         struct RefAndObject
; 2499 :         {
; 2500 :             long m_refCount;
; 2501 :             object_t m_object;
; 2502 : 
; 2503 :             RefAndObject() : m_refCount(1), m_object()
; 2504 :             {
; 2505 :             }
; 2506 : 
; 2507 :             template <typename param_t>
; 2508 :             RefAndObject(param_t&& param1) : m_refCount(1), m_object(wistd::forward<param_t>(param1))
; 2509 :             {
; 2510 :             }
; 2511 :         };
; 2512 : 
; 2513 :         RefAndObject* m_pCopy;
; 2514 :     };
; 2515 : 
; 2516 :     // The following functions are basically the same, but are kept separated to:
; 2517 :     // 1) Provide a unique count and last error code per-type
; 2518 :     // 2) Avoid merging the types to allow easy debugging (breakpoints, conditional breakpoints based
; 2519 :     //      upon count of errors from a particular type, etc)
; 2520 :     __WI_PUSH_WARNINGS
; 2521 : #if __clang_major__ >= 13
; 2522 :     __WI_CLANG_DISABLE_WARNING(-Wunused-but-set-variable) // s_hrErrorLast used for debugging. We intentionally only assign to it
; 2523 : #endif
; 2524 :     __WI_MSVC_DISABLE_WARNING(4746) // s_hrErrorLast' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2525 : 
; 2526 :     __declspec(noinline) inline int RecordException(HRESULT hr) WI_NOEXCEPT
; 2527 :     {
; 2528 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2529 :         static long volatile s_cErrorCount = 0;
; 2530 :         s_hrErrorLast = hr;
; 2531 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2532 :     }
; 2533 : 
; 2534 :     __declspec(noinline) inline int RecordReturn(HRESULT hr) WI_NOEXCEPT
; 2535 :     {
; 2536 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2537 :         static long volatile s_cErrorCount = 0;
; 2538 :         s_hrErrorLast = hr;
; 2539 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2540 :     }
; 2541 : 
; 2542 :     __declspec(noinline) inline int RecordLog(HRESULT hr) WI_NOEXCEPT
; 2543 :     {
; 2544 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2545 :         static long volatile s_cErrorCount = 0;
; 2546 :         s_hrErrorLast = hr;
; 2547 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2548 :     }
; 2549 : 
; 2550 :     __declspec(noinline) inline int RecordFailFast(HRESULT hr) WI_NOEXCEPT
; 2551 :     {
; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;
; 2554 :         return 1;
; 2555 :     }
; 2556 :     __WI_POP_WARNINGS
; 2557 : 
; 2558 :     inline RESULT_NORETURN void __stdcall WilRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_opt_ PCONTEXT cr, _In_ DWORD flags)
; 2559 :     {
; 2560 :         // if we managed to load the pointer either through WilDynamicRaiseFailFastException (PARTITION_DESKTOP etc.)
; 2561 :         // or via direct linkage (e.g. UWP apps), then use it.
; 2562 :         if (g_pfnRaiseFailFastException)
; 2563 :         {
; 2564 :             g_pfnRaiseFailFastException(er, cr, flags);
; 2565 :         }
; 2566 :         // if not, as a best effort, we are just going to call the intrinsic.
; 2567 :         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
; 2568 :     }
; 2569 : 
; 2570 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2571 :     inline bool __stdcall GetModuleInformation(
; 2572 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_NOEXCEPT
; 2573 :     {
; 2574 :         HMODULE hModule = nullptr;
; 2575 :         if (address && !GetModuleHandleExW(
; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))
; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);
; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))
; 2599 :             {
; 2600 :                 start--;
; 2601 :             }
; 2602 :             StringCchCopyA(name, size, start);
; 2603 :         }
; 2604 :         return true;
; 2605 :     }
; 2606 : 
; 2607 :     __WI_PUSH_WARNINGS
; 2608 :     __WI_MSVC_DISABLE_WARNING(4746) // s_fModuleValid' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2609 :     inline PCSTR __stdcall GetCurrentModuleName() WI_NOEXCEPT
; 2610 :     {
; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable
; 2614 :         {
; 2615 :             GetModuleInformation(reinterpret_cast<void*>(&RecordFailFast), nullptr, s_szModule, ARRAYSIZE(s_szModule));
; 2616 :             s_fModuleValid = true;
; 2617 :         }
; 2618 :         return s_szModule;
; 2619 :     }
; 2620 :     __WI_POP_WARNINGS
; 2621 : 
; 2622 :     inline void __stdcall DebugBreak() WI_NOEXCEPT
; 2623 :     {
; 2624 :         ::DebugBreak();
; 2625 :     }
; 2626 : 
; 2627 :     inline void __stdcall WilDynamicLoadRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_ PCONTEXT cr, _In_ DWORD flags)
; 2628 :     {
; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");
; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)
; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);
; 2636 :         }
; 2637 :     }
; 2638 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2639 : 
; 2640 :     inline bool __stdcall GetModuleInformationFromAddress(
; 2641 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* buffer, size_t size) WI_NOEXCEPT
; 2642 :     {
; 2643 :         if (size > 0)
; 2644 :         {
; 2645 :             assign_to_opt_param(buffer, '\0');
; 2646 :         }
; 2647 :         if (addressOffset)
; 2648 :         {
; 2649 :             *addressOffset = 0;
; 2650 :         }
; 2651 :         if (g_pfnGetModuleInformation)
; 2652 :         {
; 2653 :             return g_pfnGetModuleInformation(address, addressOffset, buffer, size);
; 2654 :         }
; 2655 :         return false;
; 2656 :     }
; 2657 : 
; 2658 :     __declspec(noinline) inline HRESULT NtStatusToHr(NTSTATUS status) WI_NOEXCEPT
; 2659 :     {
; 2660 :         // The following conversions are the only known incorrect mappings in RtlNtStatusToDosErrorNoTeb
; 2661 :         if (SUCCEEDED_NTSTATUS(status))
; 2662 :         {
; 2663 :             // All successful status codes have only one hresult equivalent, S_OK
; 2664 :             return S_OK;
; 2665 :         }
; 2666 :         if (status == static_cast<NTSTATUS>(STATUS_NO_MEMORY))
; 2667 :         {
; 2668 :             // RtlNtStatusToDosErrorNoTeb maps STATUS_NO_MEMORY to the less popular of two Win32 no memory error codes resulting in an unexpected mapping
; 2669 :             return E_OUTOFMEMORY;
; 2670 :         }
; 2671 : 
; 2672 :         if (g_pfnRtlNtStatusToDosErrorNoTeb != nullptr)
; 2673 :         {
; 2674 :             DWORD err = g_pfnRtlNtStatusToDosErrorNoTeb(status);
; 2675 : 
; 2676 :             // ERROR_MR_MID_NOT_FOUND indicates a bug in the originator of the error (failure to add a mapping to the Win32 error codes).
; 2677 :             // There are known instances of this bug which are unlikely to be fixed soon, and it's always possible that additional instances
; 2678 :             // could be added in the future. In these cases, it's better to use HRESULT_FROM_NT rather than returning a meaningless error.
; 2679 :             if ((err != 0) && (err != ERROR_MR_MID_NOT_FOUND))
; 2680 :             {
; 2681 :                 return __HRESULT_FROM_WIN32(err);
; 2682 :             }
; 2683 :         }
; 2684 : 
; 2685 :         return HRESULT_FROM_NT(status);
; 2686 :     }
; 2687 : 
; 2688 :     __declspec(noinline) inline NTSTATUS HrToNtStatus(HRESULT hr) WI_NOEXCEPT
; 2689 :     {
; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)
; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;
; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;
; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;
; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;
; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;
; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;
; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;
; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;
; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;
; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;
; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;
; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;
; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;
; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;
; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;
; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;
; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;
; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;
; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;
; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;
; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)
; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);
; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));
; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)
; 2787 :             {
; 2788 :                 status =
; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }
; 2800 : 
; 2801 :     // The following set of functions all differ only based upon number of arguments.  They are unified in their handling
; 2802 :     // of data from each of the various error-handling types (fast fail, exceptions, etc.).
; 2803 :     _Post_equals_last_error_ inline DWORD GetLastErrorFail(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2804 :     {
; 2805 :         __R_FN_UNREFERENCED;
; 2806 :         auto err = ::GetLastError();
; 2807 :         if (SUCCEEDED_WIN32(err))
; 2808 :         {
; 2809 :             // This function should only be called when GetLastError() is set to a FAILURE.
; 2810 :             // If you hit this assert (or are reviewing this failure telemetry), then there are one of three issues:
; 2811 :             //  1) Your code is using a macro (such as RETURN_IF_WIN32_BOOL_FALSE()) on a function that does not actually
; 2812 :             //      set the last error (consult MSDN).
; 2813 :             //  2) Your macro check against the error is not immediately after the API call.  Pushing it later can result
; 2814 :             //      in another API call between the previous one and the check resetting the last error.
; 2815 :             //  3) The API you're calling has a bug in it and does not accurately set the last error (there are a few
; 2816 :             //      examples here, such as SendMessageTimeout() that don't accurately set the last error).
; 2817 :             //      [MSFT internal] For these, please send mail to 'wildisc' when found and work-around with win32errorhelpers.
; 2818 : 
; 2819 :             WI_USAGE_ERROR_FORWARD("CALLER BUG: Macro usage error detected.  GetLastError() does not have an error.");
; 2820 :             return ERROR_ASSERTION_FAILURE;
; 2821 :         }
; 2822 :         return err;
; 2823 :     }
; 2824 : 
; 2825 :     inline __declspec(noinline) DWORD GetLastErrorFail() WI_NOEXCEPT
; 2826 :     {
; 2827 :         __R_FN_LOCALS_FULL_RA;
; 2828 :         return GetLastErrorFail(__R_FN_CALL_FULL);
; 2829 :     }
; 2830 : 
; 2831 :     _Translates_last_error_to_HRESULT_
; 2832 :     inline HRESULT GetLastErrorFailHr(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2833 :     {
; 2834 :         return HRESULT_FROM_WIN32(GetLastErrorFail(__R_FN_CALL_FULL));
; 2835 :     }
; 2836 : 
; 2837 :     _Translates_last_error_to_HRESULT_
; 2838 :     inline __declspec(noinline) HRESULT GetLastErrorFailHr() WI_NOEXCEPT
; 2839 :     {
; 2840 :         __R_FN_LOCALS_FULL_RA;
; 2841 :         return GetLastErrorFailHr(__R_FN_CALL_FULL);
; 2842 :     }
; 2843 : 
; 2844 :     inline void PrintLoggingMessage(
; 2845 :         _Out_writes_(cchDest) _Post_z_ PWSTR pszDest,
; 2846 :         _Pre_satisfies_(cchDest > 0) size_t cchDest,
; 2847 :         _In_opt_ _Printf_format_string_ PCSTR formatString,
; 2848 :         _In_opt_ va_list argList) WI_NOEXCEPT
; 2849 :     {
; 2850 :         if (formatString == nullptr)
; 2851 :         {
; 2852 :             pszDest[0] = L'\0';
; 2853 :         }
; 2854 :         else if (argList == nullptr)
; 2855 :         {
; 2856 :             StringCchPrintfW(pszDest, cchDest, L"%hs", formatString);
; 2857 :         }
; 2858 :         else
; 2859 :         {
; 2860 :             wchar_t szFormatWide[2048];
; 2861 :             StringCchPrintfW(szFormatWide, ARRAYSIZE(szFormatWide), L"%hs", formatString);
; 2862 :             StringCchVPrintfW(pszDest, cchDest, szFormatWide, argList);
; 2863 :         }
; 2864 :     }
; 2865 : 
; 2866 : #pragma warning(push)
; 2867 : #pragma warning(disable : __WARNING_RETURNING_BAD_RESULT)
; 2868 :     // NOTE: The following two functions are unfortunate copies of strsafe.h functions that have been copied to reduce the friction associated with using
; 2869 :     // Result.h and ResultException.h in a build that does not have WINAPI_PARTITION_DESKTOP defined (where these are conditionally enabled).
; 2870 : 
; 2871 :     inline HRESULT WilStringLengthWorkerA(
; 2872 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2873 :         _In_ _In_range_(<=, STRSAFE_MAX_CCH) size_t cchMax,
; 2874 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2875 :     {
; 2876 :         HRESULT hr = S_OK;
; 2877 :         size_t cchOriginalMax = cchMax;
; 2878 :         while (cchMax && (*psz != '\0'))
; 2879 :         {
; 2880 :             psz++;
; 2881 :             cchMax--;
; 2882 :         }
; 2883 :         if (cchMax == 0)
; 2884 :         {
; 2885 :             // the string is longer than cchMax
; 2886 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2887 :         }
; 2888 :         if (pcchLength)
; 2889 :         {
; 2890 :             if (SUCCEEDED(hr))
; 2891 :             {
; 2892 :                 *pcchLength = cchOriginalMax - cchMax;
; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 *pcchLength = 0;
; 2897 :             }
; 2898 :         }
; 2899 :         return hr;
; 2900 :     }
; 2901 : 
; 2902 :     _Must_inspect_result_
; 2903 :     inline HRESULT StringCchLengthA(
; 2904 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2905 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
; 2906 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2907 :     {
; 2908 :         HRESULT hr = S_OK;
; 2909 :         if ((psz == nullptr) || (cchMax > STRSAFE_MAX_CCH))
; 2910 :         {
; 2911 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2912 :         }
; 2913 :         else
; 2914 :         {
; 2915 :             hr = WilStringLengthWorkerA(psz, cchMax, pcchLength);
; 2916 :         }
; 2917 :         if (FAILED(hr) && pcchLength)
; 2918 :         {
; 2919 :             *pcchLength = 0;
; 2920 :         }
; 2921 :         return hr;
; 2922 :     }
; 2923 : #pragma warning(pop)
; 2924 : 
; 2925 :     _Post_satisfies_(cchDest > 0 && cchDest <= cchMax) inline HRESULT
; 2926 :         WilStringValidateDestA(_In_reads_opt_(cchDest) PCNZCH /*pszDest*/, _In_ size_t cchDest, _In_ const size_t cchMax)
; 2927 :     {
; 2928 :         HRESULT hr = S_OK;
; 2929 :         if ((cchDest == 0) || (cchDest > cchMax))
; 2930 :         {
; 2931 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2932 :         }
; 2933 :         return hr;
; 2934 :     }
; 2935 : 
; 2936 :     inline HRESULT WilStringVPrintfWorkerA(
; 2937 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2938 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchDest,
; 2939 :         _Always_(_Out_opt_ _Deref_out_range_(<=, cchDest - 1)) size_t* pcchNewDestLength,
; 2940 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2941 :         _In_ va_list argList)
; 2942 :     {
; 2943 :         HRESULT hr = S_OK;
; 2944 :         int iRet{};
; 2945 : 
; 2946 :         // leave the last space for the null terminator
; 2947 :         size_t cchMax = cchDest - 1;
; 2948 :         size_t cchNewDestLength = 0;
; 2949 : #undef STRSAFE_USE_SECURE_CRT
; 2950 : #define STRSAFE_USE_SECURE_CRT 1
; 2951 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 2952 :         iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 2953 : #else
; 2954 : #pragma warning(push)
; 2955 : #pragma warning(disable : __WARNING_BANNED_API_USAGE) // "STRSAFE not included"
; 2956 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
; 2957 : #pragma warning(pop)
; 2958 : #endif
; 2959 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 2960 : 
; 2961 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))
; 2962 :         {
; 2963 :             // need to null terminate the string
; 2964 :             pszDest += cchMax;
; 2965 :             *pszDest = '\0';
; 2966 : 
; 2967 :             cchNewDestLength = cchMax;
; 2968 : 
; 2969 :             // we have truncated pszDest
; 2970 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 2971 :         }
; 2972 :         else if (((size_t)iRet) == cchMax)
; 2973 :         {
; 2974 :             // need to null terminate the string
; 2975 :             pszDest += cchMax;
; 2976 :             *pszDest = '\0';
; 2977 : 
; 2978 :             cchNewDestLength = cchMax;
; 2979 :         }
; 2980 :         else
; 2981 :         {
; 2982 :             cchNewDestLength = (size_t)iRet;
; 2983 :         }
; 2984 : 
; 2985 :         if (pcchNewDestLength)
; 2986 :         {
; 2987 :             *pcchNewDestLength = cchNewDestLength;
; 2988 :         }
; 2989 : 
; 2990 :         return hr;
; 2991 :     }
; 2992 : 
; 2993 :     inline HRESULT StringCchPrintfA(
; 2994 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2995 :         _In_ size_t cchDest,
; 2996 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2997 :         ...)
; 2998 :     {
; 2999 :         HRESULT hr;
; 3000 :         hr = wil::details::WilStringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 3001 :         if (SUCCEEDED(hr))
; 3002 :         {
; 3003 :             va_list argList;
; 3004 :             va_start(argList, pszFormat);
; 3005 :             hr = wil::details::WilStringVPrintfWorkerA(pszDest, cchDest, nullptr, pszFormat, argList);
; 3006 :             va_end(argList);
; 3007 :         }
; 3008 :         else if (cchDest > 0)
; 3009 :         {
; 3010 :             *pszDest = '\0';
; 3011 :         }
; 3012 :         return hr;
; 3013 :     }
; 3014 : 
; 3015 :     _Ret_range_(sizeof(char), (psz == nullptr) ? sizeof(char) : (_String_length_(psz) + sizeof(char)))
; 3016 :     inline size_t ResultStringSize(_In_opt_ PCSTR psz)
; 3017 :     {
; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));
; 3019 :     }
; 3020 : 
; 3021 :     _Ret_range_(sizeof(wchar_t), (psz == nullptr) ? sizeof(wchar_t) : ((_String_length_(psz) + 1) * sizeof(wchar_t)))
; 3022 :     inline size_t ResultStringSize(_In_opt_ PCWSTR psz)
; 3023 :     {
; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);
; 3025 :     }
; 3026 : 
; 3027 :     template <typename TString>
; 3028 :     _Ret_range_(pStart, pEnd)
; 3029 :     inline unsigned char* WriteResultString(
; 3030 :         _Pre_satisfies_(pStart <= pEnd) _When_((pStart == pEnd) || (pszString == nullptr) || (pszString[0] == 0), _In_opt_) _When_(
; 3031 :             (pStart != pEnd) && (pszString != nullptr) && (pszString[0] != 0),
; 3032 :             _Out_writes_bytes_opt_(_String_length_(pszString) * sizeof(pszString[0]))) unsigned char* pStart,
; 3033 :         _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd,
; 3034 :         _In_opt_z_ TString pszString,
; 3035 :         _Outptr_result_maybenull_z_ TString* ppszBufferString)
; 3036 :     {
; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)
; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;
; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;
; 3049 :         if (bufferSize < stringSize)
; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);
; 3056 :         assign_to_opt_param(
; 3057 :             ppszBufferString,
; 3058 :             reinterpret_cast<TString>(
; 3059 :                 pStart)); // lgtm[cpp/incorrect-string-type-conversion] False positive - The query is misinterpreting a buffer (char *) with a MBS string, the cast to TString is expected.
; 3060 :         return pStart + stringSize;
; 3061 :     }
; 3062 : 
; 3063 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3064 :     inline size_t UntrustedStringLength(_In_ PCSTR psz, _In_ size_t cchMax)
; 3065 :     {
; 3066 :         size_t cbLength;
; 3067 :         return SUCCEEDED(wil::details::StringCchLengthA(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3068 :     }
; 3069 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3070 :     inline size_t UntrustedStringLength(_In_ PCWSTR psz, _In_ size_t cchMax)
; 3071 :     {
; 3072 :         size_t cbLength;
; 3073 :         return SUCCEEDED(::StringCchLengthW(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3074 :     }
; 3075 : 
; 3076 :     template <typename TString>
; 3077 :     _Ret_range_(pStart, pEnd)
; 3078 :     inline unsigned char* GetResultString(
; 3079 :         _In_reads_to_ptr_opt_(pEnd) unsigned char* pStart, _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd, _Out_ TString* ppszBufferString)
; 3080 :     {
; 3081 :         size_t cchLen = UntrustedStringLength(reinterpret_cast<TString>(pStart), (pEnd - pStart) / sizeof((*ppszBufferString)[0]));
; 3082 :         *ppszBufferString = (cchLen > 0) ? reinterpret_cast<TString>(pStart) : nullptr;
; 3083 :         auto pReturn = (wistd::min)(pEnd, pStart + ((cchLen + 1) * sizeof((*ppszBufferString)[0])));
; 3084 :         __analysis_assume((pReturn >= pStart) && (pReturn <= pEnd));
; 3085 :         return pReturn;
; 3086 :     }
; 3087 : } // namespace details
; 3088 : /// @endcond
; 3089 : 
; 3090 : //*****************************************************************************
; 3091 : // WIL result handling initializers
; 3092 : //
; 3093 : // Generally, callers do not need to manually initialize WIL. This header creates
; 3094 : // the appropriate .CRT init section pieces through global objects to ensure that
; 3095 : // WilInitialize... is called before DllMain or main().
; 3096 : //
; 3097 : // Certain binaries do not link with the CRT or do not support .CRT-section based
; 3098 : // initializers. Those binaries must link only with other static libraries that
; 3099 : // also set RESULT_SUPPRESS_STATIC_INITIALIZERS to ensure no .CRT inits are left,
; 3100 : // and they should call one of the WilInitialize_ResultMacros_??? methods during
; 3101 : // their initialization phase.  Skipping this initialization path is OK as well,
; 3102 : // but results in a slightly degraded experience with result reporting.
; 3103 : //
; 3104 : // Calling WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse provides:
; 3105 : // - The name of the current module in wil::FailureInfo::pszModule
; 3106 : // - The name of the returning-to module during wil/staging.h failures
; 3107 : //*****************************************************************************
; 3108 : 
; 3109 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3110 : //! Call this method to initialize WIL manually in a module where RESULT_SUPPRESS_STATIC_INITIALIZERS is required. WIL will
; 3111 : //! only use publicly documented APIs.
; 3112 : inline void WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse()
; 3113 : {
; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }
; 3119 : 
; 3120 : /// @cond
; 3121 : namespace details
; 3122 : {
; 3123 : #ifndef RESULT_SUPPRESS_STATIC_INITIALIZERS
; 3124 : #if !defined(BUILD_WINDOWS) || defined(WIL_SUPPRESS_PRIVATE_API_USE)
; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {
; 3126 :         ::wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse();
; 3127 :         return 1;
; 3128 :     });
; 3129 : #endif
; 3130 : #endif
; 3131 : } // namespace details
; 3132 : /// @endcond
; 3133 : #else  // !WINAPI_PARTITION_DESKTOP, !WINAPI_PARTITION_SYSTEM, explicitly assume these modules can direct link
; 3134 : namespace details
; 3135 : {
; 3136 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_AppOnly, [] {
; 3137 :         g_pfnRaiseFailFastException = ::RaiseFailFastException;
; 3138 :         return 1;
; 3139 :     });
; 3140 : } // namespace details
; 3141 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3142 : 
; 3143 : //*****************************************************************************
; 3144 : // Public Error Handling Helpers
; 3145 : //*****************************************************************************
; 3146 : 
; 3147 : //! Call this method to determine if process shutdown is in progress (allows avoiding work during dll unload).
; 3148 : inline bool ProcessShutdownInProgress()
; 3149 : {
; 3150 :     return (details::g_processShutdownInProgress || (details::g_pfnDllShutdownInProgress ? details::g_pfnDllShutdownInProgress() : false));
; 3151 : }
; 3152 : 
; 3153 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down,
; 3154 : but the hosting DLL doesn't support CRT initializers (such as kernelbase.dll).  The hosting DLL is responsible for calling
; 3155 : Construct() and Destroy() to manually run the constructor and destructor during DLL load & unload.
; 3156 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3157 : called as is typical. */
; 3158 : template <class T>
; 3159 : class manually_managed_shutdown_aware_object
; 3160 : {
; 3161 : public:
; 3162 :     manually_managed_shutdown_aware_object() = default;
; 3163 :     manually_managed_shutdown_aware_object(manually_managed_shutdown_aware_object const&) = delete;
; 3164 :     void operator=(manually_managed_shutdown_aware_object const&) = delete;
; 3165 : 
; 3166 :     void construct()
; 3167 :     {
; 3168 :         void* var = &m_raw;
; 3169 :         ::new (var) T();
; 3170 :     }
; 3171 : 
; 3172 :     void destroy()
; 3173 :     {
; 3174 :         if (ProcessShutdownInProgress())
; 3175 :         {
; 3176 :             get().ProcessShutdown();
; 3177 :         }
; 3178 :         else
; 3179 :         {
; 3180 :             (&get())->~T();
; 3181 :         }
; 3182 :     }
; 3183 : 
; 3184 :     //! Retrieves a reference to the contained object
; 3185 :     T& get() WI_NOEXCEPT
; 3186 :     {
; 3187 :         return *reinterpret_cast<T*>(&m_raw);
; 3188 :     }
; 3189 : 
; 3190 : private:
; 3191 :     alignas(T) unsigned char m_raw[sizeof(T)];
; 3192 : };
; 3193 : 
; 3194 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down.
; 3195 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3196 : called as is typical. */
; 3197 : template <class T>
; 3198 : class shutdown_aware_object
; 3199 : {
; 3200 : public:
; 3201 :     shutdown_aware_object()
; 3202 :     {
; 3203 :         m_object.construct();
; 3204 :     }
; 3205 : 
; 3206 :     ~shutdown_aware_object()
; 3207 :     {
; 3208 :         m_object.destroy();
; 3209 :     }
; 3210 : 
; 3211 :     shutdown_aware_object(shutdown_aware_object const&) = delete;
; 3212 :     void operator=(shutdown_aware_object const&) = delete;
; 3213 : 
; 3214 :     //! Retrieves a reference to the contained object
; 3215 :     T& get() WI_NOEXCEPT
; 3216 :     {
; 3217 :         return m_object.get();
; 3218 :     }
; 3219 : 
; 3220 : private:
; 3221 :     manually_managed_shutdown_aware_object<T> m_object;
; 3222 : };
; 3223 : 
; 3224 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down. */
; 3225 : template <class T>
; 3226 : class object_without_destructor_on_shutdown
; 3227 : {
; 3228 : public:
; 3229 :     object_without_destructor_on_shutdown()
; 3230 :     {
; 3231 :         void* var = &m_raw;
; 3232 :         ::new (var) T();
; 3233 :     }
; 3234 : 
; 3235 :     ~object_without_destructor_on_shutdown()
; 3236 :     {
; 3237 :         if (!ProcessShutdownInProgress())
; 3238 :         {
; 3239 :             get().~T();
; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     object_without_destructor_on_shutdown(object_without_destructor_on_shutdown const&) = delete;
; 3244 :     void operator=(object_without_destructor_on_shutdown const&) = delete;
; 3245 : 
; 3246 :     //! Retrieves a reference to the contained object
; 3247 :     T& get() WI_NOEXCEPT
; 3248 :     {
; 3249 :         return *reinterpret_cast<T*>(&m_raw);
; 3250 :     }
; 3251 : 
; 3252 : private:
; 3253 :     alignas(T) unsigned char m_raw[sizeof(T)]{};
; 3254 : };
; 3255 : 
; 3256 : /** Forward your DLLMain to this function so that WIL can have visibility into whether a DLL unload is because
; 3257 : of termination or normal unload.  Note that when g_pfnDllShutdownInProgress is set, WIL attempts to make this
; 3258 : determination on its own without this callback.  Suppressing private APIs requires use of this. */
; 3259 : inline void DLLMain(HINSTANCE, DWORD reason, _In_opt_ LPVOID reserved)
; 3260 : {
; 3261 :     if (!details::g_processShutdownInProgress)
; 3262 :     {
; 3263 :         if ((reason == DLL_PROCESS_DETACH) && (reserved != nullptr))
; 3264 :         {
; 3265 :             details::g_processShutdownInProgress = true;
; 3266 :         }
; 3267 :     }
; 3268 : }
; 3269 : 
; 3270 : // [optionally] Plug in fallback telemetry reporting
; 3271 : // Normally, the callback is owned by including ResultLogging.h in the including module.  Alternatively a module
; 3272 : // could re-route fallback telemetry to any ONE specific provider by calling this method.
; 3273 : inline void SetResultTelemetryFallback(_In_opt_ decltype(details::g_pfnTelemetryCallback) callbackFunction)
; 3274 : {
; 3275 :     // Only ONE telemetry provider can own the fallback telemetry callback.
; 3276 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3277 :         (details::g_pfnTelemetryCallback == nullptr) || (callbackFunction == nullptr) ||
; 3278 :         (details::g_pfnTelemetryCallback == callbackFunction));
; 3279 :     details::g_pfnTelemetryCallback = callbackFunction;
; 3280 : }
; 3281 : 
; 3282 : // [optionally] Plug in result logging (do not use for telemetry)
; 3283 : // This provides the ability for a module to hook all failures flowing through the system for inspection
; 3284 : // and/or logging.
; 3285 : inline void SetResultLoggingCallback(_In_opt_ decltype(details::g_pfnLoggingCallback) callbackFunction)
; 3286 : {
; 3287 :     // Only ONE function can own the result logging callback
; 3288 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3289 :         (details::g_pfnLoggingCallback == nullptr) || (callbackFunction == nullptr) ||
; 3290 :         (details::g_pfnLoggingCallback == callbackFunction));
; 3291 :     details::g_pfnLoggingCallback = callbackFunction;
; 3292 : }
; 3293 : 
; 3294 : // [optionally] Plug in custom result messages
; 3295 : // There are some purposes that require translating the full information that is known about a failure
; 3296 : // into a message to be logged (either through the console for debugging OR as the message attached
; 3297 : // to a Platform::Exception^).  This callback allows a module to format the string itself away from the
; 3298 : // default.
; 3299 : inline void SetResultMessageCallback(_In_opt_ decltype(wil::g_pfnResultLoggingCallback) callbackFunction)
; 3300 : {
; 3301 :     // Only ONE function can own the result message callback
; 3302 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3303 :         (g_pfnResultLoggingCallback == nullptr) || (callbackFunction == nullptr) || (g_pfnResultLoggingCallback == callbackFunction));
; 3304 :     details::g_resultMessageCallbackSet = true;
; 3305 :     g_pfnResultLoggingCallback = callbackFunction;
; 3306 : }
; 3307 : 
; 3308 : // [optionally] Plug in exception remapping
; 3309 : // A module can plug a callback in using this function to setup custom exception handling to allow any
; 3310 : // exception type to be converted into an HRESULT from exception barriers.
; 3311 : inline void SetResultFromCaughtExceptionCallback(_In_opt_ decltype(wil::g_pfnResultFromCaughtException) callbackFunction)
; 3312 : {
; 3313 :     // Only ONE function can own the exception conversion
; 3314 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3315 :         (g_pfnResultFromCaughtException == nullptr) || (callbackFunction == nullptr) ||
; 3316 :         (g_pfnResultFromCaughtException == callbackFunction));
; 3317 :     g_pfnResultFromCaughtException = callbackFunction;
; 3318 : }
; 3319 : 
; 3320 : // [optionally] Plug in exception remapping
; 3321 : // This provides the ability for a module to call RoOriginateError in case of a failure.
; 3322 : // Normally, the callback is owned by including result_originate.h in the including module.  Alternatively a module
; 3323 : // could re-route error origination callback to its own implementation.
; 3324 : inline void SetOriginateErrorCallback(_In_opt_ decltype(details::g_pfnOriginateCallback) callbackFunction)
; 3325 : {
; 3326 :     // Only ONE function can own the error origination callback
; 3327 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3328 :         (details::g_pfnOriginateCallback == nullptr) || (callbackFunction == nullptr) ||
; 3329 :         (details::g_pfnOriginateCallback == callbackFunction));
; 3330 :     details::g_pfnOriginateCallback = callbackFunction;
; 3331 : }
; 3332 : 
; 3333 : // [optionally] Plug in failfast callback
; 3334 : // This provides the ability for a module to call RoFailFastWithErrorContext in the failfast handler -if- there is stowed
; 3335 : // exception data available.  Normally, the callback is owned by including result_originate.h in the including module.
; 3336 : // Alternatively a module could re-route to its own implementation.
; 3337 : inline void SetFailfastWithContextCallback(_In_opt_ decltype(details::g_pfnFailfastWithContextCallback) callbackFunction)
; 3338 : {
; 3339 :     // Only ONE function can own the failfast with context callback
; 3340 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3341 :         (details::g_pfnFailfastWithContextCallback == nullptr) || (callbackFunction == nullptr) ||
; 3342 :         (details::g_pfnFailfastWithContextCallback == callbackFunction));
; 3343 :     details::g_pfnFailfastWithContextCallback = callbackFunction;
; 3344 : }
; 3345 : 
; 3346 : // A RAII wrapper around the storage of a FailureInfo struct (which is normally meant to be consumed
; 3347 : // on the stack or from the caller).  The storage of FailureInfo needs to copy some data internally
; 3348 : // for lifetime purposes.
; 3349 : 
; 3350 : class StoredFailureInfo
; 3351 : {
; 3352 : public:
; 3353 :     StoredFailureInfo() WI_NOEXCEPT
; 3354 :     {
; 3355 :         ::ZeroMemory(&m_failureInfo, sizeof(m_failureInfo));
; 3356 :     }
; 3357 : 
; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT
; 3359 :     {
; 3360 :         SetFailureInfo(other);
; 3361 :     }
; 3362 : 
; 3363 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3364 :     {
; 3365 :         return m_failureInfo;
; 3366 :     }
; 3367 : 
; 3368 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3369 :     {
; 3370 :         m_failureInfo = failure;
; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +
; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))
; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);
; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;
; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);
; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);
; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);
; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);
; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);
; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);
; 3398 :             pBuffer = details::WriteResultString(
; 3399 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextName, &m_failureInfo.callContextCurrent.contextName);
; 3400 :             pBuffer = details::WriteResultString(
; 3401 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextMessage, &m_failureInfo.callContextCurrent.contextMessage);
; 3402 :             pBuffer = details::WriteResultString(
; 3403 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextName, &m_failureInfo.callContextOriginating.contextName);
; 3404 :             pBuffer = details::WriteResultString(
; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);
; 3407 :         }
; 3408 :     }
; 3409 : 
; 3410 :     // Relies upon generated copy constructor and assignment operator
; 3411 : 
; 3412 : protected:
; 3413 :     FailureInfo m_failureInfo;
; 3414 :     details::shared_buffer m_spStrings;
; 3415 : };
; 3416 : 
; 3417 : #if defined(WIL_ENABLE_EXCEPTIONS) || defined(WIL_FORCE_INCLUDE_RESULT_EXCEPTION)
; 3418 : 
; 3419 : //! This is WIL's default exception class thrown from all THROW_XXX macros (outside of c++/cx).
; 3420 : //! This class stores all of the FailureInfo context that is available when the exception is thrown.  It's also caught by
; 3421 : //! exception guards for automatic conversion to HRESULT.
; 3422 : //!
; 3423 : //! In c++/cx, Platform::Exception^ is used instead of this class (unless @ref wil::g_fResultThrowPlatformException has been
; 3424 : //! changed).
; 3425 : class ResultException : public std::exception
; 3426 : {
; 3427 : public:
; 3428 :     //! Constructs a new ResultException from an existing FailureInfo.
; 3429 :     ResultException(const FailureInfo& failure) WI_NOEXCEPT : m_failure(failure)
; 3430 :     {
; 3431 :     }
; 3432 : 
; 3433 :     //! Constructs a new exception type from a given HRESULT (use only for constructing custom exception types).
; 3434 :     ResultException(_Pre_satisfies_(hr < 0) HRESULT hr) WI_NOEXCEPT : m_failure(CustomExceptionFailureInfo(hr))
; 3435 :     {
; 3436 :     }
; 3437 : 
; 3438 :     //! Returns the failed HRESULT that this exception represents.
; 3439 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) HRESULT GetErrorCode() const WI_NOEXCEPT
; 3440 :     {
; 3441 :         HRESULT const hr = m_failure.GetFailureInfo().hr;
; 3442 :         __analysis_assume(hr < 0);
; 3443 :         return hr;
; 3444 :     }
; 3445 : 
; 3446 :     //! Returns the failed NTSTATUS that this exception represents.
; 3447 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) NTSTATUS GetStatusCode() const WI_NOEXCEPT
; 3448 :     {
; 3449 :         NTSTATUS const status = m_failure.GetFailureInfo().status;
; 3450 :         __analysis_assume(status < 0);
; 3451 :         return status;
; 3452 :     }
; 3453 : 
; 3454 :     //! Get a reference to the stored FailureInfo.
; 3455 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3456 :     {
; 3457 :         return m_failure.GetFailureInfo();
; 3458 :     }
; 3459 : 
; 3460 :     //! Sets the stored FailureInfo (use primarily only when constructing custom exception types).
; 3461 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3462 :     {
; 3463 :         m_failure.SetFailureInfo(failure);
; 3464 :     }
; 3465 : 
; 3466 :     //! Provides a string representing the FailureInfo from this exception.
; 3467 :     WI_NODISCARD inline const char* __CLR_OR_THIS_CALL what() const WI_NOEXCEPT override
; 3468 :     {
; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)
; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);
; 3476 :             if (!m_what.create(len))
; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";
; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);
; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());
; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }
; 3498 : 
; 3499 :     // Relies upon auto-generated copy constructor and assignment operator
; 3500 : protected:
; 3501 :     StoredFailureInfo m_failure;           //!< The failure information for this exception
; 3502 :     mutable details::shared_buffer m_what; //!< The on-demand generated what() string
; 3503 : 
; 3504 :     //! Use to produce a custom FailureInfo from an HRESULT (use only when constructing custom exception types).
; 3505 :     static FailureInfo CustomExceptionFailureInfo(HRESULT hr) WI_NOEXCEPT
; 3506 :     {
; 3507 :         FailureInfo fi = {};
; 3508 :         fi.type = FailureType::Exception;
; 3509 :         fi.hr = hr;
; 3510 :         return fi;
; 3511 :     }
; 3512 : };
; 3513 : #endif
; 3514 : 
; 3515 : //*****************************************************************************
; 3516 : // Public Helpers that catch -- mostly only enabled when exceptions are enabled
; 3517 : //*****************************************************************************
; 3518 : 
; 3519 : // ResultFromCaughtException is a function that is meant to be called from within a catch(...) block.  Internally
; 3520 : // it re-throws and catches the exception to convert it to an HRESULT.  If an exception is of an unrecognized type
; 3521 : // the function will fail fast.
; 3522 : //
; 3523 : // try
; 3524 : // {
; 3525 : //     // Code
; 3526 : // }
; 3527 : // catch (...)
; 3528 : // {
; 3529 : //     hr = wil::ResultFromCaughtException();
; 3530 : // }
; 3531 : _Always_(_Post_satisfies_(return < 0)) __declspec(noinline) inline HRESULT ResultFromCaughtException() WI_NOEXCEPT
; 3532 : {
; 3533 :     bool isNormalized = false;
; 3534 :     HRESULT hr = S_OK;
; 3535 :     if (details::g_pfnResultFromCaughtExceptionInternal)
; 3536 :     {
; 3537 :         hr = details::g_pfnResultFromCaughtExceptionInternal(nullptr, 0, &isNormalized).hr;
; 3538 :     }
; 3539 :     if (FAILED(hr))
; 3540 :     {
; 3541 :         return hr;
; 3542 :     }
; 3543 : 
; 3544 :     // Caller bug: an unknown exception was thrown
; 3545 :     __WIL_PRIVATE_FAIL_FAST_HR_IF(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION), g_fResultFailFastUnknownExceptions);
; 3546 :     return __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3547 : }
; 3548 : 
; 3549 : //! Identical to 'throw;', but can be called from error-code neutral code to rethrow in code that *may* be running under an
; 3550 : //! exception context
; 3551 : inline void RethrowCaughtException()
; 3552 : {
; 3553 :     // We always want to rethrow the exception under normal circumstances.  Ordinarily, we could actually guarantee
; 3554 :     // this as we should be able to rethrow if we caught an exception, but if we got here in the middle of running
; 3555 :     // dynamic initializers, then it's possible that we haven't yet setup the rethrow function pointer, thus the
; 3556 :     // runtime check without the noreturn annotation.
; 3557 : 
; 3558 :     if (details::g_pfnRethrow)
; 3559 :     {
; 3560 :         details::g_pfnRethrow();
; 3561 :     }
; 3562 : }
; 3563 : 
; 3564 : //! Identical to 'throw ResultException(failure);', but can be referenced from error-code neutral code
; 3565 : inline void ThrowResultException(const FailureInfo& failure)
; 3566 : {
; 3567 :     if (details::g_pfnThrowResultException)
; 3568 :     {
; 3569 :         details::g_pfnThrowResultException(failure);
; 3570 :     }
; 3571 : }
; 3572 : 
; 3573 : /// @cond
; 3574 : namespace details
; 3575 : {
; 3576 : #ifdef WIL_ENABLE_EXCEPTIONS
; 3577 :     //*****************************************************************************
; 3578 :     // Private helpers to catch and propagate exceptions
; 3579 :     //*****************************************************************************
; 3580 : 
; 3581 :     RESULT_NORETURN inline void TerminateAndReportError(_In_opt_ PEXCEPTION_POINTERS)
; 3582 :     {
; 3583 :         // This is an intentional fail-fast that was caught by an exception guard with WIL.  Look back up the callstack to
; 3584 :         // determine the source of the actual exception being thrown.  The exception guard used by the calling code did not expect
; 3585 :         // this exception type to be thrown or is specifically requesting fail-fast for this class of exception.
; 3586 : 
; 3587 :         FailureInfo failure{};
; 3588 :         WilFailFast(failure);
; 3589 :     }
; 3590 : 
; 3591 :     inline void MaybeGetExceptionString(
; 3592 :         const ResultException& exception,
; 3593 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3594 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3595 :     {
; 3596 :         if (debugString)
; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());
; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$5|

; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);

	ldp         x2,x1,[fp,#0x20]
	ldr         x0,[fp,#0x50]
	bl          |?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	ldr         w0,|$LN82@catch$4|
	str         w0,[fp,#0x10]
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|
	stp         w0,wzr,[fp,#0x14]

; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);

	adrp        x0,|$LN23@catch$4|
	add         x0,x0,|$LN23@catch$4|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3
	nop
|$LN82@catch$4|
	DCD         0x8007000e

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$5@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$5

; 1939 :         }
; 1940 :         static ResultStatus FromStatus(const NTSTATUS _status)
; 1941 :         {
; 1942 :             return {wil::details::NtStatusToHr(_status), _status, Kind::NtStatus};
; 1943 :         }
; 1944 :         static ResultStatus FromFailureInfo(const FailureInfo& _failure)
; 1945 :         {
; 1946 :             return {_failure.hr, _failure.status, WI_IsFlagSet(_failure.flags, FailureFlags::NtStatus) ? Kind::NtStatus : Kind::HResult};
; 1947 :         }
; 1948 :         HRESULT hr = S_OK;
; 1949 :         NTSTATUS status = STATUS_SUCCESS;
; 1950 :         Kind kind = Kind::NtStatus;
; 1951 :     };
; 1952 : 
; 1953 :     // Fallback telemetry provider callback (set with wil::SetResultTelemetryFallback)
; 1954 :     __declspec(selectany) void(__stdcall* g_pfnTelemetryCallback)(bool alreadyReported, wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1955 : 
; 1956 :     // Result.h plug-in (WIL use only)
; 1957 :     __declspec(selectany) void(__stdcall* g_pfnNotifyFailure)(_Inout_ FailureInfo* pFailure) WI_PFN_NOEXCEPT = nullptr;
; 1958 :     __declspec(selectany) void(__stdcall* g_pfnGetContextAndNotifyFailure)(
; 1959 :         _Inout_ FailureInfo* pFailure,
; 1960 :         _Out_writes_(callContextStringLength) _Post_z_ PSTR callContextString,
; 1961 :         _Pre_satisfies_(callContextStringLength > 0) size_t callContextStringLength) WI_PFN_NOEXCEPT = nullptr;
; 1962 : 
; 1963 :     // Observe all errors flowing through the system with this callback (set with wil::SetResultLoggingCallback); use with custom logging
; 1964 :     __declspec(selectany) void(__stdcall* g_pfnLoggingCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 1965 : 
; 1966 :     // Desktop/System Only:  Module fetch function (automatically setup)
; 1967 :     __declspec(selectany) PCSTR(__stdcall* g_pfnGetModuleName)() WI_PFN_NOEXCEPT = nullptr;
; 1968 : 
; 1969 :     // Desktop/System Only:  Retrieve address offset and modulename
; 1970 :     __declspec(selectany) bool(__stdcall* g_pfnGetModuleInformation)(
; 1971 :         void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_PFN_NOEXCEPT = nullptr;
; 1972 : 
; 1973 :     // Called with the expectation that the program will terminate when called inside of a loader callout.
; 1974 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1975 :     __declspec(selectany) void(__stdcall* g_pfnFailFastInLoaderCallout)() WI_PFN_NOEXCEPT = nullptr;
; 1976 : 
; 1977 :     // Called to translate an NTSTATUS value to a Win32 error code
; 1978 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1979 :     __declspec(selectany) ULONG(__stdcall* g_pfnRtlNtStatusToDosErrorNoTeb)(NTSTATUS) WI_PFN_NOEXCEPT = nullptr;
; 1980 : 
; 1981 :     // Desktop/System Only: Call to DebugBreak
; 1982 :     __declspec(selectany) void(__stdcall* g_pfnDebugBreak)() WI_PFN_NOEXCEPT = nullptr;
; 1983 : 
; 1984 :     // Called to determine whether or not termination is happening
; 1985 :     // Desktop/System Only: Automatically setup when building Windows (BUILD_WINDOWS defined)
; 1986 :     __declspec(selectany) BOOLEAN(__stdcall* g_pfnDllShutdownInProgress)() WI_PFN_NOEXCEPT = nullptr;
; 1987 :     __declspec(selectany) bool g_processShutdownInProgress = false;
; 1988 : 
; 1989 :     // On Desktop/System WINAPI family: dynalink RaiseFailFastException because we may encounter modules
; 1990 :     // that do not have RaiseFailFastException in kernelbase.  UWP apps will directly link.
; 1991 :     __declspec(selectany) void(__stdcall* g_pfnRaiseFailFastException)(PEXCEPTION_RECORD, PCONTEXT, DWORD) = nullptr;
; 1992 : 
; 1993 :     // Exception-based compiled additions
; 1994 :     __declspec(selectany) HRESULT(__stdcall* g_pfnRunFunctorWithExceptionFilter)(IFunctor& functor, IFunctorHost& host, void* returnAddress) = nullptr;
; 1995 :     __declspec(selectany) void(__stdcall* g_pfnRethrow)() = nullptr;
; 1996 :     __declspec(selectany) void(__stdcall* g_pfnThrowResultException)(const FailureInfo& failure) = nullptr;
; 1997 :     extern "C" __declspec(selectany) ResultStatus(__stdcall* g_pfnResultFromCaughtExceptionInternal)(
; 1998 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 1999 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2000 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2001 : 
; 2002 :     // C++/WinRT additions
; 2003 :     extern "C" __declspec(selectany) HRESULT(__stdcall* g_pfnResultFromCaughtException_CppWinRt)(
; 2004 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 2005 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2006 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2007 : 
; 2008 :     // C++/cx compiled additions
; 2009 :     extern "C" __declspec(selectany) void(__stdcall* g_pfnThrowPlatformException)(FailureInfo const& failure, PCWSTR debugString) = nullptr;
; 2010 :     extern "C" __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromCaughtException_WinRt)(
; 2011 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 2012 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 2013 :         _Out_ bool* isNormalized) WI_PFN_NOEXCEPT = nullptr;
; 2014 :     __declspec(selectany) _Always_(_Post_satisfies_(return < 0)) HRESULT(__stdcall* g_pfnResultFromKnownExceptions_WinRt)(
; 2015 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor) = nullptr;
; 2016 : 
; 2017 :     // Plugin to call RoOriginateError (WIL use only)
; 2018 :     __declspec(selectany) void(__stdcall* g_pfnOriginateCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2019 : 
; 2020 :     // Plugin to call RoFailFastWithErrorContext (WIL use only)
; 2021 :     __declspec(selectany) void(__stdcall* g_pfnFailfastWithContextCallback)(wil::FailureInfo const& failure) WI_PFN_NOEXCEPT = nullptr;
; 2022 : 
; 2023 :     // Allocate and disown the allocation so that Appverifier does not complain about a false leak
; 2024 :     inline PVOID ProcessHeapAlloc(_In_ DWORD flags, _In_ size_t size) WI_NOEXCEPT
; 2025 :     {
; 2026 :         const HANDLE processHeap = ::GetProcessHeap();
; 2027 :         const PVOID allocation = ::HeapAlloc(processHeap, flags, size);
; 2028 : 
; 2029 :         static bool fetchedRtlDisownModuleHeapAllocation = false;
; 2030 :         static NTSTATUS(__stdcall * pfnRtlDisownModuleHeapAllocation)(HANDLE, PVOID) WI_PFN_NOEXCEPT = nullptr;
; 2031 : 
; 2032 :         if (pfnRtlDisownModuleHeapAllocation)
; 2033 :         {
; 2034 :             (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2035 :         }
; 2036 :         else if (!fetchedRtlDisownModuleHeapAllocation)
; 2037 :         {
; 2038 :             if (auto ntdllModule = ::GetModuleHandleW(L"ntdll.dll"))
; 2039 :             {
; 2040 :                 pfnRtlDisownModuleHeapAllocation =
; 2041 :                     details::GetProcAddress<decltype(pfnRtlDisownModuleHeapAllocation)>(ntdllModule, "RtlDisownModuleHeapAllocation");
; 2042 :             }
; 2043 :             fetchedRtlDisownModuleHeapAllocation = true;
; 2044 : 
; 2045 :             if (pfnRtlDisownModuleHeapAllocation)
; 2046 :             {
; 2047 :                 (void)pfnRtlDisownModuleHeapAllocation(processHeap, allocation);
; 2048 :             }
; 2049 :         }
; 2050 : 
; 2051 :         return allocation;
; 2052 :     }
; 2053 : 
; 2054 :     enum class ReportFailureOptions
; 2055 :     {
; 2056 :         None = 0x00,
; 2057 :         ForcePlatformException = 0x01,
; 2058 :         MayRethrow = 0x02,
; 2059 :     };
; 2060 :     DEFINE_ENUM_FLAG_OPERATORS(ReportFailureOptions);
; 2061 : 
; 2062 :     template <typename TFunctor>
; 2063 :     using functor_return_type = decltype((*static_cast<TFunctor*>(nullptr))());
; 2064 : 
; 2065 :     template <typename TFunctor>
; 2066 :     struct functor_wrapper_void : public IFunctor
; 2067 :     {
; 2068 :         TFunctor&& functor;
; 2069 :         functor_wrapper_void(TFunctor&& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2070 :         {
; 2071 :         }
; 2072 : #pragma warning(push)
; 2073 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2074 :         HRESULT Run() override
; 2075 :         {
; 2076 :             functor();
; 2077 :             return S_OK;
; 2078 :         }
; 2079 : #pragma warning(pop)
; 2080 :     };
; 2081 : 
; 2082 :     template <typename TFunctor>
; 2083 :     struct functor_wrapper_HRESULT : public IFunctor
; 2084 :     {
; 2085 :         TFunctor&& functor;
; 2086 :         functor_wrapper_HRESULT(TFunctor& functor_) : functor(wistd::forward<TFunctor>(functor_))
; 2087 :         {
; 2088 :         }
; 2089 :         HRESULT Run() override
; 2090 :         {
; 2091 :             return functor();
; 2092 :         }
; 2093 :     };
; 2094 : 
; 2095 :     template <typename TFunctor, typename TReturn>
; 2096 :     struct functor_wrapper_other : public IFunctor
; 2097 :     {
; 2098 :         TFunctor&& functor;
; 2099 :         TReturn& retVal;
; 2100 :         functor_wrapper_other(TFunctor& functor_, TReturn& retval_) : functor(wistd::forward<TFunctor>(functor_)), retVal(retval_)
; 2101 :         {
; 2102 :         }
; 2103 : #pragma warning(push)
; 2104 : #pragma warning(disable : 4702) // https://github.com/Microsoft/wil/issues/2
; 2105 :         HRESULT Run() override
; 2106 :         {
; 2107 :             retVal = functor();
; 2108 :             return S_OK;
; 2109 :         }
; 2110 : #pragma warning(pop)
; 2111 :     };
; 2112 : 
; 2113 :     struct tag_return_void : public wistd::integral_constant<size_t, 0>
; 2114 :     {
; 2115 :         template <typename TFunctor>
; 2116 :         using functor_wrapper = functor_wrapper_void<TFunctor>;
; 2117 :     };
; 2118 : 
; 2119 :     struct tag_return_HRESULT : public wistd::integral_constant<size_t, 1>
; 2120 :     {
; 2121 :         template <typename TFunctor>
; 2122 :         using functor_wrapper = functor_wrapper_HRESULT<TFunctor>;
; 2123 :     };
; 2124 : 
; 2125 :     struct tag_return_other : public wistd::integral_constant<size_t, 2>
; 2126 :     {
; 2127 :         template <typename TFunctor, typename TReturn>
; 2128 :         using functor_wrapper = functor_wrapper_other<TFunctor, TReturn>;
; 2129 :     };
; 2130 : 
; 2131 :     // type-trait to help discover the return type of a functor for tag/dispatch.
; 2132 : 
; 2133 :     template <ErrorReturn errorReturn, typename T>
; 2134 :     struct return_type
; 2135 :     {
; 2136 :         using type = tag_return_other;
; 2137 :     };
; 2138 : 
; 2139 :     template <>
; 2140 :     struct return_type<ErrorReturn::Auto, HRESULT>
; 2141 :     {
; 2142 :         using type = tag_return_HRESULT;
; 2143 :     };
; 2144 : 
; 2145 :     template <>
; 2146 :     struct return_type<ErrorReturn::Auto, void>
; 2147 :     {
; 2148 :         using type = tag_return_void;
; 2149 :     };
; 2150 : 
; 2151 :     template <>
; 2152 :     struct return_type<ErrorReturn::None, void>
; 2153 :     {
; 2154 :         using type = tag_return_void;
; 2155 :     };
; 2156 : 
; 2157 :     template <ErrorReturn errorReturn, typename Functor>
; 2158 :     using functor_tag = typename return_type<errorReturn, functor_return_type<Functor>>::type;
; 2159 : 
; 2160 :     // Forward declarations to enable use of fail fast and reporting internally...
; 2161 :     namespace __R_NS_NAME
; 2162 :     {
; 2163 :         _Post_satisfies_(return == hr) __R_DIRECT_METHOD(HRESULT, Log_Hr)(__R_DIRECT_FN_PARAMS HRESULT hr) WI_NOEXCEPT;
; 2164 :         _Post_satisfies_(return == hr)
; 2165 :             __R_DIRECT_METHOD(HRESULT, Log_HrMsg)(__R_DIRECT_FN_PARAMS HRESULT hr, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2166 :         _Post_satisfies_(return == err)
; 2167 :             __R_DIRECT_METHOD(DWORD, Log_Win32Msg)(__R_DIRECT_FN_PARAMS DWORD err, _Printf_format_string_ PCSTR formatString, ...) WI_NOEXCEPT;
; 2168 :     } // namespace __R_NS_NAME
; 2169 :     namespace __RFF_NS_NAME
; 2170 :     {
; 2171 :         __RFF_DIRECT_NORET_METHOD(void, FailFast_Unexpected)(__RFF_DIRECT_FN_PARAMS_ONLY) WI_NOEXCEPT;
; 2172 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2173 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_If)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2174 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2175 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_HrIf)(__RFF_CONDITIONAL_FN_PARAMS HRESULT hr, bool condition) WI_NOEXCEPT;
; 2176 :         _Post_satisfies_(return == condition) _When_(!condition, _Analysis_noreturn_)
; 2177 :         __RFF_CONDITIONAL_METHOD(bool, FailFast_IfFalse)(__RFF_CONDITIONAL_FN_PARAMS bool condition) WI_NOEXCEPT;
; 2178 :         _Post_satisfies_(return == condition) _When_(condition, _Analysis_noreturn_)
; 2179 :         __RFF_CONDITIONAL_METHOD(bool, FailFastImmediate_If)(bool condition) WI_NOEXCEPT;
; 2180 :     } // namespace __RFF_NS_NAME
; 2181 : 
; 2182 :     RESULT_NORETURN inline void __stdcall WilFailFast(const FailureInfo& info);
; 2183 :     inline void LogFailure(
; 2184 :         __R_FN_PARAMS_FULL,
; 2185 :         FailureType type,
; 2186 :         const ResultStatus& resultPair,
; 2187 :         _In_opt_ PCWSTR message,
; 2188 :         bool fWantDebugString,
; 2189 :         _Out_writes_(debugStringSizeChars) _Post_z_ PWSTR debugString,
; 2190 :         _Pre_satisfies_(debugStringSizeChars > 0) size_t debugStringSizeChars,
; 2191 :         _Out_writes_(callContextStringSizeChars) _Post_z_ PSTR callContextString,
; 2192 :         _Pre_satisfies_(callContextStringSizeChars > 0) size_t callContextStringSizeChars,
; 2193 :         FailureFlags flags,
; 2194 :         _Out_ FailureInfo* failure) WI_NOEXCEPT;
; 2195 : 
; 2196 :     __declspec(noinline) inline void ReportFailure(
; 2197 :         __R_FN_PARAMS_FULL,
; 2198 :         FailureType type,
; 2199 :         const ResultStatus& resultPair,
; 2200 :         _In_opt_ PCWSTR message = nullptr,
; 2201 :         ReportFailureOptions options = ReportFailureOptions::None);
; 2202 :     template <FailureType, bool = false>
; 2203 :     __declspec(noinline) inline void ReportFailure_Base(
; 2204 :         __R_FN_PARAMS_FULL,
; 2205 :         const ResultStatus& resultPair,
; 2206 :         _In_opt_ PCWSTR message = nullptr,
; 2207 :         ReportFailureOptions options = ReportFailureOptions::None,
; 2208 :         FailureFlags flags = FailureFlags::None);
; 2209 :     template <FailureType>
; 2210 :     inline void ReportFailure_ReplaceMsg(__R_FN_PARAMS_FULL, HRESULT hr, _Printf_format_string_ PCSTR formatString, ...);
; 2211 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, FailureType type, HRESULT hr);
; 2212 :     template <FailureType>
; 2213 :     __declspec(noinline) inline void ReportFailure_Hr(__R_FN_PARAMS_FULL, HRESULT hr, FailureFlags flags = FailureFlags::None);
; 2214 :     template <FailureType>
; 2215 :     __declspec(noinline) inline HRESULT ReportFailure_CaughtException(
; 2216 :         __R_FN_PARAMS_FULL, SupportedExceptions supported = SupportedExceptions::Default);
; 2217 : 
; 2218 : //*****************************************************************************
; 2219 : // Fail fast helpers (for use only internally to WIL)
; 2220 : //*****************************************************************************
; 2221 : 
; 2222 : /// @cond
; 2223 : #define __FAIL_FAST_ASSERT__(condition) \
; 2224 :     do \
; 2225 :     { \
; 2226 :         if (!(condition)) \
; 2227 :         { \
; 2228 :             __RFF_FN(FailFast_Unexpected)(__RFF_INFO_ONLY(#condition)); \
; 2229 :         } \
; 2230 :     } while ((void)0, 0)
; 2231 : #define __FAIL_FAST_IMMEDIATE_ASSERT__(condition) \
; 2232 :     do \
; 2233 :     { \
; 2234 :         if (!(condition)) \
; 2235 :         { \
; 2236 :             wil::FailureInfo failure{}; \
; 2237 :             wil::details::WilFailFast(failure); \
; 2238 :         } \
; 2239 :     } while ((void)0, 0)
; 2240 : #define __FAIL_FAST_ASSERT_WIN32_BOOL_FALSE__(condition) \
; 2241 :     __RFF_FN(FailFast_IfWin32BoolFalse)(__RFF_INFO(#condition) wil::verify_BOOL(condition))
; 2242 : 
; 2243 :     // A simple ref-counted buffer class.  The interface is very similar to shared_ptr<>, only it manages
; 2244 :     // an allocated buffer and maintains the size.
; 2245 : 
; 2246 :     class shared_buffer
; 2247 :     {
; 2248 :     public:
; 2249 :         shared_buffer() WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2250 :         {
; 2251 :         }
; 2252 : 
; 2253 :         shared_buffer(shared_buffer const& other) WI_NOEXCEPT : m_pCopy(nullptr), m_size(0)
; 2254 :         {
; 2255 :             assign(other.m_pCopy, other.m_size);
; 2256 :         }
; 2257 : 
; 2258 :         shared_buffer(shared_buffer&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy), m_size(other.m_size)
; 2259 :         {
; 2260 :             other.m_pCopy = nullptr;
; 2261 :             other.m_size = 0;
; 2262 :         }
; 2263 : 
; 2264 :         ~shared_buffer() WI_NOEXCEPT
; 2265 :         {
; 2266 :             reset();
; 2267 :         }
; 2268 : 
; 2269 :         shared_buffer& operator=(shared_buffer const& other) WI_NOEXCEPT
; 2270 :         {
; 2271 :             if (this != wistd::addressof(other))
; 2272 :             {
; 2273 :                 assign(other.m_pCopy, other.m_size);
; 2274 :             }
; 2275 :             return *this;
; 2276 :         }
; 2277 : 
; 2278 :         shared_buffer& operator=(shared_buffer&& other) WI_NOEXCEPT
; 2279 :         {
; 2280 :             if (this != wistd::addressof(other))
; 2281 :             {
; 2282 :                 reset();
; 2283 :                 m_pCopy = other.m_pCopy;
; 2284 :                 m_size = other.m_size;
; 2285 :                 other.m_pCopy = nullptr;
; 2286 :                 other.m_size = 0;
; 2287 :             }
; 2288 :             return *this;
; 2289 :         }
; 2290 : 
; 2291 :         void reset() WI_NOEXCEPT
; 2292 :         {
; 2293 :             if (m_pCopy != nullptr)
; 2294 :             {
; 2295 :                 if (0 == ::InterlockedDecrementRelease(m_pCopy))
; 2296 :                 {
; 2297 :                     WIL_FreeMemory(m_pCopy);
; 2298 :                 }
; 2299 :                 m_pCopy = nullptr;
; 2300 :                 m_size = 0;
; 2301 :             }
; 2302 :         }
; 2303 : 
; 2304 :         bool create(_In_reads_bytes_opt_(cbData) void const* pData, size_t cbData) WI_NOEXCEPT
; 2305 :         {
; 2306 :             if (cbData == 0)
; 2307 :             {
; 2308 :                 reset();
; 2309 :                 return true;
; 2310 :             }
; 2311 : 
; 2312 :             long* pCopyRefCount = reinterpret_cast<long*>(WIL_AllocateMemory(sizeof(long) + cbData));
; 2313 :             if (pCopyRefCount == nullptr)
; 2314 :             {
; 2315 :                 return false;
; 2316 :             }
; 2317 : 
; 2318 :             *pCopyRefCount = 0;
; 2319 :             if (pData != nullptr)
; 2320 :             {
; 2321 :                 memcpy_s(pCopyRefCount + 1, cbData, pData, cbData); // +1 to advance past sizeof(long) counter
; 2322 :             }
; 2323 :             assign(pCopyRefCount, cbData);
; 2324 :             return true;
; 2325 :         }
; 2326 : 
; 2327 :         bool create(size_t cbData) WI_NOEXCEPT
; 2328 :         {
; 2329 :             return create(nullptr, cbData);
; 2330 :         }
; 2331 : 
; 2332 :         WI_NODISCARD void* get(_Out_opt_ size_t* pSize = nullptr) const WI_NOEXCEPT
; 2333 :         {
; 2334 :             if (pSize != nullptr)
; 2335 :             {
; 2336 :                 *pSize = m_size;
; 2337 :             }
; 2338 :             return (m_pCopy == nullptr) ? nullptr : (m_pCopy + 1);
; 2339 :         }
; 2340 : 
; 2341 :         WI_NODISCARD size_t size() const WI_NOEXCEPT
; 2342 :         {
; 2343 :             return m_size;
; 2344 :         }
; 2345 : 
; 2346 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2347 :         {
; 2348 :             return (m_pCopy != nullptr);
; 2349 :         }
; 2350 : 
; 2351 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2352 :         {
; 2353 :             return ((m_pCopy != nullptr) && (*m_pCopy == 1));
; 2354 :         }
; 2355 : 
; 2356 :     private:
; 2357 :         long* m_pCopy; // pointer to allocation: refcount + data
; 2358 :         size_t m_size; // size of the data from m_pCopy
; 2359 : 
; 2360 :         void assign(_In_opt_ long* pCopy, size_t cbSize) WI_NOEXCEPT
; 2361 :         {
; 2362 :             reset();
; 2363 :             if (pCopy != nullptr)
; 2364 :             {
; 2365 :                 m_pCopy = pCopy;
; 2366 :                 m_size = cbSize;
; 2367 :                 ::InterlockedIncrementNoFence(m_pCopy);
; 2368 :             }
; 2369 :         }
; 2370 :     };
; 2371 : 
; 2372 :     inline shared_buffer make_shared_buffer_nothrow(_In_reads_bytes_opt_(countBytes) void* pData, size_t countBytes) WI_NOEXCEPT
; 2373 :     {
; 2374 :         shared_buffer buffer;
; 2375 :         buffer.create(pData, countBytes);
; 2376 :         return buffer;
; 2377 :     }
; 2378 : 
; 2379 :     inline shared_buffer make_shared_buffer_nothrow(size_t countBytes) WI_NOEXCEPT
; 2380 :     {
; 2381 :         shared_buffer buffer;
; 2382 :         buffer.create(countBytes);
; 2383 :         return buffer;
; 2384 :     }
; 2385 : 
; 2386 :     // A small mimic of the STL shared_ptr class, but unlike shared_ptr, a pointer is not attached to the class, but is
; 2387 :     // always simply contained within (it cannot be attached or detached).
; 2388 : 
; 2389 :     template <typename object_t>
; 2390 :     class shared_object
; 2391 :     {
; 2392 :     public:
; 2393 :         shared_object() WI_NOEXCEPT : m_pCopy(nullptr)
; 2394 :         {
; 2395 :         }
; 2396 : 
; 2397 :         shared_object(shared_object const& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2398 :         {
; 2399 :             if (m_pCopy != nullptr)
; 2400 :             {
; 2401 :                 ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2402 :             }
; 2403 :         }
; 2404 : 
; 2405 :         shared_object(shared_object&& other) WI_NOEXCEPT : m_pCopy(other.m_pCopy)
; 2406 :         {
; 2407 :             other.m_pCopy = nullptr;
; 2408 :         }
; 2409 : 
; 2410 :         ~shared_object() WI_NOEXCEPT
; 2411 :         {
; 2412 :             reset();
; 2413 :         }
; 2414 : 
; 2415 :         shared_object& operator=(shared_object const& other) WI_NOEXCEPT
; 2416 :         {
; 2417 :             if (this != wistd::addressof(other))
; 2418 :             {
; 2419 :                 reset();
; 2420 :                 m_pCopy = other.m_pCopy;
; 2421 :                 if (m_pCopy != nullptr)
; 2422 :                 {
; 2423 :                     ::InterlockedIncrementNoFence(&m_pCopy->m_refCount);
; 2424 :                 }
; 2425 :             }
; 2426 :             return *this;
; 2427 :         }
; 2428 : 
; 2429 :         shared_object& operator=(shared_object&& other) WI_NOEXCEPT
; 2430 :         {
; 2431 :             if (this != wistd::addressof(other))
; 2432 :             {
; 2433 :                 reset();
; 2434 :                 m_pCopy = other.m_pCopy;
; 2435 :                 other.m_pCopy = nullptr;
; 2436 :             }
; 2437 :             return *this;
; 2438 :         }
; 2439 : 
; 2440 :         void reset() WI_NOEXCEPT
; 2441 :         {
; 2442 :             if (m_pCopy != nullptr)
; 2443 :             {
; 2444 :                 if (0 == ::InterlockedDecrementRelease(&m_pCopy->m_refCount))
; 2445 :                 {
; 2446 :                     delete m_pCopy;
; 2447 :                 }
; 2448 :                 m_pCopy = nullptr;
; 2449 :             }
; 2450 :         }
; 2451 : 
; 2452 :         bool create()
; 2453 :         {
; 2454 :             RefAndObject* pObject = new (std::nothrow) RefAndObject();
; 2455 :             if (pObject == nullptr)
; 2456 :             {
; 2457 :                 return false;
; 2458 :             }
; 2459 :             reset();
; 2460 :             m_pCopy = pObject;
; 2461 :             return true;
; 2462 :         }
; 2463 : 
; 2464 :         template <typename param_t>
; 2465 :         bool create(param_t&& param1)
; 2466 :         {
; 2467 :             RefAndObject* pObject = new (std::nothrow) RefAndObject(wistd::forward<param_t>(param1));
; 2468 :             if (pObject == nullptr)
; 2469 :             {
; 2470 :                 return false;
; 2471 :             }
; 2472 :             reset();
; 2473 :             m_pCopy = pObject;
; 2474 :             return true;
; 2475 :         }
; 2476 : 
; 2477 :         WI_NODISCARD object_t* get() const WI_NOEXCEPT
; 2478 :         {
; 2479 :             return (m_pCopy == nullptr) ? nullptr : &m_pCopy->m_object;
; 2480 :         }
; 2481 : 
; 2482 :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 2483 :         {
; 2484 :             return (m_pCopy != nullptr);
; 2485 :         }
; 2486 : 
; 2487 :         WI_NODISCARD bool unique() const WI_NOEXCEPT
; 2488 :         {
; 2489 :             return ((m_pCopy != nullptr) && (m_pCopy->m_refCount == 1));
; 2490 :         }
; 2491 : 
; 2492 :         WI_NODISCARD object_t* operator->() const WI_NOEXCEPT
; 2493 :         {
; 2494 :             return get();
; 2495 :         }
; 2496 : 
; 2497 :     private:
; 2498 :         struct RefAndObject
; 2499 :         {
; 2500 :             long m_refCount;
; 2501 :             object_t m_object;
; 2502 : 
; 2503 :             RefAndObject() : m_refCount(1), m_object()
; 2504 :             {
; 2505 :             }
; 2506 : 
; 2507 :             template <typename param_t>
; 2508 :             RefAndObject(param_t&& param1) : m_refCount(1), m_object(wistd::forward<param_t>(param1))
; 2509 :             {
; 2510 :             }
; 2511 :         };
; 2512 : 
; 2513 :         RefAndObject* m_pCopy;
; 2514 :     };
; 2515 : 
; 2516 :     // The following functions are basically the same, but are kept separated to:
; 2517 :     // 1) Provide a unique count and last error code per-type
; 2518 :     // 2) Avoid merging the types to allow easy debugging (breakpoints, conditional breakpoints based
; 2519 :     //      upon count of errors from a particular type, etc)
; 2520 :     __WI_PUSH_WARNINGS
; 2521 : #if __clang_major__ >= 13
; 2522 :     __WI_CLANG_DISABLE_WARNING(-Wunused-but-set-variable) // s_hrErrorLast used for debugging. We intentionally only assign to it
; 2523 : #endif
; 2524 :     __WI_MSVC_DISABLE_WARNING(4746) // s_hrErrorLast' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2525 : 
; 2526 :     __declspec(noinline) inline int RecordException(HRESULT hr) WI_NOEXCEPT
; 2527 :     {
; 2528 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2529 :         static long volatile s_cErrorCount = 0;
; 2530 :         s_hrErrorLast = hr;
; 2531 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2532 :     }
; 2533 : 
; 2534 :     __declspec(noinline) inline int RecordReturn(HRESULT hr) WI_NOEXCEPT
; 2535 :     {
; 2536 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2537 :         static long volatile s_cErrorCount = 0;
; 2538 :         s_hrErrorLast = hr;
; 2539 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2540 :     }
; 2541 : 
; 2542 :     __declspec(noinline) inline int RecordLog(HRESULT hr) WI_NOEXCEPT
; 2543 :     {
; 2544 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2545 :         static long volatile s_cErrorCount = 0;
; 2546 :         s_hrErrorLast = hr;
; 2547 :         return ::InterlockedIncrementNoFence(&s_cErrorCount);
; 2548 :     }
; 2549 : 
; 2550 :     __declspec(noinline) inline int RecordFailFast(HRESULT hr) WI_NOEXCEPT
; 2551 :     {
; 2552 :         static HRESULT volatile s_hrErrorLast = S_OK;
; 2553 :         s_hrErrorLast = hr;
; 2554 :         return 1;
; 2555 :     }
; 2556 :     __WI_POP_WARNINGS
; 2557 : 
; 2558 :     inline RESULT_NORETURN void __stdcall WilRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_opt_ PCONTEXT cr, _In_ DWORD flags)
; 2559 :     {
; 2560 :         // if we managed to load the pointer either through WilDynamicRaiseFailFastException (PARTITION_DESKTOP etc.)
; 2561 :         // or via direct linkage (e.g. UWP apps), then use it.
; 2562 :         if (g_pfnRaiseFailFastException)
; 2563 :         {
; 2564 :             g_pfnRaiseFailFastException(er, cr, flags);
; 2565 :         }
; 2566 :         // if not, as a best effort, we are just going to call the intrinsic.
; 2567 :         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
; 2568 :     }
; 2569 : 
; 2570 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2571 :     inline bool __stdcall GetModuleInformation(
; 2572 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* name, size_t size) WI_NOEXCEPT
; 2573 :     {
; 2574 :         HMODULE hModule = nullptr;
; 2575 :         if (address && !GetModuleHandleExW(
; 2576 :                            GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
; 2577 :                            reinterpret_cast<PCWSTR>(address),
; 2578 :                            &hModule))
; 2579 :         {
; 2580 :             assign_to_opt_param(addressOffset, 0U);
; 2581 :             return false;
; 2582 :         }
; 2583 :         if (addressOffset)
; 2584 :         {
; 2585 :             *addressOffset =
; 2586 :                 address ? static_cast<unsigned int>(static_cast<unsigned char*>(address) - reinterpret_cast<unsigned char*>(hModule))
; 2587 :                         : 0;
; 2588 :         }
; 2589 :         if (name)
; 2590 :         {
; 2591 :             char modulePath[MAX_PATH];
; 2592 :             if (!GetModuleFileNameA(hModule, modulePath, ARRAYSIZE(modulePath)))
; 2593 :             {
; 2594 :                 return false;
; 2595 :             }
; 2596 : 
; 2597 :             PCSTR start = modulePath + strlen(modulePath);
; 2598 :             while ((start > modulePath) && (*(start - 1) != '\\'))
; 2599 :             {
; 2600 :                 start--;
; 2601 :             }
; 2602 :             StringCchCopyA(name, size, start);
; 2603 :         }
; 2604 :         return true;
; 2605 :     }
; 2606 : 
; 2607 :     __WI_PUSH_WARNINGS
; 2608 :     __WI_MSVC_DISABLE_WARNING(4746) // s_fModuleValid' is subject to /volatile:<iso|ms> setting; consider using __iso_volatile_load/store intrinsic functions
; 2609 :     inline PCSTR __stdcall GetCurrentModuleName() WI_NOEXCEPT
; 2610 :     {
; 2611 :         static char s_szModule[64] = {};
; 2612 :         static volatile bool s_fModuleValid = false;
; 2613 :         if (!s_fModuleValid) // Races are acceptable
; 2614 :         {
; 2615 :             GetModuleInformation(reinterpret_cast<void*>(&RecordFailFast), nullptr, s_szModule, ARRAYSIZE(s_szModule));
; 2616 :             s_fModuleValid = true;
; 2617 :         }
; 2618 :         return s_szModule;
; 2619 :     }
; 2620 :     __WI_POP_WARNINGS
; 2621 : 
; 2622 :     inline void __stdcall DebugBreak() WI_NOEXCEPT
; 2623 :     {
; 2624 :         ::DebugBreak();
; 2625 :     }
; 2626 : 
; 2627 :     inline void __stdcall WilDynamicLoadRaiseFailFastException(_In_ PEXCEPTION_RECORD er, _In_ PCONTEXT cr, _In_ DWORD flags)
; 2628 :     {
; 2629 :         auto k32handle = GetModuleHandleW(L"kernelbase.dll");
; 2630 :         _Analysis_assume_(k32handle != nullptr);
; 2631 :         auto pfnRaiseFailFastException =
; 2632 :             details::GetProcAddress<decltype(WilDynamicLoadRaiseFailFastException)*>(k32handle, "RaiseFailFastException");
; 2633 :         if (pfnRaiseFailFastException)
; 2634 :         {
; 2635 :             pfnRaiseFailFastException(er, cr, flags);
; 2636 :         }
; 2637 :     }
; 2638 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 2639 : 
; 2640 :     inline bool __stdcall GetModuleInformationFromAddress(
; 2641 :         _In_opt_ void* address, _Out_opt_ unsigned int* addressOffset, _Out_writes_bytes_opt_(size) char* buffer, size_t size) WI_NOEXCEPT
; 2642 :     {
; 2643 :         if (size > 0)
; 2644 :         {
; 2645 :             assign_to_opt_param(buffer, '\0');
; 2646 :         }
; 2647 :         if (addressOffset)
; 2648 :         {
; 2649 :             *addressOffset = 0;
; 2650 :         }
; 2651 :         if (g_pfnGetModuleInformation)
; 2652 :         {
; 2653 :             return g_pfnGetModuleInformation(address, addressOffset, buffer, size);
; 2654 :         }
; 2655 :         return false;
; 2656 :     }
; 2657 : 
; 2658 :     __declspec(noinline) inline HRESULT NtStatusToHr(NTSTATUS status) WI_NOEXCEPT
; 2659 :     {
; 2660 :         // The following conversions are the only known incorrect mappings in RtlNtStatusToDosErrorNoTeb
; 2661 :         if (SUCCEEDED_NTSTATUS(status))
; 2662 :         {
; 2663 :             // All successful status codes have only one hresult equivalent, S_OK
; 2664 :             return S_OK;
; 2665 :         }
; 2666 :         if (status == static_cast<NTSTATUS>(STATUS_NO_MEMORY))
; 2667 :         {
; 2668 :             // RtlNtStatusToDosErrorNoTeb maps STATUS_NO_MEMORY to the less popular of two Win32 no memory error codes resulting in an unexpected mapping
; 2669 :             return E_OUTOFMEMORY;
; 2670 :         }
; 2671 : 
; 2672 :         if (g_pfnRtlNtStatusToDosErrorNoTeb != nullptr)
; 2673 :         {
; 2674 :             DWORD err = g_pfnRtlNtStatusToDosErrorNoTeb(status);
; 2675 : 
; 2676 :             // ERROR_MR_MID_NOT_FOUND indicates a bug in the originator of the error (failure to add a mapping to the Win32 error codes).
; 2677 :             // There are known instances of this bug which are unlikely to be fixed soon, and it's always possible that additional instances
; 2678 :             // could be added in the future. In these cases, it's better to use HRESULT_FROM_NT rather than returning a meaningless error.
; 2679 :             if ((err != 0) && (err != ERROR_MR_MID_NOT_FOUND))
; 2680 :             {
; 2681 :                 return __HRESULT_FROM_WIN32(err);
; 2682 :             }
; 2683 :         }
; 2684 : 
; 2685 :         return HRESULT_FROM_NT(status);
; 2686 :     }
; 2687 : 
; 2688 :     __declspec(noinline) inline NTSTATUS HrToNtStatus(HRESULT hr) WI_NOEXCEPT
; 2689 :     {
; 2690 :         // Constants taken from ntstatus.h
; 2691 :         static constexpr NTSTATUS WIL_STATUS_INVALID_PARAMETER = 0xC000000D;
; 2692 :         static constexpr NTSTATUS WIL_STATUS_INTERNAL_ERROR = 0xC00000E5;
; 2693 :         static constexpr NTSTATUS WIL_STATUS_INTEGER_OVERFLOW = 0xC0000095;
; 2694 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_PATH_NOT_FOUND = 0xC000003A;
; 2695 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_NOT_FOUND = 0xC0000034;
; 2696 :         static constexpr NTSTATUS WIL_STATUS_NOT_IMPLEMENTED = 0xC0000002;
; 2697 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_OVERFLOW = 0x80000005;
; 2698 :         static constexpr NTSTATUS WIL_STATUS_IMPLEMENTATION_LIMIT = 0xC000042B;
; 2699 :         static constexpr NTSTATUS WIL_STATUS_NO_MORE_MATCHES = 0xC0000273;
; 2700 :         static constexpr NTSTATUS WIL_STATUS_ILLEGAL_CHARACTER = 0xC0000161;
; 2701 :         static constexpr NTSTATUS WIL_STATUS_UNDEFINED_CHARACTER = 0xC0000163;
; 2702 :         static constexpr NTSTATUS WIL_STATUS_BUFFER_TOO_SMALL = 0xC0000023;
; 2703 :         static constexpr NTSTATUS WIL_STATUS_DISK_FULL = 0xC000007F;
; 2704 :         static constexpr NTSTATUS WIL_STATUS_OBJECT_NAME_INVALID = 0xC0000033;
; 2705 :         static constexpr NTSTATUS WIL_STATUS_DLL_NOT_FOUND = 0xC0000135;
; 2706 :         static constexpr NTSTATUS WIL_STATUS_REVISION_MISMATCH = 0xC0000059;
; 2707 :         static constexpr NTSTATUS WIL_STATUS_XML_PARSE_ERROR = 0xC000A083;
; 2708 :         static constexpr HRESULT WIL_E_FAIL = 0x80004005;
; 2709 : 
; 2710 :         NTSTATUS status = STATUS_SUCCESS;
; 2711 : 
; 2712 :         switch (hr)
; 2713 :         {
; 2714 :         case S_OK:
; 2715 :             status = STATUS_SUCCESS;
; 2716 :             break;
; 2717 :         case E_INVALIDARG:
; 2718 :             status = WIL_STATUS_INVALID_PARAMETER;
; 2719 :             break;
; 2720 :         case __HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR):
; 2721 :             status = WIL_STATUS_INTERNAL_ERROR;
; 2722 :             break;
; 2723 :         case E_OUTOFMEMORY:
; 2724 :             status = STATUS_NO_MEMORY;
; 2725 :             break;
; 2726 :         case __HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW):
; 2727 :             status = WIL_STATUS_INTEGER_OVERFLOW;
; 2728 :             break;
; 2729 :         case __HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
; 2730 :             status = WIL_STATUS_OBJECT_PATH_NOT_FOUND;
; 2731 :             break;
; 2732 :         case __HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
; 2733 :             status = WIL_STATUS_OBJECT_NAME_NOT_FOUND;
; 2734 :             break;
; 2735 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
; 2736 :             status = WIL_STATUS_NOT_IMPLEMENTED;
; 2737 :             break;
; 2738 :         case __HRESULT_FROM_WIN32(ERROR_MORE_DATA):
; 2739 :             status = WIL_STATUS_BUFFER_OVERFLOW;
; 2740 :             break;
; 2741 :         case __HRESULT_FROM_WIN32(ERROR_IMPLEMENTATION_LIMIT):
; 2742 :             status = WIL_STATUS_IMPLEMENTATION_LIMIT;
; 2743 :             break;
; 2744 :         case __HRESULT_FROM_WIN32(ERROR_NO_MORE_MATCHES):
; 2745 :             status = WIL_STATUS_NO_MORE_MATCHES;
; 2746 :             break;
; 2747 :         case __HRESULT_FROM_WIN32(ERROR_ILLEGAL_CHARACTER):
; 2748 :             status = WIL_STATUS_ILLEGAL_CHARACTER;
; 2749 :             break;
; 2750 :         case __HRESULT_FROM_WIN32(ERROR_UNDEFINED_CHARACTER):
; 2751 :             status = WIL_STATUS_UNDEFINED_CHARACTER;
; 2752 :             break;
; 2753 :         case __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
; 2754 :             status = WIL_STATUS_BUFFER_TOO_SMALL;
; 2755 :             break;
; 2756 :         case __HRESULT_FROM_WIN32(ERROR_DISK_FULL):
; 2757 :             status = WIL_STATUS_DISK_FULL;
; 2758 :             break;
; 2759 :         case __HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
; 2760 :             status = WIL_STATUS_OBJECT_NAME_INVALID;
; 2761 :             break;
; 2762 :         case __HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
; 2763 :             status = WIL_STATUS_DLL_NOT_FOUND;
; 2764 :             break;
; 2765 :         case __HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION):
; 2766 :             status = WIL_STATUS_REVISION_MISMATCH;
; 2767 :             break;
; 2768 :         case WIL_E_FAIL:
; 2769 :             status = STATUS_UNSUCCESSFUL;
; 2770 :             break;
; 2771 :         case __HRESULT_FROM_WIN32(ERROR_XML_PARSE_ERROR):
; 2772 :             status = WIL_STATUS_XML_PARSE_ERROR;
; 2773 :             break;
; 2774 :         case __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION):
; 2775 :             status = STATUS_NONCONTINUABLE_EXCEPTION;
; 2776 :             break;
; 2777 :         default:
; 2778 :             if ((hr & FACILITY_NT_BIT) != 0)
; 2779 :             {
; 2780 :                 status = (hr & ~FACILITY_NT_BIT);
; 2781 :             }
; 2782 :             else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
; 2783 :             {
; 2784 :                 status = __NTSTATUS_FROM_WIN32(HRESULT_CODE(hr));
; 2785 :             }
; 2786 :             else if (HRESULT_FACILITY(hr) == FACILITY_SSPI)
; 2787 :             {
; 2788 :                 status =
; 2789 :                     ((NTSTATUS)(hr) <= 0 ? ((NTSTATUS)(hr))
; 2790 :                                          : ((NTSTATUS)(((hr) & 0x0000FFFF) | (FACILITY_SSPI << 16) | ERROR_SEVERITY_ERROR)));
; 2791 :             }
; 2792 :             else
; 2793 :             {
; 2794 :                 status = WIL_STATUS_INTERNAL_ERROR;
; 2795 :             }
; 2796 :             break;
; 2797 :         }
; 2798 :         return status;
; 2799 :     }
; 2800 : 
; 2801 :     // The following set of functions all differ only based upon number of arguments.  They are unified in their handling
; 2802 :     // of data from each of the various error-handling types (fast fail, exceptions, etc.).
; 2803 :     _Post_equals_last_error_ inline DWORD GetLastErrorFail(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2804 :     {
; 2805 :         __R_FN_UNREFERENCED;
; 2806 :         auto err = ::GetLastError();
; 2807 :         if (SUCCEEDED_WIN32(err))
; 2808 :         {
; 2809 :             // This function should only be called when GetLastError() is set to a FAILURE.
; 2810 :             // If you hit this assert (or are reviewing this failure telemetry), then there are one of three issues:
; 2811 :             //  1) Your code is using a macro (such as RETURN_IF_WIN32_BOOL_FALSE()) on a function that does not actually
; 2812 :             //      set the last error (consult MSDN).
; 2813 :             //  2) Your macro check against the error is not immediately after the API call.  Pushing it later can result
; 2814 :             //      in another API call between the previous one and the check resetting the last error.
; 2815 :             //  3) The API you're calling has a bug in it and does not accurately set the last error (there are a few
; 2816 :             //      examples here, such as SendMessageTimeout() that don't accurately set the last error).
; 2817 :             //      [MSFT internal] For these, please send mail to 'wildisc' when found and work-around with win32errorhelpers.
; 2818 : 
; 2819 :             WI_USAGE_ERROR_FORWARD("CALLER BUG: Macro usage error detected.  GetLastError() does not have an error.");
; 2820 :             return ERROR_ASSERTION_FAILURE;
; 2821 :         }
; 2822 :         return err;
; 2823 :     }
; 2824 : 
; 2825 :     inline __declspec(noinline) DWORD GetLastErrorFail() WI_NOEXCEPT
; 2826 :     {
; 2827 :         __R_FN_LOCALS_FULL_RA;
; 2828 :         return GetLastErrorFail(__R_FN_CALL_FULL);
; 2829 :     }
; 2830 : 
; 2831 :     _Translates_last_error_to_HRESULT_
; 2832 :     inline HRESULT GetLastErrorFailHr(__R_FN_PARAMS_FULL) WI_NOEXCEPT
; 2833 :     {
; 2834 :         return HRESULT_FROM_WIN32(GetLastErrorFail(__R_FN_CALL_FULL));
; 2835 :     }
; 2836 : 
; 2837 :     _Translates_last_error_to_HRESULT_
; 2838 :     inline __declspec(noinline) HRESULT GetLastErrorFailHr() WI_NOEXCEPT
; 2839 :     {
; 2840 :         __R_FN_LOCALS_FULL_RA;
; 2841 :         return GetLastErrorFailHr(__R_FN_CALL_FULL);
; 2842 :     }
; 2843 : 
; 2844 :     inline void PrintLoggingMessage(
; 2845 :         _Out_writes_(cchDest) _Post_z_ PWSTR pszDest,
; 2846 :         _Pre_satisfies_(cchDest > 0) size_t cchDest,
; 2847 :         _In_opt_ _Printf_format_string_ PCSTR formatString,
; 2848 :         _In_opt_ va_list argList) WI_NOEXCEPT
; 2849 :     {
; 2850 :         if (formatString == nullptr)
; 2851 :         {
; 2852 :             pszDest[0] = L'\0';
; 2853 :         }
; 2854 :         else if (argList == nullptr)
; 2855 :         {
; 2856 :             StringCchPrintfW(pszDest, cchDest, L"%hs", formatString);
; 2857 :         }
; 2858 :         else
; 2859 :         {
; 2860 :             wchar_t szFormatWide[2048];
; 2861 :             StringCchPrintfW(szFormatWide, ARRAYSIZE(szFormatWide), L"%hs", formatString);
; 2862 :             StringCchVPrintfW(pszDest, cchDest, szFormatWide, argList);
; 2863 :         }
; 2864 :     }
; 2865 : 
; 2866 : #pragma warning(push)
; 2867 : #pragma warning(disable : __WARNING_RETURNING_BAD_RESULT)
; 2868 :     // NOTE: The following two functions are unfortunate copies of strsafe.h functions that have been copied to reduce the friction associated with using
; 2869 :     // Result.h and ResultException.h in a build that does not have WINAPI_PARTITION_DESKTOP defined (where these are conditionally enabled).
; 2870 : 
; 2871 :     inline HRESULT WilStringLengthWorkerA(
; 2872 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2873 :         _In_ _In_range_(<=, STRSAFE_MAX_CCH) size_t cchMax,
; 2874 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2875 :     {
; 2876 :         HRESULT hr = S_OK;
; 2877 :         size_t cchOriginalMax = cchMax;
; 2878 :         while (cchMax && (*psz != '\0'))
; 2879 :         {
; 2880 :             psz++;
; 2881 :             cchMax--;
; 2882 :         }
; 2883 :         if (cchMax == 0)
; 2884 :         {
; 2885 :             // the string is longer than cchMax
; 2886 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2887 :         }
; 2888 :         if (pcchLength)
; 2889 :         {
; 2890 :             if (SUCCEEDED(hr))
; 2891 :             {
; 2892 :                 *pcchLength = cchOriginalMax - cchMax;
; 2893 :             }
; 2894 :             else
; 2895 :             {
; 2896 :                 *pcchLength = 0;
; 2897 :             }
; 2898 :         }
; 2899 :         return hr;
; 2900 :     }
; 2901 : 
; 2902 :     _Must_inspect_result_
; 2903 :     inline HRESULT StringCchLengthA(
; 2904 :         _In_reads_or_z_(cchMax) PCNZCH psz,
; 2905 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchMax,
; 2906 :         _Out_opt_ _Deref_out_range_(<, cchMax) _Deref_out_range_(<=, _String_length_(psz)) size_t* pcchLength)
; 2907 :     {
; 2908 :         HRESULT hr = S_OK;
; 2909 :         if ((psz == nullptr) || (cchMax > STRSAFE_MAX_CCH))
; 2910 :         {
; 2911 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2912 :         }
; 2913 :         else
; 2914 :         {
; 2915 :             hr = WilStringLengthWorkerA(psz, cchMax, pcchLength);
; 2916 :         }
; 2917 :         if (FAILED(hr) && pcchLength)
; 2918 :         {
; 2919 :             *pcchLength = 0;
; 2920 :         }
; 2921 :         return hr;
; 2922 :     }
; 2923 : #pragma warning(pop)
; 2924 : 
; 2925 :     _Post_satisfies_(cchDest > 0 && cchDest <= cchMax) inline HRESULT
; 2926 :         WilStringValidateDestA(_In_reads_opt_(cchDest) PCNZCH /*pszDest*/, _In_ size_t cchDest, _In_ const size_t cchMax)
; 2927 :     {
; 2928 :         HRESULT hr = S_OK;
; 2929 :         if ((cchDest == 0) || (cchDest > cchMax))
; 2930 :         {
; 2931 :             hr = STRSAFE_E_INVALID_PARAMETER;
; 2932 :         }
; 2933 :         return hr;
; 2934 :     }
; 2935 : 
; 2936 :     inline HRESULT WilStringVPrintfWorkerA(
; 2937 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2938 :         _In_ _In_range_(1, STRSAFE_MAX_CCH) size_t cchDest,
; 2939 :         _Always_(_Out_opt_ _Deref_out_range_(<=, cchDest - 1)) size_t* pcchNewDestLength,
; 2940 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2941 :         _In_ va_list argList)
; 2942 :     {
; 2943 :         HRESULT hr = S_OK;
; 2944 :         int iRet{};
; 2945 : 
; 2946 :         // leave the last space for the null terminator
; 2947 :         size_t cchMax = cchDest - 1;
; 2948 :         size_t cchNewDestLength = 0;
; 2949 : #undef STRSAFE_USE_SECURE_CRT
; 2950 : #define STRSAFE_USE_SECURE_CRT 1
; 2951 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 2952 :         iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 2953 : #else
; 2954 : #pragma warning(push)
; 2955 : #pragma warning(disable : __WARNING_BANNED_API_USAGE) // "STRSAFE not included"
; 2956 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
; 2957 : #pragma warning(pop)
; 2958 : #endif
; 2959 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 2960 : 
; 2961 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))
; 2962 :         {
; 2963 :             // need to null terminate the string
; 2964 :             pszDest += cchMax;
; 2965 :             *pszDest = '\0';
; 2966 : 
; 2967 :             cchNewDestLength = cchMax;
; 2968 : 
; 2969 :             // we have truncated pszDest
; 2970 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;
; 2971 :         }
; 2972 :         else if (((size_t)iRet) == cchMax)
; 2973 :         {
; 2974 :             // need to null terminate the string
; 2975 :             pszDest += cchMax;
; 2976 :             *pszDest = '\0';
; 2977 : 
; 2978 :             cchNewDestLength = cchMax;
; 2979 :         }
; 2980 :         else
; 2981 :         {
; 2982 :             cchNewDestLength = (size_t)iRet;
; 2983 :         }
; 2984 : 
; 2985 :         if (pcchNewDestLength)
; 2986 :         {
; 2987 :             *pcchNewDestLength = cchNewDestLength;
; 2988 :         }
; 2989 : 
; 2990 :         return hr;
; 2991 :     }
; 2992 : 
; 2993 :     inline HRESULT StringCchPrintfA(
; 2994 :         _Out_writes_(cchDest) _Always_(_Post_z_) STRSAFE_LPSTR pszDest,
; 2995 :         _In_ size_t cchDest,
; 2996 :         _In_ _Printf_format_string_ STRSAFE_LPCSTR pszFormat,
; 2997 :         ...)
; 2998 :     {
; 2999 :         HRESULT hr;
; 3000 :         hr = wil::details::WilStringValidateDestA(pszDest, cchDest, STRSAFE_MAX_CCH);
; 3001 :         if (SUCCEEDED(hr))
; 3002 :         {
; 3003 :             va_list argList;
; 3004 :             va_start(argList, pszFormat);
; 3005 :             hr = wil::details::WilStringVPrintfWorkerA(pszDest, cchDest, nullptr, pszFormat, argList);
; 3006 :             va_end(argList);
; 3007 :         }
; 3008 :         else if (cchDest > 0)
; 3009 :         {
; 3010 :             *pszDest = '\0';
; 3011 :         }
; 3012 :         return hr;
; 3013 :     }
; 3014 : 
; 3015 :     _Ret_range_(sizeof(char), (psz == nullptr) ? sizeof(char) : (_String_length_(psz) + sizeof(char)))
; 3016 :     inline size_t ResultStringSize(_In_opt_ PCSTR psz)
; 3017 :     {
; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));
; 3019 :     }
; 3020 : 
; 3021 :     _Ret_range_(sizeof(wchar_t), (psz == nullptr) ? sizeof(wchar_t) : ((_String_length_(psz) + 1) * sizeof(wchar_t)))
; 3022 :     inline size_t ResultStringSize(_In_opt_ PCWSTR psz)
; 3023 :     {
; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);
; 3025 :     }
; 3026 : 
; 3027 :     template <typename TString>
; 3028 :     _Ret_range_(pStart, pEnd)
; 3029 :     inline unsigned char* WriteResultString(
; 3030 :         _Pre_satisfies_(pStart <= pEnd) _When_((pStart == pEnd) || (pszString == nullptr) || (pszString[0] == 0), _In_opt_) _When_(
; 3031 :             (pStart != pEnd) && (pszString != nullptr) && (pszString[0] != 0),
; 3032 :             _Out_writes_bytes_opt_(_String_length_(pszString) * sizeof(pszString[0]))) unsigned char* pStart,
; 3033 :         _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd,
; 3034 :         _In_opt_z_ TString pszString,
; 3035 :         _Outptr_result_maybenull_z_ TString* ppszBufferString)
; 3036 :     {
; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)
; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;
; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;
; 3049 :         if (bufferSize < stringSize)
; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);
; 3056 :         assign_to_opt_param(
; 3057 :             ppszBufferString,
; 3058 :             reinterpret_cast<TString>(
; 3059 :                 pStart)); // lgtm[cpp/incorrect-string-type-conversion] False positive - The query is misinterpreting a buffer (char *) with a MBS string, the cast to TString is expected.
; 3060 :         return pStart + stringSize;
; 3061 :     }
; 3062 : 
; 3063 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3064 :     inline size_t UntrustedStringLength(_In_ PCSTR psz, _In_ size_t cchMax)
; 3065 :     {
; 3066 :         size_t cbLength;
; 3067 :         return SUCCEEDED(wil::details::StringCchLengthA(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3068 :     }
; 3069 :     _Ret_range_(0, (cchMax > 0) ? cchMax - 1 : 0)
; 3070 :     inline size_t UntrustedStringLength(_In_ PCWSTR psz, _In_ size_t cchMax)
; 3071 :     {
; 3072 :         size_t cbLength;
; 3073 :         return SUCCEEDED(::StringCchLengthW(psz, cchMax, &cbLength)) ? cbLength : 0;
; 3074 :     }
; 3075 : 
; 3076 :     template <typename TString>
; 3077 :     _Ret_range_(pStart, pEnd)
; 3078 :     inline unsigned char* GetResultString(
; 3079 :         _In_reads_to_ptr_opt_(pEnd) unsigned char* pStart, _Pre_satisfies_(pEnd >= pStart) unsigned char* pEnd, _Out_ TString* ppszBufferString)
; 3080 :     {
; 3081 :         size_t cchLen = UntrustedStringLength(reinterpret_cast<TString>(pStart), (pEnd - pStart) / sizeof((*ppszBufferString)[0]));
; 3082 :         *ppszBufferString = (cchLen > 0) ? reinterpret_cast<TString>(pStart) : nullptr;
; 3083 :         auto pReturn = (wistd::min)(pEnd, pStart + ((cchLen + 1) * sizeof((*ppszBufferString)[0])));
; 3084 :         __analysis_assume((pReturn >= pStart) && (pReturn <= pEnd));
; 3085 :         return pReturn;
; 3086 :     }
; 3087 : } // namespace details
; 3088 : /// @endcond
; 3089 : 
; 3090 : //*****************************************************************************
; 3091 : // WIL result handling initializers
; 3092 : //
; 3093 : // Generally, callers do not need to manually initialize WIL. This header creates
; 3094 : // the appropriate .CRT init section pieces through global objects to ensure that
; 3095 : // WilInitialize... is called before DllMain or main().
; 3096 : //
; 3097 : // Certain binaries do not link with the CRT or do not support .CRT-section based
; 3098 : // initializers. Those binaries must link only with other static libraries that
; 3099 : // also set RESULT_SUPPRESS_STATIC_INITIALIZERS to ensure no .CRT inits are left,
; 3100 : // and they should call one of the WilInitialize_ResultMacros_??? methods during
; 3101 : // their initialization phase.  Skipping this initialization path is OK as well,
; 3102 : // but results in a slightly degraded experience with result reporting.
; 3103 : //
; 3104 : // Calling WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse provides:
; 3105 : // - The name of the current module in wil::FailureInfo::pszModule
; 3106 : // - The name of the returning-to module during wil/staging.h failures
; 3107 : //*****************************************************************************
; 3108 : 
; 3109 : #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3110 : //! Call this method to initialize WIL manually in a module where RESULT_SUPPRESS_STATIC_INITIALIZERS is required. WIL will
; 3111 : //! only use publicly documented APIs.
; 3112 : inline void WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse()
; 3113 : {
; 3114 :     details::g_pfnGetModuleName = details::GetCurrentModuleName;
; 3115 :     details::g_pfnGetModuleInformation = details::GetModuleInformation;
; 3116 :     details::g_pfnDebugBreak = details::DebugBreak;
; 3117 :     details::g_pfnRaiseFailFastException = wil::details::WilDynamicLoadRaiseFailFastException;
; 3118 : }
; 3119 : 
; 3120 : /// @cond
; 3121 : namespace details
; 3122 : {
; 3123 : #ifndef RESULT_SUPPRESS_STATIC_INITIALIZERS
; 3124 : #if !defined(BUILD_WINDOWS) || defined(WIL_SUPPRESS_PRIVATE_API_USE)
; 3125 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse, [] {
; 3126 :         ::wil::WilInitialize_ResultMacros_DesktopOrSystem_SuppressPrivateApiUse();
; 3127 :         return 1;
; 3128 :     });
; 3129 : #endif
; 3130 : #endif
; 3131 : } // namespace details
; 3132 : /// @endcond
; 3133 : #else  // !WINAPI_PARTITION_DESKTOP, !WINAPI_PARTITION_SYSTEM, explicitly assume these modules can direct link
; 3134 : namespace details
; 3135 : {
; 3136 :     WI_HEADER_INITIALIZATION_FUNCTION(WilInitialize_ResultMacros_AppOnly, [] {
; 3137 :         g_pfnRaiseFailFastException = ::RaiseFailFastException;
; 3138 :         return 1;
; 3139 :     });
; 3140 : } // namespace details
; 3141 : #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
; 3142 : 
; 3143 : //*****************************************************************************
; 3144 : // Public Error Handling Helpers
; 3145 : //*****************************************************************************
; 3146 : 
; 3147 : //! Call this method to determine if process shutdown is in progress (allows avoiding work during dll unload).
; 3148 : inline bool ProcessShutdownInProgress()
; 3149 : {
; 3150 :     return (details::g_processShutdownInProgress || (details::g_pfnDllShutdownInProgress ? details::g_pfnDllShutdownInProgress() : false));
; 3151 : }
; 3152 : 
; 3153 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down,
; 3154 : but the hosting DLL doesn't support CRT initializers (such as kernelbase.dll).  The hosting DLL is responsible for calling
; 3155 : Construct() and Destroy() to manually run the constructor and destructor during DLL load & unload.
; 3156 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3157 : called as is typical. */
; 3158 : template <class T>
; 3159 : class manually_managed_shutdown_aware_object
; 3160 : {
; 3161 : public:
; 3162 :     manually_managed_shutdown_aware_object() = default;
; 3163 :     manually_managed_shutdown_aware_object(manually_managed_shutdown_aware_object const&) = delete;
; 3164 :     void operator=(manually_managed_shutdown_aware_object const&) = delete;
; 3165 : 
; 3166 :     void construct()
; 3167 :     {
; 3168 :         void* var = &m_raw;
; 3169 :         ::new (var) T();
; 3170 :     }
; 3171 : 
; 3172 :     void destroy()
; 3173 :     {
; 3174 :         if (ProcessShutdownInProgress())
; 3175 :         {
; 3176 :             get().ProcessShutdown();
; 3177 :         }
; 3178 :         else
; 3179 :         {
; 3180 :             (&get())->~T();
; 3181 :         }
; 3182 :     }
; 3183 : 
; 3184 :     //! Retrieves a reference to the contained object
; 3185 :     T& get() WI_NOEXCEPT
; 3186 :     {
; 3187 :         return *reinterpret_cast<T*>(&m_raw);
; 3188 :     }
; 3189 : 
; 3190 : private:
; 3191 :     alignas(T) unsigned char m_raw[sizeof(T)];
; 3192 : };
; 3193 : 
; 3194 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down.
; 3195 : Upon process shutdown a method (ProcessShutdown()) is called that must be implemented on the object, otherwise the destructor is
; 3196 : called as is typical. */
; 3197 : template <class T>
; 3198 : class shutdown_aware_object
; 3199 : {
; 3200 : public:
; 3201 :     shutdown_aware_object()
; 3202 :     {
; 3203 :         m_object.construct();
; 3204 :     }
; 3205 : 
; 3206 :     ~shutdown_aware_object()
; 3207 :     {
; 3208 :         m_object.destroy();
; 3209 :     }
; 3210 : 
; 3211 :     shutdown_aware_object(shutdown_aware_object const&) = delete;
; 3212 :     void operator=(shutdown_aware_object const&) = delete;
; 3213 : 
; 3214 :     //! Retrieves a reference to the contained object
; 3215 :     T& get() WI_NOEXCEPT
; 3216 :     {
; 3217 :         return m_object.get();
; 3218 :     }
; 3219 : 
; 3220 : private:
; 3221 :     manually_managed_shutdown_aware_object<T> m_object;
; 3222 : };
; 3223 : 
; 3224 : /** Use this object to wrap an object that wants to prevent its destructor from being run when the process is shutting down. */
; 3225 : template <class T>
; 3226 : class object_without_destructor_on_shutdown
; 3227 : {
; 3228 : public:
; 3229 :     object_without_destructor_on_shutdown()
; 3230 :     {
; 3231 :         void* var = &m_raw;
; 3232 :         ::new (var) T();
; 3233 :     }
; 3234 : 
; 3235 :     ~object_without_destructor_on_shutdown()
; 3236 :     {
; 3237 :         if (!ProcessShutdownInProgress())
; 3238 :         {
; 3239 :             get().~T();
; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     object_without_destructor_on_shutdown(object_without_destructor_on_shutdown const&) = delete;
; 3244 :     void operator=(object_without_destructor_on_shutdown const&) = delete;
; 3245 : 
; 3246 :     //! Retrieves a reference to the contained object
; 3247 :     T& get() WI_NOEXCEPT
; 3248 :     {
; 3249 :         return *reinterpret_cast<T*>(&m_raw);
; 3250 :     }
; 3251 : 
; 3252 : private:
; 3253 :     alignas(T) unsigned char m_raw[sizeof(T)]{};
; 3254 : };
; 3255 : 
; 3256 : /** Forward your DLLMain to this function so that WIL can have visibility into whether a DLL unload is because
; 3257 : of termination or normal unload.  Note that when g_pfnDllShutdownInProgress is set, WIL attempts to make this
; 3258 : determination on its own without this callback.  Suppressing private APIs requires use of this. */
; 3259 : inline void DLLMain(HINSTANCE, DWORD reason, _In_opt_ LPVOID reserved)
; 3260 : {
; 3261 :     if (!details::g_processShutdownInProgress)
; 3262 :     {
; 3263 :         if ((reason == DLL_PROCESS_DETACH) && (reserved != nullptr))
; 3264 :         {
; 3265 :             details::g_processShutdownInProgress = true;
; 3266 :         }
; 3267 :     }
; 3268 : }
; 3269 : 
; 3270 : // [optionally] Plug in fallback telemetry reporting
; 3271 : // Normally, the callback is owned by including ResultLogging.h in the including module.  Alternatively a module
; 3272 : // could re-route fallback telemetry to any ONE specific provider by calling this method.
; 3273 : inline void SetResultTelemetryFallback(_In_opt_ decltype(details::g_pfnTelemetryCallback) callbackFunction)
; 3274 : {
; 3275 :     // Only ONE telemetry provider can own the fallback telemetry callback.
; 3276 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3277 :         (details::g_pfnTelemetryCallback == nullptr) || (callbackFunction == nullptr) ||
; 3278 :         (details::g_pfnTelemetryCallback == callbackFunction));
; 3279 :     details::g_pfnTelemetryCallback = callbackFunction;
; 3280 : }
; 3281 : 
; 3282 : // [optionally] Plug in result logging (do not use for telemetry)
; 3283 : // This provides the ability for a module to hook all failures flowing through the system for inspection
; 3284 : // and/or logging.
; 3285 : inline void SetResultLoggingCallback(_In_opt_ decltype(details::g_pfnLoggingCallback) callbackFunction)
; 3286 : {
; 3287 :     // Only ONE function can own the result logging callback
; 3288 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3289 :         (details::g_pfnLoggingCallback == nullptr) || (callbackFunction == nullptr) ||
; 3290 :         (details::g_pfnLoggingCallback == callbackFunction));
; 3291 :     details::g_pfnLoggingCallback = callbackFunction;
; 3292 : }
; 3293 : 
; 3294 : // [optionally] Plug in custom result messages
; 3295 : // There are some purposes that require translating the full information that is known about a failure
; 3296 : // into a message to be logged (either through the console for debugging OR as the message attached
; 3297 : // to a Platform::Exception^).  This callback allows a module to format the string itself away from the
; 3298 : // default.
; 3299 : inline void SetResultMessageCallback(_In_opt_ decltype(wil::g_pfnResultLoggingCallback) callbackFunction)
; 3300 : {
; 3301 :     // Only ONE function can own the result message callback
; 3302 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3303 :         (g_pfnResultLoggingCallback == nullptr) || (callbackFunction == nullptr) || (g_pfnResultLoggingCallback == callbackFunction));
; 3304 :     details::g_resultMessageCallbackSet = true;
; 3305 :     g_pfnResultLoggingCallback = callbackFunction;
; 3306 : }
; 3307 : 
; 3308 : // [optionally] Plug in exception remapping
; 3309 : // A module can plug a callback in using this function to setup custom exception handling to allow any
; 3310 : // exception type to be converted into an HRESULT from exception barriers.
; 3311 : inline void SetResultFromCaughtExceptionCallback(_In_opt_ decltype(wil::g_pfnResultFromCaughtException) callbackFunction)
; 3312 : {
; 3313 :     // Only ONE function can own the exception conversion
; 3314 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3315 :         (g_pfnResultFromCaughtException == nullptr) || (callbackFunction == nullptr) ||
; 3316 :         (g_pfnResultFromCaughtException == callbackFunction));
; 3317 :     g_pfnResultFromCaughtException = callbackFunction;
; 3318 : }
; 3319 : 
; 3320 : // [optionally] Plug in exception remapping
; 3321 : // This provides the ability for a module to call RoOriginateError in case of a failure.
; 3322 : // Normally, the callback is owned by including result_originate.h in the including module.  Alternatively a module
; 3323 : // could re-route error origination callback to its own implementation.
; 3324 : inline void SetOriginateErrorCallback(_In_opt_ decltype(details::g_pfnOriginateCallback) callbackFunction)
; 3325 : {
; 3326 :     // Only ONE function can own the error origination callback
; 3327 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3328 :         (details::g_pfnOriginateCallback == nullptr) || (callbackFunction == nullptr) ||
; 3329 :         (details::g_pfnOriginateCallback == callbackFunction));
; 3330 :     details::g_pfnOriginateCallback = callbackFunction;
; 3331 : }
; 3332 : 
; 3333 : // [optionally] Plug in failfast callback
; 3334 : // This provides the ability for a module to call RoFailFastWithErrorContext in the failfast handler -if- there is stowed
; 3335 : // exception data available.  Normally, the callback is owned by including result_originate.h in the including module.
; 3336 : // Alternatively a module could re-route to its own implementation.
; 3337 : inline void SetFailfastWithContextCallback(_In_opt_ decltype(details::g_pfnFailfastWithContextCallback) callbackFunction)
; 3338 : {
; 3339 :     // Only ONE function can own the failfast with context callback
; 3340 :     __FAIL_FAST_IMMEDIATE_ASSERT__(
; 3341 :         (details::g_pfnFailfastWithContextCallback == nullptr) || (callbackFunction == nullptr) ||
; 3342 :         (details::g_pfnFailfastWithContextCallback == callbackFunction));
; 3343 :     details::g_pfnFailfastWithContextCallback = callbackFunction;
; 3344 : }
; 3345 : 
; 3346 : // A RAII wrapper around the storage of a FailureInfo struct (which is normally meant to be consumed
; 3347 : // on the stack or from the caller).  The storage of FailureInfo needs to copy some data internally
; 3348 : // for lifetime purposes.
; 3349 : 
; 3350 : class StoredFailureInfo
; 3351 : {
; 3352 : public:
; 3353 :     StoredFailureInfo() WI_NOEXCEPT
; 3354 :     {
; 3355 :         ::ZeroMemory(&m_failureInfo, sizeof(m_failureInfo));
; 3356 :     }
; 3357 : 
; 3358 :     StoredFailureInfo(FailureInfo const& other) WI_NOEXCEPT
; 3359 :     {
; 3360 :         SetFailureInfo(other);
; 3361 :     }
; 3362 : 
; 3363 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3364 :     {
; 3365 :         return m_failureInfo;
; 3366 :     }
; 3367 : 
; 3368 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3369 :     {
; 3370 :         m_failureInfo = failure;
; 3371 : 
; 3372 :         size_t const cbNeed = details::ResultStringSize(failure.pszMessage) + details::ResultStringSize(failure.pszCode) +
; 3373 :                               details::ResultStringSize(failure.pszFunction) + details::ResultStringSize(failure.pszFile) +
; 3374 :                               details::ResultStringSize(failure.pszCallContext) + details::ResultStringSize(failure.pszModule) +
; 3375 :                               details::ResultStringSize(failure.callContextCurrent.contextName) +
; 3376 :                               details::ResultStringSize(failure.callContextCurrent.contextMessage) +
; 3377 :                               details::ResultStringSize(failure.callContextOriginating.contextName) +
; 3378 :                               details::ResultStringSize(failure.callContextOriginating.contextMessage);
; 3379 : 
; 3380 :         if (!m_spStrings.unique() || (m_spStrings.size() < cbNeed))
; 3381 :         {
; 3382 :             m_spStrings.reset();
; 3383 :             m_spStrings.create(cbNeed);
; 3384 :         }
; 3385 : 
; 3386 :         size_t cbAlloc;
; 3387 :         unsigned char* pBuffer = static_cast<unsigned char*>(m_spStrings.get(&cbAlloc));
; 3388 :         unsigned char* pBufferEnd = (pBuffer != nullptr) ? pBuffer + cbAlloc : nullptr;
; 3389 : 
; 3390 :         if (pBuffer)
; 3391 :         {
; 3392 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszMessage, &m_failureInfo.pszMessage);
; 3393 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCode, &m_failureInfo.pszCode);
; 3394 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFunction, &m_failureInfo.pszFunction);
; 3395 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszFile, &m_failureInfo.pszFile);
; 3396 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszCallContext, &m_failureInfo.pszCallContext);
; 3397 :             pBuffer = details::WriteResultString(pBuffer, pBufferEnd, failure.pszModule, &m_failureInfo.pszModule);
; 3398 :             pBuffer = details::WriteResultString(
; 3399 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextName, &m_failureInfo.callContextCurrent.contextName);
; 3400 :             pBuffer = details::WriteResultString(
; 3401 :                 pBuffer, pBufferEnd, failure.callContextCurrent.contextMessage, &m_failureInfo.callContextCurrent.contextMessage);
; 3402 :             pBuffer = details::WriteResultString(
; 3403 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextName, &m_failureInfo.callContextOriginating.contextName);
; 3404 :             pBuffer = details::WriteResultString(
; 3405 :                 pBuffer, pBufferEnd, failure.callContextOriginating.contextMessage, &m_failureInfo.callContextOriginating.contextMessage);
; 3406 :             ZeroMemory(pBuffer, pBufferEnd - pBuffer);
; 3407 :         }
; 3408 :     }
; 3409 : 
; 3410 :     // Relies upon generated copy constructor and assignment operator
; 3411 : 
; 3412 : protected:
; 3413 :     FailureInfo m_failureInfo;
; 3414 :     details::shared_buffer m_spStrings;
; 3415 : };
; 3416 : 
; 3417 : #if defined(WIL_ENABLE_EXCEPTIONS) || defined(WIL_FORCE_INCLUDE_RESULT_EXCEPTION)
; 3418 : 
; 3419 : //! This is WIL's default exception class thrown from all THROW_XXX macros (outside of c++/cx).
; 3420 : //! This class stores all of the FailureInfo context that is available when the exception is thrown.  It's also caught by
; 3421 : //! exception guards for automatic conversion to HRESULT.
; 3422 : //!
; 3423 : //! In c++/cx, Platform::Exception^ is used instead of this class (unless @ref wil::g_fResultThrowPlatformException has been
; 3424 : //! changed).
; 3425 : class ResultException : public std::exception
; 3426 : {
; 3427 : public:
; 3428 :     //! Constructs a new ResultException from an existing FailureInfo.
; 3429 :     ResultException(const FailureInfo& failure) WI_NOEXCEPT : m_failure(failure)
; 3430 :     {
; 3431 :     }
; 3432 : 
; 3433 :     //! Constructs a new exception type from a given HRESULT (use only for constructing custom exception types).
; 3434 :     ResultException(_Pre_satisfies_(hr < 0) HRESULT hr) WI_NOEXCEPT : m_failure(CustomExceptionFailureInfo(hr))
; 3435 :     {
; 3436 :     }
; 3437 : 
; 3438 :     //! Returns the failed HRESULT that this exception represents.
; 3439 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) HRESULT GetErrorCode() const WI_NOEXCEPT
; 3440 :     {
; 3441 :         HRESULT const hr = m_failure.GetFailureInfo().hr;
; 3442 :         __analysis_assume(hr < 0);
; 3443 :         return hr;
; 3444 :     }
; 3445 : 
; 3446 :     //! Returns the failed NTSTATUS that this exception represents.
; 3447 :     WI_NODISCARD _Always_(_Post_satisfies_(return < 0)) NTSTATUS GetStatusCode() const WI_NOEXCEPT
; 3448 :     {
; 3449 :         NTSTATUS const status = m_failure.GetFailureInfo().status;
; 3450 :         __analysis_assume(status < 0);
; 3451 :         return status;
; 3452 :     }
; 3453 : 
; 3454 :     //! Get a reference to the stored FailureInfo.
; 3455 :     WI_NODISCARD FailureInfo const& GetFailureInfo() const WI_NOEXCEPT
; 3456 :     {
; 3457 :         return m_failure.GetFailureInfo();
; 3458 :     }
; 3459 : 
; 3460 :     //! Sets the stored FailureInfo (use primarily only when constructing custom exception types).
; 3461 :     void SetFailureInfo(FailureInfo const& failure) WI_NOEXCEPT
; 3462 :     {
; 3463 :         m_failure.SetFailureInfo(failure);
; 3464 :     }
; 3465 : 
; 3466 :     //! Provides a string representing the FailureInfo from this exception.
; 3467 :     WI_NODISCARD inline const char* __CLR_OR_THIS_CALL what() const WI_NOEXCEPT override
; 3468 :     {
; 3469 : #if !defined(NONLS) && !defined(NOAPISET)
; 3470 :         if (!m_what)
; 3471 :         {
; 3472 :             wchar_t message[2048];
; 3473 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3474 : 
; 3475 :             int len = WideCharToMultiByte(CP_ACP, 0, message, -1, nullptr, 0, nullptr, nullptr);
; 3476 :             if (!m_what.create(len))
; 3477 :             {
; 3478 :                 // Allocation failed, return placeholder string.
; 3479 :                 return "WIL Exception";
; 3480 :             }
; 3481 : 
; 3482 :             WideCharToMultiByte(CP_ACP, 0, message, -1, static_cast<char*>(m_what.get()), len, nullptr, nullptr);
; 3483 :         }
; 3484 :         return static_cast<const char*>(m_what.get());
; 3485 : #else
; 3486 :         if (!m_what)
; 3487 :         {
; 3488 :             wchar_t message[2048];
; 3489 :             GetFailureLogString(message, ARRAYSIZE(message), m_failure.GetFailureInfo());
; 3490 : 
; 3491 :             char messageA[1024];
; 3492 :             wil::details::StringCchPrintfA(messageA, ARRAYSIZE(messageA), "%ws", message);
; 3493 :             m_what.create(messageA, strlen(messageA) + sizeof(*messageA));
; 3494 :         }
; 3495 :         return static_cast<const char*>(m_what.get());
; 3496 : #endif
; 3497 :     }
; 3498 : 
; 3499 :     // Relies upon auto-generated copy constructor and assignment operator
; 3500 : protected:
; 3501 :     StoredFailureInfo m_failure;           //!< The failure information for this exception
; 3502 :     mutable details::shared_buffer m_what; //!< The on-demand generated what() string
; 3503 : 
; 3504 :     //! Use to produce a custom FailureInfo from an HRESULT (use only when constructing custom exception types).
; 3505 :     static FailureInfo CustomExceptionFailureInfo(HRESULT hr) WI_NOEXCEPT
; 3506 :     {
; 3507 :         FailureInfo fi = {};
; 3508 :         fi.type = FailureType::Exception;
; 3509 :         fi.hr = hr;
; 3510 :         return fi;
; 3511 :     }
; 3512 : };
; 3513 : #endif
; 3514 : 
; 3515 : //*****************************************************************************
; 3516 : // Public Helpers that catch -- mostly only enabled when exceptions are enabled
; 3517 : //*****************************************************************************
; 3518 : 
; 3519 : // ResultFromCaughtException is a function that is meant to be called from within a catch(...) block.  Internally
; 3520 : // it re-throws and catches the exception to convert it to an HRESULT.  If an exception is of an unrecognized type
; 3521 : // the function will fail fast.
; 3522 : //
; 3523 : // try
; 3524 : // {
; 3525 : //     // Code
; 3526 : // }
; 3527 : // catch (...)
; 3528 : // {
; 3529 : //     hr = wil::ResultFromCaughtException();
; 3530 : // }
; 3531 : _Always_(_Post_satisfies_(return < 0)) __declspec(noinline) inline HRESULT ResultFromCaughtException() WI_NOEXCEPT
; 3532 : {
; 3533 :     bool isNormalized = false;
; 3534 :     HRESULT hr = S_OK;
; 3535 :     if (details::g_pfnResultFromCaughtExceptionInternal)
; 3536 :     {
; 3537 :         hr = details::g_pfnResultFromCaughtExceptionInternal(nullptr, 0, &isNormalized).hr;
; 3538 :     }
; 3539 :     if (FAILED(hr))
; 3540 :     {
; 3541 :         return hr;
; 3542 :     }
; 3543 : 
; 3544 :     // Caller bug: an unknown exception was thrown
; 3545 :     __WIL_PRIVATE_FAIL_FAST_HR_IF(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION), g_fResultFailFastUnknownExceptions);
; 3546 :     return __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3547 : }
; 3548 : 
; 3549 : //! Identical to 'throw;', but can be called from error-code neutral code to rethrow in code that *may* be running under an
; 3550 : //! exception context
; 3551 : inline void RethrowCaughtException()
; 3552 : {
; 3553 :     // We always want to rethrow the exception under normal circumstances.  Ordinarily, we could actually guarantee
; 3554 :     // this as we should be able to rethrow if we caught an exception, but if we got here in the middle of running
; 3555 :     // dynamic initializers, then it's possible that we haven't yet setup the rethrow function pointer, thus the
; 3556 :     // runtime check without the noreturn annotation.
; 3557 : 
; 3558 :     if (details::g_pfnRethrow)
; 3559 :     {
; 3560 :         details::g_pfnRethrow();
; 3561 :     }
; 3562 : }
; 3563 : 
; 3564 : //! Identical to 'throw ResultException(failure);', but can be referenced from error-code neutral code
; 3565 : inline void ThrowResultException(const FailureInfo& failure)
; 3566 : {
; 3567 :     if (details::g_pfnThrowResultException)
; 3568 :     {
; 3569 :         details::g_pfnThrowResultException(failure);
; 3570 :     }
; 3571 : }
; 3572 : 
; 3573 : /// @cond
; 3574 : namespace details
; 3575 : {
; 3576 : #ifdef WIL_ENABLE_EXCEPTIONS
; 3577 :     //*****************************************************************************
; 3578 :     // Private helpers to catch and propagate exceptions
; 3579 :     //*****************************************************************************
; 3580 : 
; 3581 :     RESULT_NORETURN inline void TerminateAndReportError(_In_opt_ PEXCEPTION_POINTERS)
; 3582 :     {
; 3583 :         // This is an intentional fail-fast that was caught by an exception guard with WIL.  Look back up the callstack to
; 3584 :         // determine the source of the actual exception being thrown.  The exception guard used by the calling code did not expect
; 3585 :         // this exception type to be thrown or is specifically requesting fail-fast for this class of exception.
; 3586 : 
; 3587 :         FailureInfo failure{};
; 3588 :         WilFailFast(failure);
; 3589 :     }
; 3590 : 
; 3591 :     inline void MaybeGetExceptionString(
; 3592 :         const ResultException& exception,
; 3593 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3594 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3595 :     {
; 3596 :         if (debugString)
; 3597 :         {
; 3598 :             GetFailureLogString(debugString, debugStringChars, exception.GetFailureInfo());
; 3599 :         }
; 3600 :     }
; 3601 : 
; 3602 :     inline void MaybeGetExceptionString(
; 3603 :         const std::exception& exception,
; 3604 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3605 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3606 :     {
; 3607 :         if (debugString)
; 3608 :         {
; 3609 :             StringCchPrintfW(debugString, debugStringChars, L"std::exception: %hs", exception.what());
; 3610 :         }
; 3611 :     }
; 3612 : 
; 3613 :     inline HRESULT ResultFromKnownException(const ResultException& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3614 :     {
; 3615 :         wchar_t message[2048]{};
; 3616 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3617 :         auto hr = exception.GetErrorCode();
; 3618 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3619 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3620 :         return hr;
; 3621 :     }
; 3622 : 
; 3623 :     inline HRESULT ResultFromKnownException(const std::bad_alloc& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3624 :     {
; 3625 :         wchar_t message[2048]{};
; 3626 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3627 :         constexpr auto hr = E_OUTOFMEMORY;
; 3628 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3629 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3630 :         return hr;
; 3631 :     }
; 3632 : 
; 3633 :     inline HRESULT ResultFromKnownException(const std::exception& exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3634 :     {
; 3635 :         wchar_t message[2048]{};
; 3636 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3637 :         constexpr auto hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3638 :         ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3639 :         return hr;
; 3640 :     }
; 3641 : 
; 3642 :     inline HRESULT ResultFromKnownException_CppWinRT(const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3643 :     {
; 3644 :         if (g_pfnResultFromCaughtException_CppWinRt)
; 3645 :         {
; 3646 :             wchar_t message[2048]{};
; 3647 :             bool ignored;
; 3648 :             auto hr = g_pfnResultFromCaughtException_CppWinRt(message, ARRAYSIZE(message), &ignored);
; 3649 :             if (FAILED(hr))
; 3650 :             {
; 3651 :                 ReportFailure_Base<FailureType::Log>(__R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3652 :                 return hr;
; 3653 :             }
; 3654 :         }
; 3655 : 
; 3656 :         // Indicate that this either isn't a C++/WinRT exception or a handler isn't configured by returning success
; 3657 :         return S_OK;
; 3658 :     }
; 3659 : 
; 3660 :     inline HRESULT RecognizeCaughtExceptionFromCallback(
; 3661 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3662 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3663 :     {
; 3664 :         HRESULT hr = g_pfnResultFromCaughtException();
; 3665 : 
; 3666 :         // If we still don't know the error -- or we would like to get the debug string for the error (if possible) we
; 3667 :         // rethrow and catch std::exception.
; 3668 : 
; 3669 :         if (SUCCEEDED(hr) || debugString)
; 3670 :         {
; 3671 :             try
; 3672 :             {
; 3673 :                 throw;
; 3674 :             }
; 3675 :             catch (std::exception& exception)
; 3676 :             {
; 3677 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3678 :                 if (SUCCEEDED(hr))
; 3679 :                 {
; 3680 :                     hr = __HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3681 :                 }
; 3682 :             }
; 3683 :             catch (...)
; 3684 :             {
; 3685 :                 // Fall through to returning 'hr' below
; 3686 :             }
; 3687 :         }
; 3688 : 
; 3689 :         return hr;
; 3690 :     }
; 3691 : 
; 3692 :     // clang-format off
; 3693 : #ifdef __cplusplus_winrt
; 3694 :     inline Platform::String^ GetPlatformExceptionMessage(Platform::Exception^ exception)
; 3695 :     {
; 3696 :         struct RawExceptionData_Partial
; 3697 :         {
; 3698 :             PCWSTR description;
; 3699 :             PCWSTR restrictedErrorString;
; 3700 :         };
; 3701 : 
; 3702 :         auto exceptionPtr = reinterpret_cast<void*>(static_cast<::Platform::Object^>(exception));
; 3703 :         auto exceptionInfoPtr = reinterpret_cast<ULONG_PTR*>(exceptionPtr) - 1;
; 3704 :         auto partial = reinterpret_cast<RawExceptionData_Partial*>(*exceptionInfoPtr);
; 3705 : 
; 3706 :         Platform::String^ message = exception->Message;
; 3707 : 
; 3708 :         PCWSTR errorString = partial->restrictedErrorString;
; 3709 :         PCWSTR messageString = reinterpret_cast<PCWSTR>(message ? message->Data() : nullptr);
; 3710 : 
; 3711 :         // An old Platform::Exception^ bug that did not actually expose the error string out of the exception
; 3712 :         // message.  We do it by hand here if the message associated with the strong does not contain the
; 3713 :         // message that was originally attached to the string (in the fixed version it will).
; 3714 : 
; 3715 :         if ((errorString && *errorString && messageString) && (wcsstr(messageString, errorString) == nullptr))
; 3716 :         {
; 3717 :             return ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(errorString));
; 3718 :         }
; 3719 :         return message;
; 3720 :     }
; 3721 : 
; 3722 :     inline void MaybeGetExceptionString(
; 3723 :         _In_ Platform::Exception^ exception,
; 3724 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3725 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars)
; 3726 :     {
; 3727 :         if (debugString)
; 3728 :         {
; 3729 :             auto message = GetPlatformExceptionMessage(exception);
; 3730 :             auto messageString = !message ? L"(null Message)" : reinterpret_cast<PCWSTR>(message->Data());
; 3731 :             StringCchPrintfW(debugString, debugStringChars, L"Platform::Exception^: %ws", messageString);
; 3732 :         }
; 3733 :     }
; 3734 : 
; 3735 :     inline HRESULT ResultFromKnownException(
; 3736 :         Platform::Exception^ exception, const DiagnosticsInfo& diagnostics, void* returnAddress)
; 3737 :     {
; 3738 :         wchar_t message[2048];
; 3739 :         message[0] = L'\0';
; 3740 :         MaybeGetExceptionString(exception, message, ARRAYSIZE(message));
; 3741 :         auto hr = exception->HResult;
; 3742 :         wil::details::ReportFailure_Base<FailureType::Log>(
; 3743 :             __R_DIAGNOSTICS_RA(diagnostics, returnAddress), ResultStatus::FromResult(hr), message);
; 3744 :         return hr;
; 3745 :     }
; 3746 : 
; 3747 :     inline HRESULT __stdcall ResultFromCaughtException_WinRt(
; 3748 :         _Inout_updates_opt_(debugStringChars) PWSTR debugString,
; 3749 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3750 :         _Inout_ bool* isNormalized) WI_NOEXCEPT
; 3751 :     {
; 3752 :         if (g_pfnResultFromCaughtException)
; 3753 :         {
; 3754 :             try
; 3755 :             {
; 3756 :                 throw;
; 3757 :             }
; 3758 :             catch (const ResultException& exception)
; 3759 :             {
; 3760 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3761 :                 return exception.GetErrorCode();
; 3762 :             }
; 3763 :             catch (Platform::Exception^ exception)
; 3764 :             {
; 3765 :                 *isNormalized = true;
; 3766 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3767 :                 // information out of the exception object and place it back into thread-local storage.
; 3768 :                 __abi_translateCurrentException(false);
; 3769 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3770 :                 return exception->HResult;
; 3771 :             }
; 3772 :             catch (const std::bad_alloc& exception)
; 3773 :             {
; 3774 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3775 :                 return E_OUTOFMEMORY;
; 3776 :             }
; 3777 :             catch (...)
; 3778 :             {
; 3779 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3780 :                 if (FAILED(hr))
; 3781 :                 {
; 3782 :                     return hr;
; 3783 :                 }
; 3784 :             }
; 3785 :         }
; 3786 :         else
; 3787 :         {
; 3788 :             try
; 3789 :             {
; 3790 :                 throw;
; 3791 :             }
; 3792 :             catch (const ResultException& exception)
; 3793 :             {
; 3794 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3795 :                 return exception.GetErrorCode();
; 3796 :             }
; 3797 :             catch (Platform::Exception^ exception)
; 3798 :             {
; 3799 :                 *isNormalized = true;
; 3800 :                 // We need to call __abi_translateCurrentException so that the CX runtime will pull the originated error
; 3801 :                 // information out of the exception object and place it back into thread-local storage.
; 3802 :                 __abi_translateCurrentException(false);
; 3803 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3804 :                 return exception->HResult;
; 3805 :             }
; 3806 :             catch (const std::bad_alloc& exception)
; 3807 :             {
; 3808 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3809 :                 return E_OUTOFMEMORY;
; 3810 :             }
; 3811 :             catch (std::exception& exception)
; 3812 :             {
; 3813 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3814 :                 return HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION);
; 3815 :             }
; 3816 :             catch (...)
; 3817 :             {
; 3818 :                 // Fall through to returning 'S_OK' below
; 3819 :             }
; 3820 :         }
; 3821 : 
; 3822 :         // Tell the caller that we were unable to map the exception by succeeding...
; 3823 :         return S_OK;
; 3824 :     }
; 3825 : 
; 3826 :     // WinRT supporting version to execute a functor and catch known exceptions.
; 3827 :     inline HRESULT __stdcall ResultFromKnownExceptions_WinRt(
; 3828 :         const DiagnosticsInfo& diagnostics, void* returnAddress, SupportedExceptions supported, IFunctor& functor)
; 3829 :     {
; 3830 :         WI_ASSERT(supported != SupportedExceptions::Default);
; 3831 : 
; 3832 :         switch (supported)
; 3833 :         {
; 3834 :         case SupportedExceptions::Known:
; 3835 :             try
; 3836 :             {
; 3837 :                 return functor.Run();
; 3838 :             }
; 3839 :             catch (const ResultException& exception)
; 3840 :             {
; 3841 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3842 :             }
; 3843 :             catch (Platform::Exception^ exception)
; 3844 :             {
; 3845 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3846 :             }
; 3847 :             catch (const std::bad_alloc& exception)
; 3848 :             {
; 3849 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3850 :             }
; 3851 :             catch (std::exception& exception)
; 3852 :             {
; 3853 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3854 :             }
; 3855 :             catch (...)
; 3856 :             {
; 3857 :                 auto hr = ResultFromKnownException_CppWinRT(diagnostics, returnAddress);
; 3858 :                 if (FAILED(hr))
; 3859 :                 {
; 3860 :                     return hr;
; 3861 :                 }
; 3862 : 
; 3863 :                 // Unknown exception
; 3864 :                 throw;
; 3865 :             }
; 3866 :             break;
; 3867 : 
; 3868 :         case SupportedExceptions::ThrownOrAlloc:
; 3869 :             try
; 3870 :             {
; 3871 :                 return functor.Run();
; 3872 :             }
; 3873 :             catch (const ResultException& exception)
; 3874 :             {
; 3875 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3876 :             }
; 3877 :             catch (Platform::Exception^ exception)
; 3878 :             {
; 3879 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3880 :             }
; 3881 :             catch (const std::bad_alloc& exception)
; 3882 :             {
; 3883 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3884 :             }
; 3885 :             break;
; 3886 : 
; 3887 :         case SupportedExceptions::Thrown:
; 3888 :             try
; 3889 :             {
; 3890 :                 return functor.Run();
; 3891 :             }
; 3892 :             catch (const ResultException& exception)
; 3893 :             {
; 3894 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3895 :             }
; 3896 :             catch (Platform::Exception^ exception)
; 3897 :             {
; 3898 :                 return ResultFromKnownException(exception, diagnostics, returnAddress);
; 3899 :             }
; 3900 :             break;
; 3901 :         }
; 3902 : 
; 3903 :         WI_ASSERT(false);
; 3904 :         return S_OK;
; 3905 :     }
; 3906 : 
; 3907 :     inline void __stdcall ThrowPlatformException(FailureInfo const& failure, LPCWSTR debugString)
; 3908 :     {
; 3909 :         throw Platform::Exception::CreateException(
; 3910 :             failure.hr, ref new Platform::String(reinterpret_cast<_Null_terminated_ const __wchar_t*>(debugString)));
; 3911 :     }
; 3912 : 
; 3913 : #if !defined(RESULT_SUPPRESS_STATIC_INITIALIZERS)
; 3914 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeWinRt, [] {
; 3915 :         g_pfnResultFromCaughtException_WinRt = ResultFromCaughtException_WinRt;
; 3916 :         g_pfnResultFromKnownExceptions_WinRt = ResultFromKnownExceptions_WinRt;
; 3917 :         g_pfnThrowPlatformException = ThrowPlatformException;
; 3918 :         return 1;
; 3919 :     });
; 3920 : #endif
; 3921 : #endif
; 3922 :     // clang-format on
; 3923 : 
; 3924 :     inline void __stdcall Rethrow()
; 3925 :     {
; 3926 :         throw;
; 3927 :     }
; 3928 : 
; 3929 :     inline void __stdcall ThrowResultExceptionInternal(const FailureInfo& failure)
; 3930 :     {
; 3931 :         throw ResultException(failure);
; 3932 :     }
; 3933 : 
; 3934 :     __declspec(noinline) inline ResultStatus __stdcall ResultFromCaughtExceptionInternal(
; 3935 :         _Out_writes_opt_(debugStringChars) PWSTR debugString,
; 3936 :         _When_(debugString != nullptr, _Pre_satisfies_(debugStringChars > 0)) size_t debugStringChars,
; 3937 :         _Out_ bool* isNormalized) WI_NOEXCEPT
; 3938 :     {
; 3939 :         if (debugString)
; 3940 :         {
; 3941 :             *debugString = L'\0';
; 3942 :         }
; 3943 :         *isNormalized = false;
; 3944 : 
; 3945 :         if (details::g_pfnResultFromCaughtException_CppWinRt != nullptr)
; 3946 :         {
; 3947 :             const auto hr = details::g_pfnResultFromCaughtException_CppWinRt(debugString, debugStringChars, isNormalized);
; 3948 :             if (FAILED(hr))
; 3949 :             {
; 3950 :                 return ResultStatus::FromResult(hr);
; 3951 :             }
; 3952 :         }
; 3953 : 
; 3954 :         if (details::g_pfnResultFromCaughtException_WinRt != nullptr)
; 3955 :         {
; 3956 :             const auto hr = details::g_pfnResultFromCaughtException_WinRt(debugString, debugStringChars, isNormalized);
; 3957 :             return ResultStatus::FromResult(hr);
; 3958 :         }
; 3959 : 
; 3960 :         if (g_pfnResultFromCaughtException)
; 3961 :         {
; 3962 :             try
; 3963 :             {
; 3964 :                 throw;
; 3965 :             }
; 3966 :             catch (const ResultException& exception)
; 3967 :             {
; 3968 :                 *isNormalized = true;
; 3969 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3970 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3971 :             }
; 3972 :             catch (const std::bad_alloc& exception)
; 3973 :             {
; 3974 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3975 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 3976 :             }
; 3977 :             catch (...)
; 3978 :             {
; 3979 :                 auto hr = RecognizeCaughtExceptionFromCallback(debugString, debugStringChars);
; 3980 :                 if (FAILED(hr))
; 3981 :                 {
; 3982 :                     return ResultStatus::FromResult(hr);
; 3983 :                 }
; 3984 :             }
; 3985 :         }
; 3986 :         else
; 3987 :         {
; 3988 :             try
; 3989 :             {
; 3990 :                 throw;
; 3991 :             }
; 3992 :             catch (const ResultException& exception)
; 3993 :             {
; 3994 :                 *isNormalized = true;
; 3995 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 3996 :                 return ResultStatus::FromFailureInfo(exception.GetFailureInfo());
; 3997 :             }
; 3998 :             catch (const std::bad_alloc& exception)
; 3999 :             {
; 4000 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);
; 4001 :                 return ResultStatus::FromResult(E_OUTOFMEMORY);
; 4002 :             }
; 4003 :             catch (std::exception& exception)
; 4004 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$6|

; 4005 :                 MaybeGetExceptionString(exception, debugString, debugStringChars);

	ldp         x2,x1,[fp,#0x20]
	ldr         x0,[fp,#0x58]
	bl          |?MaybeGetExceptionString@details@wil@@YAXAEBVexception@std@@PEA_W_K@Z|

; 1938 :             return {_hr, wil::details::HrToNtStatus(_hr), Kind::HResult};

	ldr         w0,|$LN83@catch$5|
	str         w0,[fp,#0x10]
	bl          |?HrToNtStatus@details@wil@@YAJJ@Z|
	stp         w0,wzr,[fp,#0x14]

; 4006 :                 return ResultStatus::FromResult(__HRESULT_FROM_WIN32(ERROR_UNHANDLED_EXCEPTION));

	adrp        x0,|$LN23@catch$5|
	add         x0,x0,|$LN23@catch$5|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3
	nop
|$LN83@catch$5|
	DCD         0x8007023e

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$6@?0??ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z@4HA| PROC ; `wil::details::ResultFromCaughtExceptionInternal'::`1'::catch$6

; 4009 :             {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z$7|

; 4010 :                 // Fall through to returning 'S_OK' below
; 4011 :             }

	adrp        x0,|$LN37@catch$6|
	add         x0,x0,|$LN37@catch$6|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?ResultFromCaughtExceptionInternal@details@wil@@YA?AUResultStatus@12@PEA_W_KPEA_N@Z|, wil::details::ResultFromCaughtExceptionInternal

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z| PROC ; wil::details::RunFunctorWithExceptionFilter

; 4155 :     {

|$LN12|
	stp         fp,lr,[sp,#-0x30]!
	mov         fp,sp
	mov         x8,x0
	mov         x0,x1
	mov         xip0,#-2
	stp         x0,x2,[fp,#0x10]
	str         xip0,[fp,#0x20]

; 4156 :         try
; 4157 :         {
; 4158 :             return host.Run(functor);

	ldr         x9,[x0]
	mov         x1,x8
	ldr         x9,[x9]
	blr         x9
	b           |$LN6@RunFunctor|
|$LN7@RunFunctor|

; 4159 :         }
; 4160 :         catch (...)
; 4161 :         {
; 4162 :             // Note that the host may choose to re-throw, throw a normalized exception, return S_OK and eat the exception or
; 4163 :             // return the remapped failure.
; 4164 :             return host.ExceptionThrown(returnAddress);

	ldr         w0,[fp,#0x10]
|$LN6@RunFunctor|
	ldp         fp,lr,[sp],#0x30
	ret
	svc         #3

	ENDP  ; |?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|, wil::details::RunFunctorWithExceptionFilter

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?catch$0@?0??RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z@4HA| PROC ; `wil::details::RunFunctorWithExceptionFilter'::`1'::catch$0

; 4161 :         {

	stp         fp,lr,[sp,#-0x10]!
|__catch$?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z$0|

; 4162 :             // Note that the host may choose to re-throw, throw a normalized exception, return S_OK and eat the exception or
; 4163 :             // return the remapped failure.
; 4164 :             return host.ExceptionThrown(returnAddress);

	ldp         x0,x1,[fp,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#8]
	blr         x8
	str         w0,[fp,#0x10]
	adrp        x0,|$LN7@catch$0|
	add         x0,x0,|$LN7@catch$0|
	ldp         fp,lr,[sp],#0x10
	ret
	svc         #3

	ENDP  ; |?RunFunctorWithExceptionFilter@details@wil@@YAJAEAUIFunctor@12@AEAUIFunctorHost@12@PEAX@Z|, wil::details::RunFunctorWithExceptionFilter

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??R<lambda_2>@details@wil@@QEBA@XZ| PROC		; wil::details::<lambda_2>::operator()

; 4168 :     WI_HEADER_INITIALIZATION_FUNCTION(InitializeResultExceptions, [] {

	mov         w0,#1
	ret

	ENDP  ; |??R<lambda_2>@details@wil@@QEBA@XZ|, wil::details::<lambda_2>::operator()

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z| PROC ; wil::EnterCriticalSection

; 3353 : {

|$LN16|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
	mov         x19,x1
	mov         x20,x0
	mov         x0,x19
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x19,[x20]

; 3355 :     return cs_leave_scope_exit(pcs);

	mov         x0,x20
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |?EnterCriticalSection@wil@@YA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@1@PEAU_RTL_CRITICAL_SECTION@@@Z|, wil::EnterCriticalSection

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ| PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >
|$LN21|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x0]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN18@unique_any|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
|$LN18@unique_any|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|, wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??0critical_section@wil@@QEAA@K@Z| PROC		; wil::critical_section::critical_section

; 3373 :     critical_section(ULONG spincount = 0) WI_NOEXCEPT

|$LN8|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 3374 :     {
; 3375 :         // Initialization will not fail without invalid params...
; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
	mov         w2,#0
	mov         w1,#0
	mov         x19,x0
	blr         x8

; 3377 :     }

	mov         x0,x19
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |??0critical_section@wil@@QEAA@K@Z|, wil::critical_section::critical_section

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??1critical_section@wil@@QEAA@XZ| PROC			; wil::critical_section::~critical_section

; 3380 :     {

|$LN8|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 3381 :         ::DeleteCriticalSection(&m_cs);

	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	blr         x8
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??1critical_section@wil@@QEAA@XZ|, wil::critical_section::~critical_section

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ| PROC ; wil::critical_section::lock

; 3385 :     {

|$LN21|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
	mov         x20,x0
	mov         x19,x1
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[x19]

; 3386 :         return wil::EnterCriticalSection(&m_cs);

	mov         x0,x19
	ldp         fp,lr,[sp],#0x10
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |?lock@critical_section@wil@@QEAA?AV?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@2@XZ|, wil::critical_section::lock

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h

	AREA	|.text$mn|, CODE, ARM64

|?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ| PROC		; CUnknown::GetOwner

; 197  :         return m_pUnknown;

	ldr         x0,[x0,#8]
	ret

	ENDP  ; |?GetOwner@CUnknown@@QEBAPEAUIUnknown@@XZ|, CUnknown::GetOwner

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h

	AREA	|.text$mn|, CODE, ARM64

|?toULong@@YAKW4UACSampleFormat@@@Z| PROC		; toULong

; 81   : {

	ret

	ENDP  ; |?toULong@@YAKW4UACSampleFormat@@@Z|, toULong

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h

	AREA	|.text$mn|, CODE, ARM64

|?toInt@@YAHW4DeviceStatuses@@@Z| PROC			; toInt

; 99   : {

	ret

	ENDP  ; |?toInt@@YAHW4DeviceStatuses@@@Z|, toInt

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h

	AREA	|.text$mn|, CODE, ARM64

|?toInt@@YAHW4UserThreadStatuses@@@Z| PROC		; toInt

; 138  : {

	ret

	ENDP  ; |?toInt@@YAHW4UserThreadStatuses@@@Z|, toInt

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\shared\UAC_User.h

	AREA	|.text$mn|, CODE, ARM64

|?toInt@@YAHW4UACSampleType@@@Z| PROC			; toInt

; 169  : {

	ret

	ENDP  ; |?toInt@@YAHW4UACSampleType@@@Z|, toInt

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

	AREA	|.text$mn|, CODE, ARM64

|?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| PROC ; CUSBAsio::QueryInterface

; 69   :     DECLARE_IUNKNOWN

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8]
	br          x8

	ENDP  ; |?QueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z|, CUSBAsio::QueryInterface

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

	AREA	|.text$mn|, CODE, ARM64

|?AddRef@CUSBAsio@@UEAAKXZ| PROC			; CUSBAsio::AddRef

; 69   :     DECLARE_IUNKNOWN

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#8]
	br          x8

	ENDP  ; |?AddRef@CUSBAsio@@UEAAKXZ|, CUSBAsio::AddRef

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

	AREA	|.text$mn|, CODE, ARM64

|?Release@CUSBAsio@@UEAAKXZ| PROC			; CUSBAsio::Release

; 69   :     DECLARE_IUNKNOWN

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#0x10]
	br          x8

	ENDP  ; |?Release@CUSBAsio@@UEAAKXZ|, CUSBAsio::Release

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z| PROC	; getNanoSeconds

; 100  : {

	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 101  :     double nanoSeconds = (double)((unsigned long)timeGetTime()) * 1000000.;

	adrp        x8,__imp_timeGetTime
	ldr         x8,[x8,__imp_timeGetTime]
	mov         x19,x0
	blr         x8
	ldr         d16,|$LN6@getNanoSec|
	ucvtf       d17,w0
	fmul        d18,d17,d16

; 102  :     timeStamp->hi = (unsigned long)(nanoSeconds / c_TwoRaisedTo32);

	ldr         d16,|$LN7@getNanoSec|
	fmul        d16,d18,d16
	fcvtzu      w9,d16

; 103  :     timeStamp->lo = (unsigned long)(nanoSeconds - (timeStamp->hi * c_TwoRaisedTo32));

	ldr         d16,|$LN8@getNanoSec|
	ucvtf       d17,w9
	fmul        d16,d17,d16
	fsub        d16,d18,d16
	fcvtzu      w8,d16
	stp         w9,w8,[x19]
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
|$LN6@getNanoSec|
	DCFD         1e+06
|$LN7@getNanoSec|
	DCFD         2.32831e-10
|$LN8@getNanoSec|
	DCFD         4.29497e+09

	ENDP  ; |?getNanoSeconds@@YAXPEAUASIOTimeStamp@@@Z|, getNanoSeconds

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z| PROC ; CUSBAsio::CreateInstance

; 159  : {

|$LN243|
	stp         fp,lr,[sp,#-0x60]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	str         x27,[sp,#0x50]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x380
	mov         x26,sp
	mov         xip0,#-2
	mov         x22,x0
	str         xip0,[x26]

; 160  :     return (CUnknown *)new CUSBAsio(unknown, result);

	mov         x0,#0xE98
	bl          |??2@YAPEAX_K@Z|
	mov         x19,x0
	str         x19,[x26,#8]
	mov         x2,#0xE98
	mov         w1,#0
	bl          memset
	adrp        x8,|??_7IASIO@@6B@|
	add         x8,x8,|??_7IASIO@@6B@|
	str         x8,[x19]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 30   :     InterlockedIncrement(&m_cObjects);

	adrp        x8,|?m_cObjects@CBaseObject@@0JA|
	add         x0,x8,|?m_cObjects@CBaseObject@@0JA|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 182  :     : CUnknown((TCHAR *)_T("CUSBAsio"), unknown, result)

	add         x23,x19,#8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 30   :     InterlockedIncrement(&m_cObjects);

	bl          _InterlockedIncrement

; 71   : {

	adrp        x8,|??_7CUnknown@@6B@|
	add         x9,x8,|??_7CUnknown@@6B@|

; 62   : /* Set our pointer to our IUnknown interface.                      */
; 63   : /* If we have an outer, use its, otherwise use ours.               */
; 64   : /* This pointer effectivly points to the owner of                  */
; 65   : /* this object and can be accessed by the GetOwner() method.       */
; 66   : , m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )

	cmp         x22,#0
	cselne      x8,x22,x23
	stp         x9,x8,[x23]

; 31   : 
; 32   : #ifdef DEBUG
; 33   :     m_dwCookie = DbgRegisterObjectCreation(pName);
; 34   : #endif
; 35   : }
; 36   : 
; 37   : 
; 38   : /* Destructor */
; 39   : 
; 40   : CBaseObject::~CBaseObject()
; 41   : {
; 42   :     /* Decrement the number of objects active */
; 43   :     InterlockedDecrement(&m_cObjects);
; 44   : 
; 45   : #ifdef DEBUG
; 46   :     DbgRegisterObjectDestruction(m_dwCookie);
; 47   : #endif
; 48   : }
; 49   : 
; 50   : 
; 51   : /* Constructor */
; 52   : 
; 53   : // We know we use "this" in the initialization list, we also know we don't modify *phr.
; 54   : #pragma warning( disable : 4355 4100 ) 
; 55   : CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) 
; 56   : : CBaseObject(pName)
; 57   : /* Start the object with a reference count of zero - when the      */
; 58   : /* object is queried for it's first interface this may be          */
; 59   : /* incremented depending on whether or not this object is          */
; 60   : /* currently being aggregated upon                                 */
; 61   : , m_cRef(0)

	str         wzr,[x23,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	adrp        x8,|??_7CUSBAsio@@6BIASIO@@@|
	add         x8,x8,|??_7CUSBAsio@@6BIASIO@@@|
	str         x8,[x19]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 160  :     double                        m_sampleRate{UAC_DEFAULT_SAMPLE_RATE};

	ldr         d16,|$LN242@CreateInst|
	adrp        x8,|??_7CUSBAsio@@6BCUnknown@@@|
	add         x8,x8,|??_7CUSBAsio@@6BCUnknown@@@|
	str         xzr,[x19,#0x20]

; 161  :     ASIOCallbacks *               m_callbacks{nullptr};

	str         xzr,[x19,#0x30]

; 162  :     ASIOTime                      m_asioTime{0};
; 163  :     ASIOTimeStamp                 m_theSystemTime{0};
; 164  :     volatile UCHAR *              m_inputBuffers[NUMOFINPUTS * 2]{};

	mov         x2,#0x400
	str         d16,[x19,#0x28]
	movi        v16.16b,#0
	mov         w1,#0
	str         x8,[x23]
	add         x8,x19,#0x38
	add         x0,x19,#0xD8
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	str         q16,[x8,#0x80]
	str         s16,[x8,#0x90]
	stur        xzr,[x19,#0xCC]
	bl          memset

; 165  :     UCHAR *                       m_outputBuffers[NUMOFOUTPUTS * 2]{};

	mov         x2,#0x400
	mov         w1,#0
	add         x0,x19,#0x4D8
	bl          memset
	add         x8,x19,#0x8D8

; 166  :     DWORD                         m_initialSystemTime{0};
; 167  :     DWORD                         m_calculatedSystemTime{0};
; 168  :     ULONGLONG                     m_initialKernelTime{0};
; 169  :     TCHAR *                       m_desiredPath{nullptr};
; 170  :     long                          m_inMap[NUMOFINPUTS]{};

	movi        v16.16b,#0
	stp         xzr,xzr,[x8]
	add         x8,x19,#0x8F0
	str         xzr,[x19,#0x8E8]
	add         x9,x19,#0xAF0
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	stp         q16,q16,[x8,#0x80]
	stp         q16,q16,[x8,#0xA0]
	stp         q16,q16,[x8,#0xC0]
	stp         q16,q16,[x8,#0xE0]

; 171  :     long                          m_outMap[NUMOFOUTPUTS]{};

	movi        v16.16b,#0
	add         x8,x19,#0x9F0
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	stp         q16,q16,[x8,#0x80]
	stp         q16,q16,[x8,#0xA0]
	stp         q16,q16,[x8,#0xC0]
	stp         q16,q16,[x8,#0xE0]

; 172  :     long                          m_blockFrames{UAC_DEFAULT_ASIO_BUFFER_SIZE};

	mov         x8,#0x200
	stp         x8,xzr,[x9]

; 173  :     long                          m_inputLatency{0};
; 174  :     long                          m_outputLatency{0};
; 175  :     ULONG                         m_activeInputs{0};
; 176  :     ULONG                         m_activeOutputs{0};

	str         xzr,[x19,#0xB00]

; 177  :     long                          m_toggle{0};
; 178  :     bool                          m_isActive{false};
; 179  :     bool                          m_isStarted{false};
; 180  :     bool                          m_isTimeInfoMode{false};
; 181  :     bool                          m_isTcRead{false};
; 182  :     TCHAR                         m_errorMessage[ERROR_MESSAGE_LENGTH]{};

	movi        v16.16b,#0
	str         wzr,[x19,#0xB08]
	add         x21,x19,#0xB0C

; 183  :     bool                          m_requireSampleRateChange{0.};
; 184  :     ASIOSampleRate                m_nextSampleRate{0.};
; 185  :     bool                          m_isRequireAsioReset{false};
; 186  :     bool                          m_isDropoutDetectionSetting{true};
; 187  :     bool                          m_isSupportDropoutDetection{false};
; 188  :     bool                          m_isRequireReportDropout{false};
; 189  :     bool                          m_isRequireLatencyChange{false};
; 190  :     LONG                          m_outputReadyBlock{0};
; 191  :     HANDLE                        m_usbDeviceHandle{INVALID_HANDLE_VALUE};
; 192  :     UAC_AUDIO_PROPERTY            m_audioProperty{0};

	add         x20,x19,#0xBB0
	mov         w8,#0x100
	stp         q16,q16,[x21]
	mov         x25,#-1
	stp         q16,q16,[x21,#0x20]
	add         x0,x26,#0x10
	stp         q16,q16,[x21,#0x40]
	mov         w2,#0x198
	stp         q16,q16,[x21,#0x60]
	movi        v16.16b,#0
	add         x1,x19,#0xBB0
	str         w8,[x19,#0xB98]
	strb        wzr,[x19,#0xB8C]
	str         xzr,[x19,#0xB90]
	strb        wzr,[x19,#0xB9C]
	str         wzr,[x19,#0xBA0]
	str         x25,[x19,#0xBA8]
	stp         q16,q16,[x20]
	stp         q16,q16,[x20,#0x20]
	stp         q16,q16,[x20,#0x40]
	stp         q16,q16,[x20,#0x60]
	stp         q16,q16,[x20,#0x80]
	stp         q16,q16,[x20,#0xA0]
	stp         q16,q16,[x20,#0xC0]
	stp         q16,q16,[x20,#0xE0]
	stp         q16,q16,[x20,#0x100]
	stp         q16,q16,[x20,#0x120]
	stp         q16,q16,[x20,#0x140]
	stp         q16,q16,[x20,#0x160]
	str         q16,[x20,#0x180]
	str         d16,[x20,#0x190]
	bl          memcpy

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	movi        v16.16b,#0
	add         x23,x19,#0xD48

; 194  :     ULONG                         m_fixedSamplingRate{0};

	add         x8,x19,#0xD84
	stp         q16,q16,[x23]
	add         x22,x19,#0xD98

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         q16,[x23,#0x20]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	mov         w2,#0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         d16,[x23,#0x30]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	mov         w1,#0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         s16,[x23,#0x38]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	add         x0,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 194  :     ULONG                         m_fixedSamplingRate{0};

	str         xzr,[x8]
	str         x8,[x26,#0x1D0]

; 195  :     ASIOIoFormatType              m_requestedSampleFormat{0};
; 196  :     ULONG                         m_inAvailableChannels{0};

	add         x8,x19,#0xD8C
	str         xzr,[x8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 198  :     PUAC_GET_CHANNEL_INFO_CONTEXT m_channelInfo{nullptr};

	stp         xzr,xzr,[x22]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	blr         x8
	nop
	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
	mov         w2,#0
	mov         w1,#0
	add         x0,x19,#0xDD0
	blr         x8
	nop
	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
	mov         w2,#0
	mov         w1,#0
	add         x0,x19,#0xDF8
	blr         x8
	nop
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 212  :     LONG                          m_threadPriority{-2};

	mov         w8,#-2
	stp         xzr,xzr,[x22,#0x88]
	str         w8,[x19,#0xE68]
	stp         xzr,xzr,[x22,#0x98]
	stp         xzr,xzr,[x22,#0xA8]
	stp         xzr,xzr,[x22,#0xB8]
	str         xzr,[x19,#0xE60]

; 213  :     HANDLE                        m_asioResetEvent{nullptr};

	stp         xzr,xzr,[x22,#0xD8]

; 214  :     HANDLE                        m_terminateAsioResetEvent{nullptr};
; 215  :     HANDLE                        m_asioResetThread{nullptr};

	stp         xzr,xzr,[x22,#0xE8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 191  :     m_InstanceIndex = InterlockedIncrement(&g_Instance);

	adrp        x8,|?g_Instance@@3JA|
	add         x0,x8,|?g_Instance@@3JA|
	bl          _InterlockedIncrement

; 192  : 
; 193  :     info_print_("USB ASIO created, instance %d.\n", InterlockedCompareExchange(&g_Instance, 0, 0));
; 194  : 
; 195  :     RtlZeroMemory(&m_audioProperty, sizeof(UAC_AUDIO_PROPERTY));

	movi        v16.16b,#0
	str         w0,[x19,#0xE90]
	stp         q16,q16,[x20]
	stp         q16,q16,[x20,#0x20]
	stp         q16,q16,[x20,#0x40]
	stp         q16,q16,[x20,#0x60]
	stp         q16,q16,[x20,#0x80]
	stp         q16,q16,[x20,#0xA0]
	stp         q16,q16,[x20,#0xC0]
	stp         q16,q16,[x20,#0xE0]
	stp         q16,q16,[x20,#0x100]
	stp         q16,q16,[x20,#0x120]
	stp         q16,q16,[x20,#0x140]
	stp         q16,q16,[x20,#0x160]
	str         q16,[x20,#0x180]
	str         d16,[x20,#0x190]

; 1679 :     if (m_desiredPath != nullptr)

	ldr         x0,[x19,#0x8E8]
	cbz         x0,|$LN55@CreateInst|

; 1680 :     {
; 1681 :         delete[] m_desiredPath;

	bl          |??_V@YAXPEAX@Z|

; 1682 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]
|$LN55@CreateInst|

; 1683 :     }
; 1684 : 
; 1685 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	adrp        x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	add         x1,x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	adrp        x8,__imp_RegOpenKeyExA
	ldr         x8,[x8,__imp_RegOpenKeyExA]
	add         x4,x26,#0x1B0
	mov         w3,#0x19
	movk        w3,#2,lsl #0x10
	mov         w2,#0
	mov         x0,#-0x7FFFFFFF
	blr         x8

; 1686 :     if (result != ERROR_SUCCESS)

	cbnz        w0,|$LN54@CreateInst|

; 1687 :     {
; 1688 :         return false;
; 1689 :     }
; 1690 : 
; 1691 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, nullptr, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	ldr         x0,[x26,#0x1B0]
	adrp        x22,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x1,x22,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x5,x26,#0x1B8
	mov         x4,#0
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1692 :     if (result != ERROR_SUCCESS || size == 0)

	cbnz        w0,|$LN58@CreateInst|
	ldr         w0,[x26,#0x1B8]
	cbz         w0,|$LN58@CreateInst|

; 1695 :         return false;
; 1696 :     }
; 1697 : 
; 1698 :     m_desiredPath = new TCHAR[size / sizeof(TCHAR)];

	bl          |??_U@YAPEAX_K@Z|

; 1699 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, (LPBYTE)m_desiredPath, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         x0,[x19,#0x8E8]
	mov         x4,x0
	ldr         x0,[x26,#0x1B0]
	add         x5,x26,#0x1B8
	mov         x3,#0
	mov         x2,#0
	add         x1,x22,|??_C@_0L@ONBBLLLB@AsioDevice@|
	blr         x8

; 1700 :     if (result != ERROR_SUCCESS)

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	cbz         w0,|$LN59@CreateInst|

; 1701 :     {
; 1702 :         RegCloseKey(hKey);

	ldr         x0,[x26,#0x1B0]
	blr         x8

; 1703 :         delete[] m_desiredPath;

	ldr         x0,[x19,#0x8E8]
	bl          |??_V@YAXPEAX@Z|

; 1704 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]

; 1705 :         return false;

	b           |$LN54@CreateInst|
|$LN58@CreateInst|

; 1693 :     {
; 1694 :         RegCloseKey(hKey);

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
|$LN59@CreateInst|

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	ldr         x0,[x26,#0x1B0]
	blr         x8
|$LN54@CreateInst|
	ldr         x22,[x19,#0x8E8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 157  :     HANDLE targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, desiredPath);

	mov         x3,x22
	bl          |?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z|

; 158  : 
; 159  :     if ((targetHandle == INVALID_HANDLE_VALUE) && (desiredPath != nullptr))

	cmn         x0,#1
	ccmpeq      x22,#0,#4
	beq         |$LN62@CreateInst|

; 160  :     {
; 161  :         // force open
; 162  :         targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, nullptr);

	mov         x3,#0
	bl          |?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z|
|$LN62@CreateInst|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	str         x0,[x19,#0xBA8]

; 200  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE)

	cmn         x0,#1
	bne         |$LN23@CreateInst|

; 201  :     {
; 202  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 203  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	stp         q16,q16,[x26,#0x280]
	stp         q16,q16,[x26,#0x2A0]
	stp         q16,q16,[x26,#0x2C0]
	stp         q16,q16,[x26,#0x2E0]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x280
	mov         w1,#0x66
	blr         x8

; 204  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x280
	mov         x1,#0x80
	mov         x0,x21
	bl          strcpy_s

; 205  :         return;

	b           |$LN11@CreateInst|
|$LN23@CreateInst|

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x20,x8,KSPROPSETID_LowLatencyAudio
	str         x21,[x26,#0x1B8]
	mov         x0,#8
	movk        x0,#2,lsl #0x20
	mov         w24,#0
	mov         x21,x0
	mov         w22,#3
	movk        w22,#0x2F,lsl #0x10
	adrp        x27,__imp_DeviceIoControl
	adrp        x25,__imp_Sleep
|$LN14@CreateInst|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 373  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	ldr         q16,[x20]

; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         wzr,[x26,#0x1D8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 211  :         isSuccess = GetAsioOwnership(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	add         x6,x26,#0x1D8
	str         x21,[x26,#0x210]
	ldr         x8,[x27,__imp_DeviceIoControl]
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	str         q16,[x26,#0x200]
	add         x2,x26,#0x200
	mov         w1,w22
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 212  :         if (isSuccess)

	cbnz        w0,|$LN238@CreateInst|

; 213  :         {
; 214  :             break;
; 215  :         }
; 216  :         if (retry < maxRetry - 1)

	cmp         w24,#5
	bhs         |$LN12@CreateInst|

; 217  :         {
; 218  :             Sleep(500);

	ldr         x8,[x25,__imp_Sleep]
	mov         w0,#0x1F4
	blr         x8
|$LN12@CreateInst|

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	add         w24,w24,#1
	cmp         w24,#6
	blo         |$LN14@CreateInst|

; 219  :         }
; 220  :     }
; 221  : 
; 222  :     if (!isSuccess)
; 223  :     {
; 224  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 225  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	ldr         x21,[x26,#0x1B8]
	mov         x25,#-1
	stp         q16,q16,[x26,#0x300]
	stp         q16,q16,[x26,#0x320]
	stp         q16,q16,[x26,#0x340]
	stp         q16,q16,[x26,#0x360]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x300
	mov         w1,#0x66
	blr         x8

; 226  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x300
	mov         x1,#0x80
	mov         x0,x21
	bl          strcpy_s

; 227  :         CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xBA8]
	blr         x8

; 228  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	str         x25,[x19,#0xBA8]
|$LN238@CreateInst|

; 1503 :     m_driverFlags.FirstPacketLatency = UAC_DEFAULT_FIRST_PACKET_LATENCY;

	mov         w8,#0x14
	ldr         x27,[x26,#0x1D0]

; 1504 :     m_driverFlags.ClassicFramesPerIrp = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1505 :     m_driverFlags.MaxIrpNumber = UAC_DEFAULT_MAX_IRP_NUMBER;
; 1506 :     m_driverFlags.PreSendFrames = UAC_DEFAULT_PRE_SEND_FRAMES;
; 1507 :     m_driverFlags.OutputFrameDelay = UAC_DEFAULT_OUTPUT_FRAME_DELAY;
; 1508 :     m_driverFlags.DelayedOutputBufferSwitch = UAC_DEFAULT_DELAYED_OUTPUT_BUFFER_SWITCH;

	str         wzr,[x19,#0xD5C]
	str         w8,[x23]
	add         x9,x19,#0xD4C
	mov         x8,#4
	movk        x8,#8,lsl #0x20
	str         x9,[x26,#0x1B8]
	str         x8,[x9]
	add         x9,x19,#0xD54
	str         x9,[x26,#0x1B0]

; 1509 :     m_driverFlags.InputBufferOperationOffset = UAC_DEFAULT_IN_BUFFER_OPERATION_OFFSET;

	mov         x8,#0x90000000
	str         xzr,[x9]
	add         x9,x19,#0xD64
	str         x8,[x9]

; 1510 :     m_driverFlags.InputHubOffset = UAC_DEFAULT_IN_HUB_OFFSET;
; 1511 :     m_driverFlags.OutputBufferOperationOffset = UAC_DEFAULT_OUT_BUFFER_OPERATION_OFFSET;

	mov         x8,#0x10
	movk        x8,#0x9000,lsl #0x10
	add         x24,x19,#0xD6C
	str         wzr,[x27]
	str         x8,[x24]

; 1512 :     m_driverFlags.OutputHubOffset = UAC_DEFAULT_OUT_HUB_OFFSET;
; 1513 :     m_driverFlags.BufferThreadPriority = UAC_DEFAULT_BUFFER_THREAD_PRIORITY;

	mov         x8,#0x1E
	movk        x8,#4,lsl #0x20
	add         x25,x19,#0xD74
	str         x9,[x26,#0x1D0]
	str         x8,[x25]

; 1514 :     m_driverFlags.ClassicFramesPerIrp2 = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1515 :     m_driverFlags.SuggestedBufferPeriod = UAC_DEFAULT_ASIO_BUFFER_SIZE;
; 1516 :     m_threadPriority = 2;

	mov         w8,#2
	str         w8,[x19,#0xE68]

; 1517 :     m_isDropoutDetectionSetting = UAC_DEFAULT_DROPOUT_DETECTION;

	mov         w8,#1
	strb        w8,[x19,#0xB99]

; 1518 : 
; 1519 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	adrp        x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	add         x1,x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	adrp        x8,__imp_RegOpenKeyExA
	ldr         x8,[x8,__imp_RegOpenKeyExA]
	mov         x10,#0x200
	add         x4,x26,#0x1A8
	mov         w3,#0x19
	movk        w3,#2,lsl #0x10
	str         w10,[x19,#0xAF0]
	mov         w2,#0
	str         w10,[x19,#0xD7C]
	mov         x0,#-0x7FFFFFFF
	blr         x8

; 1520 : 
; 1521 :     if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN67@CreateInst|

; 1522 :     {
; 1523 :         size = sizeof(ULONG);
; 1524 :         result = RegQueryValueEx(hKey, c_FixedSamplingRateValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BC@CNPFEPCO@FixedSamplingRate@|
	add         x1,x8,|??_C@_0BC@CNPFEPCO@FixedSamplingRate@|
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	ldr         x0,[x26,#0x1A8]
	mov         w21,#4
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	str         w21,[x26,#0x1C8]
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1525 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN68@CreateInst|

; 1526 :         {
; 1527 :             m_fixedSamplingRate = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x27]
|$LN68@CreateInst|

; 1528 :         }
; 1529 : 
; 1530 :         size = sizeof(ULONG);
; 1531 :         result = RegQueryValueEx(hKey, c_PeriodFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@FDBGAPPM@PeriodFrames@|
	add         x1,x8,|??_C@_0N@FDBGAPPM@PeriodFrames@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1532 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN69@CreateInst|

; 1533 :         {
; 1534 :             m_blockFrames = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xAF0]
|$LN69@CreateInst|

; 1535 :         }
; 1536 : 
; 1537 :         size = sizeof(ULONG);
; 1538 :         result = RegQueryValueEx(hKey, c_FirstPacketLatencyValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BD@JPDMMNEG@FirstPacketLatency@|
	add         x1,x8,|??_C@_0BD@JPDMMNEG@FirstPacketLatency@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1539 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN70@CreateInst|

; 1540 :         {
; 1541 :             m_driverFlags.FirstPacketLatency = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x23]
|$LN70@CreateInst|

; 1542 :         }
; 1543 :         size = sizeof(ULONG);
; 1544 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrpValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@|
	add         x1,x8,|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1545 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN71@CreateInst|

; 1546 :         {
; 1547 :             m_driverFlags.ClassicFramesPerIrp = temp;

	ldr         w8,[x26,#0x1CC]
	ldr         x9,[x26,#0x1B8]
	str         w8,[x9]
|$LN71@CreateInst|

; 1548 :         }
; 1549 :         size = sizeof(ULONG);
; 1550 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrp2ValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@|
	add         x1,x8,|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1551 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN72@CreateInst|

; 1552 :         {
; 1553 :             m_driverFlags.ClassicFramesPerIrp2 = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD78]
|$LN72@CreateInst|

; 1554 :         }
; 1555 : 
; 1556 :         size = sizeof(ULONG);
; 1557 :         result = RegQueryValueEx(hKey, c_MaxIrpNumberValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@BNFIBEN@MaxIrpNumber@|
	add         x1,x8,|??_C@_0N@BNFIBEN@MaxIrpNumber@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1558 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN73@CreateInst|

; 1559 :         {
; 1560 :             m_driverFlags.MaxIrpNumber = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD50]
|$LN73@CreateInst|

; 1561 :         }
; 1562 : 
; 1563 :         size = sizeof(ULONG);
; 1564 :         result = RegQueryValueEx(hKey, c_PreSendFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0O@DDKFKBEA@PreSendFrames@|
	add         x1,x8,|??_C@_0O@DDKFKBEA@PreSendFrames@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1565 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN74@CreateInst|

; 1566 :         {
; 1567 :             m_driverFlags.PreSendFrames = temp;

	ldr         w8,[x26,#0x1CC]
	ldr         x9,[x26,#0x1B0]
	str         w8,[x9]
|$LN74@CreateInst|

; 1568 :         }
; 1569 : 
; 1570 :         size = sizeof(ULONG);
; 1571 :         result = RegQueryValueEx(hKey, c_OutputFrameDelayValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BB@PIAJBBGI@OutputFrameDelay@|
	add         x1,x8,|??_C@_0BB@PIAJBBGI@OutputFrameDelay@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1572 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN75@CreateInst|

; 1573 :         {
; 1574 :             m_driverFlags.OutputFrameDelay = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD58]
|$LN75@CreateInst|

; 1575 :         }
; 1576 : 
; 1577 :         size = sizeof(ULONG);
; 1578 :         result = RegQueryValueEx(hKey, c_DelayedOutputBufferSwitchName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@|
	add         x1,x8,|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1579 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN76@CreateInst|

; 1580 :         {
; 1581 :             m_driverFlags.DelayedOutputBufferSwitch = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD5C]
|$LN76@CreateInst|

; 1582 :         }
; 1583 : 
; 1584 :         size = sizeof(ULONG);
; 1585 :         result = RegQueryValueEx(hKey, c_InputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@|
	add         x1,x8,|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1586 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN77@CreateInst|

; 1587 :         {
; 1588 :             m_driverFlags.InputBufferOperationOffset = temp;

	ldr         w8,[x26,#0x1CC]
	ldr         x9,[x26,#0x1D0]
	str         w8,[x9]
|$LN77@CreateInst|

; 1589 :         }
; 1590 : 
; 1591 :         size = sizeof(ULONG);
; 1592 :         result = RegQueryValueEx(hKey, c_InputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0M@IIIMLOLG@InHubOffset@|
	add         x1,x8,|??_C@_0M@IIIMLOLG@InHubOffset@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1593 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN78@CreateInst|

; 1594 :         {
; 1595 :             m_driverFlags.InputHubOffset = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD68]
|$LN78@CreateInst|

; 1596 :         }
; 1597 : 
; 1598 :         size = sizeof(ULONG);
; 1599 :         result = RegQueryValueEx(hKey, c_OutputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@|
	add         x1,x8,|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1600 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN79@CreateInst|

; 1601 :         {
; 1602 :             m_driverFlags.OutputBufferOperationOffset = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x24]
|$LN79@CreateInst|

; 1603 :         }
; 1604 : 
; 1605 :         size = sizeof(ULONG);
; 1606 :         result = RegQueryValueEx(hKey, c_OutputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@DLKKJNAP@OutHubOffset@|
	add         x1,x8,|??_C@_0N@DLKKJNAP@OutHubOffset@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1607 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN80@CreateInst|

; 1608 :         {
; 1609 :             m_driverFlags.OutputHubOffset = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x19,#0xD70]
|$LN80@CreateInst|

; 1610 :         }
; 1611 : 
; 1612 :         size = sizeof(ULONG);
; 1613 :         result = RegQueryValueEx(hKey, c_BufferThreadPriorityName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BF@BAAHAIB@BufferThreadPriority@|
	add         x1,x8,|??_C@_0BF@BAAHAIB@BufferThreadPriority@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1614 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN81@CreateInst|

; 1615 :         {
; 1616 :             m_driverFlags.BufferThreadPriority = temp;

	ldr         w8,[x26,#0x1CC]
	str         w8,[x25]
|$LN81@CreateInst|

; 1617 :         }
; 1618 : 
; 1619 :         size = sizeof(ULONG);
; 1620 :         result = RegQueryValueEx(hKey, c_DropoutDetectionName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BB@GLAIOBJJ@DropoutDetection@|
	add         x1,x8,|??_C@_0BB@GLAIOBJJ@DropoutDetection@|
	ldr         x0,[x26,#0x1A8]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w21,[x26,#0x1C8]
	add         x5,x26,#0x1C8
	add         x4,x26,#0x1CC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1621 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN82@CreateInst|

; 1622 :         {
; 1623 :             m_isDropoutDetectionSetting = temp != 0;

	ldr         w8,[x26,#0x1CC]
	cmp         w8,#0
	csetne      w8
	strb        w8,[x19,#0xB99]
|$LN82@CreateInst|

; 1624 :         }
; 1625 : 
; 1626 :         m_driverFlags.SuggestedBufferPeriod = m_blockFrames;

	ldr         w8,[x19,#0xAF0]

; 1627 : 
; 1628 :         RegCloseKey(hKey);

	ldr         x0,[x26,#0x1A8]
	str         w8,[x19,#0xD7C]
	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	blr         x8
|$LN67@CreateInst|

; 1629 :     }
; 1630 : 
; 1631 :     if (!SetFlags(m_usbDeviceHandle, m_driverFlags))

	add         x10,x19,#0xD48
	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 314  :     ULONG                 bytesReturned = 0;

	str         wzr,[x26,#0x1D0]

; 315  :     UAC_SET_FLAGS_CONTEXT setFlagsContext = flags;

	ldr         x8,[x10,#0x30]

; 316  : 
; 317  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;
; 318  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 319  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetFlags);
; 320  : 
; 321  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setFlagsContext, sizeof(UAC_SET_FLAGS_CONTEXT), &bytesReturned, nullptr);

	mov         x7,#0
	ldp         q17,q16,[x10]
	add         x6,x26,#0x1D0
	mov         w5,#0x3C
	add         x4,x26,#0x240
	str         x8,[x26,#0x270]
	ldr         w8,[x10,#0x38]
	mov         w3,#0x18
	stp         q17,q16,[x26,#0x240]
	ldr         q16,[x10,#0x20]
	add         x2,x26,#0x220
	mov         w1,w22
	str         w8,[x26,#0x278]
	mov         x8,#5
	movk        x8,#2,lsl #0x20
	str         x8,[x26,#0x230]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	str         q16,[x26,#0x260]
	ldr         q16,[x20]
	str         q16,[x26,#0x220]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 235  :     isSuccess = ObtainDeviceParameter();

	mov         x0,x19
	str         xzr,[x19,#0x30]
	bl          |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|

; 236  :     if (!isSuccess)

	tbz         w0,#0,|$LN11@CreateInst|

; 237  :     {
; 238  :         return;
; 239  :     }
; 240  : 
; 241  :     switch (m_audioProperty.CurrentSampleFormat)

	ldr         w8,[x19,#0xCD8]

; 246  :         break;
; 247  :     default:
; 248  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM8:
; 249  :         m_requestedSampleFormat = kASIOFormatInvalid;

	mov         w9,#-1
	cmp         w8,#0
	ccmpne      w8,#5,#4
	add         x8,x19,#0xD88
	bne         |$LN15@CreateInst|

; 242  :     {
; 243  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM:
; 244  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT:
; 245  :         m_requestedSampleFormat = kASIOPCMFormat;

	mov         w9,#0
|$LN15@CreateInst|

; 250  :         break;
; 251  :     }
; 252  : 
; 253  :     GetClockInfo(m_usbDeviceHandle, &m_clockInfo);

	str         w9,[x8]
	add         x21,x19,#0xDA0
	ldr         x23,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 242  :     ULONG      bytesReturned = 0;

	str         wzr,[x26,#0x1C0]

; 243  : 
; 244  :     if (clockInfo == nullptr)

	cbz         x21,|$LN94@CreateInst|

; 245  :     {
; 246  :         return result;
; 247  :     }
; 248  : 
; 249  :     *clockInfo = {};
; 250  : 
; 251  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;
; 252  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 253  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetClockInfo);

	mov         x8,#2
	movk        x8,#1,lsl #0x20
	ldr         q16,[x20]
	str         x8,[x26,#0x1F0]

; 254  : 
; 255  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	mov         x7,#0
	str         xzr,[x21]
	add         x6,x26,#0x1C0
	mov         w5,#0
	str         q16,[x26,#0x1E0]
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x26,#0x1E0
	mov         w1,w22
	mov         x0,x23
	blr         x8

; 256  : 
; 257  :     if (!result)

	cbnz        w0,|$LN94@CreateInst|

; 258  :     {
; 259  :         DWORD error = GetLastError();

	adrp        x8,__imp_GetLastError
	ldr         x8,[x8,__imp_GetLastError]
	blr         x8
	mov         w8,#0x58

; 260  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CLOCK_INFO_CONTEXT)))

	cmp         w0,#0xEA
	ldr         w0,[x26,#0x1C0]
	ccmpeq      w0,w8,#0
	blo         |$LN94@CreateInst|

; 261  :         {
; 262  :             *clockInfo = (PUAC_GET_CLOCK_INFO_CONTEXT)(new BYTE[bytesReturned]);

	bl          |??_U@YAPEAX_K@Z|

; 263  :             if (clockInfo != nullptr)
; 264  :             {
; 265  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *clockInfo, bytesReturned, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	ldr         w5,[x26,#0x1C0]
	str         x0,[x21]
	mov         x4,x0
	mov         x7,#0
	add         x6,x26,#0x1C0
	mov         w3,#0x18
	add         x2,x26,#0x1E0
	mov         w1,w22
	mov         x0,x23
	blr         x8

; 266  :                 if (!result)

	cbnz        w0,|$LN94@CreateInst|

; 267  :                 {
; 268  :                     delete[] (BYTE *)(*clockInfo);

	ldr         x0,[x21]
	bl          |??_V@YAXPEAX@Z|

; 269  :                     *clockInfo = nullptr;

	str         xzr,[x21]
|$LN94@CreateInst|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 255  :     m_stopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	mov         w2,#0
	mov         w1,#1
	mov         x0,#0
	blr         x8

; 256  : 
; 257  :     m_asioResetEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE58]
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8

; 258  :     m_terminateAsioResetEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE70]
	mov         w2,#0
	mov         w1,#1
	mov         x0,#0
	blr         x8

; 259  : 
; 260  :     m_outputReadyBlockEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE78]
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8

; 261  : 
; 262  :     auto beginThreadResult = _beginthreadex(nullptr, 0, AsioResetThread, this, 0, nullptr);

	adrp        x8,|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	add         x2,x8,|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	mov         x5,#0
	str         x0,[x19,#0xE88]
	mov         w4,#0
	mov         x0,#0
	mov         x3,x19
	mov         w1,#0
	bl          _beginthreadex

; 263  :     ;
; 264  :     if (beginThreadResult <= 0)

	cbz         x0,|$LN11@CreateInst|

; 265  :     {
; 266  :         return;
; 267  :     }
; 268  :     m_asioResetThread = (HANDLE)beginThreadResult;
; 269  :     SetThreadPriority(m_asioResetThread, THREAD_PRIORITY_ABOVE_NORMAL);

	adrp        x8,__imp_SetThreadPriority
	ldr         x8,[x8,__imp_SetThreadPriority]
	mov         w1,#1
	str         x0,[x19,#0xE80]
	blr         x8

; 270  : 
; 271  :     m_samplePosition = 0;

	str         xzr,[x19,#0x20]

; 272  :     m_isActive = false;

	str         wzr,[x19,#0xB08]

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	str         xzr,[x19,#0xD8]

; 279  :         m_inMap[i] = 0;

	str         wzr,[x19,#0x8F0]
	str         xzr,[x19,#0xE0]
	str         wzr,[x19,#0x8F4]
	str         xzr,[x19,#0xE8]
	str         wzr,[x19,#0x8F8]
	str         xzr,[x19,#0xF0]
	str         wzr,[x19,#0x8FC]
	str         xzr,[x19,#0xF8]
	str         wzr,[x19,#0x900]
	str         xzr,[x19,#0x100]
	str         wzr,[x19,#0x904]
	str         xzr,[x19,#0x108]
	str         wzr,[x19,#0x908]
	str         xzr,[x19,#0x110]
	str         wzr,[x19,#0x90C]
	str         xzr,[x19,#0x118]
	str         wzr,[x19,#0x910]
	str         xzr,[x19,#0x120]
	str         wzr,[x19,#0x914]
	str         xzr,[x19,#0x128]
	str         wzr,[x19,#0x918]
	str         xzr,[x19,#0x130]
	str         wzr,[x19,#0x91C]
	str         xzr,[x19,#0x138]
	str         wzr,[x19,#0x920]
	str         xzr,[x19,#0x140]
	str         wzr,[x19,#0x924]
	str         xzr,[x19,#0x148]
	str         wzr,[x19,#0x928]
	str         xzr,[x19,#0x150]
	str         wzr,[x19,#0x92C]
	str         xzr,[x19,#0x158]
	str         wzr,[x19,#0x930]
	str         xzr,[x19,#0x160]
	str         wzr,[x19,#0x934]
	str         xzr,[x19,#0x168]
	str         wzr,[x19,#0x938]
	str         xzr,[x19,#0x170]
	str         wzr,[x19,#0x93C]
	str         xzr,[x19,#0x178]
	str         wzr,[x19,#0x940]
	str         xzr,[x19,#0x180]
	str         wzr,[x19,#0x944]
	str         xzr,[x19,#0x188]
	str         wzr,[x19,#0x948]
	str         xzr,[x19,#0x190]
	str         wzr,[x19,#0x94C]
	str         xzr,[x19,#0x198]
	str         wzr,[x19,#0x950]
	str         xzr,[x19,#0x1A0]
	str         wzr,[x19,#0x954]
	str         xzr,[x19,#0x1A8]
	str         wzr,[x19,#0x958]
	str         xzr,[x19,#0x1B0]
	str         wzr,[x19,#0x95C]
	str         xzr,[x19,#0x1B8]
	str         wzr,[x19,#0x960]
	str         xzr,[x19,#0x1C0]
	str         wzr,[x19,#0x964]
	str         xzr,[x19,#0x1C8]
	str         wzr,[x19,#0x968]
	str         xzr,[x19,#0x1D0]
	str         wzr,[x19,#0x96C]
	str         xzr,[x19,#0x1D8]
	str         wzr,[x19,#0x970]
	str         xzr,[x19,#0x1E0]
	str         wzr,[x19,#0x974]
	str         xzr,[x19,#0x1E8]
	str         wzr,[x19,#0x978]
	str         xzr,[x19,#0x1F0]
	str         wzr,[x19,#0x97C]
	str         xzr,[x19,#0x1F8]
	str         wzr,[x19,#0x980]
	str         xzr,[x19,#0x200]
	str         wzr,[x19,#0x984]
	str         xzr,[x19,#0x208]
	str         wzr,[x19,#0x988]
	str         xzr,[x19,#0x210]
	str         wzr,[x19,#0x98C]
	str         xzr,[x19,#0x218]
	str         wzr,[x19,#0x990]
	str         xzr,[x19,#0x220]
	str         wzr,[x19,#0x994]
	str         xzr,[x19,#0x228]
	str         wzr,[x19,#0x998]
	str         xzr,[x19,#0x230]
	str         wzr,[x19,#0x99C]
	str         xzr,[x19,#0x238]
	str         wzr,[x19,#0x9A0]
	str         xzr,[x19,#0x240]
	str         wzr,[x19,#0x9A4]
	str         xzr,[x19,#0x248]
	str         wzr,[x19,#0x9A8]
	str         xzr,[x19,#0x250]
	str         wzr,[x19,#0x9AC]
	str         xzr,[x19,#0x258]
	str         wzr,[x19,#0x9B0]
	str         xzr,[x19,#0x260]
	str         wzr,[x19,#0x9B4]
	str         xzr,[x19,#0x268]
	str         wzr,[x19,#0x9B8]
	str         xzr,[x19,#0x270]
	str         wzr,[x19,#0x9BC]
	str         xzr,[x19,#0x278]
	str         wzr,[x19,#0x9C0]
	str         xzr,[x19,#0x280]
	str         wzr,[x19,#0x9C4]
	str         xzr,[x19,#0x288]
	str         wzr,[x19,#0x9C8]
	str         xzr,[x19,#0x290]
	str         wzr,[x19,#0x9CC]
	str         xzr,[x19,#0x298]
	str         wzr,[x19,#0x9D0]
	str         xzr,[x19,#0x2A0]
	str         wzr,[x19,#0x9D4]
	str         xzr,[x19,#0x2A8]
	str         wzr,[x19,#0x9D8]
	str         xzr,[x19,#0x2B0]
	str         wzr,[x19,#0x9DC]
	str         xzr,[x19,#0x2B8]
	str         wzr,[x19,#0x9E0]
	str         xzr,[x19,#0x2C0]
	str         wzr,[x19,#0x9E4]
	str         xzr,[x19,#0x2C8]
	str         wzr,[x19,#0x9E8]
	str         xzr,[x19,#0x2D0]
	str         wzr,[x19,#0x9EC]

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	str         xzr,[x19,#0x4D8]

; 284  :         m_outMap[i] = 0;

	str         wzr,[x19,#0x9F0]
	str         xzr,[x19,#0x4E0]
	str         wzr,[x19,#0x9F4]
	str         xzr,[x19,#0x4E8]
	str         wzr,[x19,#0x9F8]
	str         xzr,[x19,#0x4F0]
	str         wzr,[x19,#0x9FC]
	str         xzr,[x19,#0x4F8]
	str         wzr,[x19,#0xA00]
	str         xzr,[x19,#0x500]
	str         wzr,[x19,#0xA04]
	str         xzr,[x19,#0x508]
	str         wzr,[x19,#0xA08]
	str         xzr,[x19,#0x510]
	str         wzr,[x19,#0xA0C]
	str         xzr,[x19,#0x518]
	str         wzr,[x19,#0xA10]
	str         xzr,[x19,#0x520]
	str         wzr,[x19,#0xA14]
	str         xzr,[x19,#0x528]
	str         wzr,[x19,#0xA18]
	str         xzr,[x19,#0x530]
	str         wzr,[x19,#0xA1C]
	str         xzr,[x19,#0x538]
	str         wzr,[x19,#0xA20]
	str         xzr,[x19,#0x540]
	str         wzr,[x19,#0xA24]
	str         xzr,[x19,#0x548]
	str         wzr,[x19,#0xA28]
	str         xzr,[x19,#0x550]
	str         wzr,[x19,#0xA2C]
	str         xzr,[x19,#0x558]
	str         wzr,[x19,#0xA30]
	str         xzr,[x19,#0x560]
	str         wzr,[x19,#0xA34]
	str         xzr,[x19,#0x568]
	str         wzr,[x19,#0xA38]
	str         xzr,[x19,#0x570]
	str         wzr,[x19,#0xA3C]
	str         xzr,[x19,#0x578]
	str         wzr,[x19,#0xA40]
	str         xzr,[x19,#0x580]
	str         wzr,[x19,#0xA44]
	str         xzr,[x19,#0x588]
	str         wzr,[x19,#0xA48]
	str         xzr,[x19,#0x590]
	str         wzr,[x19,#0xA4C]
	str         xzr,[x19,#0x598]
	str         wzr,[x19,#0xA50]
	str         xzr,[x19,#0x5A0]
	str         wzr,[x19,#0xA54]
	str         xzr,[x19,#0x5A8]
	str         wzr,[x19,#0xA58]
	str         xzr,[x19,#0x5B0]
	str         wzr,[x19,#0xA5C]
	str         xzr,[x19,#0x5B8]
	str         wzr,[x19,#0xA60]
	str         xzr,[x19,#0x5C0]
	str         wzr,[x19,#0xA64]
	str         xzr,[x19,#0x5C8]
	str         wzr,[x19,#0xA68]
	str         xzr,[x19,#0x5D0]
	str         wzr,[x19,#0xA6C]
	str         xzr,[x19,#0x5D8]
	str         wzr,[x19,#0xA70]
	str         xzr,[x19,#0x5E0]
	str         wzr,[x19,#0xA74]
	str         xzr,[x19,#0x5E8]
	str         wzr,[x19,#0xA78]
	str         xzr,[x19,#0x5F0]
	str         wzr,[x19,#0xA7C]
	str         xzr,[x19,#0x5F8]
	str         wzr,[x19,#0xA80]
	str         xzr,[x19,#0x600]
	str         wzr,[x19,#0xA84]
	str         xzr,[x19,#0x608]
	str         wzr,[x19,#0xA88]
	str         xzr,[x19,#0x610]
	str         wzr,[x19,#0xA8C]
	str         xzr,[x19,#0x618]
	str         wzr,[x19,#0xA90]
	str         xzr,[x19,#0x620]
	str         wzr,[x19,#0xA94]
	str         xzr,[x19,#0x628]
	str         wzr,[x19,#0xA98]
	str         xzr,[x19,#0x630]
	str         wzr,[x19,#0xA9C]
	str         xzr,[x19,#0x638]
	str         wzr,[x19,#0xAA0]
	str         xzr,[x19,#0x640]
	str         wzr,[x19,#0xAA4]
	str         xzr,[x19,#0x648]
	str         wzr,[x19,#0xAA8]
	str         xzr,[x19,#0x650]
	str         wzr,[x19,#0xAAC]
	str         xzr,[x19,#0x658]
	str         wzr,[x19,#0xAB0]
	str         xzr,[x19,#0x660]
	str         wzr,[x19,#0xAB4]
	str         xzr,[x19,#0x668]
	str         wzr,[x19,#0xAB8]
	str         xzr,[x19,#0x670]
	str         wzr,[x19,#0xABC]
	str         xzr,[x19,#0x678]
	str         wzr,[x19,#0xAC0]
	str         xzr,[x19,#0x680]
	str         wzr,[x19,#0xAC4]
	str         xzr,[x19,#0x688]
	str         wzr,[x19,#0xAC8]
	str         xzr,[x19,#0x690]
	str         wzr,[x19,#0xACC]
	str         xzr,[x19,#0x698]
	str         wzr,[x19,#0xAD0]
	str         xzr,[x19,#0x6A0]
	str         wzr,[x19,#0xAD4]
	str         xzr,[x19,#0x6A8]
	str         wzr,[x19,#0xAD8]
	str         xzr,[x19,#0x6B0]
	str         wzr,[x19,#0xADC]
	str         xzr,[x19,#0x6B8]
	str         wzr,[x19,#0xAE0]
	str         xzr,[x19,#0x6C0]
	str         wzr,[x19,#0xAE4]
	str         xzr,[x19,#0x6C8]
	str         wzr,[x19,#0xAE8]
	str         xzr,[x19,#0x6D0]
	str         wzr,[x19,#0xAEC]

; 285  :     }
; 286  :     m_toggle = 0;

	str         wzr,[x19,#0xB04]
|$LN11@CreateInst|

; 160  :     return (CUnknown *)new CUSBAsio(unknown, result);

	add         x0,x19,#8
	add         sp,sp,#0x380
	bl          __security_pop_cookie
	ldr         x27,[sp,#0x50]
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ret
|$LN242@CreateInst|
	DCFD         44100

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	mov         x1,#0xE98
	ldr         x0,[x26,#8]
	bl          |??3@YAXPEAX_K@Z|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#8
	bl          |??1CUnknown@@UEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$2@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$2
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDA8
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$3@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$3
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDD0
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$4@?0??CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CreateInstance'::`1'::dtor$4
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDF8
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?CreateInstance@CUSBAsio@@SAPEAVCUnknown@@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CreateInstance

; Function compile flags: /Ogtp

	AREA	|.text$mn|, CODE, ARM64

|?__autoclassinit2@CUSBAsio@@QEAAX_K@Z| PROC		; CUSBAsio::__autoclassinit2
	mov         x2,#0xE98
	mov         w1,#0
	b           memset

	ENDP  ; |?__autoclassinit2@CUSBAsio@@QEAAX_K@Z|, CUSBAsio::__autoclassinit2

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z| PROC ; CUSBAsio::NonDelegatingQueryInterface

; 169  : {

|$LN33|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	adrp        x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	add         x10,x8,|?IID_ASIO_DRIVER@@3U_GUID@@A|
	ldr         x9,[x1]
	ldr         x8,[x10]
	mov         w11,#-1
	rev         x9,x9
	rev         x8,x8
	cmp         x9,x8
	bne         |$LN23@NonDelegat|
	ldr         x9,[x1,#8]
	ldr         x8,[x10,#8]
	rev         x9,x9
	rev         x8,x8
	cmp         x9,x8
	mov         w8,#0
	beq         |$LN24@NonDelegat|
|$LN23@NonDelegat|
	cneghs      w8,w11
|$LN24@NonDelegat|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 170  :     if (riid == IID_ASIO_DRIVER)

	cbnz        w8,|$LN2@NonDelegat|

; 171  :     {
; 172  :         return GetInterface(this, object);

	sub         x0,x0,#8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 160  :     CheckPointer(ppv, E_POINTER);

	cbnz        x2,|$LN9@NonDelegat|
|$LN29@NonDelegat|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 175  : }

	ldr         w0,|$LN31@NonDelegat|
	ldp         fp,lr,[sp],#0x10
	ret
|$LN9@NonDelegat|
	str         x0,[x2]
	ldr         x8,[x0]
	ldr         x8,[x8,#8]
	blr         x8
	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ret
|$LN2@NonDelegat|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 80   :     CheckPointer(ppv,E_POINTER);

	cbz         x2,|$LN29@NonDelegat|
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	adrp        x8,IID_IUnknown
	add         x10,x8,IID_IUnknown
	ldr         x8,[x10]
	ldr         x9,[x1]
	rev         x8,x8
	rev         x9,x9
	cmp         x9,x8
	bne         |$LN25@NonDelegat|
	ldr         x9,[x1,#8]
	ldr         x8,[x10,#8]
	rev         x9,x9
	rev         x8,x8
	cmp         x9,x8
	mov         w8,#0
	beq         |$LN26@NonDelegat|
|$LN25@NonDelegat|
	cneghs      w8,w11
|$LN26@NonDelegat|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 85   :     if (riid == IID_IUnknown) {

	cbz         w8,|$LN9@NonDelegat|

; 86   :         GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv);
; 87   :         return NOERROR;
; 88   :     } else {
; 89   :         *ppv = NULL;

	str         xzr,[x2]

; 90   :         return E_NOINTERFACE;

	ldr         w0,|$LN32@NonDelegat|
	ldp         fp,lr,[sp],#0x10
	ret
|$LN31@NonDelegat|
	DCD         0x80004003
|$LN32@NonDelegat|
	DCD         0x80004002

	ENDP  ; |?NonDelegatingQueryInterface@CUSBAsio@@UEAAJAEBU_GUID@@PEAPEAX@Z|, CUSBAsio::NonDelegatingQueryInterface

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z| PROC		; CUSBAsio::CUSBAsio

; 183  : {

|$LN211|
	stp         fp,lr,[sp,#-0x60]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	str         x27,[sp,#0x50]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x310
	mov         x26,sp
	adrp        x8,|??_7IASIO@@6B@|
	add         x8,x8,|??_7IASIO@@6B@|
	str         x0,[x26,#0x1B8]
	mov         x19,x0
	mov         xip0,#-2
	mov         x21,x1
	stp         xip0,x19,[x26]
	add         x22,x19,#8
	str         x8,[x19]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 30   :     InterlockedIncrement(&m_cObjects);

	adrp        x8,|?m_cObjects@CBaseObject@@0JA|
	add         x0,x8,|?m_cObjects@CBaseObject@@0JA|
	bl          _InterlockedIncrement

; 71   : {

	adrp        x8,|??_7CUnknown@@6B@|
	add         x9,x8,|??_7CUnknown@@6B@|

; 62   : /* Set our pointer to our IUnknown interface.                      */
; 63   : /* If we have an outer, use its, otherwise use ours.               */
; 64   : /* This pointer effectivly points to the owner of                  */
; 65   : /* this object and can be accessed by the GetOwner() method.       */
; 66   : , m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) ) )

	cmp         x21,#0
	cselne      x8,x21,x22
	stp         x9,x8,[x22]

; 31   : 
; 32   : #ifdef DEBUG
; 33   :     m_dwCookie = DbgRegisterObjectCreation(pName);
; 34   : #endif
; 35   : }
; 36   : 
; 37   : 
; 38   : /* Destructor */
; 39   : 
; 40   : CBaseObject::~CBaseObject()
; 41   : {
; 42   :     /* Decrement the number of objects active */
; 43   :     InterlockedDecrement(&m_cObjects);
; 44   : 
; 45   : #ifdef DEBUG
; 46   :     DbgRegisterObjectDestruction(m_dwCookie);
; 47   : #endif
; 48   : }
; 49   : 
; 50   : 
; 51   : /* Constructor */
; 52   : 
; 53   : // We know we use "this" in the initialization list, we also know we don't modify *phr.
; 54   : #pragma warning( disable : 4355 4100 ) 
; 55   : CUnknown::CUnknown(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) 
; 56   : : CBaseObject(pName)
; 57   : /* Start the object with a reference count of zero - when the      */
; 58   : /* object is queried for it's first interface this may be          */
; 59   : /* incremented depending on whether or not this object is          */
; 60   : /* currently being aggregated upon                                 */
; 61   : , m_cRef(0)

	str         wzr,[x22,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 183  : {

	adrp        x8,|??_7CUSBAsio@@6BIASIO@@@|
	add         x8,x8,|??_7CUSBAsio@@6BIASIO@@@|
	str         x8,[x19]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 160  :     double                        m_sampleRate{UAC_DEFAULT_SAMPLE_RATE};

	ldr         d16,|$LN210@CUSBAsio|
	adrp        x8,|??_7CUSBAsio@@6BCUnknown@@@|
	add         x8,x8,|??_7CUSBAsio@@6BCUnknown@@@|
	str         xzr,[x19,#0x20]

; 161  :     ASIOCallbacks *               m_callbacks{nullptr};

	str         xzr,[x19,#0x30]

; 162  :     ASIOTime                      m_asioTime{0};
; 163  :     ASIOTimeStamp                 m_theSystemTime{0};
; 164  :     volatile UCHAR *              m_inputBuffers[NUMOFINPUTS * 2]{};

	mov         x2,#0x400
	str         d16,[x19,#0x28]
	movi        v16.16b,#0
	mov         w1,#0
	str         x8,[x22]
	add         x8,x19,#0x38
	add         x0,x19,#0xD8
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	str         q16,[x8,#0x80]
	str         s16,[x8,#0x90]
	stur        xzr,[x19,#0xCC]
	bl          memset

; 165  :     UCHAR *                       m_outputBuffers[NUMOFOUTPUTS * 2]{};

	mov         x2,#0x400
	mov         w1,#0
	add         x0,x19,#0x4D8
	bl          memset
	add         x8,x19,#0x8D8

; 166  :     DWORD                         m_initialSystemTime{0};
; 167  :     DWORD                         m_calculatedSystemTime{0};
; 168  :     ULONGLONG                     m_initialKernelTime{0};
; 169  :     TCHAR *                       m_desiredPath{nullptr};
; 170  :     long                          m_inMap[NUMOFINPUTS]{};

	movi        v16.16b,#0
	stp         xzr,xzr,[x8]
	add         x8,x19,#0x8F0
	str         xzr,[x19,#0x8E8]

; 171  :     long                          m_outMap[NUMOFOUTPUTS]{};
; 172  :     long                          m_blockFrames{UAC_DEFAULT_ASIO_BUFFER_SIZE};

	mov         x9,#0x200
	stp         q16,q16,[x8]

; 173  :     long                          m_inputLatency{0};
; 174  :     long                          m_outputLatency{0};
; 175  :     ULONG                         m_activeInputs{0};
; 176  :     ULONG                         m_activeOutputs{0};
; 177  :     long                          m_toggle{0};
; 178  :     bool                          m_isActive{false};
; 179  :     bool                          m_isStarted{false};
; 180  :     bool                          m_isTimeInfoMode{false};
; 181  :     bool                          m_isTcRead{false};
; 182  :     TCHAR                         m_errorMessage[ERROR_MESSAGE_LENGTH]{};

	add         x22,x19,#0xB0C
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	stp         q16,q16,[x8,#0x80]
	stp         q16,q16,[x8,#0xA0]
	stp         q16,q16,[x8,#0xC0]
	stp         q16,q16,[x8,#0xE0]
	movi        v16.16b,#0
	add         x8,x19,#0x9F0
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	stp         q16,q16,[x8,#0x60]
	stp         q16,q16,[x8,#0x80]
	stp         q16,q16,[x8,#0xA0]
	stp         q16,q16,[x8,#0xC0]
	stp         q16,q16,[x8,#0xE0]
	movi        v16.16b,#0
	add         x8,x19,#0xAF0
	stp         x9,xzr,[x8]
	str         xzr,[x19,#0xB00]
	str         wzr,[x19,#0xB08]
	stp         q16,q16,[x22]
	stp         q16,q16,[x22,#0x20]
	stp         q16,q16,[x22,#0x40]
	stp         q16,q16,[x22,#0x60]

; 183  :     bool                          m_requireSampleRateChange{0.};
; 184  :     ASIOSampleRate                m_nextSampleRate{0.};
; 185  :     bool                          m_isRequireAsioReset{false};
; 186  :     bool                          m_isDropoutDetectionSetting{true};
; 187  :     bool                          m_isSupportDropoutDetection{false};
; 188  :     bool                          m_isRequireReportDropout{false};
; 189  :     bool                          m_isRequireLatencyChange{false};
; 190  :     LONG                          m_outputReadyBlock{0};
; 191  :     HANDLE                        m_usbDeviceHandle{INVALID_HANDLE_VALUE};
; 192  :     UAC_AUDIO_PROPERTY            m_audioProperty{0};

	movi        v16.16b,#0
	add         x20,x19,#0xBB0
	strb        wzr,[x19,#0xB8C]
	mov         w8,#0x100
	str         xzr,[x19,#0xB90]
	mov         x24,#-1
	str         w8,[x19,#0xB98]
	strb        wzr,[x19,#0xB9C]
	add         x0,x26,#0x10
	str         wzr,[x19,#0xBA0]
	mov         w2,#0x198
	str         x24,[x19,#0xBA8]
	add         x1,x19,#0xBB0
	stp         q16,q16,[x20]
	stp         q16,q16,[x20,#0x20]
	stp         q16,q16,[x20,#0x40]
	stp         q16,q16,[x20,#0x60]
	stp         q16,q16,[x20,#0x80]
	stp         q16,q16,[x20,#0xA0]
	stp         q16,q16,[x20,#0xC0]
	stp         q16,q16,[x20,#0xE0]
	stp         q16,q16,[x20,#0x100]
	stp         q16,q16,[x20,#0x120]
	stp         q16,q16,[x20,#0x140]
	stp         q16,q16,[x20,#0x160]
	str         q16,[x20,#0x180]
	str         d16,[x20,#0x190]
	bl          memcpy

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	movi        v16.16b,#0
	add         x8,x19,#0xD48
	add         x21,x19,#0xD98
	stp         q16,q16,[x8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	mov         w2,#0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         q16,[x8,#0x20]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	mov         w1,#0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         d16,[x8,#0x30]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	add         x0,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 193  :     UAC_SET_FLAGS_CONTEXT         m_driverFlags{0};

	str         s16,[x8,#0x38]

; 194  :     ULONG                         m_fixedSamplingRate{0};

	add         x8,x19,#0xD84
	str         xzr,[x8]

; 195  :     ASIOIoFormatType              m_requestedSampleFormat{0};
; 196  :     ULONG                         m_inAvailableChannels{0};

	add         x8,x19,#0xD8C
	str         xzr,[x8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 198  :     PUAC_GET_CHANNEL_INFO_CONTEXT m_channelInfo{nullptr};

	stp         xzr,xzr,[x21]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3376 :         ::InitializeCriticalSectionEx(&m_cs, spincount, 0);

	blr         x8
	nop
	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
	mov         w2,#0
	mov         w1,#0
	add         x0,x19,#0xDD0
	blr         x8
	nop
	adrp        x8,__imp_InitializeCriticalSectionEx
	ldr         x8,[x8,__imp_InitializeCriticalSectionEx]
	mov         w2,#0
	mov         w1,#0
	add         x0,x19,#0xDF8
	blr         x8
	nop
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.h

; 212  :     LONG                          m_threadPriority{-2};

	mov         w8,#-2
	stp         xzr,xzr,[x21,#0x88]
	str         w8,[x19,#0xE68]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 191  :     m_InstanceIndex = InterlockedIncrement(&g_Instance);

	adrp        x8,|?g_Instance@@3JA|
	add         x0,x8,|?g_Instance@@3JA|
	stp         xzr,xzr,[x21,#0x98]
	stp         xzr,xzr,[x21,#0xA8]
	stp         xzr,xzr,[x21,#0xB8]
	str         xzr,[x19,#0xE60]
	stp         xzr,xzr,[x21,#0xD8]
	stp         xzr,xzr,[x21,#0xE8]
	bl          _InterlockedIncrement

; 192  : 
; 193  :     info_print_("USB ASIO created, instance %d.\n", InterlockedCompareExchange(&g_Instance, 0, 0));
; 194  : 
; 195  :     RtlZeroMemory(&m_audioProperty, sizeof(UAC_AUDIO_PROPERTY));

	movi        v16.16b,#0
	str         w0,[x19,#0xE90]
	stp         q16,q16,[x20]
	stp         q16,q16,[x20,#0x20]
	stp         q16,q16,[x20,#0x40]
	stp         q16,q16,[x20,#0x60]
	stp         q16,q16,[x20,#0x80]
	stp         q16,q16,[x20,#0xA0]
	stp         q16,q16,[x20,#0xC0]
	stp         q16,q16,[x20,#0xE0]
	stp         q16,q16,[x20,#0x100]
	stp         q16,q16,[x20,#0x120]
	stp         q16,q16,[x20,#0x140]
	stp         q16,q16,[x20,#0x160]
	str         q16,[x20,#0x180]
	str         d16,[x20,#0x190]

; 1679 :     if (m_desiredPath != nullptr)

	ldr         x0,[x19,#0x8E8]
	cbz         x0,|$LN45@CUSBAsio|

; 1680 :     {
; 1681 :         delete[] m_desiredPath;

	bl          |??_V@YAXPEAX@Z|

; 1682 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]
|$LN45@CUSBAsio|

; 1683 :     }
; 1684 : 
; 1685 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	adrp        x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	add         x1,x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	adrp        x8,__imp_RegOpenKeyExA
	ldr         x8,[x8,__imp_RegOpenKeyExA]
	add         x4,x26,#0x1A8
	mov         w3,#0x19
	movk        w3,#2,lsl #0x10
	mov         w2,#0
	mov         x0,#-0x7FFFFFFF
	blr         x8

; 1686 :     if (result != ERROR_SUCCESS)

	cbnz        w0,|$LN44@CUSBAsio|

; 1687 :     {
; 1688 :         return false;
; 1689 :     }
; 1690 : 
; 1691 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, nullptr, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	ldr         x0,[x26,#0x1A8]
	adrp        x21,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x1,x21,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x5,x26,#0x1B8
	mov         x4,#0
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1692 :     if (result != ERROR_SUCCESS || size == 0)

	cbnz        w0,|$LN48@CUSBAsio|
	ldr         w0,[x26,#0x1B8]
	cbz         w0,|$LN48@CUSBAsio|

; 1695 :         return false;
; 1696 :     }
; 1697 : 
; 1698 :     m_desiredPath = new TCHAR[size / sizeof(TCHAR)];

	bl          |??_U@YAPEAX_K@Z|

; 1699 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, (LPBYTE)m_desiredPath, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         x0,[x19,#0x8E8]
	mov         x4,x0
	ldr         x0,[x26,#0x1A8]
	add         x5,x26,#0x1B8
	mov         x3,#0
	mov         x2,#0
	add         x1,x21,|??_C@_0L@ONBBLLLB@AsioDevice@|
	blr         x8

; 1700 :     if (result != ERROR_SUCCESS)

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	cbz         w0,|$LN49@CUSBAsio|

; 1701 :     {
; 1702 :         RegCloseKey(hKey);

	ldr         x0,[x26,#0x1A8]
	blr         x8

; 1703 :         delete[] m_desiredPath;

	ldr         x0,[x19,#0x8E8]
	bl          |??_V@YAXPEAX@Z|

; 1704 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]

; 1705 :         return false;

	b           |$LN44@CUSBAsio|
|$LN48@CUSBAsio|

; 1693 :     {
; 1694 :         RegCloseKey(hKey);

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
|$LN49@CUSBAsio|

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	ldr         x0,[x26,#0x1A8]
	blr         x8
|$LN44@CUSBAsio|
	ldr         x21,[x19,#0x8E8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 157  :     HANDLE targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, desiredPath);

	mov         x3,x21
	bl          |?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z|

; 158  : 
; 159  :     if ((targetHandle == INVALID_HANDLE_VALUE) && (desiredPath != nullptr))

	cmn         x0,#1
	ccmpeq      x21,#0,#4
	beq         |$LN52@CUSBAsio|

; 160  :     {
; 161  :         // force open
; 162  :         targetHandle = OpenUsbDeviceCore(classGuid, serviceName, referenceString, nullptr);

	mov         x3,#0
	bl          |?OpenUsbDeviceCore@@YAPEAXQEAU_GUID@@PEBD11@Z|
|$LN52@CUSBAsio|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 199  :     m_usbDeviceHandle = OpenUsbDevice((const LPGUID)&KSCATEGORY_AUDIO, c_ServiceName, c_ReferenceName, m_desiredPath);

	str         x0,[x19,#0xBA8]

; 200  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE)

	cmn         x0,#1
	bne         |$LN13@CUSBAsio|

; 201  :     {
; 202  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 203  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	stp         q16,q16,[x26,#0x210]
	stp         q16,q16,[x26,#0x230]
	stp         q16,q16,[x26,#0x250]
	stp         q16,q16,[x26,#0x270]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x210
	mov         w1,#0x66
	blr         x8

; 204  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x210
	mov         x1,#0x80
	mov         x0,x22
	bl          strcpy_s

; 205  :         return;

	b           |$LN1@CUSBAsio|
|$LN13@CUSBAsio|

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x20,x8,KSPROPSETID_LowLatencyAudio
	mov         w23,#0
	mov         x27,#8
	movk        x27,#2,lsl #0x20
	mov         w21,#3
	movk        w21,#0x2F,lsl #0x10
	adrp        x25,__imp_DeviceIoControl
	adrp        x24,__imp_Sleep
|$LN4@CUSBAsio|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 373  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	ldr         q16,[x20]

; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         wzr,[x26,#0x1C0]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 211  :         isSuccess = GetAsioOwnership(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 377  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	add         x6,x26,#0x1C0
	str         x27,[x26,#0x200]
	ldr         x8,[x25,__imp_DeviceIoControl]
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	str         q16,[x26,#0x1F0]
	add         x2,x26,#0x1F0
	mov         w1,w21
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 212  :         if (isSuccess)

	cbnz        w0,|$LN206@CUSBAsio|

; 213  :         {
; 214  :             break;
; 215  :         }
; 216  :         if (retry < maxRetry - 1)

	cmp         w23,#5
	bhs         |$LN2@CUSBAsio|

; 217  :         {
; 218  :             Sleep(500);

	ldr         x8,[x24,__imp_Sleep]
	mov         w0,#0x1F4
	blr         x8
|$LN2@CUSBAsio|

; 206  :     }
; 207  : 
; 208  :     const ULONG maxRetry = 6;
; 209  :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	add         w23,w23,#1
	cmp         w23,#6
	blo         |$LN4@CUSBAsio|

; 219  :         }
; 220  :     }
; 221  : 
; 222  :     if (!isSuccess)
; 223  :     {
; 224  :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 225  :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	mov         x24,#-1
	stp         q16,q16,[x26,#0x290]
	stp         q16,q16,[x26,#0x2B0]
	stp         q16,q16,[x26,#0x2D0]
	stp         q16,q16,[x26,#0x2F0]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x290
	mov         w1,#0x66
	blr         x8

; 226  :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x290
	mov         x1,#0x80
	mov         x0,x22
	bl          strcpy_s

; 227  :         CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xBA8]
	blr         x8

; 228  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	str         x24,[x19,#0xBA8]
|$LN206@CUSBAsio|

; 229  :     }
; 230  : 
; 231  :     ApplySettings();

	mov         x0,x19
	bl          |?ApplySettings@CUSBAsio@@AEAA_NXZ|

; 232  : 
; 233  :     m_callbacks = 0;
; 234  : 
; 235  :     isSuccess = ObtainDeviceParameter();

	mov         x0,x19
	str         xzr,[x19,#0x30]
	bl          |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|

; 236  :     if (!isSuccess)

	tbz         w0,#0,|$LN1@CUSBAsio|

; 241  :     switch (m_audioProperty.CurrentSampleFormat)

	ldr         w8,[x19,#0xCD8]

; 242  :     {
; 243  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM:
; 244  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT:
; 245  :         m_requestedSampleFormat = kASIOPCMFormat;
; 246  :         break;
; 247  :     default:
; 248  :     case UACSampleFormat::UAC_SAMPLE_FORMAT_PCM8:
; 249  :         m_requestedSampleFormat = kASIOFormatInvalid;
; 250  :         break;
; 251  :     }
; 252  : 
; 253  :     GetClockInfo(m_usbDeviceHandle, &m_clockInfo);

	add         x24,x19,#0xDA0
	cmp         w8,#0
	ccmpne      w8,#5,#4
	csetmne     w8
	str         w8,[x19,#0xD88]
	ldr         x22,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 242  :     ULONG      bytesReturned = 0;

	str         wzr,[x26,#0x1B0]

; 243  : 
; 244  :     if (clockInfo == nullptr)

	cbz         x24,|$LN63@CUSBAsio|

; 245  :     {
; 246  :         return result;
; 247  :     }
; 248  : 
; 249  :     *clockInfo = {};
; 250  : 
; 251  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;
; 252  :     privateProperty.Flags = KSPROPERTY_TYPE_GET;
; 253  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetClockInfo);

	mov         x8,#2
	movk        x8,#1,lsl #0x20
	ldr         q16,[x20]
	str         x8,[x26,#0x1E0]

; 254  : 
; 255  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	mov         x7,#0
	str         xzr,[x24]
	add         x6,x26,#0x1B0
	mov         w5,#0
	str         q16,[x26,#0x1D0]
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x26,#0x1D0
	mov         w1,w21
	mov         x0,x22
	blr         x8

; 256  : 
; 257  :     if (!result)

	cbnz        w0,|$LN63@CUSBAsio|

; 258  :     {
; 259  :         DWORD error = GetLastError();

	adrp        x8,__imp_GetLastError
	ldr         x8,[x8,__imp_GetLastError]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 241  :     switch (m_audioProperty.CurrentSampleFormat)

	mov         w8,#0x58
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 260  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CLOCK_INFO_CONTEXT)))

	cmp         w0,#0xEA
	ldr         w0,[x26,#0x1B0]
	ccmpeq      w0,w8,#0
	blo         |$LN63@CUSBAsio|

; 261  :         {
; 262  :             *clockInfo = (PUAC_GET_CLOCK_INFO_CONTEXT)(new BYTE[bytesReturned]);

	bl          |??_U@YAPEAX_K@Z|

; 263  :             if (clockInfo != nullptr)
; 264  :             {
; 265  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *clockInfo, bytesReturned, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	ldr         w5,[x26,#0x1B0]
	str         x0,[x24]
	mov         x4,x0
	mov         x7,#0
	add         x6,x26,#0x1B0
	mov         w3,#0x18
	add         x2,x26,#0x1D0
	mov         w1,w21
	mov         x0,x22
	blr         x8

; 266  :                 if (!result)

	cbnz        w0,|$LN63@CUSBAsio|

; 267  :                 {
; 268  :                     delete[] (BYTE *)(*clockInfo);

	ldr         x0,[x24]
	bl          |??_V@YAXPEAX@Z|

; 269  :                     *clockInfo = nullptr;

	str         xzr,[x24]
|$LN63@CUSBAsio|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 255  :     m_stopEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	mov         w2,#0
	mov         w1,#1
	mov         x0,#0
	blr         x8

; 256  : 
; 257  :     m_asioResetEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE58]
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8

; 258  :     m_terminateAsioResetEvent = CreateEvent(nullptr, TRUE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE70]
	mov         w2,#0
	mov         w1,#1
	mov         x0,#0
	blr         x8

; 259  : 
; 260  :     m_outputReadyBlockEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	str         x0,[x19,#0xE78]
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8

; 261  : 
; 262  :     auto beginThreadResult = _beginthreadex(nullptr, 0, AsioResetThread, this, 0, nullptr);

	adrp        x8,|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	add         x2,x8,|?AsioResetThread@CUSBAsio@@CAIPEAX@Z|
	mov         x5,#0
	str         x0,[x19,#0xE88]
	mov         w4,#0
	mov         x0,#0
	mov         x3,x19
	mov         w1,#0
	bl          _beginthreadex

; 263  :     ;
; 264  :     if (beginThreadResult <= 0)

	cbz         x0,|$LN1@CUSBAsio|

; 265  :     {
; 266  :         return;
; 267  :     }
; 268  :     m_asioResetThread = (HANDLE)beginThreadResult;
; 269  :     SetThreadPriority(m_asioResetThread, THREAD_PRIORITY_ABOVE_NORMAL);

	adrp        x8,__imp_SetThreadPriority
	ldr         x8,[x8,__imp_SetThreadPriority]
	mov         w1,#1
	str         x0,[x19,#0xE80]
	blr         x8

; 270  : 
; 271  :     m_samplePosition = 0;

	str         xzr,[x19,#0x20]

; 272  :     m_isActive = false;

	str         wzr,[x19,#0xB08]

; 273  :     m_isStarted = false;
; 274  :     m_isTimeInfoMode = false;
; 275  :     m_isTcRead = false;
; 276  :     for (i = 0; i < NUMOFINPUTS; i++)
; 277  :     {
; 278  :         m_inputBuffers[i] = 0;

	str         xzr,[x19,#0xD8]

; 279  :         m_inMap[i] = 0;

	str         wzr,[x19,#0x8F0]
	str         xzr,[x19,#0xE0]
	str         wzr,[x19,#0x8F4]
	str         xzr,[x19,#0xE8]
	str         wzr,[x19,#0x8F8]
	str         xzr,[x19,#0xF0]
	str         wzr,[x19,#0x8FC]
	str         xzr,[x19,#0xF8]
	str         wzr,[x19,#0x900]
	str         xzr,[x19,#0x100]
	str         wzr,[x19,#0x904]
	str         xzr,[x19,#0x108]
	str         wzr,[x19,#0x908]
	str         xzr,[x19,#0x110]
	str         wzr,[x19,#0x90C]
	str         xzr,[x19,#0x118]
	str         wzr,[x19,#0x910]
	str         xzr,[x19,#0x120]
	str         wzr,[x19,#0x914]
	str         xzr,[x19,#0x128]
	str         wzr,[x19,#0x918]
	str         xzr,[x19,#0x130]
	str         wzr,[x19,#0x91C]
	str         xzr,[x19,#0x138]
	str         wzr,[x19,#0x920]
	str         xzr,[x19,#0x140]
	str         wzr,[x19,#0x924]
	str         xzr,[x19,#0x148]
	str         wzr,[x19,#0x928]
	str         xzr,[x19,#0x150]
	str         wzr,[x19,#0x92C]
	str         xzr,[x19,#0x158]
	str         wzr,[x19,#0x930]
	str         xzr,[x19,#0x160]
	str         wzr,[x19,#0x934]
	str         xzr,[x19,#0x168]
	str         wzr,[x19,#0x938]
	str         xzr,[x19,#0x170]
	str         wzr,[x19,#0x93C]
	str         xzr,[x19,#0x178]
	str         wzr,[x19,#0x940]
	str         xzr,[x19,#0x180]
	str         wzr,[x19,#0x944]
	str         xzr,[x19,#0x188]
	str         wzr,[x19,#0x948]
	str         xzr,[x19,#0x190]
	str         wzr,[x19,#0x94C]
	str         xzr,[x19,#0x198]
	str         wzr,[x19,#0x950]
	str         xzr,[x19,#0x1A0]
	str         wzr,[x19,#0x954]
	str         xzr,[x19,#0x1A8]
	str         wzr,[x19,#0x958]
	str         xzr,[x19,#0x1B0]
	str         wzr,[x19,#0x95C]
	str         xzr,[x19,#0x1B8]
	str         wzr,[x19,#0x960]
	str         xzr,[x19,#0x1C0]
	str         wzr,[x19,#0x964]
	str         xzr,[x19,#0x1C8]
	str         wzr,[x19,#0x968]
	str         xzr,[x19,#0x1D0]
	str         wzr,[x19,#0x96C]
	str         xzr,[x19,#0x1D8]
	str         wzr,[x19,#0x970]
	str         xzr,[x19,#0x1E0]
	str         wzr,[x19,#0x974]
	str         xzr,[x19,#0x1E8]
	str         wzr,[x19,#0x978]
	str         xzr,[x19,#0x1F0]
	str         wzr,[x19,#0x97C]
	str         xzr,[x19,#0x1F8]
	str         wzr,[x19,#0x980]
	str         xzr,[x19,#0x200]
	str         wzr,[x19,#0x984]
	str         xzr,[x19,#0x208]
	str         wzr,[x19,#0x988]
	str         xzr,[x19,#0x210]
	str         wzr,[x19,#0x98C]
	str         xzr,[x19,#0x218]
	str         wzr,[x19,#0x990]
	str         xzr,[x19,#0x220]
	str         wzr,[x19,#0x994]
	str         xzr,[x19,#0x228]
	str         wzr,[x19,#0x998]
	str         xzr,[x19,#0x230]
	str         wzr,[x19,#0x99C]
	str         xzr,[x19,#0x238]
	str         wzr,[x19,#0x9A0]
	str         xzr,[x19,#0x240]
	str         wzr,[x19,#0x9A4]
	str         xzr,[x19,#0x248]
	str         wzr,[x19,#0x9A8]
	str         xzr,[x19,#0x250]
	str         wzr,[x19,#0x9AC]
	str         xzr,[x19,#0x258]
	str         wzr,[x19,#0x9B0]
	str         xzr,[x19,#0x260]
	str         wzr,[x19,#0x9B4]
	str         xzr,[x19,#0x268]
	str         wzr,[x19,#0x9B8]
	str         xzr,[x19,#0x270]
	str         wzr,[x19,#0x9BC]
	str         xzr,[x19,#0x278]
	str         wzr,[x19,#0x9C0]
	str         xzr,[x19,#0x280]
	str         wzr,[x19,#0x9C4]
	str         xzr,[x19,#0x288]
	str         wzr,[x19,#0x9C8]
	str         xzr,[x19,#0x290]
	str         wzr,[x19,#0x9CC]
	str         xzr,[x19,#0x298]
	str         wzr,[x19,#0x9D0]
	str         xzr,[x19,#0x2A0]
	str         wzr,[x19,#0x9D4]
	str         xzr,[x19,#0x2A8]
	str         wzr,[x19,#0x9D8]
	str         xzr,[x19,#0x2B0]
	str         wzr,[x19,#0x9DC]
	str         xzr,[x19,#0x2B8]
	str         wzr,[x19,#0x9E0]
	str         xzr,[x19,#0x2C0]
	str         wzr,[x19,#0x9E4]
	str         xzr,[x19,#0x2C8]
	str         wzr,[x19,#0x9E8]
	str         xzr,[x19,#0x2D0]
	str         wzr,[x19,#0x9EC]

; 280  :     }
; 281  :     for (i = 0; i < NUMOFOUTPUTS; i++)
; 282  :     {
; 283  :         m_outputBuffers[i] = 0;

	str         xzr,[x19,#0x4D8]

; 284  :         m_outMap[i] = 0;

	str         wzr,[x19,#0x9F0]
	str         xzr,[x19,#0x4E0]
	str         wzr,[x19,#0x9F4]
	str         xzr,[x19,#0x4E8]
	str         wzr,[x19,#0x9F8]
	str         xzr,[x19,#0x4F0]
	str         wzr,[x19,#0x9FC]
	str         xzr,[x19,#0x4F8]
	str         wzr,[x19,#0xA00]
	str         xzr,[x19,#0x500]
	str         wzr,[x19,#0xA04]
	str         xzr,[x19,#0x508]
	str         wzr,[x19,#0xA08]
	str         xzr,[x19,#0x510]
	str         wzr,[x19,#0xA0C]
	str         xzr,[x19,#0x518]
	str         wzr,[x19,#0xA10]
	str         xzr,[x19,#0x520]
	str         wzr,[x19,#0xA14]
	str         xzr,[x19,#0x528]
	str         wzr,[x19,#0xA18]
	str         xzr,[x19,#0x530]
	str         wzr,[x19,#0xA1C]
	str         xzr,[x19,#0x538]
	str         wzr,[x19,#0xA20]
	str         xzr,[x19,#0x540]
	str         wzr,[x19,#0xA24]
	str         xzr,[x19,#0x548]
	str         wzr,[x19,#0xA28]
	str         xzr,[x19,#0x550]
	str         wzr,[x19,#0xA2C]
	str         xzr,[x19,#0x558]
	str         wzr,[x19,#0xA30]
	str         xzr,[x19,#0x560]
	str         wzr,[x19,#0xA34]
	str         xzr,[x19,#0x568]
	str         wzr,[x19,#0xA38]
	str         xzr,[x19,#0x570]
	str         wzr,[x19,#0xA3C]
	str         xzr,[x19,#0x578]
	str         wzr,[x19,#0xA40]
	str         xzr,[x19,#0x580]
	str         wzr,[x19,#0xA44]
	str         xzr,[x19,#0x588]
	str         wzr,[x19,#0xA48]
	str         xzr,[x19,#0x590]
	str         wzr,[x19,#0xA4C]
	str         xzr,[x19,#0x598]
	str         wzr,[x19,#0xA50]
	str         xzr,[x19,#0x5A0]
	str         wzr,[x19,#0xA54]
	str         xzr,[x19,#0x5A8]
	str         wzr,[x19,#0xA58]
	str         xzr,[x19,#0x5B0]
	str         wzr,[x19,#0xA5C]
	str         xzr,[x19,#0x5B8]
	str         wzr,[x19,#0xA60]
	str         xzr,[x19,#0x5C0]
	str         wzr,[x19,#0xA64]
	str         xzr,[x19,#0x5C8]
	str         wzr,[x19,#0xA68]
	str         xzr,[x19,#0x5D0]
	str         wzr,[x19,#0xA6C]
	str         xzr,[x19,#0x5D8]
	str         wzr,[x19,#0xA70]
	str         xzr,[x19,#0x5E0]
	str         wzr,[x19,#0xA74]
	str         xzr,[x19,#0x5E8]
	str         wzr,[x19,#0xA78]
	str         xzr,[x19,#0x5F0]
	str         wzr,[x19,#0xA7C]
	str         xzr,[x19,#0x5F8]
	str         wzr,[x19,#0xA80]
	str         xzr,[x19,#0x600]
	str         wzr,[x19,#0xA84]
	str         xzr,[x19,#0x608]
	str         wzr,[x19,#0xA88]
	str         xzr,[x19,#0x610]
	str         wzr,[x19,#0xA8C]
	str         xzr,[x19,#0x618]
	str         wzr,[x19,#0xA90]
	str         xzr,[x19,#0x620]
	str         wzr,[x19,#0xA94]
	str         xzr,[x19,#0x628]
	str         wzr,[x19,#0xA98]
	str         xzr,[x19,#0x630]
	str         wzr,[x19,#0xA9C]
	str         xzr,[x19,#0x638]
	str         wzr,[x19,#0xAA0]
	str         xzr,[x19,#0x640]
	str         wzr,[x19,#0xAA4]
	str         xzr,[x19,#0x648]
	str         wzr,[x19,#0xAA8]
	str         xzr,[x19,#0x650]
	str         wzr,[x19,#0xAAC]
	str         xzr,[x19,#0x658]
	str         wzr,[x19,#0xAB0]
	str         xzr,[x19,#0x660]
	str         wzr,[x19,#0xAB4]
	str         xzr,[x19,#0x668]
	str         wzr,[x19,#0xAB8]
	str         xzr,[x19,#0x670]
	str         wzr,[x19,#0xABC]
	str         xzr,[x19,#0x678]
	str         wzr,[x19,#0xAC0]
	str         xzr,[x19,#0x680]
	str         wzr,[x19,#0xAC4]
	str         xzr,[x19,#0x688]
	str         wzr,[x19,#0xAC8]
	str         xzr,[x19,#0x690]
	str         wzr,[x19,#0xACC]
	str         xzr,[x19,#0x698]
	str         wzr,[x19,#0xAD0]
	str         xzr,[x19,#0x6A0]
	str         wzr,[x19,#0xAD4]
	str         xzr,[x19,#0x6A8]
	str         wzr,[x19,#0xAD8]
	str         xzr,[x19,#0x6B0]
	str         wzr,[x19,#0xADC]
	str         xzr,[x19,#0x6B8]
	str         wzr,[x19,#0xAE0]
	str         xzr,[x19,#0x6C0]
	str         wzr,[x19,#0xAE4]
	str         xzr,[x19,#0x6C8]
	str         wzr,[x19,#0xAE8]
	str         xzr,[x19,#0x6D0]
	str         wzr,[x19,#0xAEC]

; 285  :     }
; 286  :     m_toggle = 0;

	str         wzr,[x19,#0xB04]
|$LN1@CUSBAsio|

; 287  : }

	mov         x0,x19
	add         sp,sp,#0x310
	bl          __security_pop_cookie
	ldr         x27,[sp,#0x50]
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ret
	nop
|$LN210@CUSBAsio|
	DCFD         44100

	ENDP  ; |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CUSBAsio

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#8
	bl          |??1CUnknown@@UEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CUSBAsio

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDA8
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CUSBAsio

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$2@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$2
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDD0
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CUSBAsio

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$3@?0???0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z@4HA| PROC ; `CUSBAsio::CUSBAsio'::`1'::dtor$3
	stp         fp,lr,[sp,#-0x10]!
	ldr         x8,[x26,#8]
	add         x0,x8,#0xDF8
	bl          |??1critical_section@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??0CUSBAsio@@QEAA@PEAUIUnknown@@PEAJ@Z|, CUSBAsio::CUSBAsio

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

	AREA	|.text$mn|, CODE, ARM64

|??_GCUSBAsio@@UEAAPEAXI@Z| PROC			; CUSBAsio::`scalar deleting destructor'
|$LN43|
	stp         fp,lr,[sp,#-0x30]!
	stp         x19,x20,[sp,#0x10]
	str         x21,[sp,#0x20]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x30
	mov         x21,sp
	mov         xip0,#-2
	str         xip0,[x21]
	mov         x20,x0
	mov         w19,w1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 290  : {

	adrp        x8,|??_7CUSBAsio@@6BIASIO@@@|
	add         x9,x8,|??_7CUSBAsio@@6BIASIO@@@|
	adrp        x8,|??_7CUSBAsio@@6BCUnknown@@@|
	add         x8,x8,|??_7CUSBAsio@@6BCUnknown@@@|
	stp         x9,x8,[x20]

; 291  :     DWORD result = 0;
; 292  : 
; 293  :     disposeBuffers();

	bl          |?disposeBuffers@CUSBAsio@@UEAAJXZ|

; 294  : 
; 295  :     if (m_channelInfo != nullptr)

	ldr         x0,[x20,#0xD98]
	cbz         x0,|$LN6@scalar|

; 296  :     {
; 297  :         delete[] ((UCHAR *)m_channelInfo);

	bl          |??_V@YAXPEAX@Z|
|$LN6@scalar|

; 298  :     }
; 299  :     if (m_clockInfo != nullptr)

	ldr         x0,[x20,#0xDA0]
	cbz         x0,|$LN7@scalar|

; 300  :     {
; 301  :         delete[] ((UCHAR *)m_clockInfo);

	bl          |??_V@YAXPEAX@Z|
|$LN7@scalar|

; 302  :     }
; 303  :     if (m_desiredPath != nullptr)

	ldr         x0,[x20,#0x8E8]
	cbz         x0,|$LN8@scalar|

; 304  :     {
; 305  :         delete[] m_desiredPath;

	bl          |??_V@YAXPEAX@Z|
|$LN8@scalar|

; 306  :     }
; 307  :     if (m_usbDeviceHandle != INVALID_HANDLE_VALUE)

	ldr         x0,[x20,#0xBA8]
	cmn         x0,#1
	beq         |$LN9@scalar|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	ldr         q16,[x8]

; 471  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov         x8,#0xD
	movk        x8,#2,lsl #0x20
	str         wzr,[x21,#8]

; 473  : 
; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         x8,[x21,#0x20]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	add         x6,x21,#8
	str         q16,[x21,#0x10]
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x21,#0x10
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 310  :         CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x20,#0xBA8]
	blr         x8

; 311  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov         x8,#-1
	str         x8,[x20,#0xBA8]
|$LN9@scalar|

; 312  :     }
; 313  :     if (m_terminateAsioResetEvent != nullptr)

	ldr         x0,[x20,#0xE78]
	cbz         x0,|$LN10@scalar|

; 314  :     {
; 315  :         if (m_asioResetThread != nullptr)

	ldr         x8,[x20,#0xE80]
	cbz         x8,|$LN12@scalar|

; 316  :         {
; 317  :             DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 318  :             SetEvent(m_terminateAsioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	blr         x8

; 319  :             result = WaitForSingleObject(m_asioResetThread, timeout);

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	ldr         x0,[x20,#0xE80]
	mov         w1,#0x1770
	blr         x8

; 320  :             if (result == WAIT_OBJECT_0)

	cbnz        w0,|$LN12@scalar|

; 321  :             {
; 322  :                 CloseHandle(m_asioResetThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x20,#0xE80]
	blr         x8
|$LN12@scalar|

; 323  :             }
; 324  :         }
; 325  :         CloseHandle(m_terminateAsioResetEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x20,#0xE78]
	blr         x8
|$LN10@scalar|

; 326  :     }
; 327  :     if (m_asioResetEvent != nullptr)

	ldr         x0,[x20,#0xE70]
	cbz         x0,|$LN13@scalar|

; 328  :     {
; 329  :         CloseHandle(m_asioResetEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN13@scalar|

; 330  :     }
; 331  :     if (m_stopEvent != nullptr)

	ldr         x0,[x20,#0xE58]
	cbz         x0,|$LN14@scalar|

; 332  :     {
; 333  :         CloseHandle(m_stopEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN14@scalar|

; 334  :     }
; 335  :     if (m_outputReadyBlockEvent != nullptr)

	ldr         x0,[x20,#0xE88]
	cbz         x0,|$LN15@scalar|

; 336  :     {
; 337  :         CloseHandle(m_outputReadyBlockEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN15@scalar|

; 338  :     }
; 339  : 
; 340  :     InterlockedDecrement(&g_Instance);

	adrp        x8,|?g_Instance@@3JA|
	add         x0,x8,|?g_Instance@@3JA|
	bl          _InterlockedDecrement
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3381 :         ::DeleteCriticalSection(&m_cs);

	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x20,#0xDF8
	blr         x8
	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x20,#0xDD0
	blr         x8
	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x20,#0xDA8
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h

; 192  :     virtual ~CUnknown() {};

	adrp        x8,|??_7CUnknown@@6B@|
	add         x8,x8,|??_7CUnknown@@6B@|
	str         x8,[x20,#8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 43   :     InterlockedDecrement(&m_cObjects);

	adrp        x8,|?m_cObjects@CBaseObject@@0JA|
	add         x0,x8,|?m_cObjects@CBaseObject@@0JA|
	bl          _InterlockedDecrement
	nop
	tbz         w19,#0,|$LN2@scalar|
	mov         x1,#0xE98
	mov         x0,x20
	bl          |??3@YAXPEAX_K@Z|
|$LN2@scalar|
	mov         x0,x20
	add         sp,sp,#0x30
	bl          __security_pop_cookie
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x30
	ret

	ENDP  ; |??_GCUSBAsio@@UEAAPEAXI@Z|, CUSBAsio::`scalar deleting destructor'

; Function compile flags: /Ogtp

	AREA	|.text$mn|, CODE, ARM64

|??0IASIO@@QEAA@XZ| PROC				; IASIO::IASIO
	adrp        x8,|??_7IASIO@@6B@|
	add         x8,x8,|??_7IASIO@@6B@|
	str         x8,[x0]
	ret

	ENDP  ; |??0IASIO@@QEAA@XZ|, IASIO::IASIO

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|??1CUSBAsio@@UEAA@XZ| PROC				; CUSBAsio::~CUSBAsio

; 290  : {

|$LN37|
	stp         fp,lr,[sp,#-0x20]!
	stp         x19,x20,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x30
	mov         x20,sp
	adrp        x8,|??_7CUSBAsio@@6BIASIO@@@|
	add         x9,x8,|??_7CUSBAsio@@6BIASIO@@@|
	adrp        x8,|??_7CUSBAsio@@6BCUnknown@@@|
	add         x8,x8,|??_7CUSBAsio@@6BCUnknown@@@|
	mov         xip0,#-2
	mov         x19,x0
	str         xip0,[x20]
	stp         x9,x8,[x19]

; 291  :     DWORD result = 0;
; 292  : 
; 293  :     disposeBuffers();

	bl          |?disposeBuffers@CUSBAsio@@UEAAJXZ|

; 294  : 
; 295  :     if (m_channelInfo != nullptr)

	ldr         x0,[x19,#0xD98]
	cbz         x0,|$LN2@CUSBAsio|

; 296  :     {
; 297  :         delete[] ((UCHAR *)m_channelInfo);

	bl          |??_V@YAXPEAX@Z|
|$LN2@CUSBAsio|

; 298  :     }
; 299  :     if (m_clockInfo != nullptr)

	ldr         x0,[x19,#0xDA0]
	cbz         x0,|$LN3@CUSBAsio|

; 300  :     {
; 301  :         delete[] ((UCHAR *)m_clockInfo);

	bl          |??_V@YAXPEAX@Z|
|$LN3@CUSBAsio|

; 302  :     }
; 303  :     if (m_desiredPath != nullptr)

	ldr         x0,[x19,#0x8E8]
	cbz         x0,|$LN4@CUSBAsio|

; 304  :     {
; 305  :         delete[] m_desiredPath;

	bl          |??_V@YAXPEAX@Z|
|$LN4@CUSBAsio|

; 306  :     }
; 307  :     if (m_usbDeviceHandle != INVALID_HANDLE_VALUE)

	ldr         x0,[x19,#0xBA8]
	cmn         x0,#1
	beq         |$LN5@CUSBAsio|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 470  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	ldr         q16,[x8]

; 471  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov         x8,#0xD
	movk        x8,#2,lsl #0x20
	str         wzr,[x20,#8]

; 473  : 
; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         x8,[x20,#0x20]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	add         x6,x20,#8
	str         q16,[x20,#0x10]
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x20,#0x10
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 310  :         CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xBA8]
	blr         x8

; 311  :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov         x8,#-1
	str         x8,[x19,#0xBA8]
|$LN5@CUSBAsio|

; 312  :     }
; 313  :     if (m_terminateAsioResetEvent != nullptr)

	ldr         x0,[x19,#0xE78]
	cbz         x0,|$LN6@CUSBAsio|

; 314  :     {
; 315  :         if (m_asioResetThread != nullptr)

	ldr         x8,[x19,#0xE80]
	cbz         x8,|$LN8@CUSBAsio|

; 316  :         {
; 317  :             DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 318  :             SetEvent(m_terminateAsioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	blr         x8

; 319  :             result = WaitForSingleObject(m_asioResetThread, timeout);

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	ldr         x0,[x19,#0xE80]
	mov         w1,#0x1770
	blr         x8

; 320  :             if (result == WAIT_OBJECT_0)

	cbnz        w0,|$LN8@CUSBAsio|

; 321  :             {
; 322  :                 CloseHandle(m_asioResetThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE80]
	blr         x8
|$LN8@CUSBAsio|

; 323  :             }
; 324  :         }
; 325  :         CloseHandle(m_terminateAsioResetEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE78]
	blr         x8
|$LN6@CUSBAsio|

; 326  :     }
; 327  :     if (m_asioResetEvent != nullptr)

	ldr         x0,[x19,#0xE70]
	cbz         x0,|$LN9@CUSBAsio|

; 328  :     {
; 329  :         CloseHandle(m_asioResetEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN9@CUSBAsio|

; 330  :     }
; 331  :     if (m_stopEvent != nullptr)

	ldr         x0,[x19,#0xE58]
	cbz         x0,|$LN10@CUSBAsio|

; 332  :     {
; 333  :         CloseHandle(m_stopEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN10@CUSBAsio|

; 334  :     }
; 335  :     if (m_outputReadyBlockEvent != nullptr)

	ldr         x0,[x19,#0xE88]
	cbz         x0,|$LN11@CUSBAsio|

; 336  :     {
; 337  :         CloseHandle(m_outputReadyBlockEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8
|$LN11@CUSBAsio|

; 338  :     }
; 339  : 
; 340  :     InterlockedDecrement(&g_Instance);

	adrp        x8,|?g_Instance@@3JA|
	add         x0,x8,|?g_Instance@@3JA|
	bl          _InterlockedDecrement
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3381 :         ::DeleteCriticalSection(&m_cs);

	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x19,#0xDF8
	blr         x8
	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x19,#0xDD0
	blr         x8
	adrp        x8,__imp_DeleteCriticalSection
	ldr         x8,[x8,__imp_DeleteCriticalSection]
	add         x0,x19,#0xDA8
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.h

; 192  :     virtual ~CUnknown() {};

	adrp        x8,|??_7CUnknown@@6B@|
	add         x8,x8,|??_7CUnknown@@6B@|
	str         x8,[x19,#8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\asio\combase.cpp

; 43   :     InterlockedDecrement(&m_cObjects);

	adrp        x8,|?m_cObjects@CBaseObject@@0JA|
	add         x0,x8,|?m_cObjects@CBaseObject@@0JA|
	bl          _InterlockedDecrement
	add         sp,sp,#0x30
	bl          __security_pop_cookie
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |??1CUSBAsio@@UEAA@XZ|, CUSBAsio::~CUSBAsio

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getDriverName@CUSBAsio@@UEAAXPEAD@Z| PROC		; CUSBAsio::getDriverName

; 348  :     strcpy_s(name, DRIVER_NAME_LENGTH, DRIVER_NAME_8b);

	adrp        x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	add         x2,x8,|??_C@_0BC@LDCENIFA@USB?5ASIO?5?$CIARM64X?$CJ@|
	mov         x0,x1
	mov         x1,#0x1F
	b           strcpy_s

	ENDP  ; |?getDriverName@CUSBAsio@@UEAAXPEAD@Z|, CUSBAsio::getDriverName

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getDriverVersion@CUSBAsio@@UEAAJXZ| PROC		; CUSBAsio::getDriverVersion

; 353  :     info_print_("getDriverVersion\n");
; 354  :     return 0x00010000L;

	mov         w0,#0x10000
	ret

	ENDP  ; |?getDriverVersion@CUSBAsio@@UEAAJXZ|, CUSBAsio::getDriverVersion

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z| PROC		; CUSBAsio::getErrorMessage

; 359  : {

	mov         x8,x0
	mov         x0,x1

; 360  :     info_print_("getErrorMessage\n");
; 361  :     // >>comment-001<<
; 362  :     size_t size = _tcslen(m_errorMessage) + 1;
; 363  :     size = min(size, ERROR_MESSAGE_LENGTH);
; 364  : 
; 365  : #ifdef _UNICODE
; 366  :     // TCHAR is wchar_t  convert wide char to multibyte
; 367  :     WideCharToMultiByte(CP_ACP, 0, m_errorMessage, -1, errorMessage, ERROR_MESSAGE_LENGTH, NULL, NULL);
; 368  : #else
; 369  :     // TCHAR is char  direct copy
; 370  :     strcpy_s(errorMessage, ERROR_MESSAGE_LENGTH, m_errorMessage);

	add         x2,x8,#0xB0C
	mov         x1,#0x80
	b           strcpy_s

	ENDP  ; |?getErrorMessage@CUSBAsio@@UEAAXPEAD@Z|, CUSBAsio::getErrorMessage

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?init@CUSBAsio@@UEAAJPEAX@Z| PROC			; CUSBAsio::init

; 377  :     info_print_("init\n");
; 378  :     // Due to a change in the error handling policy, it has been changed to return an error if an error occurs in CUSBAsio::CUSBAsio ().
; 379  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN9@init|
	ldr         w8,[x0,#0xAF4]
	cbz         w8,|$LN9@init|
	ldr         w8,[x0,#0xAF8]
	cmp         w8,#0
	csetne      w0
	ret
|$LN9@init|

; 380  :     {
; 381  :         // Error in CUSBAsio::CUSBAsio ()
; 382  :         return ASIOFalse;

	mov         w0,#0
	ret

	ENDP  ; |?init@CUSBAsio@@UEAAJPEAX@Z|, CUSBAsio::init

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?start@CUSBAsio@@UEAAJXZ| PROC				; CUSBAsio::start

; 388  : {

|$LN18|

; 389  :     info_print_("start\n");
; 390  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN3@start|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN15@start|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN15@start|

; 393  :     }
; 394  : 
; 395  :     if (!m_isActive)

	ldrb        w8,[x19,#0xB08]
	cbz         w8,|$LN15@start|

; 396  :     {
; 397  :         return ASE_NotPresent;
; 398  :     }
; 399  : 
; 400  :     if (m_callbacks)

	ldr         x8,[x19,#0x30]
	cbz         x8,|$LN15@start|
	add         x8,x19,#0x8D8

; 1971 :     ResetEvent(m_stopEvent);

	ldr         x0,[x19,#0xE58]

; 405  : 
; 406  :         m_initialSystemTime = 0;

	stp         xzr,xzr,[x8]

; 407  :         m_calculatedSystemTime = 0;
; 408  :         m_initialKernelTime = 0;
; 409  : 
; 410  :         m_isStarted = true;

	mov         w8,#1
	strb        w8,[x19,#0xB09]

; 1971 :     ResetEvent(m_stopEvent);

	adrp        x8,__imp_ResetEvent
	ldr         x8,[x8,__imp_ResetEvent]

; 401  :     {
; 402  :         m_samplePosition = 0;

	str         xzr,[x19,#0x20]

; 403  :         m_theSystemTime.lo = m_theSystemTime.hi = 0;

	stur        xzr,[x19,#0xCC]

; 404  :         m_toggle = 0;

	str         wzr,[x19,#0xB04]

; 1971 :     ResetEvent(m_stopEvent);

	blr         x8

; 1972 :     auto beginThreadResult = _beginthreadex(nullptr, 0, WorkerThread, this, 0, nullptr);

	adrp        x8,|?WorkerThread@CUSBAsio@@CAIPEAX@Z|
	add         x2,x8,|?WorkerThread@CUSBAsio@@CAIPEAX@Z|
	mov         x5,#0
	mov         w4,#0
	mov         x3,x19
	mov         w1,#0
	mov         x0,#0
	bl          _beginthreadex

; 1973 :     m_workerThread = (HANDLE)beginThreadResult;

	str         x0,[x19,#0xE60]

; 1974 :     if ((beginThreadResult > 0) && (m_threadPriority == -2))

	cbz         x0,|$LN8@start|
	ldr         w8,[x19,#0xE68]
	cmn         w8,#2
	bne         |$LN8@start|

; 1975 :     {
; 1976 :         SetThreadPriority(m_workerThread, THREAD_PRIORITY_TIME_CRITICAL);

	adrp        x8,__imp_SetThreadPriority
	ldr         x8,[x8,__imp_SetThreadPriority]
	mov         w1,#0xF
	blr         x8
|$LN8@start|

; 411  : 
; 412  :         ThreadStart(); // activate 'hardware'
; 413  : 
; 414  :         return ASE_OK;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
|$LN15@start|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
|$LN3@start|

; 391  :     {
; 392  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ret

	ENDP  ; |?start@CUSBAsio@@UEAAJXZ|, CUSBAsio::start

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?stop@CUSBAsio@@UEAAJXZ| PROC				; CUSBAsio::stop

; 420  : {

|$LN21|

; 421  :     info_print_("stop\n");
; 422  : 
; 423  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN3@stop|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN17@stop|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN17@stop|

; 426  :     }
; 427  : 
; 428  :     if (!m_isStarted)

	ldrb        w8,[x19,#0xB09]
	cbz         w8,|$LN19@stop|

; 1984 :     SetEvent(m_stopEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE58]

; 429  :     {
; 430  :         return ASE_OK;
; 431  :     }
; 432  :     m_isStarted = false;

	strb        wzr,[x19,#0xB09]

; 1984 :     SetEvent(m_stopEvent);

	blr         x8

; 1985 :     if (m_workerThread != nullptr)

	ldr         x0,[x19,#0xE60]
	cbz         x0,|$LN10@stop|

; 1986 :     {
; 1987 :         DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 1988 :         status = WaitForSingleObject(m_workerThread, timeout);

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	mov         w1,#0x1770
	blr         x8

; 1989 :         if (status == WAIT_OBJECT_0)

	cbnz        w0,|$LN8@stop|

; 1990 :         {
; 1991 :             CloseHandle(m_workerThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE60]
	blr         x8

; 1992 :         }

	b           |$LN10@stop|
|$LN8@stop|

; 1993 :         else if (status == WAIT_TIMEOUT)

	cmp         w0,#0x102
	bne         |$LN10@stop|

; 1994 :         {
; 1995 :             error_print_("wait timouut. force terminating worker thread.");
; 1996 :             // Understanding that there is an issue, preventing proper cleanup, call TerminateThread.
; 1997 :             // TerminateThread(m_workerThread, 0);
; 1998 : 
; 1999 :             // Implemented without using TerminateThread.
; 2000 :             // If the thread does not exit within the timeout, it will be forcibly terminated by the OS when the application exits.
; 2001 : 
; 2002 :             CloseHandle(m_workerThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE60]
	blr         x8

; 2003 :             InterlockedDecrement(&g_WorkerThread);

	adrp        x8,|?g_WorkerThread@@3JA|
	add         x0,x8,|?g_WorkerThread@@3JA|
	bl          _InterlockedDecrement
|$LN10@stop|

; 433  :     ThreadStop(); // de-activate 'hardware'
; 434  :     StopAsioStream(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]

; 2010 :     m_workerThread = nullptr;

	str         xzr,[x19,#0xE60]

; 433  :     ThreadStop(); // de-activate 'hardware'
; 434  :     StopAsioStream(m_usbDeviceHandle);

	bl          |?StopAsioStream@@YAHPEAX@Z|
|$LN19@stop|

; 435  : 
; 436  :     return ASE_OK;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
|$LN17@stop|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
|$LN3@stop|

; 424  :     {
; 425  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ret

	ENDP  ; |?stop@CUSBAsio@@UEAAJXZ|, CUSBAsio::stop

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getChannels@CUSBAsio@@UEAAJPEAJ0@Z| PROC		; CUSBAsio::getChannels

; 441  : {

|$LN51|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 442  :     info_print_("getChannels\n");
; 443  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN3@getChannel|
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	mov         x19,x0
	mov         x21,x1
	mov         x22,x2
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN47@getChannel|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN47@getChannel|

; 449  :     }
; 450  :     if (numInputChannels == nullptr || numOutputChannels == nullptr)

	cbz         x21,|$LN5@getChannel|
	cbz         x22,|$LN5@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 455  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x20,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 456  :         *numInputChannels = m_inAvailableChannels;

	ldr         w8,[x19,#0xD8C]
	str         w8,[x21]

; 457  :         *numOutputChannels = m_outAvailableChannels;

	ldr         w8,[x19,#0xD90]
	str         w8,[x22]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN41@getChannel|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN41@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 460  :     return ASE_OK;

	mov         w0,#0
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN5@getChannel|

; 451  :     {
; 452  :         return ASE_InvalidParameter;

	mov         w0,#-0x3E6
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN47@getChannel|

; 442  :     info_print_("getChannels\n");
; 443  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	mov         x1,x21
	mov         x2,x22
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
|$LN3@getChannel|

; 444  :     {
; 445  :         *numInputChannels = 0;

	str         wzr,[x1]

; 446  :         *numOutputChannels = 0;
; 447  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 448  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	str         wzr,[x2]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?getChannels@CUSBAsio@@UEAAJPEAJ0@Z|, CUSBAsio::getChannels

; Function compile flags: /Ogtp

	AREA	|.text$mn|, CODE, ARM64

|?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z| PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2
	str         xzr,[x0]
	ret

	ENDP  ; |?__autoclassinit2@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAAX_K@Z|, wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::__autoclassinit2

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z| PROC		; CUSBAsio::getLatencies

; 465  : {

|$LN15|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 466  :     info_print_("getLatencies\n");
; 467  : 
; 468  :     *inputLatency = 0;

	str         wzr,[x1]

; 469  :     *outputLatency = 0;

	str         wzr,[x2]

; 470  : 
; 471  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x3,[x0,#0xBA8]
	cmn         x3,#1
	beq         |$LN3@getLatenci|
	stp         x19,x20,[sp,#0x10]
	str         x21,[sp,#0x20]
	mov         x19,x0
	mov         x21,x1
	mov         x20,x2
	mov         x0,x3
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN12@getLatenci|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN12@getLatenci|

; 475  :     }
; 476  :     if (inputLatency == nullptr || outputLatency == nullptr)
; 477  :     {
; 478  :         return ASE_InvalidParameter;
; 479  :     }
; 480  : 
; 481  :     if (GetAudioProperty(m_usbDeviceHandle, &m_audioProperty))

	add         x1,x19,#0xBB0
	bl          |?GetAudioProperty@@YAHPEAXPEAU_UAC_AUDIO_PROPERTY@@@Z|

; 482  :     {
; 483  :         info_print_("Obtained latency offset in-%d out-%d\n", m_audioProperty.InputLatencyOffset, m_audioProperty.OutputLatencyOffset);
; 484  :     }
; 485  : 
; 486  :     *inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	ldr         w9,[x19,#0xCEC]

; 487  :     *outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;
; 488  : 
; 489  :     // >>comment-002<<
; 490  :     return ASE_OK;

	mov         w0,#0
	ldr         w8,[x19,#0xAF0]
	add         w8,w9,w8
	str         w8,[x21]
	ldr         w9,[x19,#0xD24]
	ldr         w8,[x19,#0xAF0]
	add         w8,w9,w8
	str         w8,[x20]
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN12@getLatenci|
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
|$LN3@getLatenci|

; 472  :     {
; 473  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 474  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?getLatencies@CUSBAsio@@UEAAJPEAJ0@Z|, CUSBAsio::getLatencies

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z| PROC		; CUSBAsio::getBufferSize

; 496  :     info_print_("getBufferSize\n");
; 497  : 
; 498  :     *minSize = 0;

	str         wzr,[x1]

; 499  :     *maxSize = 0;

	str         wzr,[x2]

; 500  :     *preferredSize = 0;

	str         wzr,[x3]

; 501  :     *granularity = 0;

	str         wzr,[x4]

; 502  : 
; 503  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN11@getBufferS|
	ldr         w8,[x0,#0xAF4]
	cbz         w8,|$LN11@getBufferS|
	ldr         w8,[x0,#0xAF8]
	cbz         w8,|$LN11@getBufferS|

; 507  :     }
; 508  :     if (minSize == nullptr || maxSize == nullptr || preferredSize == nullptr || granularity == nullptr)
; 509  :     {
; 510  :         return ASE_InvalidParameter;
; 511  :     }
; 512  :     *minSize = *maxSize = *preferredSize = m_blockFrames; // allow this size only

	ldr         w8,[x0,#0xAF0]

; 513  :     *granularity = 0;
; 514  :     // No error is returned even if the hardware is unusable.
; 515  :     // Some DAWs will crash if 0 is returned, so the initial value of m_blockFrames is 1024.
; 516  :     return ASE_OK;

	mov         w0,#0
	str         w8,[x3]
	str         w8,[x2]
	str         w8,[x1]
	str         wzr,[x4]
	ret
|$LN11@getBufferS|

; 504  :     {
; 505  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 506  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ret

	ENDP  ; |?getBufferSize@CUSBAsio@@UEAAJPEAJ000@Z|, CUSBAsio::getBufferSize

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?canSampleRate@CUSBAsio@@UEAAJN@Z| PROC		; CUSBAsio::canSampleRate

; 521  : {

|$LN82|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 522  :     info_print_("canSampleRate\n");
; 523  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN6@canSampleR|
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	mov         x20,x0
	mov         x22,x0
	ldr         w8,[x20,#0xAF4]
	cbz         w8,|$LN78@canSampleR|
	ldr         w8,[x20,#0xAF8]
	cbz         w8,|$LN78@canSampleR|

; 527  :     }
; 528  :     info_print_("requested %lf Hz\n", sampleRate);
; 529  :     if (m_fixedSamplingRate != 0)

	ldr         w8,[x20,#0xD84]
	fcvtzu      w21,d0
	cbz         w8,|$LN9@canSampleR|

; 530  :     {
; 531  :         if ((ULONG)sampleRate == m_fixedSamplingRate)

	cmp         w21,w8
	beq         |$LN47@canSampleR|
|$LN62@canSampleR|

; 558  :     return ASE_NoClock;

	mov         w0,#-0x3E3
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN9@canSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 542  :         auto        lockDevice = m_deviceInfoCS.lock();

	add         x19,x20,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x19
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 545  :         if ((m_requestedSampleFormat == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	ldr         w8,[x20,#0xD88]
	cbnz        w8,|$LN76@canSampleR|
	ldr         w9,[x20,#0xCD4]
	mov         w8,#0x21
	tst         w9,w8
	beq         |$LN76@canSampleR|

; 548  :             {
; 549  :                 if ((requiredFrameRate == c_FrameRateList[index]) && ((m_audioProperty.SupportedSampleRate & (1 << index)) != 0))

	adrp        x9,|?c_FrameRateList@@3QBKB|
	add         x9,x9,|?c_FrameRateList@@3QBKB|
	mov         w8,#0
	mov         w10,#1
|$LL4@canSampleR|
	ldr         w11,[x9,w8 uxtw #2]
	cmp         w21,w11
	bne         |$LN2@canSampleR|
	ldr         w11,[x22,#0xCC4]
	lsl         w12,w10,w8
	tst         w12,w11
	bne         |$LN75@canSampleR|
|$LN2@canSampleR|

; 546  :         {
; 547  :             for (ULONG index = 0; index < c_FrameRateListNumber; ++index)

	add         w8,w8,#1
	cmp         w8,#0xD
	blo         |$LL4@canSampleR|
|$LN76@canSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN62@canSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 558  :     return ASE_NoClock;

	b           |$LN62@canSampleR|
|$LN75@canSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN47@canSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
|$LN47@canSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 552  :                     return ASE_OK;

	mov         w0,#0
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN78@canSampleR|
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
|$LN6@canSampleR|

; 524  :     {
; 525  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 526  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?canSampleRate@CUSBAsio@@UEAAJN@Z|, CUSBAsio::canSampleRate

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getSampleRate@CUSBAsio@@UEAAJPEAN@Z| PROC		; CUSBAsio::getSampleRate

; 563  : {

|$LN48|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 564  :     verbose_print_("getSampleRate\n");
; 565  : 
; 566  :     if (sampleRate == nullptr)

	cbnz        x1,|$LN44@getSampleR|

; 567  :     {
; 568  :         return ASE_InvalidParameter;

	mov         w0,#-0x3E6
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN44@getSampleR|
	stp         x19,x20,[sp,#0x10]
	str         x21,[sp,#0x20]

; 564  :     verbose_print_("getSampleRate\n");
; 565  : 
; 566  :     if (sampleRate == nullptr)

	mov         x19,x0
	mov         x21,x1

; 569  :     }
; 570  : 
; 571  :     *sampleRate = {};

	str         xzr,[x21]

; 572  : 
; 573  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x19,#0xBA8]
	cmn         x8,#1
	beq         |$LN4@getSampleR|
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN4@getSampleR|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN4@getSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 581  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x20,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 582  :         *sampleRate = m_sampleRate;

	ldr         d16,[x19,#0x28]
	str         d16,[x21]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN40@getSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN40@getSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 586  :     return ASE_OK;

	mov         w0,#0
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN4@getSampleR|

; 574  :     {
; 575  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 576  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?getSampleRate@CUSBAsio@@UEAAJPEAN@Z|, CUSBAsio::getSampleRate

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?setSampleRate@CUSBAsio@@UEAAJN@Z| PROC		; CUSBAsio::setSampleRate

; 591  : {

|$LN235|
	stp         fp,lr,[sp,#-0x50]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	str         d8,[sp,#0x40]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x40
	mov         x24,sp
	mov         xip0,#-2
	fmov        d8,d0
	mov         x19,x0
	str         xip0,[x24]

; 592  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x19,#0xBA8]
	mov         x23,x0
	cmn         x8,#1
	beq         |$LN6@setSampleR|
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN6@setSampleR|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN6@setSampleR|

; 596  :     }
; 597  :     info_print_("setSampleRate\n");
; 598  :     info_print_("current %lf Hz, device current %u Hz, request %lf Hz\n", this->m_sampleRate, m_audioProperty.SampleRate, sampleRate);
; 599  :     if (canSampleRate(sampleRate) != ASE_OK)

	ldr         x8,[x19]
	ldr         x8,[x8,#0x60]
	blr         x8
	cbz         w0,|$LN7@setSampleR|

; 600  :     {
; 601  :         return ASE_NoClock;

	mov         w0,#-0x3E3
	b           |$LN1@setSampleR|
|$LN7@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 604  :         auto lockClient = m_clientInfoCS.lock();

	add         x21,x19,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x21
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x21,[x24,#8]

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 605  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x20,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[x24,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 607  :         if (sampleRate != this->m_sampleRate)

	ldr         d16,[x19,#0x28]
	fcmp        d8,d16
	beq         |$LN18@setSampleR|

; 608  :         {
; 609  :             BOOL  result = FALSE;
; 610  :             ULONG sampleFormat;
; 611  :             if (m_requestedSampleFormat != kASIOPCMFormat)

	ldr         w8,[x19,#0xD88]
	cbnz        w8,|$LN14@setSampleR|

; 612  :             {
; 613  :                 return ASE_NoClock;
; 614  :             }
; 615  :             if ((m_audioProperty.CurrentSampleFormat != UACSampleFormat::UAC_SAMPLE_FORMAT_PCM) && (m_audioProperty.CurrentSampleFormat == UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT))

	ldr         w8,[x19,#0xCD8]
	cmp         w8,#5
	bne         |$LN11@setSampleR|

; 616  :             {
; 617  :                 if (m_audioProperty.SupportedSampleFormats & (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT)))

	ldr         w8,[x19,#0xCD4]
	tbz         w8,#5,|$LN12@setSampleR|

; 618  :                 {
; 619  :                     sampleFormat = toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT);

	mov         w8,#5

; 620  :                 }

	b           |$LN11@setSampleR|
|$LN12@setSampleR|

; 621  :                 else if (m_audioProperty.SupportedSampleFormats & (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)))

	tbz         w8,#0,|$LN14@setSampleR|

; 622  :                 {
; 623  :                     sampleFormat = toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM);

	mov         w8,#0
|$LN11@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 334  :     ULONG      bytesReturned = 0;

	stp         wzr,w8,[x24,#0x18]

; 335  : 
; 336  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x22,x8,KSPROPSETID_LowLatencyAudio

; 337  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 338  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetSampleFormat);

	mov         x8,#6
	movk        x8,#2,lsl #0x20
	ldr         q16,[x22]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 635  :             result = SetSampleFormat(m_usbDeviceHandle, sampleFormat);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 340  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleFormat, sizeof(ULONG), &bytesReturned, nullptr);

	mov         x7,#0
	str         x8,[x24,#0x30]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	add         x6,x24,#0x18
	str         q16,[x24,#0x20]
	mov         w5,#4
	add         x4,x24,#0x1C
	mov         w3,#0x18
	add         x2,x24,#0x20
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 640  :                 if (frameRate == c_FrameRateList[i] &&

	adrp        x10,|?c_FrameRateList@@3QBKB|
	add         x10,x10,|?c_FrameRateList@@3QBKB|
	fcvtzu      w9,d8
	mov         w8,#0
	mov         w11,#1
|$LL4@setSampleR|
	ldr         w12,[x10,w8 uxtw #2]
	cmp         w9,w12
	bne         |$LN2@setSampleR|
	ldr         w12,[x23,#0xCC4]
	lsl         w13,w11,w8
	tst         w13,w12
	bne         |$LN231@setSampleR|
|$LN2@setSampleR|

; 636  :             ULONG frameRate = (ULONG)sampleRate;
; 637  : 
; 638  :             for (ULONG i = 0; i < c_FrameRateListNumber; ++i)

	add         w8,w8,#1
	cmp         w8,#0xD
	blo         |$LL4@setSampleR|
	b           |$LN232@setSampleR|
|$LN231@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 357  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ChangeSampleRate);

	mov         x8,#7
	movk        x8,#2,lsl #0x20
	ldr         q16,[x22]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 644  :                     result = ChangeSampleRate(m_usbDeviceHandle, frameRate);

	stp         w9,wzr,[x24,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 357  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ChangeSampleRate);

	str         x8,[x24,#0x30]

; 359  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleRate, sizeof(ULONG), &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 644  :                     result = ChangeSampleRate(m_usbDeviceHandle, frameRate);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 359  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &sampleRate, sizeof(ULONG), &bytesReturned, nullptr);

	mov         x7,#0
	add         x6,x24,#0x1C
	mov         w5,#4
	str         q16,[x24,#0x20]
	add         x4,x24,#0x18
	mov         w3,#0x18
	add         x2,x24,#0x20
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
|$LN232@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 649  :             if (!result)

	cbnz        w0,|$LN17@setSampleR|

; 650  :             {
; 651  :                 return ASE_InvalidMode;

	mov         w19,#-0x3E5
	b           |$LN24@setSampleR|
|$LN17@setSampleR|

; 652  :             }
; 653  :             this->m_sampleRate = sampleRate;
; 654  : 
; 655  :             if (!RequestClockInfoChange())

	mov         x0,x19
	str         d8,[x19,#0x28]
	bl          |?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|
	tbnz        w0,#0,|$LN18@setSampleR|

; 657  :                 return ASE_NotPresent;

	mov         w19,#-0x3E8
	b           |$LN24@setSampleR|
|$LN14@setSampleR|
	mov         w19,#-0x3E3
|$LN24@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN38@setSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
	nop
|$LN38@setSampleR|

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN53@setSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
|$LN53@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 657  :                 return ASE_NotPresent;

	mov         w0,w19
	b           |$LN1@setSampleR|
|$LN18@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN110@setSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
	nop
|$LN110@setSampleR|

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN125@setSampleR|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
|$LN125@setSampleR|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 661  :     return ASE_OK;

	mov         w0,#0
	b           |$LN1@setSampleR|
|$LN6@setSampleR|

; 593  :     {
; 594  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 595  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
|$LN1@setSampleR|
	add         sp,sp,#0x40
	bl          __security_pop_cookie
	ldr         d8,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x50
	ret

	ENDP  ; |?setSampleRate@CUSBAsio@@UEAAJN@Z|, CUSBAsio::setSampleRate

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| PROC	; `CUSBAsio::setSampleRate'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x24,#8
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?setSampleRate@CUSBAsio@@UEAAJN@Z|, CUSBAsio::setSampleRate

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??setSampleRate@CUSBAsio@@UEAAJN@Z@4HA| PROC	; `CUSBAsio::setSampleRate'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x24,#0x10
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?setSampleRate@CUSBAsio@@UEAAJN@Z|, CUSBAsio::setSampleRate

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z| PROC ; CUSBAsio::getClockSources

; 666  : {

|$LN81|
	sub         sp,sp,#0x50
	stp         fp,lr,[sp,#-0x40]!
	mov         fp,sp

; 667  :     verbose_print_("getClockSources\n");
; 668  : 
; 669  :     if (clocks == nullptr)

	cbz         x1,|$LN68@getClockSo|
	stp         x19,x20,[sp,#0x40]
	stp         x21,x22,[sp,#0x50]
	stp         x23,x24,[sp,#0x60]
	stp         x25,x26,[sp,#0x70]
	stp         x27,x28,[sp,#0x80]
	mov         x19,x0
	mov         x23,x1
	mov         x21,x2

; 670  :     {
; 671  :         return ASE_InvalidParameter;
; 672  :     }
; 673  :     *clocks = {};

	movi        v16.16b,#0
	stp         q16,q16,[sp,#0x10]
	str         q16,[sp,#0x30]
	ldp         q17,q16,[sp,#0x10]
	stp         q17,q16,[x23]
	ldr         q16,[sp,#0x30]
	str         q16,[x23,#0x20]

; 674  : 
; 675  :     if (numSources == nullptr)

	cbz         x21,|$LN77@getClockSo|

; 678  :     }
; 679  :     *numSources = 0;

	str         wzr,[x21]

; 680  : 
; 681  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x19,#0xBA8]
	cmn         x8,#1
	beq         |$LN8@getClockSo|
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN8@getClockSo|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN8@getClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 694  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x20,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 695  :         if (m_clockInfo == nullptr)

	ldr         x22,[x19,#0xDA0]
	cbnz        x22,|$LN10@getClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN47@getClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN47@getClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 697  :             return ASE_HWMalfunction;

	mov         w0,#-0x3E7
|$LN78@getClockSo|
	ldp         x27,x28,[sp,#0x80]
	ldp         x25,x26,[sp,#0x70]
	ldp         x23,x24,[sp,#0x60]
	ldp         x21,x22,[sp,#0x50]
	ldp         x19,x20,[sp,#0x40]
	ldp         fp,lr,[sp],#0x40
	add         sp,sp,#0x50
	ret
|$LN10@getClockSo|

; 698  :         }
; 699  :         UAC_GET_CLOCK_INFO_CONTEXT * clockInfo = m_clockInfo;

	ldr         w9,[x22]

; 700  : 
; 701  :         long numDeviceClocks = clockInfo->NumClockSource;
; 702  :         if (*numSources < (long)clockInfo->NumClockSource)
; 703  :         {
; 704  :             numDeviceClocks = *numSources;
; 705  :         }
; 706  : 
; 707  :         for (long i = 0; i < numDeviceClocks; ++i)

	mov         w19,#0
	ldr         w8,[x21]
	cmp         w8,w9
	cselge      w24,w9,w8
	cmp         w24,#0
	ble         |$LN75@getClockSo|
	adrp        x28,|??_C@_02KPKOKMHB@?$CFS@|
	mov         x27,#0x30
	mov         x26,#-1
	mov         x25,#0x54
|$LL4@getClockSo|

; 708  :         {
; 709  :             clocks[i].index = i;

	umaddl      x10,w19,w27,x23

; 710  :             clocks[i].associatedChannel = -1;
; 711  :             clocks[i].associatedGroup = -1;
; 712  :             clocks[i].isCurrentSource = clockInfo->ClockSource[i].IsCurrentSource ? ASIOTrue : ASIOFalse;
; 713  :             sprintf_s(clocks[i].name, CLOCK_SOURCE_NAME_LENGTH, "%S", clockInfo->ClockSource[i].Name);

	add         x2,x28,|??_C@_02KPKOKMHB@?$CFS@|
	umaddl      x9,w19,w25,x22
	mov         x1,#0x20
	str         w19,[x10]
	add         x0,x10,#0x10
	stur        x26,[x10,#4]
	ldr         w8,[x9,#0x10]
	add         x3,x9,#0x18
	cmp         w8,#0
	csetne      w8
	str         w8,[x10,#0xC]
	bl          sprintf_s
	add         w19,w19,#1
	cmp         w19,w24
	blt         |$LL4@getClockSo|
|$LN75@getClockSo|

; 714  :         }
; 715  :         *numSources = clockInfo->NumClockSource;

	ldr         w8,[x22]
	str         w8,[x21]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN62@getClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN62@getClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 717  :     return ASE_OK;

	mov         w0,#0
	b           |$LN78@getClockSo|
|$LN8@getClockSo|

; 682  :     {
; 683  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 684  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	b           |$LN78@getClockSo|
|$LN77@getClockSo|
	ldp         x27,x28,[sp,#0x80]
	ldp         x25,x26,[sp,#0x70]
	ldp         x23,x24,[sp,#0x60]
	ldp         x21,x22,[sp,#0x50]
	ldp         x19,x20,[sp,#0x40]
|$LN68@getClockSo|

; 676  :     {
; 677  :         return ASE_InvalidParameter;

	mov         w0,#-0x3E6
	ldp         fp,lr,[sp],#0x40
	add         sp,sp,#0x50
	ret

	ENDP  ; |?getClockSources@CUSBAsio@@UEAAJPEAUASIOClockSource@@PEAJ@Z|, CUSBAsio::getClockSources

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?setClockSource@CUSBAsio@@UEAAJJ@Z| PROC		; CUSBAsio::setClockSource

; 722  : {

|$LN150|
	stp         fp,lr,[sp,#-0x40]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	str         x23,[sp,#0x30]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x40
	mov         x23,sp
	mov         xip0,#-2
	mov         x22,x0
	str         xip0,[x23]

; 723  :     info_print_("setClockSource\n");
; 724  :     BOOL result = FALSE;
; 725  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x22,#0xBA8]
	mov         w21,w1
	cmn         x8,#1
	beq         |$LN3@setClockSo|
	ldr         w8,[x22,#0xAF4]
	cbz         w8,|$LN3@setClockSo|
	ldr         w8,[x22,#0xAF8]
	cbz         w8,|$LN3@setClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 731  :         auto lockClient = m_clientInfoCS.lock();

	add         x20,x22,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[x23,#8]

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 732  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x19,x22,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x19
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x19,[x23,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 733  :         if (index < (long)m_audioProperty.ClockSources)

	ldr         w8,[x22,#0xD40]
	cmp         w21,w8
	bge         |$LN5@setClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 297  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	ldr         q16,[x8]

; 298  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 299  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::SetClockSource);

	mov         x8,#4
	movk        x8,#2,lsl #0x20
	stp         wzr,w21,[x23,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 737  :             if (SetClockSource(m_usbDeviceHandle, index))

	ldr         x0,[x22,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 301  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setClockSourceContext, sizeof(UAC_SET_CLOCK_SOURCE_CONTEXT), &bytesReturned, nullptr);

	mov         x7,#0
	str         x8,[x23,#0x30]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	add         x6,x23,#0x18
	str         q16,[x23,#0x20]
	mov         w5,#4
	add         x4,x23,#0x1C
	mov         w3,#0x18
	add         x2,x23,#0x20
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 737  :             if (SetClockSource(m_usbDeviceHandle, index))

	cbz         w0,|$LN5@setClockSo|

; 738  :             {
; 739  :                 if (m_clockInfo != nullptr)

	ldr         x0,[x22,#0xDA0]
	cbz         x0,|$LN6@setClockSo|

; 740  :                 {
; 741  :                     delete[] ((UCHAR *)m_clockInfo);

	bl          |??_V@YAXPEAX@Z|

; 742  :                     m_clockInfo = nullptr;

	str         xzr,[x22,#0xDA0]
|$LN6@setClockSo|

; 743  :                 }
; 744  :                 GetClockInfo(m_usbDeviceHandle, &m_clockInfo);

	ldr         x0,[x22,#0xBA8]
	add         x1,x22,#0xDA0
	bl          |?GetClockInfo@@YAHPEAXPEAPEAUUAC_GET_CLOCK_INFO_CONTEXT_@@@Z|

; 745  :                 result = RequestClockInfoChange();

	mov         x0,x22
	bl          |?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|
	nop

; 750  :                 return ASE_OK;

	tst         w0,#0xFF
	mov         w8,#-0x3E8
	cselne      w21,wzr,w8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN99@setClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
	nop
|$LN99@setClockSo|

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN114@setClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN114@setClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 750  :                 return ASE_OK;

	mov         w0,w21
	b           |$LN1@setClockSo|
|$LN5@setClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN129@setClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
	nop
|$LN129@setClockSo|

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN144@setClockSo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN144@setClockSo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 754  :     return ASE_InvalidMode;

	mov         w0,#-0x3E5
	b           |$LN1@setClockSo|
|$LN3@setClockSo|

; 726  :     {
; 727  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 728  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
|$LN1@setClockSo|
	add         sp,sp,#0x40
	bl          __security_pop_cookie
	ldr         x23,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x40
	ret

	ENDP  ; |?setClockSource@CUSBAsio@@UEAAJJ@Z|, CUSBAsio::setClockSource

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| PROC ; `CUSBAsio::setClockSource'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x23,#8
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?setClockSource@CUSBAsio@@UEAAJJ@Z|, CUSBAsio::setClockSource

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??setClockSource@CUSBAsio@@UEAAJJ@Z@4HA| PROC ; `CUSBAsio::setClockSource'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x23,#0x10
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?setClockSource@CUSBAsio@@UEAAJJ@Z|, CUSBAsio::setClockSource

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z| PROC ; CUSBAsio::getSamplePosition

; 760  :     // info_print_("getSamplePosition");
; 761  : 
; 762  :     *samplePosition = {};

	str         xzr,[x1]

; 763  :     *timeStamp = {};

	str         xzr,[x2]

; 764  : 
; 765  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x0,#0xBA8]
	cmn         x8,#1
	beq         |$LN13@getSampleP|
	ldr         w8,[x0,#0xAF4]
	cbz         w8,|$LN13@getSampleP|
	ldr         w8,[x0,#0xAF8]
	cbz         w8,|$LN13@getSampleP|

; 769  :     }
; 770  :     if (samplePosition == nullptr || timeStamp == nullptr)
; 771  :     {
; 772  :         return ASE_InvalidParameter;
; 773  :     }
; 774  :     timeStamp->lo = m_theSystemTime.lo;

	ldr         w8,[x0,#0xD0]

; 775  :     timeStamp->hi = m_theSystemTime.hi;
; 776  :     if (m_samplePosition >= c_TwoRaisedTo32)

	ldr         d17,|$LN16@getSampleP|
	str         w8,[x2,#4]
	ldr         w8,[x0,#0xCC]
	str         w8,[x2]
	ldr         d18,[x0,#0x20]
	fcmpe       d18,d17
	blt         |$LN6@getSampleP|

; 777  :     {
; 778  :         samplePosition->hi = (unsigned long)(m_samplePosition * c_TwoRaisedTo32Reciprocal);

	ldr         d16,|$LN17@getSampleP|
	fmul        d16,d18,d16
	fcvtzu      w8,d16

; 779  :         samplePosition->lo = (unsigned long)(m_samplePosition - (samplePosition->hi * c_TwoRaisedTo32));

	ucvtf       d16,w8
	str         w8,[x1]
	fmul        d17,d16,d17
	ldr         d16,[x0,#0x20]

; 785  :     }
; 786  :     // info_print_("getSamplePosition SamplePosition %u, TimeStamp %u\n", samplePosition->lo, timeStamp->lo);
; 787  :     return ASE_OK;

	mov         w0,#0
	fsub        d16,d16,d17
	fcvtzu      w8,d16
	str         w8,[x1,#4]
	ret
|$LN6@getSampleP|

; 780  :     }
; 781  :     else
; 782  :     {
; 783  :         samplePosition->hi = 0;

	str         wzr,[x1]

; 784  :         samplePosition->lo = (unsigned long)m_samplePosition;

	ldr         d16,[x0,#0x20]

; 785  :     }
; 786  :     // info_print_("getSamplePosition SamplePosition %u, TimeStamp %u\n", samplePosition->lo, timeStamp->lo);
; 787  :     return ASE_OK;

	mov         w0,#0
	fcvtzu      w8,d16
	str         w8,[x1,#4]
	ret
|$LN13@getSampleP|

; 766  :     {
; 767  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 768  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ret
	nop
|$LN16@getSampleP|
	DCFD         4.29497e+09
|$LN17@getSampleP|
	DCFD         2.32831e-10

	ENDP  ; |?getSamplePosition@CUSBAsio@@UEAAJPEAUASIOSamples@@PEAUASIOTimeStamp@@@Z|, CUSBAsio::getSamplePosition

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z| PROC ; CUSBAsio::getChannelInfo

; 792  : {

|$LN118|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 793  :     verbose_print_("getChannelInfo\n");
; 794  : 
; 795  :     if (info == nullptr)

	cbz         x1,|$LN64@getChannel|
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	mov         x22,x0
	mov         x21,x1
	mov         x20,x1

; 796  :     {
; 797  :         return ASE_InvalidParameter;
; 798  :     }
; 799  : 
; 800  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x22,#0xBA8]
	cmn         x8,#1
	beq         |$LN15@getChannel|
	ldr         w8,[x22,#0xAF4]
	cbz         w8,|$LN15@getChannel|
	ldr         w8,[x22,#0xAF8]
	cbz         w8,|$LN15@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 806  :         auto lockDevice = m_deviceInfoCS.lock();

	add         x19,x22,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x19
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 807  :         if (info->channel < 0 || (info->isInput ? (ULONG)info->channel >= m_inAvailableChannels : (ULONG)info->channel >= m_outAvailableChannels))

	ldr         w3,[x21]
	tbnz        w3,#0x1F,|$LN17@getChannel|
	ldr         w11,[x21,#4]
	cbz         w11,|$LN28@getChannel|
	ldr         w8,[x22,#0xD8C]
	b           |$LN114@getChannel|
|$LN28@getChannel|
	ldr         w8,[x22,#0xD90]
|$LN114@getChannel|
	cmp         w3,w8
	cseths      w8
	cbnz        w8,|$LN17@getChannel|

; 810  :         }
; 811  :         switch (m_requestedSampleFormat)

	ldr         w8,[x22,#0xD88]
	cmp         w8,#1
	beq         |$LN18@getChannel|

; 815  :             break;
; 816  :         default:
; 817  :             info->type = toInt(m_audioProperty.SampleType);

	ldr         w8,[x22,#0xCD0]
	b           |$LN2@getChannel|
|$LN18@getChannel|

; 812  :         {
; 813  :         case kASIODSDFormat:
; 814  :             info->type = ASIOSTDSDInt8MSB1;

	mov         w8,#0x21
|$LN2@getChannel|

; 818  :             break;
; 819  :         }
; 820  :         info->channelGroup = 0;

	str         w8,[x20,#0x10]

; 821  :         info->isActive = ASIOFalse;
; 822  :         ULONG i;
; 823  :         if (info->isInput)

	mov         w8,#0
	str         xzr,[x21,#8]
	cbz         w11,|$LN20@getChannel|

; 824  :         {
; 825  :             for (i = 0; i < m_activeInputs; i++)

	ldr         w9,[x22,#0xAFC]
	cbz         w9,|$LN8@getChannel|
|$LL6@getChannel|

; 826  :             {
; 827  :                 if (m_inMap[i] == info->channel)

	add         x10,x22,w8,uxtw #2
	ldr         w10,[x10,#0x8F0]
	cmp         w10,w3
	beq         |$LN106@getChannel|

; 824  :         {
; 825  :             for (i = 0; i < m_activeInputs; i++)

	add         w8,w8,#1
	cmp         w8,w9
	blo         |$LL6@getChannel|

; 828  :                 {
; 829  :                     info->isActive = ASIOTrue;
; 830  :                     break;
; 831  :                 }
; 832  :             }
; 833  :         }

	b           |$LN8@getChannel|
|$LN20@getChannel|

; 834  :         else
; 835  :         {
; 836  :             for (i = 0; i < m_activeOutputs; i++)

	ldr         w9,[x22,#0xB00]
	cbz         w9,|$LN8@getChannel|
|$LL9@getChannel|

; 837  :             {
; 838  :                 if (m_outMap[i] == info->channel)

	add         x10,x22,w8,uxtw #2
	ldr         w10,[x10,#0x9F0]
	cmp         w10,w3
	beq         |$LN106@getChannel|

; 834  :         else
; 835  :         {
; 836  :             for (i = 0; i < m_activeOutputs; i++)

	add         w8,w8,#1
	cmp         w8,w9
	blo         |$LL9@getChannel|

; 839  :                 {
; 840  :                     info->isActive = ASIOTrue;
; 841  :                     break;
; 842  :                 }
; 843  :             }
; 844  :         }
; 845  :         ULONG ch = 0;

	b           |$LN8@getChannel|
|$LN106@getChannel|
	mov         w8,#1
	str         w8,[x21,#8]
|$LN8@getChannel|

; 846  :         for (; ch < m_channelInfo->NumChannels; ++ch)

	ldr         x10,[x22,#0xD98]
	mov         w8,#0
	mov         x12,#0x50
	ldr         w9,[x10]
	cbz         w9,|$LN110@getChannel|
|$LL12@getChannel|

; 847  :         {
; 848  :             if (m_channelInfo->Channel[ch].Index == info->channel && m_channelInfo->Channel[ch].IsInput == info->isInput)

	umaddl      x14,w8,w12,x10
	ldr         w13,[x14,#4]
	cmp         w13,w3
	bne         |$LN10@getChannel|
	ldr         w13,[x14,#8]
	cmp         w13,w11
	beq         |$LN110@getChannel|
|$LN10@getChannel|

; 846  :         for (; ch < m_channelInfo->NumChannels; ++ch)

	add         w8,w8,#1
	cmp         w8,w9
	blo         |$LL12@getChannel|
|$LN110@getChannel|

; 849  :             {
; 850  :                 break;
; 851  :             }
; 852  :         }
; 853  :         if (ch == m_channelInfo->NumChannels)

	cmp         w8,w9
	mov         x1,#0x1F
	add         x0,x20,#0x14
	bne         |$LN25@getChannel|

; 854  :         {
; 855  :             sprintf_s(info->name, DRIVER_NAME_LENGTH, "channel %u", info->channel);

	adrp        x8,|??_C@_0L@CIJEIFL@channel?5?$CFu@|
	add         x2,x8,|??_C@_0L@CIJEIFL@channel?5?$CFu@|
	bl          sprintf_s

; 856  :         }

	b           |$LN26@getChannel|
|$LN25@getChannel|

; 857  :         else
; 858  :         {
; 859  :             sprintf_s(info->name, DRIVER_NAME_LENGTH, "%S", m_channelInfo->Channel[ch].Name);

	umaddl      x8,w8,w12,x10
	add         x3,x8,#0x14
	adrp        x8,|??_C@_02KPKOKMHB@?$CFS@|
	add         x2,x8,|??_C@_02KPKOKMHB@?$CFS@|
	bl          sprintf_s
|$LN26@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN79@getChannel|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
|$LN79@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 864  :     return ASE_OK;

	mov         w0,#0
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN17@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN113@getChannel|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
|$LN113@getChannel|
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
|$LN64@getChannel|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 809  :             return ASE_InvalidParameter;

	mov         w0,#-0x3E6
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret
|$LN15@getChannel|

; 801  :     {
; 802  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 803  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?getChannelInfo@CUSBAsio@@UEAAJPEAUASIOChannelInfo@@@Z|, CUSBAsio::getChannelInfo

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z| PROC ; CUSBAsio::createBuffers

; 869  : {

|$LN824|
	stp         fp,lr,[sp,#-0x60]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	str         x27,[sp,#0x50]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x100
	mov         x26,sp
	mov         xip0,#-2
	mov         x19,x0
	str         xip0,[x26,#0x28]

; 870  :     info_print_("createBuffers\n");
; 871  :     ASIOBufferInfo * info = bufferInfos;
; 872  :     long             i;
; 873  :     BOOL             result = FALSE;
; 874  : 
; 875  :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x19,#0xBA8]
	mov         x24,x1
	mov         w25,w2
	mov         w21,w3
	mov         x23,x4
	cmn         x8,#1
	beq         |$LN14@createBuff|
	ldr         w8,[x19,#0xAF4]
	cbz         w8,|$LN14@createBuff|
	ldr         w8,[x19,#0xAF8]
	cbz         w8,|$LN14@createBuff|

; 880  :     }
; 881  :     if (bufferInfos == nullptr || callbacks == nullptr)

	cbz         x24,|$LN16@createBuff|
	cbz         x23,|$LN16@createBuff|

; 884  :     }
; 885  : 
; 886  :     if (m_requestedSampleFormat == kASIOPCMFormat && (ULONG)m_sampleRate != m_audioProperty.SampleRate)

	ldr         w8,[x19,#0xD88]
	cbnz        w8,|$LN17@createBuff|
	ldr         d16,[x19,#0x28]
	ldr         w8,[x19,#0xCBC]
	fcvtzu      w9,d16
	cmp         w9,w8
	beq         |$LN17@createBuff|

; 887  :     {
; 888  :         info_print_("createBuffers : invalid format, format req %u, cur %u, fs req %lf, cur %u.\n", m_requestedSampleFormat, m_audioProperty.CurrentSampleFormat, m_sampleRate, m_audioProperty.SampleRate);
; 889  :         return ASE_InvalidMode;

	mov         w0,#-0x3E5
	b           |$LN1@createBuff|
|$LN17@createBuff|
	movi        v16.16b,#0

; 899  :     });

	add         x9,x26,#0x74

; 890  :     }
; 891  : 
; 892  :     ASIOError error = ASE_OK;

	str         wzr,[x26,#0x74]

; 899  :     });

	add         x8,x26,#0x70

; 893  :     bool      callDisposeBuffers = false;

	strb        wzr,[x26,#0x70]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 585  :         bool m_call = true;

	mov         x20,#1
	str         q16,[x26,#0x60]

; 223  :             {
; 224  :                 policy::close(m_ptr);
; 225  :             }
; 226  :         }
; 227  : 
; 228  :         WI_NODISCARD bool is_valid() const WI_NOEXCEPT
; 229  :         {
; 230  :             return policy::is_valid(m_ptr);
; 231  :         }
; 232  : 
; 233  :         void reset(pointer_storage ptr = policy::invalid_value()) WI_NOEXCEPT
; 234  :         {
; 235  :             if (policy::is_valid(m_ptr))
; 236  :             {
; 237  :                 policy::close_reset(m_ptr);
; 238  :             }
; 239  :             m_ptr = ptr;
; 240  :         }
; 241  : 
; 242  :         void reset(wistd::nullptr_t) WI_NOEXCEPT
; 243  :         {
; 244  :             static_assert(
; 245  :                 wistd::is_same<typename policy::pointer_invalid, wistd::nullptr_t>::value,
; 246  :                 "reset(nullptr): valid only for handle types using nullptr as the invalid value");
; 247  :             reset();
; 248  :         }
; 249  : 
; 250  :         WI_NODISCARD pointer get() const WI_NOEXCEPT
; 251  :         {
; 252  :             return static_cast<pointer>(m_ptr);
; 253  :         }
; 254  : 
; 255  :         pointer_storage release() WI_NOEXCEPT
; 256  :         {
; 257  :             static_assert(
; 258  :                 !wistd::is_same<typename policy::pointer_access, pointer_access_none>::value,
; 259  :                 "release(): the raw handle value is not available for this resource class");
; 260  :             auto ptr = m_ptr;
; 261  :             m_ptr = policy::invalid_value();
; 262  :             return ptr;
; 263  :         }
; 264  : 
; 265  :         pointer_storage* addressof() WI_NOEXCEPT
; 266  :         {
; 267  :             static_assert(
; 268  :                 wistd::is_same<typename policy::pointer_access, pointer_access_all>::value,
; 269  :                 "addressof(): the address of the raw handle is not available for this resource class");
; 270  :             return &m_ptr;
; 271  :         }
; 272  : 
; 273  :     protected:
; 274  :         void replace(unique_storage&& other) WI_NOEXCEPT
; 275  :         {
; 276  :             reset(other.m_ptr);
; 277  :             other.m_ptr = policy::invalid_value();
; 278  :         }
; 279  : 
; 280  :     private:
; 281  :         pointer_storage m_ptr;
; 282  :     };
; 283  : 
; 284  :     // Determines if it is safe to deallocate a resource without destructing the object
; 285  :     template <typename T>
; 286  :     struct needs_destruction
; 287  :     {
; 288  :         template <typename U>
; 289  :         static auto invoke(int) -> wistd::bool_constant<sizeof(U) >= 0>; // Always true, but SFINAE's if incomplete type
; 290  :         template <typename U>
; 291  :         static auto invoke(float) -> wistd::false_type;
; 292  : 
; 293  :         // A type needs destruction if:
; 294  :         //      1.  It is a complete type,
; 295  :         //      2.  It can be destructed, and
; 296  :         //      3.  It's not trivially destructible
; 297  :         // Note that we need the "complete type" check because some places use an undefined struct as a type-safe
; 298  :         // resource type (e.g. 'typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE')
; 299  :         static constexpr const bool value = wistd::conjunction_v<
; 300  :             decltype(invoke<wistd::remove_extent_t<T>>(0)),
; 301  :             wistd::is_destructible<wistd::remove_extent_t<T>>,
; 302  :             wistd::negation<wistd::is_trivially_destructible<wistd::remove_extent_t<T>>>>;
; 303  :     };
; 304  : 
; 305  :     template <typename T>
; 306  :     constexpr bool needs_destruction_v = needs_destruction<T>::value;
; 307  : 
; 308  :     // A pass-through type that statically asserts that the specified type does not need destruction. Useful when
; 309  :     // specifying template arguments for various unique_* types where the destructor won't run
; 310  :     template <typename T>
; 311  :     struct ensure_trivially_destructible
; 312  :     {
; 313  :         // NOTE: Temporary opt-out for existing code that uses these types incorrectly
; 314  : #ifndef WIL_DISABLE_UNIQUE_PTR_DESTRUCTOR_CHECKS
; 315  :         // If this static_assert fires, it means you've used a type that is not trivially destructible as a template
; 316  :         // argument to a wil::unique* type that will not invoke that object's destructor
; 317  :         static_assert(!needs_destruction_v<T>, "Resource type has a non-trivial destructor, but is used in a context where its destructor will not be run");
; 318  : #endif
; 319  :         using type = T;
; 320  :     };
; 321  : 
; 322  :     template <typename T>
; 323  :     using ensure_trivially_destructible_t = typename ensure_trivially_destructible<T>::type;
; 324  : } // namespace details
; 325  : /// @endcond
; 326  : 
; 327  : // This class when paired with unique_storage and an optional type-specific specialization class implements
; 328  : // the same interface as STL's unique_ptr<> for resource handle types.  It is a non-copyable, yet movable class
; 329  : // supporting attach (reset), detach (release), retrieval (get()).
; 330  : 
; 331  : template <typename storage_t>
; 332  : class unique_any_t : public storage_t
; 333  : {
; 334  : public:
; 335  :     typedef typename storage_t::policy policy;
; 336  :     typedef typename policy::pointer_storage pointer_storage;
; 337  :     typedef typename policy::pointer pointer;
; 338  : 
; 339  :     unique_any_t(unique_any_t const&) = delete;
; 340  :     unique_any_t& operator=(unique_any_t const&) = delete;
; 341  : 
; 342  :     // Note that the default constructor really shouldn't be needed (taken care of by the forwarding constructor below), but
; 343  :     // the forwarding constructor causes an internal compiler error when the class is used in a C++ array.  Defining the default
; 344  :     // constructor independent of the forwarding constructor removes the compiler limitation.
; 345  :     unique_any_t() = default;
; 346  : 
; 347  :     // forwarding constructor: forwards all 'explicit' and multi-arg constructors to the base class
; 348  :     template <typename arg1, typename... args_t>
; 349  :     explicit unique_any_t(arg1&& first, args_t&&... args)
; 350  :         __WI_NOEXCEPT_((wistd::is_nothrow_constructible_v<storage_t, arg1, args_t...>)) :
; 351  :         storage_t(wistd::forward<arg1>(first), wistd::forward<args_t>(args)...)
; 352  :     {
; 353  :         static_assert(
; 354  :             wistd::is_same<typename policy::pointer_access, details::pointer_access_none>::value ||
; 355  :                 wistd::is_same<typename policy::pointer_access, details::pointer_access_all>::value ||
; 356  :                 wistd::is_same<typename policy::pointer_access, details::pointer_access_noaddress>::value,
; 357  :             "pointer_access policy must be a known pointer_access* integral type");
; 358  :     }
; 359  : 
; 360  :     unique_any_t(wistd::nullptr_t) WI_NOEXCEPT
; 361  :     {
; 362  :         static_assert(
; 363  :             wistd::is_same<typename policy::pointer_invalid, wistd::nullptr_t>::value,
; 364  :             "nullptr constructor: valid only for handle types using nullptr as the invalid value");
; 365  :     }
; 366  : 
; 367  :     unique_any_t(unique_any_t&& other) WI_NOEXCEPT : storage_t(wistd::move(other))
; 368  :     {
; 369  :     }
; 370  : 
; 371  :     unique_any_t& operator=(unique_any_t&& other) WI_NOEXCEPT
; 372  :     {
; 373  :         if (this != wistd::addressof(other))
; 374  :         {
; 375  :             // cast to base_storage to 'skip' calling the (optional) specialization class that provides handle-specific functionality
; 376  :             storage_t::replace(wistd::move(static_cast<typename storage_t::base_storage&>(other)));
; 377  :         }
; 378  :         return (*this);
; 379  :     }
; 380  : 
; 381  :     unique_any_t& operator=(wistd::nullptr_t) WI_NOEXCEPT
; 382  :     {
; 383  :         static_assert(
; 384  :             wistd::is_same<typename policy::pointer_invalid, wistd::nullptr_t>::value,
; 385  :             "nullptr assignment: valid only for handle types using nullptr as the invalid value");
; 386  :         storage_t::reset();
; 387  :         return (*this);
; 388  :     }
; 389  : 
; 390  :     void swap(unique_any_t& other) WI_NOEXCEPT
; 391  :     {
; 392  :         unique_any_t self(wistd::move(*this));
; 393  :         operator=(wistd::move(other));
; 394  :         other = wistd::move(self);
; 395  :     }
; 396  : 
; 397  :     WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 398  :     {
; 399  :         return storage_t::is_valid();
; 400  :     }
; 401  : 
; 402  :     //!
; 403  :     //! ~~~
; 404  :     //! BOOL OpenOrCreateWaffle(PCWSTR name, HWAFFLE* handle);
; 405  :     //! wil::unique_any<HWAFFLE, decltype(&::CloseWaffle), ::CloseWaffle> waffle;
; 406  :     //! RETURN_IF_WIN32_BOOL_FALSE(OpenOrCreateWaffle(L"tasty.yum", waffle.put()));
; 407  :     //! ~~~
; 408  :     pointer_storage* put() WI_NOEXCEPT
; 409  :     {
; 410  :         static_assert(
; 411  :             wistd::is_same<typename policy::pointer_access, details::pointer_access_all>::value,
; 412  :             "operator & is not available for this handle");
; 413  :         storage_t::reset();
; 414  :         return storage_t::addressof();
; 415  :     }
; 416  : 
; 417  :     pointer_storage* operator&() WI_NOEXCEPT
; 418  :     {
; 419  :         return put();
; 420  :     }
; 421  : 
; 422  :     WI_NODISCARD pointer get() const WI_NOEXCEPT
; 423  :     {
; 424  :         static_assert(
; 425  :             !wistd::is_same<typename policy::pointer_access, details::pointer_access_none>::value,
; 426  :             "get(): the raw handle value is not available for this resource class");
; 427  :         return storage_t::get();
; 428  :     }
; 429  : 
; 430  :     // The following functions are publicly exposed by their inclusion in the unique_storage base class
; 431  : 
; 432  :     // explicit unique_any_t(pointer_storage ptr) WI_NOEXCEPT
; 433  :     // void reset(pointer_storage ptr = policy::invalid_value()) WI_NOEXCEPT
; 434  :     // void reset(wistd::nullptr_t) WI_NOEXCEPT
; 435  :     // pointer_storage release() WI_NOEXCEPT                                        // not exposed for some resource types
; 436  :     // pointer_storage *addressof() WI_NOEXCEPT                                     // not exposed for some resource types
; 437  : };
; 438  : 
; 439  : template <typename policy>
; 440  : void swap(unique_any_t<policy>& left, unique_any_t<policy>& right) WI_NOEXCEPT
; 441  : {
; 442  :     left.swap(right);
; 443  : }
; 444  : 
; 445  : template <typename policy>
; 446  : bool operator==(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 447  : {
; 448  :     return (left.get() == right.get());
; 449  : }
; 450  : 
; 451  : template <typename policy>
; 452  : bool operator==(const unique_any_t<policy>& left, wistd::nullptr_t) WI_NOEXCEPT
; 453  : {
; 454  :     static_assert(
; 455  :         wistd::is_same<typename unique_any_t<policy>::policy::pointer_invalid, wistd::nullptr_t>::value,
; 456  :         "the resource class does not use nullptr as an invalid value");
; 457  :     return !left;
; 458  : }
; 459  : 
; 460  : template <typename policy>
; 461  : bool operator==(wistd::nullptr_t, const unique_any_t<policy>& right) WI_NOEXCEPT
; 462  : {
; 463  :     static_assert(
; 464  :         wistd::is_same<typename unique_any_t<policy>::policy::pointer_invalid, wistd::nullptr_t>::value,
; 465  :         "the resource class does not use nullptr as an invalid value");
; 466  :     return !right;
; 467  : }
; 468  : 
; 469  : template <typename policy>
; 470  : bool operator!=(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 471  : {
; 472  :     return (!(left.get() == right.get()));
; 473  : }
; 474  : 
; 475  : template <typename policy>
; 476  : bool operator!=(const unique_any_t<policy>& left, wistd::nullptr_t) WI_NOEXCEPT
; 477  : {
; 478  :     static_assert(
; 479  :         wistd::is_same<typename unique_any_t<policy>::policy::pointer_invalid, wistd::nullptr_t>::value,
; 480  :         "the resource class does not use nullptr as an invalid value");
; 481  :     return !!left;
; 482  : }
; 483  : 
; 484  : template <typename policy>
; 485  : bool operator!=(wistd::nullptr_t, const unique_any_t<policy>& right) WI_NOEXCEPT
; 486  : {
; 487  :     static_assert(
; 488  :         wistd::is_same<typename unique_any_t<policy>::policy::pointer_invalid, wistd::nullptr_t>::value,
; 489  :         "the resource class does not use nullptr as an invalid value");
; 490  :     return !!right;
; 491  : }
; 492  : 
; 493  : template <typename policy>
; 494  : bool operator<(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 495  : {
; 496  :     return (left.get() < right.get());
; 497  : }
; 498  : 
; 499  : template <typename policy>
; 500  : bool operator>=(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 501  : {
; 502  :     return (!(left < right));
; 503  : }
; 504  : 
; 505  : template <typename policy>
; 506  : bool operator>(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 507  : {
; 508  :     return (right < left);
; 509  : }
; 510  : 
; 511  : template <typename policy>
; 512  : bool operator<=(const unique_any_t<policy>& left, const unique_any_t<policy>& right) WI_NOEXCEPT
; 513  : {
; 514  :     return (!(right < left));
; 515  : }
; 516  : 
; 517  : // unique_any provides a template alias for easily building a unique_any_t from a unique_storage class with the given
; 518  : // template parameters for resource_policy.
; 519  : 
; 520  : template <
; 521  :     typename pointer,                                      // The handle type
; 522  :     typename close_fn_t,                                   // The handle close function type
; 523  :     close_fn_t close_fn,                                   //      * and function pointer
; 524  :     typename pointer_access = details::pointer_access_all, // all, noaddress or none to control pointer method access
; 525  :     typename pointer_storage = pointer,          // The type used to store the handle (usually the same as the handle itself)
; 526  :     typename invalid_t = pointer,                // The invalid handle value type
; 527  :     invalid_t invalid = invalid_t{},             //      * and its value (default ZERO value)
; 528  :     typename pointer_invalid = wistd::nullptr_t> // nullptr_t if the invalid handle value is compatible with nullptr, otherwise pointer
; 529  : using unique_any =
; 530  :     unique_any_t<details::unique_storage<details::resource_policy<pointer, close_fn_t, close_fn, pointer_access, pointer_storage, invalid_t, invalid, pointer_invalid>>>;
; 531  : 
; 532  : /// @cond
; 533  : namespace details
; 534  : {
; 535  :     template <typename TLambda>
; 536  :     class lambda_call
; 537  :     {
; 538  :     public:
; 539  :         lambda_call(const lambda_call&) = delete;
; 540  :         lambda_call& operator=(const lambda_call&) = delete;
; 541  :         lambda_call& operator=(lambda_call&& other) = delete;
; 542  : 
; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	dup         v16.2d,x9
	str         x19,[x26,#0x60]

; 585  :         bool m_call = true;

	strb        w20,[x26,#0x68]
	ins         v16.d[1],x8
	str         q16,[x26,#0x50]

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 902  :         auto lockClient = m_clientInfoCS.lock();

	add         x22,x19,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x22
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 902  :         auto lockClient = m_clientInfoCS.lock();

	str         x22,[x26,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x22,[x26,#0x30]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 904  :         if (m_isActive)

	ldrb        w8,[x19,#0xB08]
	cbz         w8,|$LN18@createBuff|

; 905  :         {
; 906  :             info_print_("createBuffers : already initialized.\n");
; 907  :             error = ASE_OK;

	mov         w8,#0
	str         wzr,[x26,#0x74]
	mov         w20,#0
	b           |$LN108@createBuff|
|$LN18@createBuff|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 911  :         m_isActive = true;

	strb        w20,[x19,#0xB08]

; 914  :             auto lockDevice = m_deviceInfoCS.lock();

	add         x22,x19,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x22
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 914  :             auto lockDevice = m_deviceInfoCS.lock();

	str         x22,[x26,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x22,[x26,#0x38]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 917  :             result = StopAsioStream(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
	bl          |?StopAsioStream@@YAHPEAX@Z|

; 918  : 
; 919  :             result = UnsetAsioBuffer(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
	bl          |?UnsetAsioBuffer@@YAHPEAX@Z|

; 920  : 
; 921  :             m_activeInputs = 0;

	add         x9,x19,#0xAFC
	str         xzr,[x9]

; 922  :             m_activeOutputs = 0;
; 923  :             ULONGLONG recChannelsMap = {0};

	mov         x27,#0

; 924  :             ULONGLONG playChannelsMap = {0};

	mov         x22,#0

; 925  : 
; 926  :             for (i = 0; i < numChannels; ++i, ++info)

	mov         w10,#0
	cmp         w25,#0
	ble         |$LN802@createBuff|

; 911  :         m_isActive = true;

	add         x8,x24,#4
|$LL4@createBuff|

; 927  :             {
; 928  :                 if (info->isInput)

	ldr         w12,[x8],#0x18
	ldur        w11,[x8,#-0x1C]
	cbz         w11,|$LN19@createBuff|

; 929  :                 {
; 930  :                     if (info->channelNum < 0)

	tbnz        w12,#0x1F,|$LN796@createBuff|

; 931  :                     {
; 932  :                         info_print_("createBuffers : invalid parameter.\n");
; 933  :                         error = ASE_InvalidParameter;
; 934  :                         return error;
; 935  :                     }
; 936  :                     if ((ULONG)info->channelNum >= m_inAvailableChannels)

	ldr         w11,[x19,#0xD8C]
	cmp         w12,w11
	bhs         |$LN797@createBuff|

; 941  :                     }
; 942  :                     m_inMap[m_activeInputs] = info->channelNum;

	ldr         w11,[x9]
	add         x11,x19,w11,uxtw #2
	str         w12,[x11,#0x8F0]

; 943  :                     ++m_activeInputs;

	ldr         w11,[x9]
	add         w12,w11,#1
	str         w12,[x9]

; 944  :                     recChannelsMap |= 1ULL << info->channelNum;

	ldur        w11,[x8,#-0x18]
	lsl         x11,x20,x11
	orr         x27,x11,x27

; 945  :                     if (m_activeInputs > m_inAvailableChannels)

	ldr         w11,[x19,#0xD8C]

; 946  :                     {
; 947  :                         info_print_("createBuffers : over channel.\n");
; 948  :                         error = ASE_InvalidMode;
; 949  :                         return error;
; 950  :                     }
; 951  :                 }

	b           |$LN807@createBuff|
|$LN19@createBuff|

; 952  :                 else
; 953  :                 {
; 954  :                     if (info->channelNum < 0)

	tbnz        w12,#0x1F,|$LN799@createBuff|

; 959  :                     }
; 960  :                     if ((ULONG)info->channelNum >= m_outAvailableChannels)

	ldr         w11,[x19,#0xD90]
	cmp         w12,w11
	bhs         |$LN801@createBuff|

; 961  :                     {
; 962  :                         info_print_("createBuffers : over channel.\n");
; 963  :                         error = ASE_InvalidMode;
; 964  :                         return error;
; 965  :                     }
; 966  :                     m_outMap[m_activeOutputs] = info->channelNum;

	ldr         w11,[x19,#0xB00]
	add         x11,x19,w11,uxtw #2
	str         w12,[x11,#0x9F0]

; 967  :                     ++m_activeOutputs;

	ldr         w11,[x19,#0xB00]
	add         w12,w11,#1
	str         w12,[x19,#0xB00]

; 968  :                     playChannelsMap |= 1ULL << info->channelNum;

	ldur        w11,[x8,#-0x18]
	lsl         x11,x20,x11
	orr         x22,x11,x22

; 969  :                     if (m_activeOutputs > m_outAvailableChannels)

	ldr         w11,[x19,#0xD90]
|$LN807@createBuff|

; 925  : 
; 926  :             for (i = 0; i < numChannels; ++i, ++info)

	cmp         w12,w11
	bhi         |$LN801@createBuff|
	add         w10,w10,#1
	cmp         w10,w25
	blt         |$LL4@createBuff|
|$LN802@createBuff|

; 970  :                     {
; 971  :                         info_print_("createBuffers : over channel.\n");
; 972  :                         error = ASE_InvalidMode;
; 973  :                         return error;
; 974  :                     }
; 975  :                 }
; 976  :             }
; 977  : 
; 978  :             if (bufferSize != m_blockFrames)

	ldr         w8,[x19,#0xAF0]
	cmp         w21,w8
	beq         |$LN27@createBuff|

; 979  :             {
; 980  :                 info_print_("createBuffers : requested buffer size %u differs from preferred %u.\n", bufferSize, m_blockFrames);
; 981  :                 m_blockFrames = bufferSize;
; 982  :                 m_isRequireAsioReset = true;
; 983  :                 SetEvent(m_asioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE70]
	str         w21,[x19,#0xAF0]
	strb        w20,[x19,#0xB98]
	blr         x8
	ldr         w8,[x19,#0xAF0]
|$LN27@createBuff|

; 984  :             }
; 985  : 
; 986  :             ULONG bytesPerSample = 0;
; 987  :             switch (m_audioProperty.SampleType)

	ldr         w9,[x19,#0xCD0]
	sub         w11,w9,#0x10
	cmp         w11,#0xB
	bhi         |$LN35@createBuff|
	adr         x10,__swt
	ldrsw       x9,[x10,w11 uxtw #2]
	adr         x10,|$LN811@createBuff|
	add         x9,x10,x9,lsl #2
	br          x9
|$LN797@createBuff|

; 937  :                     {
; 938  :                         info_print_("createBuffers : over channel.\n");
; 939  :                         error = ASE_InvalidMode;
; 940  :                         return error;

	mov         w8,#-0x3E5
	str         w8,[x26,#0x74]
	mov         w20,w8
	b           |$LN123@createBuff|
|$LN796@createBuff|
	mov         w8,#-0x3E6
	str         w8,[x26,#0x74]
	mov         w20,w8
	b           |$LN123@createBuff|
|$LN801@createBuff|

; 1122 : 
; 1123 :                     return error;

	mov         w8,#-0x3E5
	str         w8,[x26,#0x74]
	mov         w20,#-0x3E5
	b           |$LN123@createBuff|
|$LN799@createBuff|

; 955  :                     {
; 956  :                         info_print_("createBuffers : invalid parameter.\n");
; 957  :                         error = ASE_InvalidParameter;

	mov         w8,#-0x3E6
	str         w8,[x26,#0x74]

; 958  :                         return error;

	mov         w20,#-0x3E6
	b           |$LN123@createBuff|
|$LN29@createBuff|

; 988  :             {
; 989  :             case UACSampleType::UACSTInt16LSB:
; 990  :                 bytesPerSample = 2;
; 991  :                 break;
; 992  :             case UACSampleType::UACSTInt24LSB:
; 993  :                 bytesPerSample = 3;

	mov         w9,#3

; 994  :                 break;

	b           |$LN5@createBuff|
|$LN30@createBuff|
|$LN811@createBuff|

; 995  :             case UACSampleType::UACSTInt32LSB16:
; 996  :             case UACSampleType::UACSTInt32LSB20:
; 997  :             case UACSampleType::UACSTInt32LSB24:
; 998  :             case UACSampleType::UACSTInt32LSB:
; 999  :             case UACSampleType::UACSTFloat32LSB:
; 1000 :                 bytesPerSample = 4;

	mov         w9,#4

; 1001 :                 break;

	b           |$LN5@createBuff|
|$LN35@createBuff|

; 1002 :             default:
; 1003 :                 bytesPerSample = 2;
; 1004 :                 break;
; 1005 :             }
; 1006 :             ULONG bufferSizeBytes = m_blockFrames;
; 1007 :             bufferSizeBytes *= bytesPerSample;

	mov         w9,#2
|$LN5@createBuff|
	mul         w11,w8,w9
	add         xip1,x19,#0xD8C

; 1008 : 
; 1009 :             ULONG playSize = sizeof(UAC_ASIO_PLAY_BUFFER_HEADER) + m_outAvailableChannels * bufferSizeBytes * 2;
; 1010 :             ULONG recSize = sizeof(UAC_ASIO_REC_BUFFER_HEADER) + m_inAvailableChannels * bufferSizeBytes * 2;

	ldp         w10,w8,[xip1]
	str         w11,[x26,#0x78]
	mul         w8,w8,w11
	add         w8,w8,#0x28
	lsl         w9,w8,#1
	mul         w8,w10,w11

; 1011 : 
; 1012 :             m_driverPlayBufferWithKsProperty = new UCHAR[sizeof(KSPROPERTY) + playSize];

	add         x0,x9,#0x18
	str         x9,[x26,#0x20]
	add         w8,w8,#0x2C
	stp         w8,w11,[x26]
	stp         w9,w8,[x26,#8]
	bl          |??_U@YAPEAX_K@Z|
	add         x8,x19,#0xE20

; 1013 :             m_driverPlayBuffer = (m_driverPlayBufferWithKsProperty != nullptr) ? &(m_driverPlayBufferWithKsProperty[sizeof(KSPROPERTY)]) : nullptr;

	add         x9,x0,#0x18
	stp         x0,x9,[x8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1015 :                 auto lockRecBuffer = m_recBufferCS.lock();

	add         x21,x19,#0xDF8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x21
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x21,[x26,#0x40]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1017 :                 m_driverRecBuffer = new UCHAR[recSize];

	ldr         w8,[x26]
	strb        w20,[x26,#0x70]
	ubfiz       x0,x8,#1,#0x1F
	bl          |??_U@YAPEAX_K@Z|
	str         x0,[x19,#0xE30]

; 1018 :                 if (m_driverPlayBuffer == nullptr || m_driverRecBuffer == nullptr)

	ldr         x0,[x19,#0xE28]
	cbz         x0,|$LN37@createBuff|

; 1022 :                     return error;
; 1023 :                 }
; 1024 : 
; 1025 :                 info_print_("play buffer at %p, %u bytes, rec buffer at %p, %u bytes, period %d samples.\n", m_driverPlayBuffer, playSize, m_driverRecBuffer, recSize, m_blockFrames);
; 1026 : 
; 1027 :                 ZeroMemory((void *)m_driverPlayBuffer, playSize);

	ldr         x2,[x26,#0x20]
	mov         w1,#0
	bl          memset

; 1028 :                 ZeroMemory((void *)m_driverRecBuffer, recSize);

	ldr         w8,[x26]
	mov         w1,#0
	ldr         x0,[x19,#0xE30]
	ubfiz       x2,x8,#1,#0x1F
	bl          memset

; 1029 : 
; 1030 :                 if (m_audioProperty.CurrentSampleFormat != UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)

	ldr         w8,[x19,#0xCD8]
	cbz         w8,|$LN38@createBuff|

; 1031 :                 {
; 1032 :                     FillMemory((void *)(m_driverPlayBuffer + sizeof(UAC_ASIO_PLAY_BUFFER_HEADER)), m_outAvailableChannels * bufferSizeBytes * 2, DSD_ZERO_BYTE);

	ldr         w8,[x19,#0xD90]
	mov         w1,#0x96
	ldr         w11,[x26,#4]
	mul         w9,w8,w11
	ldr         x8,[x19,#0xE28]
	ubfiz       x2,x9,#1,#0x1F
	add         x0,x8,#0x50
	bl          memset
|$LN38@createBuff|

; 1036 : 
; 1037 :                 m_activeInputs = 0;

	add         x8,x19,#0xAFC
	str         xzr,[x19,#0xE38]
	str         xzr,[x8]

; 1038 :                 m_activeOutputs = 0;
; 1039 :                 info = bufferInfos;
; 1040 :                 for (i = 0; i < numChannels; i++, info++)

	cmp         w25,#0
	ble         |$LN804@createBuff|

; 1033 :                 }
; 1034 : 
; 1035 :                 m_playReadyPosition = 0LL;

	ldr         w15,[x26,#0x78]
	add         x8,x24,#4
|$LN9@createBuff|

; 1041 :                 {
; 1042 :                     if (info->isInput)

	ldr         w10,[x8],#0x18
	ldur        w9,[x8,#-0x1C]
	cbz         w9,|$LN39@createBuff|

; 1043 :                     {
; 1044 :                         m_inputBuffers[m_activeInputs] = m_driverRecBuffer + sizeof(UAC_ASIO_REC_BUFFER_HEADER) + bufferSizeBytes * 2 * info->channelNum;

	mul         w9,w10,w15
	lsl         w10,w9,#1
	ldr         x9,[x19,#0xE30]
	add         x9,x9,w10,uxtw #0
	add         x10,x9,#0x58
	ldr         w9,[x19,#0xAFC]
	add         x9,x19,w9,uxtw #3
	str         x10,[x9,#0xD8]

; 1045 :                         info->buffers[0] = (void *)(m_inputBuffers[m_activeInputs]);

	ldr         w9,[x19,#0xAFC]
	add         x9,x19,w9,uxtw #3
	ldr         x9,[x9,#0xD8]
	stur        x9,[x8,#-0x14]

; 1046 :                         info->buffers[1] = (void *)(m_inputBuffers[m_activeInputs] + bufferSizeBytes);

	ldr         w9,[x19,#0xAFC]
	add         x9,x19,w9,uxtw #3
	ldr         x9,[x9,#0xD8]
	add         x9,x9,w15,uxtw #0
	stur        x9,[x8,#-0xC]

; 1047 :                         m_inMap[m_activeInputs] = info->channelNum;

	ldr         w9,[x19,#0xAFC]
	add         x10,x19,w9,uxtw #2
	ldur        w9,[x8,#-0x18]
	str         w9,[x10,#0x8F0]

; 1048 :                         ++m_activeInputs;

	ldr         w9,[x19,#0xAFC]
	add         w9,w9,#1
	str         w9,[x19,#0xAFC]

; 1049 :                     }

	b           |$LN7@createBuff|
|$LN39@createBuff|

; 1050 :                     else // output
; 1051 :                     {
; 1052 :                         m_outputBuffers[m_activeOutputs] = m_driverPlayBuffer + sizeof(UAC_ASIO_PLAY_BUFFER_HEADER) + bufferSizeBytes * 2 * info->channelNum;

	mul         w9,w10,w15
	lsl         w10,w9,#1
	ldr         x9,[x19,#0xE28]
	add         x9,x9,w10,uxtw #0
	add         x10,x9,#0x50
	ldr         w9,[x19,#0xB00]
	add         x9,x19,w9,uxtw #3
	str         x10,[x9,#0x4D8]

; 1053 :                         info->buffers[0] = (void *)(m_outputBuffers[m_activeOutputs]);

	ldr         w9,[x19,#0xB00]
	add         x9,x19,w9,uxtw #3
	ldr         x9,[x9,#0x4D8]
	stur        x9,[x8,#-0x14]

; 1054 :                         info->buffers[1] = (void *)(m_outputBuffers[m_activeOutputs] + bufferSizeBytes);

	ldr         w9,[x19,#0xB00]
	add         x9,x19,w9,uxtw #3
	ldr         x9,[x9,#0x4D8]
	add         x9,x9,w15,uxtw #0
	stur        x9,[x8,#-0xC]

; 1055 :                         m_outMap[m_activeOutputs] = info->channelNum;

	ldr         w9,[x19,#0xB00]
	add         x10,x19,w9,uxtw #2
	ldur        w9,[x8,#-0x18]
	str         w9,[x10,#0x9F0]

; 1056 :                         ++m_activeOutputs;

	ldr         w9,[x19,#0xB00]
	add         w9,w9,#1
	str         w9,[x19,#0xB00]
|$LN7@createBuff|

; 1038 :                 m_activeOutputs = 0;
; 1039 :                 info = bufferInfos;
; 1040 :                 for (i = 0; i < numChannels; i++, info++)

	sub         w25,w25,#1
	cbnz        w25,|$LN9@createBuff|
|$LN804@createBuff|

; 1057 :                     }
; 1058 :                 }
; 1059 : 
; 1060 :                 m_notificationEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8
	str         x0,[x19,#0xE40]

; 1061 :                 if (m_notificationEvent == nullptr)

	cbz         x0,|$LN37@createBuff|

; 1062 :                 {
; 1063 :                     info_print_("createBuffers : insufficient resources.\n");
; 1064 :                     error = ASE_NoMemory;
; 1065 :                     return error;
; 1066 :                 }
; 1067 : 
; 1068 :                 m_outputReadyEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8
	str         x0,[x19,#0xE48]

; 1069 :                 if (m_outputReadyEvent == nullptr)

	cbz         x0,|$LN37@createBuff|

; 1070 :                 {
; 1071 :                     info_print_("createBuffers : insufficient resources.\n");
; 1072 :                     error = ASE_NoMemory;
; 1073 :                     return error;
; 1074 :                 }
; 1075 : 
; 1076 :                 m_deviceReadyEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	adrp        x8,__imp_CreateEventA
	ldr         x8,[x8,__imp_CreateEventA]
	mov         x3,#0
	mov         w2,#0
	mov         w1,#0
	mov         x0,#0
	blr         x8
	str         x0,[x19,#0xE50]

; 1077 :                 if (m_deviceReadyEvent == nullptr)

	cbz         x0,|$LN37@createBuff|
	add         xip1,x19,#0xE28

; 1078 :                 {
; 1079 :                     info_print_("createBuffers : insufficient resources.\n");
; 1080 :                     error = ASE_NoMemory;
; 1081 :                     return error;
; 1082 :                 }
; 1083 : 
; 1084 :                 UAC_ASIO_PLAY_BUFFER_HEADER *         playHdr = (UAC_ASIO_PLAY_BUFFER_HEADER *)m_driverPlayBuffer;

	ldp         x10,x9,[xip1]

; 1085 :                 volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;
; 1086 : 
; 1087 :                 playHdr->AsioDriverVersion = UAC_ASIO_DRIVER_VERSION;
; 1088 :                 playHdr->HeaderLength = sizeof(UAC_ASIO_PLAY_BUFFER_HEADER);

	mov         x8,#0x50
	movk        x8,#1,lsl #0x30
	str         x8,[x10]

; 1089 :                 playHdr->PeriodSamples = m_blockFrames;

	ldr         w8,[x19,#0xAF0]
	str         w8,[x10,#8]

; 1090 :                 playHdr->PlayChannels = m_outAvailableChannels; // m_activeOutputs;

	ldr         w8,[x19,#0xD90]
	str         w8,[x10,#0x10]

; 1091 :                 playHdr->RecChannels = m_inAvailableChannels;   // m_activeInputs;

	ldr         w8,[x19,#0xD8C]

; 1092 :                 playHdr->PlayChannelsMap = playChannelsMap;
; 1093 :                 playHdr->RecChannelsMap = recChannelsMap;

	stp         x27,x22,[x10,#0x30]
	str         w8,[x10,#0xC]

; 1094 :                 recHdr->HeaderLength = sizeof(UAC_ASIO_REC_BUFFER_HEADER);

	mov         w8,#0x58
	str         w8,[x9]

; 1096 :                 playHdr->NotificationEvent.p64 = m_notificationEvent;

	ldr         x8,[x19,#0xE40]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 429  :     ULONG       bytesReturned = 0;

	str         wzr,[x26,#0x78]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1096 :                 playHdr->NotificationEvent.p64 = m_notificationEvent;

	str         x8,[x10,#0x18]

; 1097 :                 playHdr->OutputReadyEvent.p64 = m_outputReadyEvent;

	ldr         x8,[x19,#0xE48]
	str         x8,[x10,#0x20]

; 1098 :                 playHdr->DeviceReadyEvent.p64 = m_deviceReadyEvent;

	ldr         x8,[x19,#0xE50]

; 1099 : #else // _WIN64
; 1100 :                 playHdr->NotificationEvent = m_notificationEvent;
; 1101 :                 playHdr->OutputReadyEvent = m_outputReadyEvent;
; 1102 :                 playHdr->DeviceReadyEvent = m_deviceReadyEvent;
; 1103 : #endif
; 1104 :                 playHdr->Training = 0;

	str         wzr,[x10,#0x14]
	str         x8,[x10,#0x28]

; 1105 :                 result = SetAsioBuffer(m_usbDeviceHandle, m_driverPlayBufferWithKsProperty, sizeof(KSPROPERTY) + playSize, (UCHAR *)m_driverRecBuffer, recSize);

	ldr         w8,[x26,#8]
	ldr         x4,[x19,#0xE30]
	ldr         x2,[x19,#0xE20]
	ldr         x0,[x19,#0xBA8]
	add         w3,w8,#0x18
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 431  :     if (driverPlayBufferWithKsPropertySize > sizeof(KSPROPERTY))

	cmp         w3,#0x18
	bls         |$LN788@createBuff|

; 432  :     {
; 433  :         privateProperty->Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	ldr         q16,[x8]

; 434  :         privateProperty->Flags = KSPROPERTY_TYPE_SET;
; 435  :         privateProperty->Id = toInt(KsPropertyUACLowLatencyAudio::SetAsioBuffer);

	mov         x8,#0xB
	movk        x8,#2,lsl #0x20

; 436  : 
; 437  :         result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, privateProperty, driverPlayBufferWithKsPropertySize, driverRecBuffer, driverRecBufferSize, &bytesReturned, nullptr);

	mov         x7,#0
	str         x8,[x2,#0x10]
	ldr         w8,[x26,#0xC]
	add         x6,x26,#0x78
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	str         q16,[x2]
	lsl         w5,w8,#1
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1107 :                 if (!result)

	cbz         w0,|$LN788@createBuff|

; 1124 :                 }
; 1125 : 
; 1126 :                 this->m_callbacks = callbacks;

	str         x23,[x19,#0x30]

; 1127 :                 if (callbacks->asioMessage(kAsioSupportsTimeInfo, 0, 0, 0))

	ldr         x8,[x23,#0x10]
	mov         x3,#0
	mov         x2,#0
	mov         w1,#0
	mov         w0,#7
	blr         x8
	cbz         w0,|$LN47@createBuff|

; 1128 :                 {
; 1129 :                     info_print_("time info mode.\n");
; 1130 :                     m_isTimeInfoMode = true;
; 1131 :                     m_asioTime.timeInfo.speed = 1.;

	fmov        d16,#1

; 1132 :                     m_asioTime.timeInfo.systemTime.hi = m_asioTime.timeInfo.systemTime.lo = 0;
; 1133 :                     m_asioTime.timeInfo.samplePosition.hi = m_asioTime.timeInfo.samplePosition.lo = 0;
; 1134 :                     m_asioTime.timeInfo.sampleRate = m_sampleRate;
; 1135 :                     m_asioTime.timeInfo.flags = kSystemTimeValid | kSamplePositionValid | kSampleRateValid;

	mov         w8,#7
	strb        w20,[x19,#0xB0A]
	stp         xzr,xzr,[x19,#0x50]
	str         d16,[x19,#0x48]
	ldr         d16,[x19,#0x28]
	str         w8,[x19,#0x68]

; 1136 :                     m_asioTime.timeCode.flags = 0;

	str         wzr,[x19,#0x88]
	str         d16,[x19,#0x60]

; 1137 :                 }

	b           |$LN12@createBuff|
|$LN47@createBuff|

; 1138 :                 else
; 1139 :                 {
; 1140 :                     info_print_("NOT time info mode.\n");
; 1141 :                     m_isTimeInfoMode = false;

	strb        wzr,[x19,#0xB0A]
|$LN12@createBuff|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN194@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
	nop
|$LN194@createBuff|

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x26,#0x10]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN224@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
	nop
|$LN224@createBuff|

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x26,#0x18]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN209@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
|$LN209@createBuff|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1151 :     error = ASE_OK;

	mov         w8,#0
	str         wzr,[x26,#0x74]

; 1152 :     return error;

	mov         w20,#0
	b           |$LN67@createBuff|
|$LN788@createBuff|

; 1108 :                 {
; 1109 :                     DWORD lastError = GetLastError();

	adrp        x8,__imp_GetLastError
	ldr         x8,[x8,__imp_GetLastError]
	blr         x8

; 1110 :                     if (lastError == ERROR_REVISION_MISMATCH)

	cmp         w0,#0x51A
	bne         |$LN45@createBuff|

; 1111 :                     {
; 1112 :                         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};
; 1113 :                         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_VERSION_MISMATCH, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	stp         q16,q16,[x26,#0x80]
	stp         q16,q16,[x26,#0xA0]
	stp         q16,q16,[x26,#0xC0]
	stp         q16,q16,[x26,#0xE0]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x80
	mov         w1,#0x68
	blr         x8

; 1114 :                         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x80
	mov         x1,#0x80
	add         x0,x19,#0xB0C
	bl          strcpy_s
|$LN45@createBuff|

; 1115 :                         info_print_("createBuffers : driver version mismatch.\n");
; 1116 :                     }
; 1117 :                     else
; 1118 :                     {
; 1119 :                         info_print_("createBuffers : physical driver reports error.\n");
; 1120 :                     }
; 1121 :                     error = ASE_NotPresent;

	mov         w8,#-0x3E8

; 1122 : 
; 1123 :                     return error;

	mov         w20,#-0x3E8
	b           |$LN805@createBuff|
|$LN37@createBuff|

; 1019 :                 {
; 1020 :                     info_print_("createBuffers : insufficient resources.\n");
; 1021 :                     error = ASE_NoMemory;

	mov         w8,#-0x3E2
	mov         w20,#-0x3E2
|$LN805@createBuff|

; 1122 : 
; 1123 :                     return error;

	str         w8,[x26,#0x74]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN123@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
	ldr         w8,[x26,#0x74]
|$LN123@createBuff|

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x26,#0x10]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN108@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
	ldr         w8,[x26,#0x74]
|$LN108@createBuff|

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x26,#0x18]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN67@createBuff|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
	ldr         w8,[x26,#0x74]
|$LN67@createBuff|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	cbz         w8,|$LN78@createBuff|
	ldrb        w8,[x26,#0x70]
	cbz         w8,|$LN78@createBuff|

; 896  :         {
; 897  :             disposeBuffers();

	ldr         x8,[x19]
	mov         x0,x19
	ldr         x8,[x8,#0xA0]
	blr         x8
	nop
|$LN78@createBuff|

; 1152 :     return error;

	mov         w0,w20
	b           |$LN1@createBuff|
|$LN16@createBuff|

; 882  :     {
; 883  :         return ASE_InvalidParameter;

	mov         w0,#-0x3E6
	b           |$LN1@createBuff|
|$LN14@createBuff|

; 876  :     {
; 877  :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 878  :         info_print_("createBuffers : device not ready.\n");
; 879  :         return ASE_NotPresent;

	mov         w0,#-0x3E8
|$LN1@createBuff|
	add         sp,sp,#0x100
	bl          __security_pop_cookie
	ldr         x27,[sp,#0x50]
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ret
|__swt|
|$LN812@createBuff|

; 984  :             }
; 985  : 
; 986  :             ULONG bytesPerSample = 0;
; 987  :             switch (m_audioProperty.SampleType)

	DCD         0x2
|$LN813@createBuff|
	DCD         0xfffffffe
|$LN814@createBuff|
	DCD         0x0
|$LN815@createBuff|
	DCD         0x0
|$LN816@createBuff|
	DCD         0x2
|$LN817@createBuff|
	DCD         0x2
|$LN818@createBuff|
	DCD         0x2
|$LN819@createBuff|
	DCD         0x2
|$LN820@createBuff|
	DCD         0x0
|$LN821@createBuff|
	DCD         0x2
|$LN822@createBuff|
	DCD         0x0
|$LN823@createBuff|
	DCD         0x0

	ENDP  ; |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, CUSBAsio::createBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| PROC ; `CUSBAsio::createBuffers'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x26,#0x50
	bl          |??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, CUSBAsio::createBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| PROC ; `CUSBAsio::createBuffers'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x26,#0x30
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, CUSBAsio::createBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$2@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| PROC ; `CUSBAsio::createBuffers'::`1'::dtor$2
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x26,#0x38
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, CUSBAsio::createBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$3@?0??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@4HA| PROC ; `CUSBAsio::createBuffers'::`1'::dtor$3
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x26,#0x40
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z|, CUSBAsio::createBuffers

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|??R<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEBA@XZ| PROC ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::operator()

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	ldr         x8,[x0]
	ldr         w8,[x8]
	cbz         w8,|$LN8@operator|
	ldr         x8,[x0,#8]
	ldrb        w8,[x8]
	cbz         w8,|$LN8@operator|

; 896  :         {
; 897  :             disposeBuffers();

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#0xA0]
	br          x8
|$LN8@operator|
	ret

	ENDP  ; |??R<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEBA@XZ|, `CUSBAsio::createBuffers'::`2'::<lambda_1>::operator()

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|??0<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEAA@AEAJAEA_NPEAV2@@Z| PROC ; `CUSBAsio::createBuffers'::`2'::<lambda_1>::<lambda_1>

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)
; 896  :         {
; 897  :             disposeBuffers();
; 898  :         }
; 899  :     });

	stp         x1,x2,[x0]
	str         x3,[x0,#0x10]
	ret

	ENDP  ; |??0<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@QEAA@AEAJAEA_NPEAV2@@Z|, `CUSBAsio::createBuffers'::`2'::<lambda_1>::<lambda_1>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??$scope_exit@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wil@@YA?A_P$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z| PROC ; wil::scope_exit<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	ldr         q16,[x1]
	ldr         x8,[x1,#0x10]
	str         q16,[x0]
	str         x8,[x0,#0x10]

; 544  :         {
; 545  :             static_assert(wistd::is_same<decltype(lambda()), void>::value, "scope_exit lambdas must not have a return value");
; 546  :             static_assert(
; 547  :                 !wistd::is_lvalue_reference<TLambda>::value && !wistd::is_rvalue_reference<TLambda>::value,
; 548  :                 "scope_exit should only be directly used with a lambda");
; 549  :         }
; 550  : 
; 551  :         lambda_call(lambda_call&& other) WI_NOEXCEPT : m_lambda(wistd::move(other.m_lambda)), m_call(other.m_call)
; 552  :         {
; 553  :             other.m_call = false;
; 554  :         }
; 555  : 
; 556  :         ~lambda_call() WI_NOEXCEPT
; 557  :         {
; 558  :             reset();
; 559  :         }
; 560  : 
; 561  :         // Ensures the scope_exit lambda will not be called
; 562  :         void release() WI_NOEXCEPT
; 563  :         {
; 564  :             m_call = false;
; 565  :         }
; 566  : 
; 567  :         // Executes the scope_exit lambda immediately if not yet run; ensures it will not run again
; 568  :         void reset() WI_NOEXCEPT
; 569  :         {
; 570  :             if (m_call)
; 571  :             {
; 572  :                 m_call = false;
; 573  :                 m_lambda();
; 574  :             }
; 575  :         }
; 576  : 
; 577  :         // Returns true if the scope_exit lambda is still going to be executed
; 578  :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 579  :         {
; 580  :             return m_call;
; 581  :         }
; 582  : 
; 583  :     protected:
; 584  :         TLambda m_lambda;
; 585  :         bool m_call = true;

	mov         w8,#1
	strb        w8,[x0,#0x18]
	ret

	ENDP  ; |??$scope_exit@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wil@@YA?A_P$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z|, wil::scope_exit<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; Function compile flags: /Ogtp

	AREA	|.text$mn|, CODE, ARM64

|?__autoclassinit2@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAX_K@Z| PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::__autoclassinit2
	movi        v16.16b,#0
	stp         q16,q16,[x0]
	ret

	ENDP  ; |?__autoclassinit2@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAX_K@Z|, wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::__autoclassinit2

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?disposeBuffers@CUSBAsio@@UEAAJXZ| PROC		; CUSBAsio::disposeBuffers

; 1156 : {

|$LN141|
	stp         x19,x20,[sp,#-0x20]!
	stp         x21,x22,[sp,#0x10]
	stp         fp,lr,[sp,#-0x30]!
	mov         fp,sp
	mov         xip0,#-2
	mov         x21,x0
	str         xip0,[fp,#0x10]

; 1157 :     info_print_("disposeBuffers\n");
; 1158 :     BOOL result;
; 1159 : 
; 1160 :     if (m_usbDeviceHandle == INVALID_HANDLE_VALUE || m_inputLatency == 0 || m_outputLatency == 0)

	ldr         x8,[x21,#0xBA8]
	cmn         x8,#1
	beq         |$LN3@disposeBuf|
	ldr         w8,[x21,#0xAF4]
	cbz         w8,|$LN3@disposeBuf|
	ldr         w8,[x21,#0xAF8]
	cbz         w8,|$LN3@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1168 :         auto lockClient = m_clientInfoCS.lock();

	add         x20,x21,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[fp,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1170 :         if (!m_isActive)

	ldrb        w8,[x21,#0xB08]
	cbnz        w8,|$LN4@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN48@disposeBuf|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN48@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1172 :             return ASE_InvalidMode;

	mov         w0,#-0x3E5
	ldp         fp,lr,[sp],#0x30
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN4@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1174 :         m_isActive = false;

	strb        wzr,[x21,#0xB08]

; 1175 : 
; 1176 :         {
; 1177 :             auto lockDevice = m_deviceInfoCS.lock();

	add         x19,x21,#0xDA8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x19
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x19,[fp,#0x20]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1180 :             stop();

	ldr         x8,[x21]
	mov         x0,x21
	str         xzr,[x21,#0x30]
	ldr         x8,[x8,#0x40]
	blr         x8

; 1181 :             result = UnsetAsioBuffer(m_usbDeviceHandle);

	ldr         x0,[x21,#0xBA8]
	bl          |?UnsetAsioBuffer@@YAHPEAX@Z|

; 1182 :             m_activeInputs = 0;

	add         x8,x21,#0xAFC

; 1183 :             m_activeOutputs = 0;
; 1184 :             if (m_driverPlayBufferWithKsProperty != nullptr)

	ldr         x0,[x21,#0xE20]
	str         xzr,[x8]
	cbz         x0,|$LN5@disposeBuf|

; 1185 :             {
; 1186 :                 delete[] m_driverPlayBufferWithKsProperty;

	bl          |??_V@YAXPEAX@Z|
	add         x8,x21,#0xE20

; 1187 :                 m_driverPlayBufferWithKsProperty = nullptr;

	stp         xzr,xzr,[x8]
|$LN5@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1191 :                 auto lockRecBuffer = m_recBufferCS.lock();

	add         x22,x21,#0xDF8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x22
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1192 :                 if (m_driverRecBuffer != nullptr)

	ldr         x0,[x21,#0xE30]
	cbz         x0,|$LN6@disposeBuf|

; 1193 :                 {
; 1194 :                     delete[] m_driverRecBuffer;

	bl          |??_V@YAXPEAX@Z|

; 1195 :                     m_driverRecBuffer = nullptr;

	str         xzr,[x21,#0xE30]
|$LN6@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x22,|$LN105@disposeBuf|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x22
	blr         x8
|$LN105@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1198 :             if (m_deviceReadyEvent != nullptr)

	ldr         x0,[x21,#0xE50]
	cbz         x0,|$LN7@disposeBuf|

; 1199 :             {
; 1200 :                 result = CloseHandle(m_deviceReadyEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8

; 1201 :                 m_deviceReadyEvent = nullptr;

	str         xzr,[x21,#0xE50]
|$LN7@disposeBuf|

; 1202 :             }
; 1203 :             if (m_outputReadyEvent != nullptr)

	ldr         x0,[x21,#0xE48]
	cbz         x0,|$LN8@disposeBuf|

; 1204 :             {
; 1205 :                 result = CloseHandle(m_outputReadyEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8

; 1206 :                 m_outputReadyEvent = nullptr;

	str         xzr,[x21,#0xE48]
|$LN8@disposeBuf|

; 1207 :             }
; 1208 :             if (m_notificationEvent != nullptr)

	ldr         x0,[x21,#0xE40]
	cbz         x0,|$LN9@disposeBuf|

; 1209 :             {
; 1210 :                 result = CloseHandle(m_notificationEvent);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	blr         x8

; 1211 :                 m_notificationEvent = nullptr;

	str         xzr,[x21,#0xE40]
|$LN9@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x19,|$LN120@disposeBuf|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x19
	blr         x8
	nop
|$LN120@disposeBuf|

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN135@disposeBuf|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN135@disposeBuf|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1215 :     return ASE_OK;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x30
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN3@disposeBuf|

; 1161 :     {
; 1162 :         // No error is returned even if the hardware is unusable. -> Error handling policy changed: ASE_NotPresent is returned.
; 1163 :         info_print_("disposeBuffers : device not ready.\n");
; 1164 :         return ASE_NotPresent;

	mov         w0,#-0x3E8
	ldp         fp,lr,[sp],#0x30
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret

	ENDP  ; |?disposeBuffers@CUSBAsio@@UEAAJXZ|, CUSBAsio::disposeBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| PROC	; `CUSBAsio::disposeBuffers'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,fp,#0x18
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?disposeBuffers@CUSBAsio@@UEAAJXZ|, CUSBAsio::disposeBuffers

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??disposeBuffers@CUSBAsio@@UEAAJXZ@4HA| PROC	; `CUSBAsio::disposeBuffers'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	add         x0,fp,#0x20
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?disposeBuffers@CUSBAsio@@UEAAJXZ|, CUSBAsio::disposeBuffers

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?controlPanel@CUSBAsio@@UEAAJXZ| PROC			; CUSBAsio::controlPanel

; 1219 : {

|$LN9|
	stp         fp,lr,[sp,#-0x20]!
	str         x19,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x2B0

; 1641 :     TCHAR path[MAX_PATH] = {0};

	movi        v16.16b,#0

; 1642 :     TCHAR drive[_MAX_DRIVE] = {0};
; 1643 :     TCHAR dir[_MAX_DIR] = {0};
; 1644 : 
; 1645 :     GetModuleFileNameEx(GetCurrentProcess(), GetModuleHandle(ASIODRV_NAME), path, MAX_PATH);

	adrp        x8,|??_C@_0M@BFGLKKGE@USBAsio?4dll@|
	add         x0,x8,|??_C@_0M@BFGLKKGE@USBAsio?4dll@|
	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	strh        wzr,[sp,#0x30]
	strb        wzr,[sp,#0x32]
	stp         q16,q16,[sp,#0xA0]
	stp         q16,q16,[sp,#0xC0]
	stp         q16,q16,[sp,#0xE0]
	stp         q16,q16,[sp,#0x100]
	stp         q16,q16,[sp,#0x120]
	stp         q16,q16,[sp,#0x140]
	stp         q16,q16,[sp,#0x160]
	stp         q16,q16,[sp,#0x180]
	str         s16,[sp,#0x1A0]
	movi        v16.16b,#0
	stp         q16,q16,[sp,#0x1B0]
	stp         q16,q16,[sp,#0x1D0]
	stp         q16,q16,[sp,#0x1F0]
	stp         q16,q16,[sp,#0x210]
	stp         q16,q16,[sp,#0x230]
	stp         q16,q16,[sp,#0x250]
	stp         q16,q16,[sp,#0x270]
	stp         q16,q16,[sp,#0x290]
	blr         x8
	adrp        x8,__imp_GetCurrentProcess
	ldr         x8,[x8,__imp_GetCurrentProcess]
	mov         x19,x0
	blr         x8
	adrp        x8,__imp_K32GetModuleFileNameExA
	ldr         x8,[x8,__imp_K32GetModuleFileNameExA]
	mov         w3,#0x104
	add         x2,sp,#0xA0
	mov         x1,x19
	blr         x8

; 1646 :     _tsplitpath_s(path, drive, _MAX_DRIVE, dir, _MAX_DIR, nullptr, 0, nullptr, 0);

	mov         x7,#0
	str         xzr,[sp]
	mov         x6,#0
	mov         x5,#0
	mov         x4,#0x100
	add         x3,sp,#0x1B0
	mov         x2,#3
	add         x1,sp,#0x30
	add         x0,sp,#0xA0
	bl          _splitpath_s

; 1647 :     _stprintf_s(path, MAX_PATH, TEXT("%s%s%s"), drive, dir, CONTROLPANELPROGRAMNAME);

	adrp        x8,|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@|
	add         x5,x8,|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@|
	adrp        x8,|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@|
	add         x2,x8,|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@|
	add         x4,sp,#0x1B0
	add         x3,sp,#0x30
	mov         x1,#0x104
	add         x0,sp,#0xA0
	bl          sprintf_s

; 1648 : 
; 1649 :     STARTUPINFO startupInfo;
; 1650 :     ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
; 1651 :     startupInfo.cb = sizeof(STARTUPINFO);
; 1652 : 
; 1653 :     PROCESS_INFORMATION processInfo{};
; 1654 : 
; 1655 :     CreateProcess(

	mov         x7,#0
	movi        v16.16b,#0
	mov         x6,#0
	mov         w5,#0x20
	mov         w4,#0
	mov         x3,#0
	mov         x2,#0
	mov         x1,#0
	add         x0,sp,#0xA0
	add         x8,sp,#0x3C
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	str         s16,[x8,#0x60]
	mov         w8,#0x68
	movi        v16.16b,#0
	str         w8,[sp,#0x38]
	add         x8,sp,#0x10
	str         x8,[sp,#8]
	add         x8,sp,#0x38
	str         x8,[sp]
	adrp        x8,__imp_CreateProcessA
	ldr         x8,[x8,__imp_CreateProcessA]
	str         q16,[sp,#0x10]
	str         d16,[sp,#0x20]
	blr         x8

; 1656 :         path,
; 1657 :         nullptr,
; 1658 :         nullptr,
; 1659 :         nullptr,
; 1660 :         FALSE,
; 1661 :         NORMAL_PRIORITY_CLASS,
; 1662 :         nullptr,
; 1663 :         nullptr,
; 1664 :         &startupInfo,
; 1665 :         &processInfo
; 1666 :     );
; 1667 : 
; 1668 :     CloseHandle(processInfo.hThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[sp,#0x18]
	blr         x8

; 1669 :     CloseHandle(processInfo.hProcess);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[sp,#0x10]
	blr         x8

; 1220 :     info_print_("controlPanel\n");
; 1221 : 
; 1222 :     BOOL result = ExecuteControlPanel();
; 1223 :     if (!result)
; 1224 :     {
; 1225 :         // If the Cancel button is pressed.
; 1226 :         return ASE_OK;
; 1227 :     }
; 1228 : 
; 1229 :     return ASE_OK;

	mov         w0,#0
	add         sp,sp,#0x2B0
	bl          __security_pop_cookie
	ldr         x19,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?controlPanel@CUSBAsio@@UEAAJXZ|, CUSBAsio::controlPanel

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?future@CUSBAsio@@UEAAJJPEAX@Z| PROC			; CUSBAsio::future

; 1234 : {

|$LN137|
	stp         x19,x20,[sp,#-0x20]!
	str         x21,[sp,#0x10]
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 1235 :     switch (selector)

	mov         w8,#0x1961
	movk        w8,#0x2311,lsl #0x10
	cmp         w1,w8
	mov         x20,x2
	mov         x19,x0
	bgt         |$LN39@future|
	beq         |$LN21@future|
	sub         w10,w1,#1
	cmp         w10,#0x10
	bhi         |$LN2@future|
	adr         x9,__swt
	ldrsb       x8,[x9,w10 uxtw #0]
	add         x8,x9,x8,lsl #2
	br          x8
|$LN21@future|

; 1236 :     {
; 1237 :     case kAsioEnableTimeCodeRead:
; 1238 :         return ASE_NotPresent;
; 1239 :     case kAsioDisableTimeCodeRead:
; 1240 :         return ASE_NotPresent;
; 1241 :     case kAsioSetInputMonitor:
; 1242 :         return ASE_NotPresent;
; 1243 :     case kAsioTransport:
; 1244 :         return ASE_NotPresent;
; 1245 :     case kAsioSetInputGain:
; 1246 :         return ASE_NotPresent;
; 1247 :     case kAsioGetInputMeter:
; 1248 :         return ASE_NotPresent;
; 1249 :     case kAsioSetOutputGain:
; 1250 :         return ASE_NotPresent;
; 1251 :     case kAsioGetOutputMeter:
; 1252 :         return ASE_NotPresent;
; 1253 :     case kAsioCanInputMonitor:
; 1254 :         return ASE_NotPresent;
; 1255 :     case kAsioCanTimeInfo:
; 1256 :         return ASE_SUCCESS;
; 1257 :     case kAsioCanTimeCode:
; 1258 :         return ASE_NotPresent;
; 1259 :     case kAsioCanTransport:
; 1260 :         return ASE_NotPresent;
; 1261 :     case kAsioCanInputGain:
; 1262 :         return ASE_NotPresent;
; 1263 :     case kAsioCanInputMeter:
; 1264 :         return ASE_NotPresent;
; 1265 :     case kAsioCanOutputGain:
; 1266 :         return ASE_NotPresent;
; 1267 :     case kAsioCanOutputMeter:
; 1268 :         return ASE_NotPresent;
; 1269 :     case kAsioOptionalOne:
; 1270 :         return ASE_NotPresent;
; 1271 :     case kAsioSetIoFormat: {
; 1272 :         if (option == nullptr)

	cbz         x20,|$LN27@future|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1278 :         auto lockClient = m_clientInfoCS.lock();

	add         x21,x19,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x21
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1280 :         if ((requestedFormat->FormatType == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	ldr         w8,[x20]
	cbnz        w8,|$LN23@future|
	ldr         w9,[x19,#0xCD4]
	mov         w8,#0x21
	tst         w9,w8
	beq         |$LN23@future|

; 1281 :         {
; 1282 :             m_requestedSampleFormat = requestedFormat->FormatType;

	str         wzr,[x19,#0xD88]
	mov         w19,#0x47A0
	movk        w19,#0x3F48,lsl #0x10
	b           |$LN41@future|
|$LN23@future|

; 1287 :             return ASE_NotPresent;

	mov         w19,#-0x3E8
|$LN41@future|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN91@future|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
|$LN91@future|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1287 :             return ASE_NotPresent;

	mov         w0,w19
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN39@future|

; 1235 :     switch (selector)

	mov         w8,#0x2012
	movk        w8,#0x2404,lsl #0x10
	cmp         w1,w8
	bgt         |$LN40@future|
	beq         |$LN32@future|
	mov         w8,#0x1983
	movk        w8,#0x2311,lsl #0x10
	cmp         w1,w8
	beq         |$LN106@future|
	mov         w8,#0x2004
	movk        w8,#0x2311,lsl #0x10
	cmp         w1,w8
	bne         |$LN2@future|

; 1300 :             return ASE_SUCCESS;
; 1301 :         }
; 1302 :         else
; 1303 :         {
; 1304 :             return ASE_NotPresent;
; 1305 :         }
; 1306 :     }
; 1307 :     case kAsioCanDoIoFormat: {
; 1308 :         if (option == nullptr)

	cbz         x20,|$LN27@future|

; 1309 :         {
; 1310 :             return ASE_NotPresent;
; 1311 :         }
; 1312 :         ASIOIoFormat * requestedFormat = (ASIOIoFormat *)option;
; 1313 :         info_print_("kAsioCanDoIoFormat. Device supported %u, current 0x%x, requested %u.\n", m_audioProperty.SupportedSampleFormats, m_audioProperty.CurrentSampleFormat, requestedFormat->FormatType);
; 1314 :         if ((requestedFormat->FormatType == kASIOPCMFormat) && ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0))

	ldr         w8,[x20]
	cbnz        w8,|$LN27@future|
	ldr         w9,[x19,#0xCD4]
	mov         w8,#0x21
	tst         w9,w8
	beq         |$LN27@future|

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#0x47A0
	movk        w0,#0x3F48,lsl #0x10
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN106@future|

; 1288 :         }
; 1289 :     }
; 1290 :     case kAsioGetIoFormat: {
; 1291 :         if (option == nullptr)

	cbz         x20,|$LN27@future|

; 1292 :         {
; 1293 :             return ASE_NotPresent;
; 1294 :         }
; 1295 :         ASIOIoFormat * requestedFormat = (ASIOIoFormat *)option;
; 1296 :         info_print_("kAsioGetIoFormat request. Device supported 0x%x, current %u.\n", m_audioProperty.SupportedSampleFormats, m_audioProperty.CurrentSampleFormat);
; 1297 :         if ((m_audioProperty.SupportedSampleFormats & GetSupportedSampleFormats()) != 0)

	ldr         w9,[x19,#0xCD4]
	mov         w8,#0x21
	tst         w9,w8
	beq         |$LN27@future|

; 1298 :         {
; 1299 :             requestedFormat->FormatType = m_requestedSampleFormat;

	ldr         w8,[x19,#0xD88]

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#0x47A0
	movk        w0,#0x3F48,lsl #0x10
	str         w8,[x20]
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN32@future|

; 1315 :         {
; 1316 :             return ASE_SUCCESS;
; 1317 :         }
; 1318 :         else
; 1319 :         {
; 1320 :             return ASE_NotPresent;
; 1321 :         }
; 1322 :     }
; 1323 :     case kAsioCanReportOverload: {
; 1324 :         if (m_isDropoutDetectionSetting)

	ldrb        w8,[x19,#0xB99]
	cbz         w8,|$LN34@future|

; 1325 :         {
; 1326 :             m_isSupportDropoutDetection = true;

	mov         w8,#1
	strb        w8,[x0,#0xB9A]

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#0x47A0
	movk        w0,#0x3F48,lsl #0x10
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN34@future|

; 1327 :             info_print_("kAsioCanReportOverload request.\n");
; 1328 :             return ASE_SUCCESS;
; 1329 :         }
; 1330 :         else
; 1331 :         {
; 1332 :             m_isSupportDropoutDetection = false;

	strb        wzr,[x0,#0xB9A]
|$LN27@future|

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#-0x3E8
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN40@future|

; 1235 :     switch (selector)

	mov         w8,#0x2012
	movk        w8,#0x2504,lsl #0x10
	cmp         w1,w8
	bne         |$LN2@future|

; 1333 :             return ASE_NotPresent;
; 1334 :         }
; 1335 :     }
; 1336 :     case kAsioGetInternalBufferSamples: {
; 1337 :         if (option == nullptr)

	cbnz        x20,|$LN37@future|
|$LN2@future|

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#-0x3E6
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|$LN37@future|

; 1338 :         {
; 1339 :             return ASE_InvalidParameter;
; 1340 :         }
; 1341 :         ASIOInternalBufferInfo * internalBufferInfo = (ASIOInternalBufferInfo *)option;
; 1342 :         internalBufferInfo->inputSamples = m_audioProperty.InputDriverBuffer;

	ldr         w8,[x19,#0xD08]
	str         w8,[x20]

; 1343 :         internalBufferInfo->outputSamples = m_audioProperty.OutputDriverBuffer;

	ldr         w8,[x19,#0xD38]
	str         w8,[x20,#4]
|$LN111@future|

; 1344 :         info_print_("kAsioGetInternalBufferSamples request. in %u samples, out %u samples.\n", internalBufferInfo->inputSamples, internalBufferInfo->outputSamples);
; 1345 :         return ASE_SUCCESS;
; 1346 :     }
; 1347 :     }
; 1348 :     return ASE_InvalidParameter;
; 1349 : }

	mov         w0,#0x47A0
	movk        w0,#0x3F48,lsl #0x10
	ldp         fp,lr,[sp],#0x10
	ldr         x21,[sp,#0x10]
	ldp         x19,x20,[sp],#0x20
	ret
|__swt|
|$LN117@future|

; 1235 :     switch (selector)

	DCB         0xe7
|$LN118@future|
	DCB         0xe7
|$LN119@future|
	DCB         0xe7
|$LN120@future|
	DCB         0xe7
|$LN121@future|
	DCB         0xe7
|$LN122@future|
	DCB         0xe7
|$LN123@future|
	DCB         0xe7
|$LN124@future|
	DCB         0xe7
|$LN125@future|
	DCB         0xe7
|$LN126@future|
	DCB         0xfa
|$LN127@future|
	DCB         0xe7
|$LN128@future|
	DCB         0xe7
|$LN129@future|
	DCB         0xe7
|$LN130@future|
	DCB         0xe7
|$LN131@future|
	DCB         0xe7
|$LN132@future|
	DCB         0xe7
|$LN133@future|
	DCB         0xe7
|$LN134@future|
	DCB         0xe7
|$LN135@future|
	DCB         0xe7
|$LN136@future|
	DCB         0xe7

	ENDP  ; |?future@CUSBAsio@@UEAAJJPEAX@Z|, CUSBAsio::future

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?BufferSwitch@CUSBAsio@@QEAAXXZ| PROC			; CUSBAsio::BufferSwitch

; 1355 : {

|$LN19|

; 1356 :     if (m_isStarted && m_callbacks)

	ldrb        w8,[x0,#0xB09]
	cbz         w8,|$LN2@BufferSwit|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0
	ldr         x8,[x19,#0x30]
	cbz         x8,|$LN14@BufferSwit|

; 101  :     double nanoSeconds = (double)((unsigned long)timeGetTime()) * 1000000.;

	adrp        x8,__imp_timeGetTime
	ldr         x8,[x8,__imp_timeGetTime]
	blr         x8
	ldr         d16,|$LN16@BufferSwit|
	ucvtf       d17,w0
	fmul        d18,d17,d16

; 102  :     timeStamp->hi = (unsigned long)(nanoSeconds / c_TwoRaisedTo32);

	ldr         d16,|$LN17@BufferSwit|
	fmul        d16,d18,d16
	fcvtzu      w9,d16

; 103  :     timeStamp->lo = (unsigned long)(nanoSeconds - (timeStamp->hi * c_TwoRaisedTo32));

	ldr         d16,|$LN18@BufferSwit|
	ucvtf       d17,w9
	fmul        d16,d17,d16
	fsub        d16,d18,d16
	fcvtzu      w8,d16
	stp         w9,w8,[x19,#0xCC]

; 1357 :     {
; 1358 :         getNanoSeconds(&m_theSystemTime); // latch system time
; 1359 :         m_samplePosition += m_blockFrames;

	ldr         w8,[x19,#0xAF0]
	ldr         d16,[x19,#0x20]
	scvtf       d17,w8

; 1360 :         if (m_isTimeInfoMode)

	ldrb        w8,[x19,#0xB0A]
	fadd        d16,d17,d16
	str         d16,[x19,#0x20]
	cbz         w8,|$LN3@BufferSwit|

; 1374 :     getSamplePosition(&m_asioTime.timeInfo.samplePosition, &m_asioTime.timeInfo.systemTime);

	ldr         x8,[x19]
	add         x2,x19,#0x50
	add         x1,x19,#0x58
	mov         x0,x19
	ldr         x8,[x8,#0x88]
	blr         x8

; 1375 :     m_callbacks->bufferSwitchTimeInfo(&m_asioTime, m_toggle, ASIOTrue);

	ldr         x8,[x19,#0x30]
	mov         w2,#1
	ldr         w1,[x19,#0xB04]
	add         x0,x19,#0x38
	ldr         x8,[x8,#0x18]
	blr         x8

; 1376 :     m_asioTime.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);

	ldr         w8,[x19,#0x68]
	and         w8,w8,#0xFFFFFFCF
	str         w8,[x19,#0x68]

; 1361 :         {
; 1362 :             BufferSwitchX();
; 1363 :         }

	b           |$LN4@BufferSwit|
|$LN3@BufferSwit|

; 1364 :         else
; 1365 :         {
; 1366 :             m_callbacks->bufferSwitch(m_toggle, ASIOTrue);

	ldr         x8,[x19,#0x30]
	mov         w1,#1
	ldr         w0,[x19,#0xB04]
	ldr         x8,[x8]
	blr         x8
|$LN4@BufferSwit|

; 1367 :         }
; 1368 :         m_toggle = m_toggle ? 0 : 1;

	ldr         w8,[x19,#0xB04]
	cmp         w8,#0
	cseteq      w8
	str         w8,[x19,#0xB04]
|$LN14@BufferSwit|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
|$LN2@BufferSwit|
	ret
|$LN16@BufferSwit|
	DCFD         1e+06
|$LN17@BufferSwit|
	DCFD         2.32831e-10
|$LN18@BufferSwit|
	DCFD         4.29497e+09

	ENDP  ; |?BufferSwitch@CUSBAsio@@QEAAXXZ|, CUSBAsio::BufferSwitch

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?BufferSwitchX@CUSBAsio@@AEAAXXZ| PROC			; CUSBAsio::BufferSwitchX

; 1373 : {

|$LN6|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0

; 1374 :     getSamplePosition(&m_asioTime.timeInfo.samplePosition, &m_asioTime.timeInfo.systemTime);

	ldr         x8,[x19]
	add         x2,x19,#0x50
	add         x1,x19,#0x58
	ldr         x8,[x8,#0x88]
	blr         x8

; 1375 :     m_callbacks->bufferSwitchTimeInfo(&m_asioTime, m_toggle, ASIOTrue);

	ldr         x8,[x19,#0x30]
	mov         w2,#1
	ldr         w1,[x19,#0xB04]
	add         x0,x19,#0x38
	ldr         x8,[x8,#0x18]
	blr         x8

; 1376 :     m_asioTime.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);

	ldr         w8,[x19,#0x68]
	and         w8,w8,#0xFFFFFFCF
	str         w8,[x19,#0x68]
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |?BufferSwitchX@CUSBAsio@@AEAAXXZ|, CUSBAsio::BufferSwitchX

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?GetSupportedSampleFormats@CUSBAsio@@CAKXZ| PROC	; CUSBAsio::GetSupportedSampleFormats

; 1381 :     return ((1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_PCM)) | (1 << toULong(UACSampleFormat::UAC_SAMPLE_FORMAT_IEEE_FLOAT)));

	mov         w0,#0x21
	ret

	ENDP  ; |?GetSupportedSampleFormats@CUSBAsio@@CAKXZ|, CUSBAsio::GetSupportedSampleFormats

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?outputReady@CUSBAsio@@UEAAJXZ| PROC			; CUSBAsio::outputReady

; 1385 : {

|$LN49|
	sub         sp,sp,#0x20
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 1386 :     if (!m_isActive)

	ldrb        w8,[x0,#0xB08]
	cbz         w8,|$LN39@outputRead|
	stp         x19,x20,[sp,#0x10]
	str         x21,[sp,#0x20]
	mov         x19,x0

; 1387 :     {
; 1388 :         return ASE_OK;
; 1389 :     }
; 1390 :     auto                                  lockRecBuffer = m_recBufferCS.lock();

	add         x20,x19,#0xDF8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1391 :     volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;

	ldr         x21,[x19,#0xE30]

; 1392 :     if (recHdr != nullptr)

	cbz         x21,|$LN3@outputRead|

; 1393 :     {
; 1394 :         InterlockedOr((LONG *)&recHdr->OutputReady, toInt(UserThreadStatuses::OutputReady));

	mov         w1,#1
	add         x0,x21,#0x40
	bl          _InterlockedOr

; 1395 :         recHdr->PlayReadyPosition = m_playReadyPosition;

	ldr         x8,[x19,#0xE38]
	str         x8,[x21,#0x30]
|$LN3@outputRead|

; 1396 :     }
; 1397 :     SetEvent(m_outputReadyEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE48]
	blr         x8

; 1398 :     SetEvent(m_outputReadyBlockEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE88]
	blr         x8

; 1399 :     InterlockedOr(&m_outputReadyBlock, 1);

	mov         w1,#1
	add         x0,x19,#0xBA0
	bl          _InterlockedOr
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN46@outputRead|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN46@outputRead|
	ldr         x21,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
|$LN39@outputRead|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1400 :     return ASE_OK;

	mov         w0,#0
	ldp         fp,lr,[sp],#0x10
	add         sp,sp,#0x20
	ret

	ENDP  ; |?outputReady@CUSBAsio@@UEAAJXZ|, CUSBAsio::outputReady

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?MeasureLatency@CUSBAsio@@AEAA_NXZ| PROC		; CUSBAsio::MeasureLatency

; 1467 :     if (m_activeInputs != 0 || m_activeOutputs != 0)

	ldr         w8,[x0,#0xAFC]
	cbnz        w8,|$LN13@MeasureLat|
	ldr         w8,[x0,#0xB00]
	cbnz        w8,|$LN13@MeasureLat|

; 1470 :     }
; 1471 : 
; 1472 : #if defined(INFO_PRINT_)
; 1473 :     ULONG classicFramesPerIrp = (m_audioProperty.PacketsPerSec == 1000 ? m_driverFlags.ClassicFramesPerIrp : m_driverFlags.ClassicFramesPerIrp2);
; 1474 : #endif
; 1475 : 
; 1476 :     m_inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	ldr         w8,[x0,#0xCEC]
	ldr         w9,[x0,#0xAF0]
	add         w10,w8,w9

; 1477 : 
; 1478 :     m_outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;

	ldr         w8,[x0,#0xD24]
	add         w9,w8,w9
	add         x8,x0,#0xAF4
	stp         w10,w9,[x8]

; 1479 : 
; 1480 :     info_print_(" SampleRate = %d, m_blockFrames = %d, ClassicFramesPerIrp = %d, OutFrameDelay = %d, InputLatencyOffset = %d, OutputLatencyOffset = %d\n", m_audioProperty.SampleRate, m_blockFrames, classicFramesPerIrp, m_driverFlags.OutputFrameDelay, m_audioProperty.InputLatencyOffset, m_audioProperty.OutputLatencyOffset);
; 1481 :     info_print_("calculated latency is in:%d, out:%d samples.\n", m_inputLatency, m_outputLatency);
; 1482 : 
; 1483 :     if (m_inputLatency == 0 || m_outputLatency == 0)

	cbz         w10,|$LN6@MeasureLat|
	cbnz        w9,|$LN13@MeasureLat|
|$LN6@MeasureLat|

; 1484 :     {
; 1485 :         return false;

	mov         w0,#0
	ret
|$LN13@MeasureLat|

; 1468 :     {
; 1469 :         return true;

	mov         w0,#1
	ret

	ENDP  ; |?MeasureLatency@CUSBAsio@@AEAA_NXZ|, CUSBAsio::MeasureLatency

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?ApplySettings@CUSBAsio@@AEAA_NXZ| PROC		; CUSBAsio::ApplySettings

; 1494 : {

|$LN28|
	stp         fp,lr,[sp,#-0x40]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	str         x23,[sp,#0x30]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x80
	mov         x19,x0

; 1495 :     LONG  result;
; 1496 :     HKEY  hKey;
; 1497 :     ULONG temp;
; 1498 :     DWORD size;
; 1499 : 
; 1500 :     // default values
; 1501 :     m_fixedSamplingRate = 0;
; 1502 :     m_blockFrames = UAC_DEFAULT_ASIO_BUFFER_SIZE;
; 1503 :     m_driverFlags.FirstPacketLatency = UAC_DEFAULT_FIRST_PACKET_LATENCY;

	mov         x8,#0x14
	movk        x8,#4,lsl #0x20
	str         wzr,[x19,#0xD84]
	add         x20,x19,#0xD48
	str         x8,[x20]

; 1504 :     m_driverFlags.ClassicFramesPerIrp = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1505 :     m_driverFlags.MaxIrpNumber = UAC_DEFAULT_MAX_IRP_NUMBER;

	mov         x9,#8
	add         x8,x19,#0xD50
	stp         x9,xzr,[x8]

; 1506 :     m_driverFlags.PreSendFrames = UAC_DEFAULT_PRE_SEND_FRAMES;
; 1507 :     m_driverFlags.OutputFrameDelay = UAC_DEFAULT_OUTPUT_FRAME_DELAY;
; 1508 :     m_driverFlags.DelayedOutputBufferSwitch = UAC_DEFAULT_DELAYED_OUTPUT_BUFFER_SWITCH;
; 1509 :     m_driverFlags.InputBufferOperationOffset = UAC_DEFAULT_IN_BUFFER_OPERATION_OFFSET;

	mov         x8,#0x90000000
	add         x23,x19,#0xD64
	str         x8,[x23]

; 1510 :     m_driverFlags.InputHubOffset = UAC_DEFAULT_IN_HUB_OFFSET;
; 1511 :     m_driverFlags.OutputBufferOperationOffset = UAC_DEFAULT_OUT_BUFFER_OPERATION_OFFSET;

	mov         x8,#0x10
	movk        x8,#0x9000,lsl #0x10
	add         x22,x19,#0xD6C
	str         x8,[x22]

; 1512 :     m_driverFlags.OutputHubOffset = UAC_DEFAULT_OUT_HUB_OFFSET;
; 1513 :     m_driverFlags.BufferThreadPriority = UAC_DEFAULT_BUFFER_THREAD_PRIORITY;

	mov         x8,#0x1E
	movk        x8,#4,lsl #0x20
	add         x21,x19,#0xD74
	str         x8,[x21]

; 1514 :     m_driverFlags.ClassicFramesPerIrp2 = UAC_DEFAULT_CLASSIC_FRAMES_PER_IRP;
; 1515 :     m_driverFlags.SuggestedBufferPeriod = UAC_DEFAULT_ASIO_BUFFER_SIZE;
; 1516 :     m_threadPriority = 2;

	mov         w8,#2
	str         w8,[x19,#0xE68]

; 1517 :     m_isDropoutDetectionSetting = UAC_DEFAULT_DROPOUT_DETECTION;

	mov         w8,#1
	strb        w8,[x19,#0xB99]

; 1518 : 
; 1519 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	adrp        x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	add         x1,x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	adrp        x8,__imp_RegOpenKeyExA
	ldr         x8,[x8,__imp_RegOpenKeyExA]
	mov         w10,#0x200
	mov         x4,sp
	mov         w3,#0x19
	movk        w3,#2,lsl #0x10
	str         w10,[x19,#0xAF0]
	mov         w2,#0
	str         w10,[x19,#0xD7C]
	mov         x0,#-0x7FFFFFFF
	blr         x8

; 1520 : 
; 1521 :     if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN2@ApplySetti|
	str         x24,[sp,#0xC8]

; 1522 :     {
; 1523 :         size = sizeof(ULONG);

	mov         w24,#4
	str         w24,[sp,#8]

; 1524 :         result = RegQueryValueEx(hKey, c_FixedSamplingRateValueName, 0, nullptr, (PBYTE)&temp, &size);

	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	adrp        x8,|??_C@_0BC@CNPFEPCO@FixedSamplingRate@|
	add         x1,x8,|??_C@_0BC@CNPFEPCO@FixedSamplingRate@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	blr         x8

; 1525 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN3@ApplySetti|

; 1526 :         {
; 1527 :             m_fixedSamplingRate = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD84]
|$LN3@ApplySetti|

; 1528 :         }
; 1529 : 
; 1530 :         size = sizeof(ULONG);
; 1531 :         result = RegQueryValueEx(hKey, c_PeriodFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@FDBGAPPM@PeriodFrames@|
	add         x1,x8,|??_C@_0N@FDBGAPPM@PeriodFrames@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1532 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN4@ApplySetti|

; 1533 :         {
; 1534 :             m_blockFrames = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xAF0]
|$LN4@ApplySetti|

; 1535 :         }
; 1536 : 
; 1537 :         size = sizeof(ULONG);
; 1538 :         result = RegQueryValueEx(hKey, c_FirstPacketLatencyValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BD@JPDMMNEG@FirstPacketLatency@|
	add         x1,x8,|??_C@_0BD@JPDMMNEG@FirstPacketLatency@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1539 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN5@ApplySetti|

; 1540 :         {
; 1541 :             m_driverFlags.FirstPacketLatency = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x20]
|$LN5@ApplySetti|

; 1542 :         }
; 1543 :         size = sizeof(ULONG);
; 1544 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrpValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@|
	add         x1,x8,|??_C@_0BE@NOAOMEBF@ClassicFramesPerIrp@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1545 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN6@ApplySetti|

; 1546 :         {
; 1547 :             m_driverFlags.ClassicFramesPerIrp = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD4C]
|$LN6@ApplySetti|

; 1548 :         }
; 1549 :         size = sizeof(ULONG);
; 1550 :         result = RegQueryValueEx(hKey, c_ClassicFramesPerIrp2ValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@|
	add         x1,x8,|??_C@_0BF@IAHDLOFO@ClassicFramesPerIrp2@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1551 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN7@ApplySetti|

; 1552 :         {
; 1553 :             m_driverFlags.ClassicFramesPerIrp2 = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD78]
|$LN7@ApplySetti|

; 1554 :         }
; 1555 : 
; 1556 :         size = sizeof(ULONG);
; 1557 :         result = RegQueryValueEx(hKey, c_MaxIrpNumberValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@BNFIBEN@MaxIrpNumber@|
	add         x1,x8,|??_C@_0N@BNFIBEN@MaxIrpNumber@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1558 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN8@ApplySetti|

; 1559 :         {
; 1560 :             m_driverFlags.MaxIrpNumber = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD50]
|$LN8@ApplySetti|

; 1561 :         }
; 1562 : 
; 1563 :         size = sizeof(ULONG);
; 1564 :         result = RegQueryValueEx(hKey, c_PreSendFramesValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0O@DDKFKBEA@PreSendFrames@|
	add         x1,x8,|??_C@_0O@DDKFKBEA@PreSendFrames@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1565 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN9@ApplySetti|

; 1566 :         {
; 1567 :             m_driverFlags.PreSendFrames = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD54]
|$LN9@ApplySetti|

; 1568 :         }
; 1569 : 
; 1570 :         size = sizeof(ULONG);
; 1571 :         result = RegQueryValueEx(hKey, c_OutputFrameDelayValueName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BB@PIAJBBGI@OutputFrameDelay@|
	add         x1,x8,|??_C@_0BB@PIAJBBGI@OutputFrameDelay@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1572 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN10@ApplySetti|

; 1573 :         {
; 1574 :             m_driverFlags.OutputFrameDelay = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD58]
|$LN10@ApplySetti|

; 1575 :         }
; 1576 : 
; 1577 :         size = sizeof(ULONG);
; 1578 :         result = RegQueryValueEx(hKey, c_DelayedOutputBufferSwitchName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@|
	add         x1,x8,|??_C@_0BK@JNKNPGNG@DelayedOutputBufferSwitch@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1579 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN11@ApplySetti|

; 1580 :         {
; 1581 :             m_driverFlags.DelayedOutputBufferSwitch = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD5C]
|$LN11@ApplySetti|

; 1582 :         }
; 1583 : 
; 1584 :         size = sizeof(ULONG);
; 1585 :         result = RegQueryValueEx(hKey, c_InputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@|
	add         x1,x8,|??_C@_0BI@IIKKMOIC@InBufferOperationOffset@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1586 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN12@ApplySetti|

; 1587 :         {
; 1588 :             m_driverFlags.InputBufferOperationOffset = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x23]
|$LN12@ApplySetti|

; 1589 :         }
; 1590 : 
; 1591 :         size = sizeof(ULONG);
; 1592 :         result = RegQueryValueEx(hKey, c_InputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0M@IIIMLOLG@InHubOffset@|
	add         x1,x8,|??_C@_0M@IIIMLOLG@InHubOffset@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1593 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN13@ApplySetti|

; 1594 :         {
; 1595 :             m_driverFlags.InputHubOffset = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD68]
|$LN13@ApplySetti|

; 1596 :         }
; 1597 : 
; 1598 :         size = sizeof(ULONG);
; 1599 :         result = RegQueryValueEx(hKey, c_OutputBufferOperationOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@|
	add         x1,x8,|??_C@_0BJ@ENDJMLOO@OutBufferOperationOffset@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1600 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN14@ApplySetti|

; 1601 :         {
; 1602 :             m_driverFlags.OutputBufferOperationOffset = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x22]
|$LN14@ApplySetti|

; 1603 :         }
; 1604 : 
; 1605 :         size = sizeof(ULONG);
; 1606 :         result = RegQueryValueEx(hKey, c_OutputHubOffsetName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0N@DLKKJNAP@OutHubOffset@|
	add         x1,x8,|??_C@_0N@DLKKJNAP@OutHubOffset@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1607 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN15@ApplySetti|

; 1608 :         {
; 1609 :             m_driverFlags.OutputHubOffset = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x19,#0xD70]
|$LN15@ApplySetti|

; 1610 :         }
; 1611 : 
; 1612 :         size = sizeof(ULONG);
; 1613 :         result = RegQueryValueEx(hKey, c_BufferThreadPriorityName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BF@BAAHAIB@BufferThreadPriority@|
	add         x1,x8,|??_C@_0BF@BAAHAIB@BufferThreadPriority@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1614 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN16@ApplySetti|

; 1615 :         {
; 1616 :             m_driverFlags.BufferThreadPriority = temp;

	ldr         w8,[sp,#0xC]
	str         w8,[x21]
|$LN16@ApplySetti|

; 1617 :         }
; 1618 : 
; 1619 :         size = sizeof(ULONG);
; 1620 :         result = RegQueryValueEx(hKey, c_DropoutDetectionName, 0, nullptr, (PBYTE)&temp, &size);

	adrp        x8,|??_C@_0BB@GLAIOBJJ@DropoutDetection@|
	add         x1,x8,|??_C@_0BB@GLAIOBJJ@DropoutDetection@|
	ldr         x0,[sp]
	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         w24,[sp,#8]
	add         x5,sp,#8
	add         x4,sp,#0xC
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1621 :         if (result == ERROR_SUCCESS)

	cbnz        w0,|$LN17@ApplySetti|

; 1622 :         {
; 1623 :             m_isDropoutDetectionSetting = temp != 0;

	ldr         w8,[sp,#0xC]
	cmp         w8,#0
	csetne      w8
	strb        w8,[x19,#0xB99]
|$LN17@ApplySetti|

; 1624 :         }
; 1625 : 
; 1626 :         m_driverFlags.SuggestedBufferPeriod = m_blockFrames;
; 1627 : 
; 1628 :         RegCloseKey(hKey);

	ldr         x0,[sp]
	ldr         w8,[x19,#0xAF0]
	str         w8,[x19,#0xD7C]
	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	blr         x8
	ldr         x24,[sp,#0xC8]
|$LN2@ApplySetti|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 315  :     UAC_SET_FLAGS_CONTEXT setFlagsContext = flags;

	ldr         x8,[x20,#0x30]

; 321  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setFlagsContext, sizeof(UAC_SET_FLAGS_CONTEXT), &bytesReturned, nullptr);

	mov         x7,#0
	str         wzr,[sp,#0x10]
	ldp         q17,q16,[x20]
	add         x6,sp,#0x10
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1631 :     if (!SetFlags(m_usbDeviceHandle, m_driverFlags))

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 321  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), &setFlagsContext, sizeof(UAC_SET_FLAGS_CONTEXT), &bytesReturned, nullptr);

	mov         w5,#0x3C
	add         x4,sp,#0x40
	str         x8,[sp,#0x70]
	ldr         w8,[x20,#0x38]
	mov         w3,#0x18
	stp         q17,q16,[sp,#0x40]
	ldr         q16,[x20,#0x20]
	add         x2,sp,#0x20
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	str         w8,[sp,#0x78]
	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	str         q16,[sp,#0x60]
	ldr         q16,[x8]
	mov         x8,#5
	movk        x8,#2,lsl #0x20
	str         x8,[sp,#0x30]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	str         q16,[sp,#0x20]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1631 :     if (!SetFlags(m_usbDeviceHandle, m_driverFlags))

	cmp         w0,#0
	csetne      w0
	add         sp,sp,#0x80
	bl          __security_pop_cookie
	ldr         x23,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x40
	ret

	ENDP  ; |?ApplySettings@CUSBAsio@@AEAA_NXZ|, CUSBAsio::ApplySettings

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ| PROC		; CUSBAsio::ExecuteControlPanel

; 1640 : {

|$LN6|
	stp         fp,lr,[sp,#-0x20]!
	str         x19,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x2B0

; 1641 :     TCHAR path[MAX_PATH] = {0};

	movi        v16.16b,#0

; 1642 :     TCHAR drive[_MAX_DRIVE] = {0};
; 1643 :     TCHAR dir[_MAX_DIR] = {0};
; 1644 : 
; 1645 :     GetModuleFileNameEx(GetCurrentProcess(), GetModuleHandle(ASIODRV_NAME), path, MAX_PATH);

	adrp        x8,|??_C@_0M@BFGLKKGE@USBAsio?4dll@|
	add         x0,x8,|??_C@_0M@BFGLKKGE@USBAsio?4dll@|
	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	strh        wzr,[sp,#0x30]
	strb        wzr,[sp,#0x32]
	stp         q16,q16,[sp,#0xA0]
	stp         q16,q16,[sp,#0xC0]
	stp         q16,q16,[sp,#0xE0]
	stp         q16,q16,[sp,#0x100]
	stp         q16,q16,[sp,#0x120]
	stp         q16,q16,[sp,#0x140]
	stp         q16,q16,[sp,#0x160]
	stp         q16,q16,[sp,#0x180]
	str         s16,[sp,#0x1A0]
	movi        v16.16b,#0
	stp         q16,q16,[sp,#0x1B0]
	stp         q16,q16,[sp,#0x1D0]
	stp         q16,q16,[sp,#0x1F0]
	stp         q16,q16,[sp,#0x210]
	stp         q16,q16,[sp,#0x230]
	stp         q16,q16,[sp,#0x250]
	stp         q16,q16,[sp,#0x270]
	stp         q16,q16,[sp,#0x290]
	blr         x8
	adrp        x8,__imp_GetCurrentProcess
	ldr         x8,[x8,__imp_GetCurrentProcess]
	mov         x19,x0
	blr         x8
	adrp        x8,__imp_K32GetModuleFileNameExA
	ldr         x8,[x8,__imp_K32GetModuleFileNameExA]
	mov         w3,#0x104
	add         x2,sp,#0xA0
	mov         x1,x19
	blr         x8

; 1646 :     _tsplitpath_s(path, drive, _MAX_DRIVE, dir, _MAX_DIR, nullptr, 0, nullptr, 0);

	mov         x7,#0
	str         xzr,[sp]
	mov         x6,#0
	mov         x5,#0
	mov         x4,#0x100
	add         x3,sp,#0x1B0
	mov         x2,#3
	add         x1,sp,#0x30
	add         x0,sp,#0xA0
	bl          _splitpath_s

; 1647 :     _stprintf_s(path, MAX_PATH, TEXT("%s%s%s"), drive, dir, CONTROLPANELPROGRAMNAME);

	adrp        x8,|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@|
	add         x5,x8,|??_C@_0BI@EKCPACDK@USBAsioControlPanel?4exe@|
	adrp        x8,|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@|
	add         x2,x8,|??_C@_06DIJPEION@?$CFs?$CFs?$CFs@|
	add         x4,sp,#0x1B0
	add         x3,sp,#0x30
	mov         x1,#0x104
	add         x0,sp,#0xA0
	bl          sprintf_s

; 1648 : 
; 1649 :     STARTUPINFO startupInfo;
; 1650 :     ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
; 1651 :     startupInfo.cb = sizeof(STARTUPINFO);
; 1652 : 
; 1653 :     PROCESS_INFORMATION processInfo{};
; 1654 : 
; 1655 :     CreateProcess(

	mov         x7,#0
	movi        v16.16b,#0
	mov         x6,#0
	mov         w5,#0x20
	mov         w4,#0
	mov         x3,#0
	mov         x2,#0
	mov         x1,#0
	add         x0,sp,#0xA0
	add         x8,sp,#0x3C
	stp         q16,q16,[x8]
	stp         q16,q16,[x8,#0x20]
	stp         q16,q16,[x8,#0x40]
	str         s16,[x8,#0x60]
	mov         w8,#0x68
	movi        v16.16b,#0
	str         w8,[sp,#0x38]
	add         x8,sp,#0x10
	str         x8,[sp,#8]
	add         x8,sp,#0x38
	str         x8,[sp]
	adrp        x8,__imp_CreateProcessA
	ldr         x8,[x8,__imp_CreateProcessA]
	str         q16,[sp,#0x10]
	str         d16,[sp,#0x20]
	blr         x8

; 1656 :         path,
; 1657 :         nullptr,
; 1658 :         nullptr,
; 1659 :         nullptr,
; 1660 :         FALSE,
; 1661 :         NORMAL_PRIORITY_CLASS,
; 1662 :         nullptr,
; 1663 :         nullptr,
; 1664 :         &startupInfo,
; 1665 :         &processInfo
; 1666 :     );
; 1667 : 
; 1668 :     CloseHandle(processInfo.hThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[sp,#0x18]
	blr         x8

; 1669 :     CloseHandle(processInfo.hProcess);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[sp,#0x10]
	blr         x8

; 1670 :     return true;

	mov         w0,#1
	add         sp,sp,#0x2B0
	bl          __security_pop_cookie
	ldr         x19,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?ExecuteControlPanel@CUSBAsio@@AEAA_NXZ|, CUSBAsio::ExecuteControlPanel

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?GetDesiredPath@CUSBAsio@@AEAA_NXZ| PROC		; CUSBAsio::GetDesiredPath

; 1674 : {

|$LN12|
	stp         fp,lr,[sp,#-0x20]!
	stp         x19,x20,[sp,#0x10]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x10
	mov         x19,x0

; 1675 :     LONG  result;
; 1676 :     DWORD size;
; 1677 :     HKEY  hKey;
; 1678 : 
; 1679 :     if (m_desiredPath != nullptr)

	ldr         x0,[x19,#0x8E8]
	cbz         x0,|$LN2@GetDesired|

; 1680 :     {
; 1681 :         delete[] m_desiredPath;

	bl          |??_V@YAXPEAX@Z|

; 1682 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]
|$LN2@GetDesired|

; 1683 :     }
; 1684 : 
; 1685 :     result = RegOpenKeyEx(HKEY_CURRENT_USER, c_RegistryKeyName, 0, KEY_READ, &hKey);

	adrp        x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	add         x1,x8,|??_C@_0CE@FGCAAGLA@Software?2Microsoft?2Windows?5USB?5@|
	adrp        x8,__imp_RegOpenKeyExA
	ldr         x8,[x8,__imp_RegOpenKeyExA]
	mov         x4,sp
	mov         w3,#0x19
	movk        w3,#2,lsl #0x10
	mov         w2,#0
	mov         x0,#-0x7FFFFFFF
	blr         x8

; 1686 :     if (result != ERROR_SUCCESS)

	cbnz        w0,|$LN10@GetDesired|

; 1687 :     {
; 1688 :         return false;
; 1689 :     }
; 1690 : 
; 1691 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, nullptr, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	ldr         x0,[sp]
	adrp        x20,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x1,x20,|??_C@_0L@ONBBLLLB@AsioDevice@|
	add         x5,sp,#8
	mov         x4,#0
	mov         x3,#0
	mov         x2,#0
	blr         x8

; 1692 :     if (result != ERROR_SUCCESS || size == 0)

	cbnz        w0,|$LN5@GetDesired|
	ldr         w0,[sp,#8]
	cbz         w0,|$LN5@GetDesired|

; 1695 :         return false;
; 1696 :     }
; 1697 : 
; 1698 :     m_desiredPath = new TCHAR[size / sizeof(TCHAR)];

	bl          |??_U@YAPEAX_K@Z|

; 1699 :     result = RegQueryValueEx(hKey, c_AsioDeviceValueName, 0, nullptr, (LPBYTE)m_desiredPath, &size);

	adrp        x8,__imp_RegQueryValueExA
	ldr         x8,[x8,__imp_RegQueryValueExA]
	str         x0,[x19,#0x8E8]
	mov         x4,x0
	ldr         x0,[sp]
	add         x5,sp,#8
	mov         x3,#0
	mov         x2,#0
	add         x1,x20,|??_C@_0L@ONBBLLLB@AsioDevice@|
	blr         x8

; 1700 :     if (result != ERROR_SUCCESS)

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	cbz         w0,|$LN6@GetDesired|

; 1701 :     {
; 1702 :         RegCloseKey(hKey);

	ldr         x0,[sp]
	blr         x8

; 1703 :         delete[] m_desiredPath;

	ldr         x0,[x19,#0x8E8]
	bl          |??_V@YAXPEAX@Z|

; 1704 :         m_desiredPath = nullptr;

	str         xzr,[x19,#0x8E8]

; 1705 :         return false;

	b           |$LN10@GetDesired|
|$LN6@GetDesired|

; 1706 :     }
; 1707 : 
; 1708 :     RegCloseKey(hKey);

	ldr         x0,[sp]
	blr         x8

; 1709 : 
; 1710 :     info_print_(_T("ASIO device path : %s\n"), m_desiredPath);
; 1711 : 
; 1712 :     return true;

	mov         w0,#1
	add         sp,sp,#0x10
	bl          __security_pop_cookie
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret
|$LN5@GetDesired|

; 1693 :     {
; 1694 :         RegCloseKey(hKey);

	adrp        x8,__imp_RegCloseKey
	ldr         x8,[x8,__imp_RegCloseKey]
	ldr         x0,[sp]
	blr         x8
|$LN10@GetDesired|

; 1713 : }

	mov         w0,#0
	add         sp,sp,#0x10
	bl          __security_pop_cookie
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?GetDesiredPath@CUSBAsio@@AEAA_NXZ|, CUSBAsio::GetDesiredPath

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ| PROC	; CUSBAsio::ObtainDeviceParameter

; 1716 : {

|$LN184|
	stp         fp,lr,[sp,#-0x60]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	str         x27,[sp,#0x50]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0xD0
	mov         x26,sp
	mov         x19,x0

; 1718 :     bool isLatencyMeasured = true;
; 1719 :     BOOL result = TRUE;
; 1720 : 
; 1721 :     auto lockDevice = m_deviceInfoCS.lock();

	add         x22,x19,#0xDA8
	mov         xip0,#-2
	stp         x22,xip0,[x26]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
	mov         x0,x22
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1717 :     int  bufferCoefficient = 1;

	mov         w20,#1
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x22,[x26,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1724 :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x24,x8,KSPROPSETID_LowLatencyAudio
	mov         w21,#0
	mov         w25,#0x869F
	movk        w25,#1,lsl #0x10
	mov         w27,#0x869D
	movk        w27,#1,lsl #0x10
	mov         w22,#3
	movk        w22,#0x2F,lsl #0x10
|$LL4@ObtainDevi|

; 1725 :     {
; 1726 :         if (m_channelInfo != nullptr)

	ldr         x0,[x19,#0xD98]
	cbz         x0,|$LN5@ObtainDevi|

; 1727 :         {
; 1728 :             delete[] ((UCHAR *)m_channelInfo);

	bl          |??_V@YAXPEAX@Z|

; 1729 :             m_channelInfo = nullptr;

	str         xzr,[x19,#0xD98]
|$LN5@ObtainDevi|

; 1730 :         }
; 1731 :         m_inputLatency = 0;
; 1732 :         m_outputLatency = 0;
; 1733 : 
; 1734 :         if (m_audioProperty.SampleRate > 50000 && m_audioProperty.SampleRate < 99999)

	ldr         w10,[x19,#0xCBC]
	mov         w8,#0xC350
	mov         xip1,#0xAF4
	str         xzr,[x19,xip1]
	cmp         w10,w8
	ccmphi      w10,w25,#0xE
	bhs         |$LN6@ObtainDevi|

; 1735 :         {
; 1736 :             bufferCoefficient = 2;

	mov         w9,#2

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	b           |$LN9@ObtainDevi|
|$LN6@ObtainDevi|

; 1737 :         }
; 1738 :         if (m_audioProperty.SampleRate > 100000 && m_audioProperty.SampleRate < 199999)

	sub         w8,w10,#0x18,lsl #0xC
	sub         w8,w8,#0x6A1
	cmp         w8,w27
	bhi         |$LN7@ObtainDevi|

; 1739 :         {
; 1740 :             bufferCoefficient = 4;

	mov         w9,#4

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	b           |$LN9@ObtainDevi|
|$LN7@ObtainDevi|

; 1741 :         }
; 1742 :         if (m_audioProperty.SampleRate > 200000 && m_audioProperty.SampleRate < 399999)

	sub         w8,w10,#0x30,lsl #0xC
	sub         w9,w8,#0xD41
	mov         w8,#0xD3D
	movk        w8,#3,lsl #0x10
	cmp         w9,w8
	bhi         |$LN8@ObtainDevi|

; 1743 :         {
; 1744 :             bufferCoefficient = 8;

	mov         w9,#8

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	b           |$LN9@ObtainDevi|
|$LN8@ObtainDevi|

; 1746 :         if (m_audioProperty.SampleRate > 400000)

	mov         w8,#0x1A80
	movk        w8,#6,lsl #0x10
	cmp         w10,w8
	mov         w8,#0x10
	cselhi      w9,w8,w20
|$LN9@ObtainDevi|

; 1747 :         {
; 1748 :             bufferCoefficient = 16;
; 1749 :         }
; 1750 :         m_blockFrames /= bufferCoefficient;

	ldr         w8,[x19,#0xAF0]
	cbnz        w9,|$LN182@ObtainDevi|
	brk         #0xF004
|$LN182@ObtainDevi|
	sdiv        w8,w8,w9
	str         w8,[x19,#0xAF0]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 179  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetAudioProperty);

	mov         x8,#0x100000000
	ldr         q16,[x24]
	str         wzr,[x26,#0x20]
	str         x8,[x26,#0x40]

; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1752 :         result = GetAudioProperty(m_usbDeviceHandle, &m_audioProperty);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 181  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), audioProperty, sizeof(UAC_AUDIO_PROPERTY), &bytesReturned, nullptr);

	mov         x7,#0
	add         x6,x26,#0x20
	mov         w5,#0x198
	str         q16,[x26,#0x30]
	add         x4,x19,#0xBB0
	mov         w3,#0x18
	add         x2,x26,#0x30
	mov         w1,w22
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1753 :         if (!result || !m_audioProperty.IsAccessible)

	cbz         w0,|$LN172@ObtainDevi|
	ldrb        w8,[x19,#0xD44]
	cbz         w8,|$LN172@ObtainDevi|

; 1762 :             return false;
; 1763 :         }
; 1764 :         if ((m_audioProperty.InputAsioChannels < 1) && (m_audioProperty.OutputAsioChannels < 1))

	ldr         w8,[x19,#0xCDC]
	cbnz        w8,|$LN161@ObtainDevi|
	ldr         w8,[x19,#0xD0C]
	cbz         w8,|$LN172@ObtainDevi|
|$LN161@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 205  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetChannelInfo);

	movi        x8,#0x100000001
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1775 :         result = GetChannelInfo(m_usbDeviceHandle, (PUAC_GET_CHANNEL_INFO_CONTEXT *)&channelInfoBuffer);

	ldr         x20,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 194  :     ULONG      bytesReturned = 0;

	str         wzr,[x26,#0x18]

; 205  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::GetChannelInfo);

	str         x8,[x26,#0x40]

; 206  : 
; 207  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	ldr         q16,[x24]
	mov         x7,#0
	add         x6,x26,#0x18
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	str         q16,[x26,#0x30]
	add         x2,x26,#0x30
	mov         w1,w22
	mov         x0,x20
	mov         x23,#0
	blr         x8

; 208  : 
; 209  :     if (!result)

	cbnz        w0,|$LN93@ObtainDevi|

; 210  :     {
; 211  :         DWORD error = GetLastError();

	adrp        x8,__imp_GetLastError
	ldr         x8,[x8,__imp_GetLastError]
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1746 :         if (m_audioProperty.SampleRate > 400000)

	mov         w8,#0x54
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 212  :         if ((error == ERROR_MORE_DATA) && (bytesReturned >= sizeof(UAC_GET_CHANNEL_INFO_CONTEXT)))

	cmp         w0,#0xEA
	ldr         w0,[x26,#0x18]
	ccmpeq      w0,w8,#0
	blo         |$LN172@ObtainDevi|

; 213  :         {
; 214  :             *channelInfo = (PUAC_GET_CHANNEL_INFO_CONTEXT)(new BYTE[bytesReturned]);

	bl          |??_U@YAPEAX_K@Z|

; 215  :             if (channelInfo != nullptr)
; 216  :             {
; 217  :                 result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), *channelInfo, bytesReturned, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	ldr         w5,[x26,#0x18]
	mov         x23,x0
	mov         x7,#0
	add         x6,x26,#0x18
	mov         x4,x23
	mov         w3,#0x18
	add         x2,x26,#0x30
	mov         w1,w22
	mov         x0,x20
	blr         x8

; 218  :                 if (!result)

	cbz         w0,|$LN175@ObtainDevi|
|$LN93@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1792 :         if (m_audioProperty.SampleRate > 50000 && m_audioProperty.SampleRate < 99999)

	ldr         w8,[x19,#0xCBC]
	mov         w9,#0xC350
	str         x23,[x19,#0xD98]
	cmp         w8,w9
	ccmphi      w8,w25,#0xE
	bhs         |$LN15@ObtainDevi|

; 1793 :         {
; 1794 :             bufferCoefficient = 2;

	mov         w20,#2
	b           |$LN18@ObtainDevi|
|$LN15@ObtainDevi|

; 1795 :         }
; 1796 :         if (m_audioProperty.SampleRate > 100000 && m_audioProperty.SampleRate < 199999)

	sub         w9,w8,#0x18,lsl #0xC
	sub         w9,w9,#0x6A1
	cmp         w9,w27
	bhi         |$LN16@ObtainDevi|

; 1797 :         {
; 1798 :             bufferCoefficient = 4;

	mov         w20,#4
	b           |$LN18@ObtainDevi|
|$LN16@ObtainDevi|

; 1799 :         }
; 1800 :         if (m_audioProperty.SampleRate > 200000 && m_audioProperty.SampleRate < 399999)

	mov         w10,#0xD40
	movk        w10,#3,lsl #0x10
	cmp         w8,w10
	mov         w9,w8
	bls         |$LN17@ObtainDevi|
	mov         w10,#0x1A7F
	movk        w10,#6,lsl #0x10
	cmp         w8,w10
	bhs         |$LN17@ObtainDevi|

; 1801 :         {
; 1802 :             bufferCoefficient = 8;

	mov         w20,#8
	b           |$LN18@ObtainDevi|
|$LN17@ObtainDevi|

; 1803 :         }
; 1804 :         if (m_audioProperty.SampleRate > 400000)

	mov         w10,#0x1A80
	movk        w10,#6,lsl #0x10
	cmp         w8,w10
	mov         w20,#1
	bls         |$LN18@ObtainDevi|

; 1805 :         {
; 1806 :             bufferCoefficient = 16;

	mov         w20,#0x10
	mov         w8,w9
|$LN18@ObtainDevi|

; 1807 :         }
; 1808 :         m_blockFrames *= bufferCoefficient;

	ldr         w9,[x19,#0xAF0]

; 1812 :         m_sampleRate = (double)m_audioProperty.SampleRate;

	ucvtf       d16,w8
	add         x11,x19,#0xD8C
	ldr         w10,[x19,#0xCDC]

; 1467 :     if (m_activeInputs != 0 || m_activeOutputs != 0)

	ldr         w8,[x19,#0xAFC]

; 1807 :         }
; 1808 :         m_blockFrames *= bufferCoefficient;

	mul         w13,w20,w9

; 1809 : 
; 1810 :         m_inAvailableChannels = m_audioProperty.InputAsioChannels;
; 1811 :         m_outAvailableChannels = m_audioProperty.OutputAsioChannels;

	ldr         w9,[x19,#0xD0C]
	str         w13,[x19,#0xAF0]
	stp         w10,w9,[x11]

; 1812 :         m_sampleRate = (double)m_audioProperty.SampleRate;

	str         d16,[x19,#0x28]

; 1467 :     if (m_activeInputs != 0 || m_activeOutputs != 0)

	cbnz        w8,|$LN178@ObtainDevi|
	ldr         w8,[x19,#0xB00]
	cbnz        w8,|$LN178@ObtainDevi|

; 1468 :     {
; 1469 :         return true;
; 1470 :     }
; 1471 : 
; 1472 : #if defined(INFO_PRINT_)
; 1473 :     ULONG classicFramesPerIrp = (m_audioProperty.PacketsPerSec == 1000 ? m_driverFlags.ClassicFramesPerIrp : m_driverFlags.ClassicFramesPerIrp2);
; 1474 : #endif
; 1475 : 
; 1476 :     m_inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	ldr         w8,[x19,#0xCEC]
	add         w12,w8,w13

; 1477 : 
; 1478 :     m_outputLatency = m_blockFrames + m_audioProperty.OutputLatencyOffset;

	ldr         w8,[x19,#0xD24]
	add         w11,w8,w13
	add         x8,x19,#0xAF4

; 1468 :     {
; 1469 :         return true;
; 1470 :     }
; 1471 : 
; 1472 : #if defined(INFO_PRINT_)
; 1473 :     ULONG classicFramesPerIrp = (m_audioProperty.PacketsPerSec == 1000 ? m_driverFlags.ClassicFramesPerIrp : m_driverFlags.ClassicFramesPerIrp2);
; 1474 : #endif
; 1475 : 
; 1476 :     m_inputLatency = m_blockFrames + m_audioProperty.InputLatencyOffset;

	stp         w12,w11,[x8]

; 1479 : 
; 1480 :     info_print_(" SampleRate = %d, m_blockFrames = %d, ClassicFramesPerIrp = %d, OutFrameDelay = %d, InputLatencyOffset = %d, OutputLatencyOffset = %d\n", m_audioProperty.SampleRate, m_blockFrames, classicFramesPerIrp, m_driverFlags.OutputFrameDelay, m_audioProperty.InputLatencyOffset, m_audioProperty.OutputLatencyOffset);
; 1481 :     info_print_("calculated latency is in:%d, out:%d samples.\n", m_inputLatency, m_outputLatency);
; 1482 : 
; 1483 :     if (m_inputLatency == 0 || m_outputLatency == 0)

	cbz         w12,|$LN162@ObtainDevi|
	cbnz        w11,|$LN178@ObtainDevi|
|$LN162@ObtainDevi|

; 1813 : 
; 1814 :         isLatencyMeasured = MeasureLatency();
; 1815 :         if (isLatencyMeasured)
; 1816 :         {
; 1817 :             break;
; 1818 :         }
; 1819 :         if (retry < maxRetry - 1)

	cmp         w21,#5
	bhs         |$LN2@ObtainDevi|

; 1820 :         {
; 1821 :             Sleep(500);

	adrp        x8,__imp_Sleep
	ldr         x8,[x8,__imp_Sleep]
	mov         w0,#0x1F4
	blr         x8
|$LN2@ObtainDevi|

; 1724 :     for (ULONG retry = 0; retry < maxRetry; ++retry)

	add         w21,w21,#1
	cmp         w21,#6
	blo         |$LL4@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov         x8,#0xD
	movk        x8,#2,lsl #0x20
	ldr         q16,[x24]
	str         x8,[x26,#0x40]

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1827 :         ReleaseAsioOwnership(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         wzr,[x26,#0x20]
	add         x6,x26,#0x20
	mov         w5,#0
	str         q16,[x26,#0x30]
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x26,#0x30
	mov         w1,w22
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1828 :         CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xBA8]
	blr         x8

; 1829 :         m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov         x8,#-1

; 1830 :         // >>comment-004<<
; 1831 :         TCHAR messageString[ERROR_MESSAGE_LENGTH] = {0};

	movi        v16.16b,#0
	str         x8,[x19,#0xBA8]

; 1832 :         LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_LATENCY, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	mov         x0,#0
	stp         q16,q16,[x26,#0x50]
	stp         q16,q16,[x26,#0x70]
	stp         q16,q16,[x26,#0x90]
	stp         q16,q16,[x26,#0xB0]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x50
	mov         w1,#0x65
	blr         x8

; 1833 :         _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x50
	mov         x1,#0x80
	add         x0,x19,#0xB0C
	bl          strcpy_s
	b           |$LN28@ObtainDevi|
|$LN175@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 220  :                     delete[] (BYTE *)(*channelInfo);

	mov         x0,x23
	bl          |??_V@YAXPEAX@Z|
|$LN172@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1757 :             LoadString(GetModuleHandle(nullptr), IDS_ERRMSG_CONSTRUCT, messageString, sizeof(messageString) / sizeof(messageString[0]));

	adrp        x8,__imp_GetModuleHandleA
	ldr         x8,[x8,__imp_GetModuleHandleA]
	movi        v16.16b,#0
	mov         x0,#0
	stp         q16,q16,[x26,#0x50]
	stp         q16,q16,[x26,#0x70]
	stp         q16,q16,[x26,#0x90]
	stp         q16,q16,[x26,#0xB0]
	blr         x8
	adrp        x8,__imp_LoadStringA
	ldr         x8,[x8,__imp_LoadStringA]
	mov         w3,#0x80
	add         x2,x26,#0x50
	mov         w1,#0x66
	blr         x8

; 1758 :             _tcscpy_s(m_errorMessage, ERROR_MESSAGE_LENGTH, messageString);

	add         x2,x26,#0x50
	mov         x1,#0x80
	add         x0,x19,#0xB0C
	bl          strcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 472  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::ReleaseAsioOwnership);

	mov         x8,#0xD
	movk        x8,#2,lsl #0x20
	ldr         q16,[x24]
	str         x8,[x26,#0x40]

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1759 :             ReleaseAsioOwnership(m_usbDeviceHandle);

	ldr         x0,[x19,#0xBA8]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 474  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	mov         x7,#0
	str         wzr,[x26,#0x20]
	add         x6,x26,#0x20
	mov         w5,#0
	str         q16,[x26,#0x30]
	mov         x4,#0
	mov         w3,#0x18
	add         x2,x26,#0x30
	mov         w1,w22
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1760 :             CloseHandle(m_usbDeviceHandle);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xBA8]
	blr         x8

; 1761 :             m_usbDeviceHandle = INVALID_HANDLE_VALUE;

	mov         x8,#-1
	str         x8,[x19,#0xBA8]
|$LN28@ObtainDevi|
	mov         w19,#0
|$LN29@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x26]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN149@ObtainDevi|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
|$LN149@ObtainDevi|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1844 :     return true;

	mov         w0,w19
	add         sp,sp,#0xD0
	bl          __security_pop_cookie
	ldr         x27,[sp,#0x50]
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ret
|$LN178@ObtainDevi|

; 1834 :         return false;
; 1835 :     }
; 1836 :     if (m_inAvailableChannels > NUMOFINPUTS)

	mov         w8,#0x40
	cmp         w10,#0x40
	bls         |$LN22@ObtainDevi|

; 1837 :     {
; 1838 :         m_inAvailableChannels = NUMOFINPUTS;

	str         w8,[x19,#0xD8C]
|$LN22@ObtainDevi|

; 1839 :     }
; 1840 :     if (m_outAvailableChannels > NUMOFOUTPUTS)

	cmp         w9,#0x40
	bls         |$LN23@ObtainDevi|

; 1841 :     {
; 1842 :         m_outAvailableChannels = NUMOFOUTPUTS;

	str         w8,[x19,#0xD90]
|$LN23@ObtainDevi|

; 1844 :     return true;

	mov         w19,#1
	b           |$LN29@ObtainDevi|
	svc         #3

	ENDP  ; |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|, CUSBAsio::ObtainDeviceParameter

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ@4HA| PROC ; `CUSBAsio::ObtainDeviceParameter'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,x26,#0x10
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|, CUSBAsio::ObtainDeviceParameter

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ| PROC	; CUSBAsio::RequestClockInfoChange

; 1848 : {

|$LN106|
	stp         x19,x20,[sp,#-0x30]!
	stp         x21,x22,[sp,#0x10]
	str         x23,[sp,#0x20]
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         xip0,#-2
	mov         x23,x0
	str         xip0,[fp,#0x10]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1851 :     auto lockClient = m_clientInfoCS.lock();

	add         x22,x23,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x22
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x22,[fp,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1852 :     if (m_isActive)

	ldrb        w8,[x23,#0xB08]
	mov         w21,#1
	cbz         w8,|$LN2@RequestClo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1854 :         auto lockRecBuffer = m_recBufferCS.lock();

	add         x20,x23,#0xDF8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1856 :         volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)m_driverRecBuffer;

	ldr         x19,[x23,#0xE30]

; 1857 :         if (recHdr != nullptr && (recHdr->DeviceStatus & toInt(DeviceStatuses::SampleRateChanged)) != 0 && recHdr->CurrentSampleRate != 0)

	cbz         x19,|$LN5@RequestClo|
	ldr         w8,[x19,#4]
	tbz         w8,#1,|$LN4@RequestClo|
	ldr         w8,[x19,#8]
	cbz         w8,|$LN4@RequestClo|

; 1858 :         {
; 1859 :             m_requireSampleRateChange = true;

	strb        w21,[x23,#0xB8C]

; 1860 :             m_nextSampleRate = (ASIOSampleRate)(recHdr->CurrentSampleRate);

	ldr         w8,[x19,#8]

; 1861 :             SetEvent(m_asioResetEvent);

	ldr         x0,[x23,#0xE70]
	ucvtf       d16,w8
	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	str         d16,[x23,#0xB90]
	blr         x8

; 1862 :             recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::SampleRateChanged));

	ldr         w8,[x19,#4]
	and         w8,w8,#0xFFFFFFFD
	str         w8,[x19,#4]
|$LN4@RequestClo|

; 1863 :         }
; 1864 :         if (recHdr != nullptr && (recHdr->DeviceStatus & toInt(DeviceStatuses::ResetRequired)) != 0)

	ldr         w8,[x19,#4]
	tbz         w8,#0,|$LN5@RequestClo|

; 1865 :         {
; 1866 :             m_isRequireAsioReset = true;
; 1867 :             SetEvent(m_asioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x23,#0xE70]
	strb        w21,[x23,#0xB98]
	blr         x8

; 1868 :             recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ResetRequired));

	ldr         w8,[x19,#4]
	and         w8,w8,#0xFFFFFFFE
	str         w8,[x19,#4]
|$LN5@RequestClo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN6@RequestClo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN6@RequestClo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1881 :     return true;

	mov         w19,#1
|$LN10@RequestClo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x22,|$LN100@RequestClo|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x22
	blr         x8
|$LN100@RequestClo|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1881 :     return true;

	mov         w0,w19
	ldp         fp,lr,[sp],#0x20
	ldr         x23,[sp,#0x20]
	ldp         x21,x22,[sp,#0x10]
	ldp         x19,x20,[sp],#0x30
	ret
|$LN2@RequestClo|

; 1869 :         }
; 1870 :     }
; 1871 :     else
; 1872 :     {
; 1873 :         // If the fs/clock source is changed before the buffer is acquired, the device information is acquired again and the latency is calculated again.
; 1874 :         bool result = ObtainDeviceParameter();

	mov         x0,x23
	bl          |?ObtainDeviceParameter@CUSBAsio@@AEAA_NXZ|

; 1875 :         info_print_("ObtainDeviceParameter() completed, result %u, current rate %u, format %u\n", result, m_audioProperty.SampleRate, m_audioProperty.CurrentSampleFormat);
; 1876 :         if (!result)

	tbnz        w0,#0,|$LN6@RequestClo|
	mov         w19,#0
	b           |$LN10@RequestClo|
	svc         #3

	ENDP  ; |?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|, CUSBAsio::RequestClockInfoChange

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??RequestClockInfoChange@CUSBAsio@@AEAA_NXZ@4HA| PROC ; `CUSBAsio::RequestClockInfoChange'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	add         x0,fp,#0x18
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?RequestClockInfoChange@CUSBAsio@@AEAA_NXZ|, CUSBAsio::RequestClockInfoChange

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?AsioResetThread@CUSBAsio@@CAIPEAX@Z| PROC		; CUSBAsio::AsioResetThread

; 1886 : {

|$LN108|
	stp         fp,lr,[sp,#-0x40]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	str         x23,[sp,#0x30]
	str         d8,[sp,#0x38]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x20
	mov         x23,sp
	mov         xip0,#-2

; 1887 :     CUSBAsio *     self = (CUSBAsio *)param;
; 1888 :     bool           done = false;
; 1889 :     DWORD          status = 0;
; 1890 :     ASIOSampleRate oldSampleRate = 0;

	movi        d8,#0
	mov         x19,x0
	str         xip0,[x23,#8]

; 1891 :     ULONG          resetQueue = 0;
; 1892 :     ULONG          resetExecuted = 0;
; 1893 : 
; 1894 :     InterlockedIncrement(&g_AsioResetThread);

	adrp        x22,|?g_AsioResetThread@@3JA|
	add         x0,x22,|?g_AsioResetThread@@3JA|
	mov         w21,#0
	bl          _InterlockedIncrement
	add         xip1,x19,#0xE70

; 1895 : 
; 1896 :     info_print_("entering ASIO reset thread instance %d.\n", InterlockedCompareExchange(&g_AsioResetThread, 0, 0));
; 1897 : 
; 1898 :     HANDLE handlesForWait[] = {self->m_terminateAsioResetEvent, self->m_asioResetEvent};

	ldp         x8,x9,[xip1]
	stp         x9,x8,[x23,#0x10]
|$LL4@AsioResetT|

; 1899 : 
; 1900 :     do
; 1901 :     {
; 1902 :         if (resetQueue > 0)

	cbz         w21,|$LN57@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1904 :             auto lockClient = self->m_clientInfoCS.lock();

	add         x20,x19,#0xDD0
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[x23]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1905 :             if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	ldr         x8,[x19,#0x30]
	cbz         x8,|$LN8@AsioResetT|
	ldr         x8,[x8,#0x10]
	cbz         x8,|$LN8@AsioResetT|

; 1906 :             {
; 1907 :                 info_print_("AsioResetThread: ASIO reset callback try %u, thread ID %u.\n", resetExecuted, GetCurrentThreadId());
; 1908 :                 self->m_callbacks->asioMessage(kAsioResetRequest, 0, nullptr, nullptr);

	mov         x3,#0
	mov         x2,#0
	mov         w1,#0
	mov         w0,#3
	blr         x8

; 1909 :                 --resetQueue;

	sub         w21,w21,#1
|$LN8@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN57@AsioResetT|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN57@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1913 :         status = WaitForMultipleObjects(sizeof(handlesForWait) / sizeof(handlesForWait[0]), handlesForWait, FALSE, ASIO_RESET_TIMEOUT);

	adrp        x8,__imp_WaitForMultipleObjects
	ldr         x8,[x8,__imp_WaitForMultipleObjects]
	mov         w3,#0x3E8
	mov         w2,#0
	add         x1,x23,#0x10
	mov         w0,#2
	blr         x8

; 1914 :         switch (status)

	cbz         w0,|$LN105@AsioResetT|
	cmp         w0,#1
	beq         |$LN10@AsioResetT|
	cmp         w0,#0x102
	beq         |$LL4@AsioResetT|
|$LN105@AsioResetT|

; 1962 : 
; 1963 :     info_print_("exiting ASIO reset thread %d.\n", InterlockedCompareExchange(&g_AsioResetThread, 0, 0));
; 1964 :     InterlockedDecrement(&g_AsioResetThread);

	add         x0,x22,|?g_AsioResetThread@@3JA|
	bl          _InterlockedDecrement

; 1965 : 
; 1966 :     return 0;

	mov         w0,#0
	add         sp,sp,#0x20
	bl          __security_pop_cookie
	ldr         d8,[sp,#0x38]
	ldr         x23,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x40
	ret
|$LN10@AsioResetT|

; 1915 :         {
; 1916 :         case WAIT_OBJECT_0:
; 1917 :             done = true;
; 1918 :             break;
; 1919 :         case WAIT_OBJECT_0 + 1:
; 1920 :             if (self->m_requireSampleRateChange)

	ldrb        w8,[x19,#0xB8C]
	cbz         w8,|$LN93@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1923 :                 auto lockClient = self->m_clientInfoCS.lock();

	add         x20,x19,#0xDD0
	strb        wzr,[x19,#0xB8C]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x20
	blr         x8

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x20,[x23]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1924 :                 if (self->m_callbacks != nullptr && self->m_callbacks->sampleRateDidChange != nullptr && oldSampleRate != self->m_nextSampleRate)

	ldr         x8,[x19,#0x30]
	cbz         x8,|$LN12@AsioResetT|
	ldr         x8,[x8,#8]
	cbz         x8,|$LN12@AsioResetT|
	ldr         d0,[x19,#0xB90]
	fcmp        d8,d0
	beq         |$LN12@AsioResetT|

; 1925 :                 {
; 1926 :                     info_print_("AsioResetThread: sample rate change callback, new %lf.\n", self->m_nextSampleRate);
; 1927 :                     self->m_callbacks->sampleRateDidChange(self->m_nextSampleRate);

	blr         x8

; 1928 :                     oldSampleRate = self->m_nextSampleRate;

	ldr         d8,[x19,#0xB90]
|$LN12@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x20,|$LN93@AsioResetT|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x20
	blr         x8
|$LN93@AsioResetT|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 1931 :             if (self->m_isSupportDropoutDetection && self->m_isRequireReportDropout)

	ldrb        w8,[x19,#0xB9A]
	cbz         w8,|$LN14@AsioResetT|
	ldrb        w8,[x19,#0xB9B]
	cbz         w8,|$LN14@AsioResetT|

; 1932 :             {
; 1933 :                 self->m_isRequireReportDropout = false;
; 1934 :                 if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	ldr         x8,[x19,#0x30]
	strb        wzr,[x19,#0xB9B]
	cbz         x8,|$LN14@AsioResetT|
	ldr         x8,[x8,#0x10]
	cbz         x8,|$LN14@AsioResetT|

; 1935 :                 {
; 1936 :                     info_print_("AsioResetThread: dropout detect callback.\n");
; 1937 :                     self->m_callbacks->asioMessage(kAsioOverload, 0, nullptr, nullptr);

	mov         x3,#0
	mov         x2,#0
	mov         w1,#0
	mov         w0,#0xF
	blr         x8
|$LN14@AsioResetT|

; 1938 :                 }
; 1939 :             }
; 1940 :             if (self->m_isRequireLatencyChange)

	ldrb        w8,[x19,#0xB9C]
	cbz         w8,|$LN16@AsioResetT|

; 1941 :             {
; 1942 :                 self->m_isRequireLatencyChange = false;
; 1943 :                 if (self->m_callbacks != nullptr && self->m_callbacks->asioMessage != nullptr)

	ldr         x8,[x19,#0x30]
	strb        wzr,[x19,#0xB9C]
	cbz         x8,|$LN16@AsioResetT|
	ldr         x8,[x8,#0x10]
	cbz         x8,|$LN16@AsioResetT|

; 1944 :                 {
; 1945 :                     info_print_("AsioResetThread: latency change callback.\n");
; 1946 :                     self->m_callbacks->asioMessage(kAsioLatenciesChanged, 0, nullptr, nullptr);

	mov         x3,#0
	mov         x2,#0
	mov         w1,#0
	mov         w0,#6
	blr         x8
|$LN16@AsioResetT|

; 1947 :                 }
; 1948 :             }
; 1949 :             if (self->m_isRequireAsioReset)

	ldrb        w8,[x19,#0xB98]
	cbz         w8,|$LL4@AsioResetT|

; 1950 :             {
; 1951 :                 self->m_isRequireAsioReset = false;

	strb        wzr,[x19,#0xB98]

; 1952 :                 ++resetQueue;

	add         w21,w21,#1

; 1953 :             }
; 1954 :             break;
; 1955 :         case WAIT_TIMEOUT:
; 1956 :             break;
; 1957 :         default:
; 1958 :             done = true;
; 1959 :             break;
; 1960 :         }
; 1961 :     } while (!done);

	b           |$LL4@AsioResetT|

	ENDP  ; |?AsioResetThread@CUSBAsio@@CAIPEAX@Z|, CUSBAsio::AsioResetThread

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$0@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| PROC ; `CUSBAsio::AsioResetThread'::`1'::dtor$0
	stp         fp,lr,[sp,#-0x10]!
	mov         x0,x23
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?AsioResetThread@CUSBAsio@@CAIPEAX@Z|, CUSBAsio::AsioResetThread

; Function compile flags: /Ogtp

	AREA	|.text$x|, DATA

|?dtor$1@?0??AsioResetThread@CUSBAsio@@CAIPEAX@Z@4HA| PROC ; `CUSBAsio::AsioResetThread'::`1'::dtor$1
	stp         fp,lr,[sp,#-0x10]!
	mov         x0,x23
	bl          |??1?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@XZ|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?AsioResetThread@CUSBAsio@@CAIPEAX@Z|, CUSBAsio::AsioResetThread

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?ThreadStart@CUSBAsio@@AEAAXXZ| PROC			; CUSBAsio::ThreadStart

; 1970 : {

|$LN10|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0

; 1971 :     ResetEvent(m_stopEvent);

	adrp        x8,__imp_ResetEvent
	ldr         x8,[x8,__imp_ResetEvent]
	ldr         x0,[x19,#0xE58]
	blr         x8

; 1972 :     auto beginThreadResult = _beginthreadex(nullptr, 0, WorkerThread, this, 0, nullptr);

	adrp        x8,|?WorkerThread@CUSBAsio@@CAIPEAX@Z|
	add         x2,x8,|?WorkerThread@CUSBAsio@@CAIPEAX@Z|
	mov         x5,#0
	mov         w4,#0
	mov         x3,x19
	mov         w1,#0
	mov         x0,#0
	bl          _beginthreadex

; 1973 :     m_workerThread = (HANDLE)beginThreadResult;

	str         x0,[x19,#0xE60]

; 1974 :     if ((beginThreadResult > 0) && (m_threadPriority == -2))

	cbz         x0,|$LN8@ThreadStar|
	ldr         w8,[x19,#0xE68]
	cmn         w8,#2
	bne         |$LN8@ThreadStar|

; 1975 :     {
; 1976 :         SetThreadPriority(m_workerThread, THREAD_PRIORITY_TIME_CRITICAL);

	adrp        x8,__imp_SetThreadPriority
	ldr         x8,[x8,__imp_SetThreadPriority]
	mov         w1,#0xF
	blr         x8
|$LN8@ThreadStar|
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |?ThreadStart@CUSBAsio@@AEAAXXZ|, CUSBAsio::ThreadStart

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?ThreadStop@CUSBAsio@@AEAAXXZ| PROC			; CUSBAsio::ThreadStop

; 1982 : {

|$LN14|
	str         x19,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp
	mov         x19,x0

; 1983 :     DWORD status;
; 1984 :     SetEvent(m_stopEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE58]
	blr         x8

; 1985 :     if (m_workerThread != nullptr)

	ldr         x0,[x19,#0xE60]
	cbz         x0,|$LN12@ThreadStop|

; 1986 :     {
; 1987 :         DWORD timeout = (DWORD)(NOTIFICATION_TIMEOUT) * 2;
; 1988 :         status = WaitForSingleObject(m_workerThread, timeout);

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	mov         w1,#0x1770
	blr         x8

; 1989 :         if (status == WAIT_OBJECT_0)

	cbnz        w0,|$LN3@ThreadStop|

; 1990 :         {
; 1991 :             CloseHandle(m_workerThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE60]
	blr         x8

; 2004 :         }
; 2005 :         else
; 2006 :         {
; 2007 :             error_print_("wait timeout.\n");
; 2008 :         }
; 2009 :     }
; 2010 :     m_workerThread = nullptr;

	str         xzr,[x19,#0xE60]
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret
|$LN3@ThreadStop|

; 1992 :         }
; 1993 :         else if (status == WAIT_TIMEOUT)

	cmp         w0,#0x102
	bne         |$LN12@ThreadStop|

; 1994 :         {
; 1995 :             error_print_("wait timouut. force terminating worker thread.");
; 1996 :             // Understanding that there is an issue, preventing proper cleanup, call TerminateThread.
; 1997 :             // TerminateThread(m_workerThread, 0);
; 1998 : 
; 1999 :             // Implemented without using TerminateThread.
; 2000 :             // If the thread does not exit within the timeout, it will be forcibly terminated by the OS when the application exits.
; 2001 : 
; 2002 :             CloseHandle(m_workerThread);

	adrp        x8,__imp_CloseHandle
	ldr         x8,[x8,__imp_CloseHandle]
	ldr         x0,[x19,#0xE60]
	blr         x8

; 2003 :             InterlockedDecrement(&g_WorkerThread);

	adrp        x8,|?g_WorkerThread@@3JA|
	add         x0,x8,|?g_WorkerThread@@3JA|
	bl          _InterlockedDecrement
|$LN12@ThreadStop|

; 2004 :         }
; 2005 :         else
; 2006 :         {
; 2007 :             error_print_("wait timeout.\n");
; 2008 :         }
; 2009 :     }
; 2010 :     m_workerThread = nullptr;

	str         xzr,[x19,#0xE60]
	ldp         fp,lr,[sp],#0x10
	ldr         x19,[sp],#0x10
	ret

	ENDP  ; |?ThreadStop@CUSBAsio@@AEAAXXZ|, CUSBAsio::ThreadStop

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

	AREA	|.text$mn|, CODE, ARM64

|?WorkerThread@CUSBAsio@@CAIPEAX@Z| PROC		; CUSBAsio::WorkerThread

; 2015 : {

|$LN198|
	stp         fp,lr,[sp,#-0x60]!
	stp         x19,x20,[sp,#0x10]
	stp         x21,x22,[sp,#0x20]
	stp         x23,x24,[sp,#0x30]
	stp         x25,x26,[sp,#0x40]
	stp         x27,x28,[sp,#0x50]
	mov         fp,sp
	bl          __security_push_cookie
	sub         sp,sp,#0x120
	mov         x19,x0

; 2016 :     CUSBAsio *                            self = (CUSBAsio *)param;
; 2017 :     volatile UAC_ASIO_REC_BUFFER_HEADER * recHdr = (volatile UAC_ASIO_REC_BUFFER_HEADER *)self->m_driverRecBuffer;
; 2018 :     ULONG                                 wakeup = 0;
; 2019 :     DWORD                                 status = 0;
; 2020 :     bool                                  done = false;
; 2021 : 
; 2022 : #ifdef ASIO_THREAD_STATISTICS
; 2023 :     static const ULONG statsSize = 120000;
; 2024 :     ULONG              statsPos = 0;
; 2025 : 
; 2026 :     typedef struct ASIO_STATISTICS_
; 2027 :     {
; 2028 :         double dueTime;
; 2029 :     } ASIO_STATISTICS, *PASIO_STATISTICS;
; 2030 : 
; 2031 :     PASIO_STATISTICS stats = new ASIO_STATISTICS[statsSize];

	mov         x0,#0xA600
	movk        x0,#0xE,lsl #0x10
	ldr         x20,[x19,#0xE30]
	mov         w27,#0
	mov         w23,#0
	bl          |??_U@YAPEAX_K@Z|

; 2032 : 
; 2033 :     LARGE_INTEGER performanceFreq = {0};

	str         xzr,[sp,#0xD8]

; 2034 :     QueryPerformanceFrequency(&performanceFreq);

	adrp        x8,__imp_QueryPerformanceFrequency
	ldr         x8,[x8,__imp_QueryPerformanceFrequency]
	mov         x28,x0
	add         x0,sp,#0xD8
	blr         x8

; 2035 : 
; 2036 :     ULONGLONG lastAsioCallbackPC = {0};
; 2037 : 
; 2038 : #if defined(INFO_PRINT_)
; 2039 :     double idealPeriod = (double)(self->m_blockFrames * 1000000) / self->m_sampleRate;
; 2040 : #endif
; 2041 : #endif
; 2042 : 
; 2043 :     UAC_ASIO_REC_BUFFER_HEADER curHdr = {0};
; 2044 :     UAC_ASIO_REC_BUFFER_HEADER prevHdr = {0};
; 2045 :     prevHdr.RecBufferPosition = 0 - self->m_blockFrames;

	ldr         w8,[x19,#0xAF0]
	mov         x24,#0
	neg         w8,w8
	sxtw        x22,w8

; 2046 : 
; 2047 :     InterlockedIncrement(&g_WorkerThread);

	adrp        x8,|?g_WorkerThread@@3JA|
	add         x0,x8,|?g_WorkerThread@@3JA|
	str         x22,[sp,#0x98]
	bl          _InterlockedIncrement

; 2048 : 
; 2049 :     info_print_("entering worker thread instance %d.\n", InterlockedCompareExchange(&g_WorkerThread, 0, 0));
; 2050 : 
; 2051 :     HANDLE handlesForWait[] = {self->m_stopEvent, self->m_notificationEvent};

	ldr         x8,[x19,#0xE40]

; 2052 : 
; 2053 :     DWORD taskIndex = 0;

	str         wzr,[sp,#0xD0]
	ldr         x9,[x19,#0xE58]
	stp         x9,x8,[sp,#0x110]

; 2054 :     if (self->m_threadPriority != -2)

	ldr         w8,[x19,#0xE68]
	cmn         w8,#2
	beq         |$LN15@WorkerThre|

; 2055 :     {
; 2056 :         HANDLE hTask = AvSetMmThreadCharacteristics(TEXT("Pro Audio"), &taskIndex);

	adrp        x8,|??_C@_09FJFDCAPM@Pro?5Audio@|
	add         x0,x8,|??_C@_09FJFDCAPM@Pro?5Audio@|
	adrp        x8,__imp_AvSetMmThreadCharacteristicsA
	ldr         x8,[x8,__imp_AvSetMmThreadCharacteristicsA]
	add         x1,sp,#0xD0
	blr         x8

; 2057 :         AvSetMmThreadPriority(hTask, (AVRT_PRIORITY)self->m_threadPriority);

	adrp        x8,__imp_AvSetMmThreadPriority
	ldr         x8,[x8,__imp_AvSetMmThreadPriority]
	ldr         w1,[x19,#0xE68]
	blr         x8
|$LN15@WorkerThre|

; 2058 :         info_print_("call AvSetMmThreadPriority %d.\n", self->m_threadPriority);
; 2059 :     }
; 2060 : 
; 2061 :     self->BufferSwitch();

	mov         x0,x19
	bl          |?BufferSwitch@CUSBAsio@@QEAAXXZ|

; 2062 : 
; 2063 :     Sleep(self->m_blockFrames / 1000 / self->m_audioProperty.SampleRate);

	ldr         w8,[x19,#0xAF0]
	mov         w21,#0x4DD3
	movk        w21,#0x1062,lsl #0x10
	smull       x8,w8,w21
	lsr         x8,x8,#0x20
	asr         w8,w8,#6
	add         w9,w8,w8,lsr #0x1F
	ldr         w8,[x19,#0xCBC]
	cbnz        w8,|$LN193@WorkerThre|
	brk         #0xF004
|$LN193@WorkerThre|
	udiv        w0,w9,w8
	adrp        x8,__imp_Sleep
	ldr         x8,[x8,__imp_Sleep]
	blr         x8

; 2064 : 
; 2065 :     self->BufferSwitch();

	mov         x0,x19
	bl          |?BufferSwitch@CUSBAsio@@QEAAXXZ|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBDevice.cpp

; 391  :     privateProperty.Set = KSPROPSETID_LowLatencyAudio;

	adrp        x8,KSPROPSETID_LowLatencyAudio
	add         x8,x8,KSPROPSETID_LowLatencyAudio
	ldr         q16,[x8]

; 392  :     privateProperty.Flags = KSPROPERTY_TYPE_SET;
; 393  :     privateProperty.Id = toInt(KsPropertyUACLowLatencyAudio::StartAsioStream);

	mov         x8,#9
	movk        x8,#2,lsl #0x20
	str         wzr,[sp,#0xD4]

; 394  : 
; 395  :     result = DeviceIoControl(deviceHandle, IOCTL_KS_PROPERTY, &privateProperty, sizeof(KSPROPERTY), nullptr, 0, &bytesReturned, nullptr);

	ldr         x0,[x19,#0xBA8]
	mov         x7,#0
	str         x8,[sp,#0x100]
	adrp        x8,__imp_DeviceIoControl
	ldr         x8,[x8,__imp_DeviceIoControl]
	add         x6,sp,#0xD4
	str         q16,[sp,#0xF0]
	mov         w5,#0
	mov         x4,#0
	mov         w3,#0x18
	add         x2,sp,#0xF0
	mov         w1,#3
	movk        w1,#0x2F,lsl #0x10
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2069 :     DWORD timeout = NOTIFICATION_TIMEOUT;

	mov         w25,#0xBB8

; 2070 : 
; 2071 :     recHdr->CallbackRemain = 0;

	str         wzr,[x20,#0x48]
	mov         w26,#1
|$LL4@WorkerThre|

; 2072 : 
; 2073 :     do
; 2074 :     {
; 2075 :         bool setAsioResetEvent = false;
; 2076 :         status = WaitForMultipleObjects(sizeof(handlesForWait) / sizeof(handlesForWait[0]), handlesForWait, FALSE, timeout);

	adrp        x8,__imp_WaitForMultipleObjects
	ldr         x8,[x8,__imp_WaitForMultipleObjects]
	mov         w3,w25
	mov         w2,#0
	add         x1,sp,#0x110
	mov         w0,#2
	mov         w21,#0
	blr         x8

; 2077 :         switch (status)

	cbz         w0,|$LN190@WorkerThre|
	cmp         w0,#1
	beq         |$LN17@WorkerThre|

; 2209 :                 ++wakeup;
; 2210 :             }
; 2211 :             break;
; 2212 :         default:
; 2213 :             // If no notification is received from the kernel driver after waiting for a certain period of time,
; 2214 :             // it is assumed that an error has occurred, the thread is terminated, and the application is prompted to reset.
; 2215 :             if (timeout == NOTIFICATION_TIMEOUT)

	cmp         w25,#0xBB8
	bne         |$LN38@WorkerThre|

; 2216 :             {
; 2217 :                 error_print_("wait timeout. requesting reset.\n");
; 2218 :                 error_print_("cur  hdr PC%7u PB%7u RC%7u RB%7u\n", recHdr->PlayCurrentPosition, recHdr->PlayBufferPosition, recHdr->RecCurrentPosition, recHdr->RecBufferPosition);
; 2219 :                 self->m_isRequireAsioReset = true;
; 2220 :                 setAsioResetEvent = true;
; 2221 :                 timeout = self->m_blockFrames / 1000 / self->m_audioProperty.SampleRate;

	ldr         w9,[x19,#0xAF0]
	mov         w8,#0x4DD3
	movk        w8,#0x1062,lsl #0x10
	strb        w26,[x19,#0xB98]
	mov         w21,#1
	smull       x8,w9,w8
	lsr         x8,x8,#0x20
	asr         w8,w8,#6
	add         w9,w8,w8,lsr #0x1F
	ldr         w8,[x19,#0xCBC]
	cbnz        w8,|$LN194@WorkerThre|
	brk         #0xF004
|$LN194@WorkerThre|
	udiv        w25,w9,w8
|$LN38@WorkerThre|

; 2222 :             }
; 2223 :             self->BufferSwitch();

	mov         x0,x19
	bl          |?BufferSwitch@CUSBAsio@@QEAAXXZ|
	b           |$LN5@WorkerThre|
|$LN17@WorkerThre|

; 2078 :         {
; 2079 :         case WAIT_OBJECT_0:
; 2080 :             done = true;
; 2081 :             break;
; 2082 :         case WAIT_OBJECT_0 + 1:
; 2083 :             memcpy(&curHdr, (void *)recHdr, sizeof(curHdr)); // Explicit copy

	ldp         q17,q16,[x20]
	stp         q17,q16,[sp,#0x10]
	ldp         q17,q16,[x20,#0x20]

; 2084 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::ClockSourceChanged)) != 0)

	ldr         w10,[sp,#0x14]
	stp         q17,q16,[sp,#0x30]
	tbz         w10,#2,|$LN172@WorkerThre|

; 2085 :             {
; 2086 :                 info_print_("clock source change detected, new %u.\n", curHdr.CurrentClockSource);
; 2087 :                 self->m_asioTime.timeInfo.flags |= kClockSourceChanged;

	ldr         w8,[x19,#0x68]
	orr         w8,w8,#0x20
	str         w8,[x19,#0x68]

; 2088 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ClockSourceChanged));

	ldr         w8,[x20,#4]
	and         w8,w8,#0xFFFFFFFB
	str         w8,[x20,#4]
|$LN172@WorkerThre|

; 2089 :             }
; 2090 :             if (((curHdr.DeviceStatus & toInt(DeviceStatuses::SampleRateChanged)) != 0 && curHdr.CurrentSampleRate != 0) ||

	ldr         w9,[sp,#0x18]
	tbz         w10,#1,|$LN21@WorkerThre|
	cbnz        w9,|$LN173@WorkerThre|
|$LN21@WorkerThre|
	ldr         d16,[x19,#0x28]
	fcvtzu      w8,d16
	cmp         w9,w8
	beq         |$LN19@WorkerThre|
|$LN173@WorkerThre|

; 2091 :                 (curHdr.CurrentSampleRate != (ULONG)self->m_sampleRate))
; 2092 :             {
; 2093 :                 info_print_("sample rate change detected, old %u, new %u.\n", self->m_audioProperty.SampleRate, curHdr.CurrentSampleRate);
; 2094 :                 self->m_asioTime.timeInfo.flags |= kSampleRateChanged;
; 2095 :                 self->m_requireSampleRateChange = true;
; 2096 :                 self->m_nextSampleRate = (ASIOSampleRate)curHdr.CurrentSampleRate;

	ucvtf       d16,w9
	ldr         w8,[x19,#0x68]
	strb        w26,[x19,#0xB8C]

; 2097 :                 setAsioResetEvent = true;

	mov         w21,#1
	orr         w8,w8,#0x10
	str         w8,[x19,#0x68]
	str         d16,[x19,#0xB90]

; 2098 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::SampleRateChanged));

	ldr         w8,[x20,#4]
	and         w8,w8,#0xFFFFFFFD
	str         w8,[x20,#4]
|$LN19@WorkerThre|

; 2099 :             }
; 2100 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::OverloadDetected)) != 0)

	tbz         w10,#3,|$LN22@WorkerThre|

; 2101 :             {
; 2102 :                 info_print_("overload detected.\n");
; 2103 :                 self->m_isRequireReportDropout = true;

	strb        w26,[x19,#0xB9B]

; 2104 :                 setAsioResetEvent = true;
; 2105 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::OverloadDetected));

	ldr         w8,[x20,#4]
	mov         w21,#1
	and         w8,w8,#0xFFFFFFF7
	str         w8,[x20,#4]
|$LN22@WorkerThre|

; 2106 :             }
; 2107 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::LatencyChanged)) != 0)

	tbz         w10,#4,|$LN23@WorkerThre|

; 2108 :             {
; 2109 :                 info_print_("latency change detected.\n");
; 2110 :                 self->m_isRequireLatencyChange = true;

	strb        w26,[x19,#0xB9C]

; 2111 :                 setAsioResetEvent = true;
; 2112 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::LatencyChanged));

	ldr         w8,[x20,#4]
	mov         w21,#1
	and         w8,w8,#0xFFFFFFEF
	str         w8,[x20,#4]
|$LN23@WorkerThre|

; 2113 :             }
; 2114 :             if ((curHdr.DeviceStatus & toInt(DeviceStatuses::ResetRequired)) != 0 ||

	tbnz        w10,#0,|$LN25@WorkerThre|
	ldr         d16,[x19,#0x28]
	fcvtzu      w8,d16
	cmp         w9,w8
	beq         |$LN24@WorkerThre|
|$LN25@WorkerThre|

; 2115 :                 (curHdr.CurrentSampleRate != (ULONG)self->m_sampleRate))
; 2116 :             {
; 2117 :                 info_print_("reset request detected.\n");
; 2118 :                 self->m_isRequireAsioReset = true;

	strb        w26,[x19,#0xB98]

; 2119 :                 setAsioResetEvent = true;
; 2120 :                 // To prevent "Ableton Live" from hanging, callbacks will be processed even after a reset request.
; 2121 :                 recHdr->DeviceStatus &= ~((ULONG)toInt(DeviceStatuses::ResetRequired));

	ldr         w8,[x20,#4]
	mov         w21,#1
	and         w8,w8,#0xFFFFFFFE
	str         w8,[x20,#4]
|$LN24@WorkerThre|

; 2122 :             }
; 2123 :             if (self->m_outputReadyBlock)

	ldr         w8,[x19,#0xBA0]
	cbz         w8,|$LN174@WorkerThre|

; 2124 :             {
; 2125 :                 if (WaitForSingleObject(&self->m_outputReadyBlockEvent, NOTIFICATION_TIMEOUT) == WAIT_TIMEOUT)

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	mov         w1,#0xBB8
	add         x0,x19,#0xE88
	blr         x8
	cmp         w0,#0x102
	bne         |$LN174@WorkerThre|

; 2126 :                 {
; 2127 :                     done = true;

	mov         w27,#1

; 2128 :                     break;

	b           |$LN5@WorkerThre|
|$LN174@WorkerThre|

; 2129 :                 }
; 2130 :             }
; 2131 :             {
; 2132 :                 LONG positionDiff = (LONG)(curHdr.RecBufferPosition - prevHdr.RecBufferPosition);

	ldr         x8,[sp,#0x38]
	sub         w9,w8,w22

; 2133 :                 LONG iteration = positionDiff / self->m_blockFrames;

	ldr         w8,[x19,#0xAF0]
	cbnz        w8,|$LN195@WorkerThre|
	brk         #0xF004
|$LN195@WorkerThre|
	sdiv        w22,w9,w8

; 2134 :                 if (iteration > 3)

	cmp         w22,#3
	ble         |$LL180@WorkerThre|

; 2135 :                 {
; 2136 :                     SetEvent(self->m_asioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE70]
	blr         x8

; 2137 :                     iteration %= 2;

	add         w8,w22,w22,lsr #0x1F
	asr         w8,w8,#1
	sub         w22,w22,w8,lsl #1
|$LL180@WorkerThre|
	str         w25,[sp,#4]
	mov         w26,#0xD4C0
	movk        w26,#1,lsl #0x10
	strb        w27,[sp,#1]
	ldr         x25,|$LN197@WorkerThre|
	mov         x27,#0x4240
	movk        x27,#0xF,lsl #0x10
	strb        w21,[sp]
|$LN7@WorkerThre|

; 2138 :                 }
; 2139 :                 while (iteration > 0)

	cmp         w22,#0
	ble         |$LN186@WorkerThre|

; 2140 :                 {
; 2141 :                     self->m_playReadyPosition = recHdr->RecBufferPosition;

	ldr         x8,[x20,#0x28]
	str         x8,[x19,#0xE38]

; 2142 :                     recHdr->PlayReadyPosition = self->m_playReadyPosition;

	str         x8,[x20,#0x30]

; 2143 : #ifdef ASIO_THREAD_STATISTICS
; 2144 :                     if (performanceFreq.QuadPart != 0)

	ldr         x8,[sp,#0xD8]
	cbz         x8,|$LN29@WorkerThre|

; 2145 :                     {
; 2146 :                         LARGE_INTEGER currentPC = {0};
; 2147 :                         QueryPerformanceCounter(&currentPC);

	adrp        x8,__imp_QueryPerformanceCounter
	ldr         x8,[x8,__imp_QueryPerformanceCounter]
	add         x0,sp,#0xE0
	str         xzr,[sp,#0xE0]
	blr         x8

; 2150 : 
; 2151 :                         if (lastAsioCallbackPC != 0 && statsPos < statsSize)

	cmp         w23,w26
	ldr         x9,[sp,#0xE0]
	ccmplo      x24,#0,#4
	beq         |$LN30@WorkerThre|

; 2148 : 
; 2149 :                         double measuredPeriod = (double)((currentPC.QuadPart - lastAsioCallbackPC) * 1000000) / (double)(performanceFreq.QuadPart);

	sub         x8,x9,x24
	mul         x8,x8,x27
	ucvtf       d17,x8
	ldr         x8,[sp,#0xD8]
	scvtf       d16,x8
	fdiv        d16,d17,d16

; 2152 :                         {
; 2153 :                             stats[statsPos].dueTime = measuredPeriod;

	str         d16,[x28,w23 uxtw #3]

; 2154 :                             ++statsPos;

	add         w23,w23,#1
|$LN30@WorkerThre|

; 2155 :                         }
; 2156 : 
; 2157 :                         lastAsioCallbackPC = currentPC.QuadPart;

	mov         x24,x9
|$LN29@WorkerThre|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2163 :                         auto lockRecBuffer = self->m_recBufferCS.lock();

	add         x21,x19,#0xDF8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	mov         x0,x21
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2164 :                         outputReady = InterlockedExchange((LONG *)&recHdr->OutputReady, toInt(UserThreadStatuses::BufferStart));

	mov         w1,#2
	add         x0,x20,#0x40
	bl          _InterlockedExchange

; 2165 :                         readyBuffers = InterlockedIncrement(&recHdr->ReadyBuffers);

	add         x0,x20,#0x44
	bl          _InterlockedIncrement
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN97@WorkerThre|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
|$LN97@WorkerThre|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2167 :                     if (self->m_initialSystemTime == 0)

	ldr         w8,[x19,#0x8D8]
	cbnz        w8,|$LN31@WorkerThre|

; 2168 :                     {
; 2169 :                         self->m_initialSystemTime = timeGetTime();

	adrp        x8,__imp_timeGetTime
	ldr         x8,[x8,__imp_timeGetTime]
	blr         x8
	str         w0,[x19,#0x8D8]

; 2170 :                         self->m_initialKernelTime = recHdr->NotifySystemTime;

	ldr         x8,[x20,#0x38]
	str         x8,[x19,#0x8E0]

; 2171 :                     }

	b           |$LN32@WorkerThre|
|$LN31@WorkerThre|

; 2172 :                     else
; 2173 :                     {
; 2174 :                         self->m_calculatedSystemTime = self->m_initialSystemTime +

	ldr         x9,[x19,#0x8E0]
	ldr         x8,[x20,#0x38]
	sub         x8,x8,x9
	umulh       x9,x8,x25
	sub         x8,x8,x9
	add         x8,x9,x8,lsr #1
	lsr         x9,x8,#9
	ldr         w8,[x19,#0x8D8]
	add         w8,w9,w8
	str         w8,[x19,#0x8DC]
|$LN32@WorkerThre|

; 2175 :                                                        (DWORD)((recHdr->NotifySystemTime - self->m_initialKernelTime) / 1000);
; 2176 :                     }
; 2177 :                     InterlockedIncrement(&recHdr->AsioProcessStart);

	add         x0,x20,#0x4C
	bl          _InterlockedIncrement

; 2178 :                     self->BufferSwitch();

	mov         x0,x19
	bl          |?BufferSwitch@CUSBAsio@@QEAAXXZ|

; 2179 :                     InterlockedIncrement(&recHdr->AsioProcessComplete);

	add         x0,x20,#0x50
	bl          _InterlockedIncrement
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 3354 :     ::EnterCriticalSection(pcs);

	adrp        x8,__imp_EnterCriticalSection
	ldr         x8,[x8,__imp_EnterCriticalSection]
	mov         x0,x21
	blr         x8
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2182 :                         outputReady = InterlockedExchange(&recHdr->OutputReady, toInt(UserThreadStatuses::BufferStart) | toInt(UserThreadStatuses::BufferEnd) | toInt(UserThreadStatuses::OutputReady));

	mov         w1,#7
	add         x0,x20,#0x40
	bl          _InterlockedExchange

; 2183 :                         if (self->m_outputReadyBlock && (!(outputReady & toInt(UserThreadStatuses::OutputReady))) && (outputReady & toInt(UserThreadStatuses::BufferStart)))

	ldr         w8,[x19,#0xBA0]
	cbz         w8,|$LN33@WorkerThre|
	tbnz        w0,#0,|$LN33@WorkerThre|
	tbz         w0,#1,|$LN33@WorkerThre|

; 2184 :                         {
; 2185 :                             InterlockedOr(&recHdr->OutputReady, toInt(UserThreadStatuses::OutputReadyDelay));

	mov         w1,#8
	add         x0,x20,#0x40
	bl          _InterlockedOr

; 2186 :                             SetEvent(self->m_outputReadyEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE48]
	blr         x8
|$LN33@WorkerThre|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x21,|$LN61@WorkerThre|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	mov         x0,x21
	blr         x8
|$LN61@WorkerThre|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 2189 :                     --iteration;

	sub         w22,w22,#1

; 2190 :                     if (iteration == 0)

	cbz         w22,|$LN186@WorkerThre|

; 2191 :                     {
; 2192 :                         break;
; 2193 :                     }
; 2194 :                     error_print_("out of sync, ASIO callback iteration %u, sleep %u(ms).\n", iteration, self->m_blockFrames * 500 / (LONG)(self->m_sampleRate));
; 2195 :                     error_print_("prev hdr PC%7u PB%7u RC%7u RB%7u\n", prevHdr.PlayCurrentPosition, prevHdr.PlayBufferPosition, prevHdr.RecCurrentPosition, prevHdr.RecBufferPosition);
; 2196 :                     error_print_("cur  hdr PC%7u PB%7u RC%7u RB%7u REB%7u\n", curHdr.PlayCurrentPosition, curHdr.PlayBufferPosition, curHdr.RecCurrentPosition, curHdr.RecBufferPosition, readyBuffers);
; 2197 :                     status = WaitForSingleObject(self->m_stopEvent, 0);

	adrp        x8,__imp_WaitForSingleObject
	ldr         x8,[x8,__imp_WaitForSingleObject]
	ldr         x0,[x19,#0xE58]
	mov         w1,#0
	blr         x8

; 2198 :                     if (status == WAIT_TIMEOUT)

	cmp         w0,#0x102
	beq         |$LN7@WorkerThre|

; 2199 :                     {
; 2200 :                         continue;
; 2201 :                     }
; 2202 :                     else
; 2203 :                     {
; 2204 :                         done = true;

	mov         w27,#1
	b           |$LN191@WorkerThre|
|$LN186@WorkerThre|

; 2205 :                         break;
; 2206 :                     }
; 2207 :                 }
; 2208 :                 prevHdr = curHdr;

	ldrb        w27,[sp,#1]
|$LN191@WorkerThre|
	ldp         q17,q16,[sp,#0x10]
	mov         w26,#1
	ldr         w25,[sp,#4]
	ldrb        w21,[sp]
	stp         q17,q16,[sp,#0x70]
	ldp         q17,q16,[sp,#0x30]
	stp         q17,q16,[sp,#0x90]
	ldr         x22,[sp,#0x98]
|$LN5@WorkerThre|

; 2224 :             break;
; 2225 :         }
; 2226 :         if (setAsioResetEvent)

	cbz         w21,|$LN2@WorkerThre|

; 2227 :         {
; 2228 :             SetEvent(self->m_asioResetEvent);

	adrp        x8,__imp_SetEvent
	ldr         x8,[x8,__imp_SetEvent]
	ldr         x0,[x19,#0xE70]
	blr         x8
|$LN2@WorkerThre|

; 2229 :         }
; 2230 :     } while (!done);

	cbz         w27,|$LL4@WorkerThre|
|$LN190@WorkerThre|

; 2231 :     info_print_("exiting worker thread...\n");
; 2232 : #ifdef ASIO_THREAD_STATISTICS
; 2233 :     if (statsPos != 0)
; 2234 :     {
; 2235 :         double dueTimeTotal = 0;
; 2236 :         for (ULONG i = 0; i < statsPos; ++i)
; 2237 :         {
; 2238 :             dueTimeTotal += stats[i].dueTime;
; 2239 :         }
; 2240 :         double dueTimeAvg = dueTimeTotal / (double)statsPos;
; 2241 :         double dueTimeVar = 0;
; 2242 :         double dueTimeMax = 0;
; 2243 :         double dueTimeMin = 60000000;
; 2244 :         for (ULONG i = 0; i < statsPos; ++i)
; 2245 :         {
; 2246 :             dueTimeVar += pow(stats[i].dueTime - dueTimeAvg, 2);
; 2247 :             if (dueTimeMax < stats[i].dueTime)
; 2248 :             {
; 2249 :                 dueTimeMax = stats[i].dueTime;
; 2250 :             }
; 2251 :             if (dueTimeMin > stats[i].dueTime)
; 2252 :             {
; 2253 :                 dueTimeMin = stats[i].dueTime;
; 2254 :             }
; 2255 :         }
; 2256 :         dueTimeVar /= (double)(statsPos);
; 2257 : #if defined(INFO_PRINT_)
; 2258 :         double dueTimeStddev = sqrt(dueTimeVar);
; 2259 : #endif
; 2260 :         info_print_("- ASIO Callback %5u(times), DueTime Calc %5d(us), Avg %5d(us), Stddev %5d(us), Max %5d(us), Min %5d(us)\n", statsPos, (LONG)idealPeriod, (LONG)dueTimeAvg, (LONG)dueTimeStddev, (LONG)dueTimeMax, (LONG)dueTimeMin);
; 2261 :     }
; 2262 :     delete[] stats;

	mov         x0,x28
	bl          |??_V@YAXPEAX@Z|

; 2263 : #endif
; 2264 :     InterlockedDecrement(&g_WorkerThread);

	adrp        x8,|?g_WorkerThread@@3JA|
	add         x0,x8,|?g_WorkerThread@@3JA|
	bl          _InterlockedDecrement

; 2265 :     return 0;

	mov         w0,#0
	add         sp,sp,#0x120
	bl          __security_pop_cookie
	ldp         x27,x28,[sp,#0x50]
	ldp         x25,x26,[sp,#0x40]
	ldp         x23,x24,[sp,#0x30]
	ldp         x21,x22,[sp,#0x20]
	ldp         x19,x20,[sp,#0x10]
	ldp         fp,lr,[sp],#0x60
	ret
	nop
|$LN197@WorkerThre|
	DCQ         0x624dd2f1a9fbe77

	ENDP  ; |?WorkerThread@CUSBAsio@@CAIPEAX@Z|, CUSBAsio::WorkerThread

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

	AREA	|.text$mn|, CODE, ARM64

|??$assign_to_opt_param@I@wil@@YAXPEAII@Z| PROC		; wil::assign_to_opt_param<unsigned int>

; 645  :     if (outParam != nullptr)

	cbz         x0,|$LN8@assign_to_|

; 646  :     {
; 647  :         *outParam = val;

	str         wzr,[x0]
|$LN8@assign_to_|
	ret

	ENDP  ; |??$assign_to_opt_param@I@wil@@YAXPEAII@Z|, wil::assign_to_opt_param<unsigned int>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z| PROC ; wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>

; 1699 :     {

|$LN8|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 1700 :         return reinterpret_cast<FuncPtr>(reinterpret_cast<void (*)()>(::GetProcAddress(module, procName)));

	adrp        x8,|??_C@_0BH@EEDPADAA@RaiseFailFastException@|
	add         x1,x8,|??_C@_0BH@EEDPADAA@RaiseFailFastException@|
	adrp        x8,__imp_GetProcAddress
	ldr         x8,[x8,__imp_GetProcAddress]
	blr         x8
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??$GetProcAddress@P6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@Z@details@wil@@YAP6AXPEAU_EXCEPTION_RECORD@@PEAU_CONTEXT@@K@ZPEAUHINSTANCE__@@PEBD@Z|, wil::details::GetProcAddress<void (__cdecl*)(_EXCEPTION_RECORD *,_CONTEXT *,unsigned long)>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z| PROC ; wil::details::WriteResultString<wchar_t const *>

; 3036 :     {

|$LN27|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         x19,x0

; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x1
	ccmpne      x2,#0,#4
	mov         x20,x3
	beq         |$LN3@WriteResul|
	ldrh        w8,[x2]
	cbz         w8,|$LN3@WriteResul|

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	mov         x8,x2
	ldrsh       w9,[x8]
	cbz         w9,|$LN25@WriteResul|
|$LL24@WriteResul|
	ldrsh       w9,[x8,#2]!
	cbnz        w9,|$LL24@WriteResul|
|$LN25@WriteResul|
	sub         x8,x8,x2
	asr         x8,x8,#1
	add         x8,x8,#1

; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x1,x19

; 3024 :         return (psz == nullptr) ? sizeof(wchar_t) : (wcslen(psz) + 1) * sizeof(wchar_t);

	str         x8,[sp,#0x10]

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x8,lsl #1
	blo         |$LN3@WriteResul|

; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	lsl         x3,x8,#1
	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x20,|$LN17@WriteResul|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x20]
|$LN17@WriteResul|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	ldr         x8,[sp,#0x10]
	add         x0,x19,x8,lsl #1
	ldp         fp,lr,[sp],#0x20
	ldp         x19,x20,[sp],#0x10
	ret
|$LN3@WriteResul|

; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;

	cbz         x20,|$LN7@WriteResul|
	str         xzr,[x20]
|$LN7@WriteResul|
	mov         x0,x19
	ldp         fp,lr,[sp],#0x20
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |??$WriteResultString@PEB_W@details@wil@@YAPEAEPEAE0PEB_WPEAPEB_W@Z|, wil::details::WriteResultString<wchar_t const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

	AREA	|.text$mn|, CODE, ARM64

|??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z| PROC ; wil::details::WriteResultString<char const *>

; 3036 :     {

|$LN27|
	stp         x19,x20,[sp,#-0x10]!
	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         x19,x0

; 3037 :         // No space? Null string? Do nothing.
; 3038 :         if ((pStart == pEnd) || !pszString || !*pszString)

	cmp         x19,x1
	ccmpne      x2,#0,#4
	mov         x20,x3
	beq         |$LN3@WriteResul|
	ldrsb       w8,[x2]
	cbz         w8,|$LN3@WriteResul|

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	mov         x8,x2
	ldrsb       w9,[x8]
	cbz         w9,|$LN25@WriteResul|
|$LL24@WriteResul|
	ldrsb       w9,[x8,#1]!
	cbnz        w9,|$LL24@WriteResul|
|$LN25@WriteResul|
	sub         x8,x8,x2
	add         x3,x8,#1

; 3042 :         }
; 3043 : 
; 3044 :         // Treats the range pStart--pEnd as a memory buffer into which pszString is copied. A pointer to
; 3045 :         // the start of the copied string is placed into ppszStringBuffer. If the buffer isn't big enough,
; 3046 :         // do nothing, and tell the caller nothing was written.
; 3047 :         size_t const stringSize = ResultStringSize(pszString);
; 3048 :         size_t const bufferSize = pEnd - pStart;

	sub         x1,x1,x19

; 3018 :         return (psz == nullptr) ? sizeof(char) : (strlen(psz) + sizeof(char));

	str         x3,[sp,#0x10]

; 3049 :         if (bufferSize < stringSize)

	cmp         x1,x3
	blo         |$LN3@WriteResul|

; 3050 :         {
; 3051 :             assign_null_to_opt_param(ppszBufferString);
; 3052 :             return pStart;
; 3053 :         }
; 3054 : 
; 3055 :         memcpy_s(pStart, bufferSize, pszString, stringSize);

	mov         x0,x19
	bl          memcpy_s
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

; 645  :     if (outParam != nullptr)

	cbz         x20,|$LN17@WriteResul|

; 646  :     {
; 647  :         *outParam = val;

	str         x19,[x20]
|$LN17@WriteResul|
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\result_macros.h

; 3060 :         return pStart + stringSize;

	ldr         x3,[sp,#0x10]
	add         x0,x3,x19
	ldp         fp,lr,[sp],#0x20
	ldp         x19,x20,[sp],#0x10
	ret
|$LN3@WriteResul|

; 3039 :         {
; 3040 :             assign_null_to_opt_param(ppszBufferString);
; 3041 :             return pStart;

	cbz         x20,|$LN7@WriteResul|
	str         xzr,[x20]
|$LN7@WriteResul|
	mov         x0,x19
	ldp         fp,lr,[sp],#0x20
	ldp         x19,x20,[sp],#0x10
	ret

	ENDP  ; |??$WriteResultString@PEBD@details@wil@@YAPEAEPEAE0PEBDPEAPEBD@Z|, wil::details::WriteResultString<char const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z| PROC ; wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	ldr         x8,[x1]
	str         x8,[x0]
	ret

	ENDP  ; |??$?0AEAPEAU_RTL_CRITICAL_SECTION@@$$V@?$unique_any_t@V?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@@wil@@QEAA@AEAPEAU_RTL_CRITICAL_SECTION@@@Z|, wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > >::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> > ><_RTL_CRITICAL_SECTION * &>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h

	AREA	|.text$mn|, CODE, ARM64

|??$forward@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z| PROC ; wistd::forward<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; 2506 : {

	ret

	ENDP  ; |??$forward@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z|, wistd::forward<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ| PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::~lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; 557  :         {

	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         xip0,#-2
	str         xip0,[fp,#0x10]

; 570  :             if (m_call)

	ldrb        w8,[x0,#0x18]
	cbz         w8,|$LN11@lambda_cal|

; 571  :             {
; 572  :                 m_call = false;

	strb        wzr,[x0,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	ldr         x8,[x0]
	ldr         w8,[x8]
	cbz         w8,|$LN11@lambda_cal|
	ldr         x8,[x0,#8]
	ldrb        w8,[x8]
	cbz         w8,|$LN11@lambda_cal|

; 896  :         {
; 897  :             disposeBuffers();

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#0xA0]
	blr         x8
	nop
|$LN11@lambda_cal|
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |??1?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@XZ|, wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::~lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??0?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z| PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; 543  :         explicit lambda_call(TLambda&& lambda) WI_NOEXCEPT : m_lambda(wistd::move(lambda))

	ldr         q16,[x1]
	str         q16,[x0]
	ldr         x8,[x1,#0x10]
	str         x8,[x0,#0x10]

; 550  : 
; 551  :         lambda_call(lambda_call&& other) WI_NOEXCEPT : m_lambda(wistd::move(other.m_lambda)), m_call(other.m_call)
; 552  :         {
; 553  :             other.m_call = false;
; 554  :         }
; 555  : 
; 556  :         ~lambda_call() WI_NOEXCEPT
; 557  :         {
; 558  :             reset();
; 559  :         }
; 560  : 
; 561  :         // Ensures the scope_exit lambda will not be called
; 562  :         void release() WI_NOEXCEPT
; 563  :         {
; 564  :             m_call = false;
; 565  :         }
; 566  : 
; 567  :         // Executes the scope_exit lambda immediately if not yet run; ensures it will not run again
; 568  :         void reset() WI_NOEXCEPT
; 569  :         {
; 570  :             if (m_call)
; 571  :             {
; 572  :                 m_call = false;
; 573  :                 m_lambda();
; 574  :             }
; 575  :         }
; 576  : 
; 577  :         // Returns true if the scope_exit lambda is still going to be executed
; 578  :         WI_NODISCARD explicit operator bool() const WI_NOEXCEPT
; 579  :         {
; 580  :             return m_call;
; 581  :         }
; 582  : 
; 583  :     protected:
; 584  :         TLambda m_lambda;
; 585  :         bool m_call = true;

	mov         w8,#1
	strb        w8,[x0,#0x18]
	ret

	ENDP  ; |??0?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAA@$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@Z|, wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ| PROC ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >

; 221  :         {

|$LN18|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	ldr         x0,[x0]

; 222  :             if (policy::is_valid(m_ptr))

	cbz         x0,|$LN15@unique_sto|

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
|$LN15@unique_sto|
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |??1?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@XZ|, wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::~unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

	AREA	|.text$mn|, CODE, ARM64

|??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z| PROC ; wil::assign_null_to_opt_param<wchar_t const *>

; 656  :     if (outParam != nullptr)

	cbz         x0,|$LN8@assign_nul|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x0]
|$LN8@assign_nul|
	ret

	ENDP  ; |??$assign_null_to_opt_param@PEB_W@wil@@YAXPEAPEB_W@Z|, wil::assign_null_to_opt_param<wchar_t const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

	AREA	|.text$mn|, CODE, ARM64

|??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z| PROC ; wil::assign_to_opt_param<wchar_t const *>

; 645  :     if (outParam != nullptr)

	cbz         x0,|$LN8@assign_to_|

; 646  :     {
; 647  :         *outParam = val;

	str         x1,[x0]
|$LN8@assign_to_|
	ret

	ENDP  ; |??$assign_to_opt_param@PEB_W@wil@@YAXPEAPEB_WPEB_W@Z|, wil::assign_to_opt_param<wchar_t const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

	AREA	|.text$mn|, CODE, ARM64

|??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z| PROC ; wil::assign_null_to_opt_param<char const *>

; 656  :     if (outParam != nullptr)

	cbz         x0,|$LN8@assign_nul|

; 657  :     {
; 658  :         *outParam = nullptr;

	str         xzr,[x0]
|$LN8@assign_nul|
	ret

	ENDP  ; |??$assign_null_to_opt_param@PEBD@wil@@YAXPEAPEBD@Z|, wil::assign_null_to_opt_param<char const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\common.h

	AREA	|.text$mn|, CODE, ARM64

|??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z| PROC ; wil::assign_to_opt_param<char const *>

; 645  :     if (outParam != nullptr)

	cbz         x0,|$LN8@assign_to_|

; 646  :     {
; 647  :         *outParam = val;

	str         x1,[x0]
|$LN8@assign_to_|
	ret

	ENDP  ; |??$assign_to_opt_param@PEBD@wil@@YAXPEAPEBDPEBD@Z|, wil::assign_to_opt_param<char const *>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h

	AREA	|.text$mn|, CODE, ARM64

|??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z| PROC ; wistd::forward<_RTL_CRITICAL_SECTION * &>

; 2506 : {

	ret

	ENDP  ; |??$forward@AEAPEAU_RTL_CRITICAL_SECTION@@@wistd@@YAAEAPEAU_RTL_CRITICAL_SECTION@@AEAPEAU1@@Z|, wistd::forward<_RTL_CRITICAL_SECTION * &>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\wistd_type_traits.h

	AREA	|.text$mn|, CODE, ARM64

|??$move@AEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z| PROC ; wistd::move<`CUSBAsio::createBuffers'::`2'::<lambda_1> &>

; 2499 : {

	ret

	ENDP  ; |??$move@AEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@wistd@@YA$$QEAV<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@AEAV1?1??23@UEAAJ0JJ1@Z@@Z|, wistd::move<`CUSBAsio::createBuffers'::`2'::<lambda_1> &>

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ| PROC ; wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::reset

; 569  :         {

	stp         fp,lr,[sp,#-0x20]!
	mov         fp,sp
	mov         xip0,#-2
	str         xip0,[fp,#0x10]

; 570  :             if (m_call)

	ldrb        w8,[x0,#0x18]
	cbz         w8,|$LN6@reset|

; 571  :             {
; 572  :                 m_call = false;

	strb        wzr,[x0,#0x18]
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\USBAsio.cpp

; 895  :         if ((error != ASE_OK) && callDisposeBuffers)

	ldr         x8,[x0]
	ldr         w8,[x8]
	cbz         w8,|$LN6@reset|
	ldr         x8,[x0,#8]
	ldrb        w8,[x8]
	cbz         w8,|$LN6@reset|

; 896  :         {
; 897  :             disposeBuffers();

	ldr         x0,[x0,#0x10]
	ldr         x8,[x0]
	ldr         x8,[x8,#0xA0]
	blr         x8
|$LN6@reset|
	ldp         fp,lr,[sp],#0x20
	ret

	ENDP  ; |?reset@?$lambda_call@V<lambda_1>@?1??createBuffers@CUSBAsio@@UEAAJPEAUASIOBufferInfo@@JJPEAUASIOCallbacks@@@Z@@details@wil@@QEAAXXZ|, wil::details::lambda_call<`CUSBAsio::createBuffers'::`2'::<lambda_1> >::reset

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z| PROC ; wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close

; 153  :         {

|$LN8|
	stp         fp,lr,[sp,#-0x10]!
	mov         fp,sp

; 154  :             close_fn(value);

	adrp        x8,__imp_LeaveCriticalSection
	ldr         x8,[x8,__imp_LeaveCriticalSection]
	blr         x8
	ldp         fp,lr,[sp],#0x10
	ret

	ENDP  ; |?close@?$close_invoke_helper@$00P6AXPEAU_RTL_CRITICAL_SECTION@@@Z$1?LeaveCriticalSection@@YAX0@ZPEAU1@@details@wil@@SAXPEAU_RTL_CRITICAL_SECTION@@@Z|, wil::details::close_invoke_helper<1,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,_RTL_CRITICAL_SECTION *>::close

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z| PROC ; wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >

; 211  :         explicit unique_storage(pointer_storage ptr) WI_NOEXCEPT : m_ptr(ptr)

	str         x1,[x0]
	ret

	ENDP  ; |??0?$unique_storage@U?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@@details@wil@@QEAA@PEAU_RTL_CRITICAL_SECTION@@@Z|, wil::details::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >::unique_storage<wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t> >

; Function compile flags: /Ogtp
; File G:\Github\microsoft\low-latency-audio\src\uac2-asio\packages\Microsoft.Windows.ImplementationLibrary.1.0.250325.1\include\wil\resource.h

	AREA	|.text$mn|, CODE, ARM64

|?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z| PROC ; wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid

; 188  :             return (static_cast<pointer>(value) != (pointer)invalid);

	cmp         x0,#0
	csetne      w0
	ret

	ENDP  ; |?is_valid@?$resource_policy@PEAU_RTL_CRITICAL_SECTION@@P6AXPEAU1@@Z$1?LeaveCriticalSection@@YAX0@ZU?$integral_constant@_K$00@wistd@@PEAU1@PEAU1@$0A@$$T@details@wil@@SA_NPEAU_RTL_CRITICAL_SECTION@@@Z|, wil::details::resource_policy<_RTL_CRITICAL_SECTION *,void (__cdecl*)(_RTL_CRITICAL_SECTION *),&LeaveCriticalSection,wistd::integral_constant<unsigned __int64,1>,_RTL_CRITICAL_SECTION *,_RTL_CRITICAL_SECTION *,0,std::nullptr_t>::is_valid

; Function compile flags: /Odsp

	AREA	|.text$mn|, CODE, ARM64

|??_ECUSBAsio@@W7EAAPEAXI@Z| PROC			; [thunk]:CUSBAsio::`vector deleting destructor'
	sub         x0,x0,#8
	b           |??_ECUSBAsio@@UEAAPEAXI@Z|

	ENDP  ; |??_ECUSBAsio@@W7EAAPEAXI@Z|, [thunk]:CUSBAsio::`vector deleting destructor'

	END
